---
phase: 06-programmatic-api-integration
plan: 04
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - test/e2e/scenario/embedded-config-dynamic.spec.ts
autonomous: true

must_haves:
  truths:
    - "Dynamic config values (cookies, DOM selectors) resolve correctly at SDK runtime"
    - "Embedded config with dynamic values can be generated without browser environment"
    - "SDK's resolveDynamicValues() is called and extracts values from page"
    - "Multiple dynamic value types work together in single config"
  artifacts:
    - path: "test/e2e/scenario/embedded-config-dynamic.spec.ts"
      provides: "E2E tests for dynamic value resolution"
      must_contain: "dynamic\|cookie\|DOM\|selector\|resolution"
  key_links:
    - from: "test/e2e/scenario/embedded-config-dynamic.spec.ts"
      to: "resolveDynamicValues()"
      via: "SDK resolves embedded config values at runtime"
      pattern: "cookie.*value\|DOM.*selector\|dynamic"
    - from: "embedded config"
      to: "SDK runtime"
      via: "dynamic values passed through unchanged, resolved in browser"
      pattern: "rcSerializedType.*dynamic"

---

## Objective

Create E2E tests verifying that dynamic configuration values (cookies, DOM selectors, JavaScript paths) are properly resolved at runtime when SDK initializes with embedded config. This validates that the generator correctly passes dynamic values through without attempting to resolve them at build time.

**Purpose:** Dynamic values are a critical feature of remote config. Tests prove the SDK can extract values from the page at runtime even when config is embedded in bundle.

**Output:**

- New E2E test file: `test/e2e/scenario/embedded-config-dynamic.spec.ts`
- Tests for each dynamic value type (cookie, DOM, JS path)
- Tests for mixed dynamic and static values
- Verification that SDK properly resolves at runtime

---

## Execution Context

@/Users/adrian.delarosa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adrian.delarosa/.claude/get-shit-done/templates/summary.md

## Context

@.planning/phases/06-programmatic-api-integration/06-RESEARCH.md (Section 2.4: Dynamic Values Resolution)
@packages/remote-config/src/remoteConfiguration.types.ts
@packages/remote-config/src/remoteConfiguration.ts (resolveDynamicValues function)

---

## Tasks

<task type="auto">
  <name>Task 1: Create dynamic value E2E tests with cookie, DOM, and JS path scenarios</name>
  <files>test/e2e/scenario/embedded-config-dynamic.spec.ts</files>
  <action>
    Create a new E2E test file that validates dynamic configuration value resolution. The tests generate bundles with dynamic values in the config and verify they're resolved correctly at runtime in the browser.

    **Test file structure and scenarios:**

    ```typescript
    // test/e2e/scenario/embedded-config-dynamic.spec.ts
    import { test, expect } from '@playwright/test'
    import { generateBundle } from '../../../scripts/build/lib/bundleGenerator'

    test.describe('Embedded Configuration with Dynamic Values', () => {
      test('cookie dynamic value resolves at runtime', async ({ page }) => {
        // 1. Set up page with cookie that SDK should extract
        await page.context().addCookies([{
          name: 'user_id',
          value: 'user-12345',
          url: page.url() || 'http://localhost:3000'
        }])

        // 2. Generate bundle with dynamic cookie value in config
        const bundle = await generateBundle({
          applicationId: 'test-app',
          remoteConfigurationId: 'test-cfg-with-cookies',
          variant: 'rum',
        })
        // Note: test-cfg-with-cookies is a mock config ID
        // In real scenario, this config comes from Datadog and contains:
        // {
        //   "user": {
        //     "id": {
        //       "rcSerializedType": "dynamic",
        //       "strategy": "cookie",
        //       "name": "user_id"
        //     }
        //   }
        // }

        // 3. Block network to config endpoint (prove no fetch)
        await page.route('**/sdk-configuration.datadoghq.com/**', route => route.abort())

        // 4. Inject bundle
        await page.addScriptTag({ content: bundle })

        // 5. Verify SDK initialized
        const initialized = await page.evaluate(() => {
          return typeof window.DD_RUM !== 'undefined'
        })
        expect(initialized).toBe(true)

        // 6. Access resolved config value
        //    (SDK's resolveDynamicValues() should have extracted cookie)
        const config = await page.evaluate(() => {
          return (window as any).DD_RUM?.getInitConfiguration?.()
        })
        expect(config?.user?.id).toBe('user-12345')
      })

      test('DOM selector dynamic value resolves at runtime', async ({ page }) => {
        // 1. Set up page with DOM element
        await page.setContent(`
          <html>
            <body>
              <div id="tracking-id">segment-uuid-789</div>
              <script>/* bundle will be injected here */</script>
            </body>
          </html>
        `)

        // 2. Generate bundle with dynamic DOM value
        const bundle = await generateBundle({
          applicationId: 'test-app',
          remoteConfigurationId: 'test-cfg-with-dom',
          variant: 'rum',
        })
        // Config contains:
        // {
        //   "sessionId": {
        //     "rcSerializedType": "dynamic",
        //     "strategy": "dom",
        //     "selector": "#tracking-id"
        //   }
        // }

        // 3. Block network
        await page.route('**/sdk-configuration.datadoghq.com/**', route => route.abort())

        // 4. Inject bundle
        await page.addScriptTag({ content: bundle })

        // 5. Verify SDK resolved DOM value
        const config = await page.evaluate(() => {
          return (window as any).DD_RUM?.getInitConfiguration?.()
        })
        expect(config?.sessionId).toBe('segment-uuid-789')
      })

      test('JavaScript path dynamic value resolves at runtime', async ({ page }) => {
        // 1. Set up page with JS object
        await page.evaluate(() => {
          (window as any).appState = {
            tracking: {
              sessionToken: 'token-abc-123'
            }
          }
        })

        // 2. Generate bundle with dynamic JS path
        const bundle = await generateBundle({
          applicationId: 'test-app',
          remoteConfigurationId: 'test-cfg-with-js',
          variant: 'rum',
        })
        // Config contains:
        // {
        //   "sessionToken": {
        //     "rcSerializedType": "dynamic",
        //     "strategy": "js",
        //     "path": "appState.tracking.sessionToken"
        //   }
        // }

        // 3. Block network
        await page.route('**/sdk-configuration.datadoghq.com/**', route => route.abort())

        // 4. Inject bundle
        await page.addScriptTag({ content: bundle })

        // 5. Verify SDK resolved JS path
        const config = await page.evaluate(() => {
          return (window as any).DD_RUM?.getInitConfiguration?.()
        })
        expect(config?.sessionToken).toBe('token-abc-123')
      })

      test('mixed static and dynamic values in same config', async ({ page }) => {
        // Set up page state (cookie + DOM + JS)
        await page.context().addCookies([{
          name: 'env',
          value: 'production',
          url: page.url() || 'http://localhost:3000'
        }])

        await page.evaluate(() => {
          (window as any).deployment = { version: '2.5.0' }
        })

        // Generate bundle with mixed config
        const bundle = await generateBundle({
          applicationId: 'test-app',
          remoteConfigurationId: 'test-cfg-mixed',
          variant: 'rum',
        })
        // Config contains mix of:
        // {
        //   "applicationId": "test-app",  // Static
        //   "environment": { rcSerializedType: 'dynamic', ... },  // Dynamic cookie
        //   "version": { rcSerializedType: 'dynamic', ... },     // Dynamic JS path
        //   "site": "datadoghq.com"        // Static
        // }

        await page.route('**/sdk-configuration.datadoghq.com/**', route => route.abort())
        await page.addScriptTag({ content: bundle })

        // Verify all values resolved correctly
        const config = await page.evaluate(() => {
          return (window as any).DD_RUM?.getInitConfiguration?.()
        })
        expect(config?.applicationId).toBe('test-app')  // Static
        expect(config?.environment).toBe('production')  // Dynamic
        expect(config?.version).toBe('2.5.0')           // Dynamic
        expect(config?.site).toBe('datadoghq.com')      // Static
      })
    })
    ```

    **Key implementation details:**

    **Dynamic value types from remote-config package:**
    - **Cookie:** `{ rcSerializedType: 'dynamic', strategy: 'cookie', name: 'cookie_name' }`
    - **DOM:** `{ rcSerializedType: 'dynamic', strategy: 'dom', selector: '#id', attribute?: 'data-value' }`
    - **JavaScript path:** `{ rcSerializedType: 'dynamic', strategy: 'js', path: 'window.path.to.value' }`

    **Test strategy:**
    - Each test sets up page state (cookies, DOM, JS variables)
    - Generates bundle with dynamic values in config
    - Injects bundle (which calls SDK.init() with embedded config)
    - Verifies SDK resolved values correctly
    - No network fetch proves dynamic resolution happens at runtime in browser

    **Why this approach:**
      - Validates SDK can extract dynamic values even with embedded config
      - Tests resolveDynamicValues() works correctly
      - Proves generator correctly passes dynamic values through
      - Real browser environment (Playwright) shows actual SDK behavior
      - Multiple test cases cover different dynamic value types
      - Mixed values test ensure static and dynamic coexist

    **Note on test config IDs:**
    - These test config IDs (test-cfg-with-cookies, etc.) are mocks
    - In real execution, they would need to exist in Datadog
    - For Phase 6 testing, use generateBundle() with real/mocked config that includes dynamic values
    - See research for how to mock remote config if needed

  </action>
  <verify>
    - Test file created at test/e2e/scenario/embedded-config-dynamic.spec.ts
    - File imports generateBundle from bundleGenerator
    - Tests set up page state (cookies, DOM, JS)
    - Tests generate bundles with dynamic config values
    - Network blocking prevents config fetch
    - Tests verify SDK resolved dynamic values correctly
    - `yarn test:e2e -g "embedded-config-dynamic"` runs successfully
  </verify>
  <done>
    - embedded-config-dynamic.spec.ts created with 4+ test cases
    - Tests cover cookie, DOM, JS path, and mixed scenarios
    - Page state setup works correctly
    - Dynamic values verified as resolved
    - All tests passing
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify dynamic value resolution works and add edge case tests</name>
  <files>test/e2e/scenario/embedded-config-dynamic.spec.ts</files>
  <action>
    Add edge case tests to verify dynamic value resolution handles errors gracefully and works in various scenarios. These tests ensure robustness.

    **Edge case tests to add (2-3 tests):**

    1. **Missing dynamic source (cookie doesn't exist)**
       - Create config with cookie dynamic value
       - Don't set the cookie on page
       - Verify SDK handles missing cookie gracefully (undefined or error handling)

    2. **Invalid dynamic selector (DOM doesn't exist)**
       - Create config with DOM dynamic value
       - DOM element referenced doesn't exist on page
       - Verify SDK handles missing element gracefully

    3. **Dynamic value with regex extractor**
       - Some dynamic values support regex extraction
       - Create config with dynamic value including regex pattern
       - Verify extractor works and extracts expected substring

    **Implementation example for test 1:**
    ```typescript
    test('missing cookie is handled gracefully', async ({ page }) => {
      // Don't set cookie (opposite of successful test)
      const bundle = await generateBundle({
        applicationId: 'test-app',
        remoteConfigurationId: 'test-cfg-with-missing-cookie',
        variant: 'rum',
      })

      await page.route('**/sdk-configuration.datadoghq.com/**', route => route.abort())
      await page.addScriptTag({ content: bundle })

      // SDK should initialize even though cookie is missing
      const initialized = await page.evaluate(() => {
        return typeof window.DD_RUM !== 'undefined'
      })
      expect(initialized).toBe(true)

      // Config should be initialized even with missing value
      const config = await page.evaluate(() => {
        return (window as any).DD_RUM?.getInitConfiguration?.()
      })
      expect(config).toBeDefined()
      // user_id might be undefined if cookie doesn't exist
      // SDK should handle this gracefully (not crash)
    })
    ```

    **Why these tests:**
      - Real-world scenarios have missing or invalid sources
      - Proves SDK is resilient to malformed dynamic values
      - Regex extraction is advanced feature worth testing
      - Ensures no crashes or hangs during value resolution
      - Validates error handling path

    **Implementation approach:**
    - Add to same file, new test.describe block or sub-group
    - Group as "Dynamic Value Edge Cases" or similar
    - Keep tests focused on single edge case each

  </action>
  <verify>
    - 2-3 edge case tests added to embedded-config-dynamic.spec.ts
    - Tests cover missing sources, invalid selectors
    - All dynamic value tests pass: `yarn test:e2e -g "embedded-config-dynamic"`
    - SDK handles missing/invalid values without crashing
    - Edge cases verified
  </verify>
  <done>
    - Edge case tests added (2-3 test cases)
    - Missing dynamic sources handled gracefully
    - Invalid selectors don't crash SDK
    - Regex extraction tested
    - All 6+ dynamic value tests passing
  </done>
</task>

</tasks>

---

## Verification

After completing both tasks:

1. **Test execution:** `yarn test:e2e -g "embedded-config-dynamic"` runs all 6+ tests successfully
2. **Dynamic resolution:** SDK correctly extracts values from cookies, DOM, and JS paths
3. **Mixed values:** Static and dynamic values coexist in same config
4. **Error handling:** Missing/invalid sources handled gracefully
5. **No regressions:** Other E2E tests still pass

---

## Success Criteria

- [x] embedded-config-dynamic.spec.ts created with 6+ E2E tests
- [x] Tests cover all dynamic value types (cookie, DOM, JS path)
- [x] Mixed static and dynamic values tested
- [x] Edge cases covered (missing sources, invalid selectors)
- [x] SDK resolution verified at runtime
- [x] Network blocking proves dynamic resolution is at runtime, not build time
- [x] All E2E tests passing

---

## Notes

**Requirement mapped:** API-05 (dynamic configuration values remain resolvable at runtime)

**Dependency:** Plan 04 depends on Plan 01 (generateBundle() must be exported). Runs in Wave 2 after Plan 01 verification.

**Remote config types:** Tests rely on remote config having dynamic values. If test config IDs need to be created, refer to @datadog/browser-remote-config package documentation.

---

## Output

After completion, create `.planning/phases/06-programmatic-api-integration/06-04-SUMMARY.md` with:

- Dynamic value test scenarios covered
- Test count (6+ tests)
- Edge cases handled
- Files created
- Commits made
