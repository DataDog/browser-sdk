---
phase: 06-programmatic-api-integration
plan: 03
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - test/e2e/scenario/embedded-config.spec.ts
autonomous: true

must_haves:
  truths:
    - "SDK loads successfully from generated embedded config bundle"
    - "SDK initializes without making network request to config endpoint"
    - "SDK has correct embedded configuration values available after init"
    - "Browser page executes bundle and DD_RUM is available globally"
  artifacts:
    - path: "test/e2e/scenario/embedded-config.spec.ts"
      provides: "E2E test scenarios for embedded config"
      must_contain: "embedded-config\|network.*block\|DD_RUM"
  key_links:
    - from: "test/e2e/scenario/embedded-config.spec.ts"
      to: "generateBundle() API"
      via: "imported and called in test"
      pattern: "import.*generateBundle\|await generateBundle"
    - from: "Playwright page"
      to: "CDN config endpoint"
      via: "network route blocked to verify zero requests"
      pattern: "page\\.route.*abort"

---

## Objective

Create E2E tests using Playwright to verify that the SDK properly loads and initializes from embedded configuration without making network requests. These tests prove that the programmatic API (Plan 01) actually solves the core problem: zero-request SDK initialization.

**Purpose:** E2E tests are critical proof that embedded config works at runtime. Unit tests verify code correctness; E2E tests verify SDK behavior in a real browser.

**Output:**
- New E2E test file: `test/e2e/scenario/embedded-config.spec.ts`
- Tests for basic embedded config load
- Tests verifying zero network requests
- Tests for configuration value accessibility

---

## Execution Context

@/Users/adrian.delarosa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adrian.delarosa/.claude/get-shit-done/templates/summary.md

## Context

@.planning/phases/06-programmatic-api-integration/06-RESEARCH.md (Section 5: Testing Strategy)
@scripts/build/lib/bundleGenerator.ts
@test/e2e/ (existing E2E test structure)

---

## Tasks

<task type="auto">
  <name>Task 1: Create embedded-config E2E test file with network blocking scenario</name>
  <files>test/e2e/scenario/embedded-config.spec.ts</files>
  <action>
    Create a new E2E test file that tests the core feature: SDK using embedded config without network requests. This is the critical proof point for Phase 6.

    **Test file structure:**
    ```typescript
    // test/e2e/scenario/embedded-config.spec.ts
    import { test, expect } from '@playwright/test'
    import { generateBundle } from '../../../scripts/build/lib/bundleGenerator'

    test.describe('Embedded Configuration', () => {
      test('SDK loads and initializes from embedded config without network requests', async ({ page, context }) => {
        // 1. Generate bundle with known test config
        const bundle = await generateBundle({
          applicationId: 'test-app-id',
          remoteConfigurationId: 'test-config-id',
          variant: 'rum',
        })

        // 2. Block network requests to config endpoint
        //    This proves SDK doesn't fetch config at runtime
        await page.route('**/sdk-configuration.datadoghq.com/**', route => route.abort())

        // 3. Block requests to any Datadog endpoint except the bundle we're testing
        await page.route('**/datadoghq.com/**', route => {
          // Allow only our generated bundle, block others
          if (route.request().url().includes('sdk-configuration')) {
            route.abort()
          } else {
            route.continue()
          }
        })

        // 4. Inject the generated bundle into the page
        await page.addScriptTag({ content: bundle })

        // 5. Verify SDK initialized (window.DD_RUM exists)
        const ddRum = await page.evaluate(() => {
          return typeof window.DD_RUM !== 'undefined'
        })
        expect(ddRum).toBe(true)

        // 6. Verify SDK has the embedded config values
        const config = await page.evaluate(() => {
          // DD_RUM.getInitConfiguration() returns the init config if available
          // Otherwise check if embedded config was passed
          return (window as any).DD_RUM?.getInitConfiguration?.()
        })
        expect(config).toBeDefined()
        expect(config.applicationId).toBe('test-app-id')
      })

      test('Multiple embedded bundles can coexist', async ({ page }) => {
        // Generate two bundles with different configs
        const bundle1 = await generateBundle({
          applicationId: 'app-1',
          remoteConfigurationId: 'cfg-1',
          variant: 'rum',
        })

        const bundle2 = await generateBundle({
          applicationId: 'app-2',
          remoteConfigurationId: 'cfg-2',
          variant: 'rum-slim',
        })

        // Block network to config endpoint
        await page.route('**/sdk-configuration.datadoghq.com/**', route => route.abort())

        // Inject both bundles
        await page.addScriptTag({ content: bundle1 })
        await page.addScriptTag({ content: bundle2 })

        // Verify both initialized
        const initialized = await page.evaluate(() => {
          return typeof window.DD_RUM !== 'undefined'
        })
        expect(initialized).toBe(true)
      })
    })
    ```

    **Key implementation details:**

    **Network blocking strategy:**
    - Block `**/sdk-configuration.datadoghq.com/**` specifically (this is the config endpoint)
    - Test will fail if SDK tries to fetch config (proves we're catching it)
    - Other Datadog endpoints may be used (RUM data submission, logging) â€” don't block those

    **Test approach:**
    - Generate bundle using the actual `generateBundle()` API from Plan 01
    - Inject generated bundle into page using Playwright
    - Verify SDK initialized without network request
    - Check configuration is available and contains expected values

    **Why this approach:**
      - Tests the actual use case: embedding config in bundle
      - Network blocking proves zero-request goal is met
      - Real browser environment (Playwright) ensures SDK really works
      - Uses actual `generateBundle()` API (integration with Plan 01)
      - Verifies SDK behavior, not just bundle generation

    **Playwright API notes:**
    - `page.route()` intercepts network requests
    - `route.abort()` blocks request (simulates network failure)
    - `page.addScriptTag()` injects script into page
    - `page.evaluate()` runs JavaScript in browser context
    - `await` ensures request routing is active before injection
  </action>
  <verify>
    - Test file created at test/e2e/scenario/embedded-config.spec.ts
    - File imports generateBundle from bundleGenerator
    - Test generates bundle with valid options
    - Network route blocking applied before script injection
    - Test verifies window.DD_RUM exists
    - Test checks configuration values are available
    - `yarn test:e2e -g "embedded-config"` runs test successfully
  </verify>
  <done>
    - embedded-config.spec.ts created with 2+ test cases
    - Tests use actual generateBundle() API
    - Network blocking proves zero-request goal
    - SDK initialization verified in browser
    - Config values checked
    - All E2E tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E tests for error scenarios and config validation</name>
  <files>test/e2e/scenario/embedded-config.spec.ts</files>
  <action>
    Add additional E2E test cases to the same embedded-config.spec.ts file to cover edge cases and error scenarios. These tests verify robustness beyond the happy path.

    **Additional test cases to add (3-4 tests):**

    1. **Invalid bundle syntax fails gracefully**
       - Generate bundle with malformed config (if possible)
       - Inject into page
       - Verify error handling doesn't crash page
       - Check console for error messages

    2. **Empty/minimal config works**
       - Generate bundle with minimal valid config
       - Verify SDK initializes with minimal config
       - Ensures no required fields are missing

    3. **Network timeout doesn't break initialization**
       - Inject bundle
       - Delay network requests to config endpoint (don't block, just slow)
       - Verify SDK initializes with embedded config before timeout
       - Confirm timeout doesn't interfere

    4. **SDK works with different page contexts**
       - Test bundle in main frame (current test)
       - (Optional) Test in iframe context
       - Verify window.DD_RUM is accessible in both

    **Implementation example for test 1:**
    ```typescript
    test('SDK handles bundle without network gracefully', async ({ page }) => {
      const bundle = await generateBundle({
        applicationId: 'test-app',
        remoteConfigurationId: 'test-cfg',
        variant: 'rum',
      })

      // Block all Datadog network requests
      await page.route('**/datadoghq.com/**', route => route.abort())
      await page.route('**/datadoghq-browser-agent.com/**', route => route.abort())

      // Inject bundle
      await page.addScriptTag({ content: bundle })

      // Verify SDK still works despite blocked network
      const hasRum = await page.evaluate(() => typeof window.DD_RUM !== 'undefined')
      expect(hasRum).toBe(true)

      // Check for any console errors related to SDK
      const errors: string[] = []
      page.on('console', msg => {
        if (msg.type() === 'error' && msg.text().includes('DD_RUM')) {
          errors.push(msg.text())
        }
      })

      // No critical errors expected
      expect(errors).toHaveLength(0)
    })
    ```

    **Why these tests:**
      - Error scenarios prove SDK is resilient
      - Network failures are expected in real world
      - Minimal config ensures users aren't forced to provide unused options
      - Different contexts test real-world usage patterns
      - Console error monitoring catches unexpected issues

    **Test organization:**
    - Group in same file under `test.describe('Embedded Configuration')`
    - Add separate `test.describe('Error Scenarios')` or sub-groups if file gets long
    - Keep related tests together
  </action>
  <verify>
    - 3-4 additional test cases added to embedded-config.spec.ts
    - Tests cover error scenarios and edge cases
    - All new tests pass: `yarn test:e2e -g "embedded-config"`
    - Test file is organized with clear test names
    - No regressions in other E2E tests
  </verify>
  <done>
    - Error scenario tests added (3-4 test cases)
    - SDK resilience verified (works without network)
    - Minimal config validated
    - Edge cases covered
    - All embedded-config E2E tests passing (5+ total)
  </done>
</task>

</tasks>

---

## Verification

After completing both tasks:

1. **Test execution:** `yarn test:e2e -g "embedded-config"` runs all 5+ tests successfully
2. **Network blocking:** Tests prove SDK doesn't fetch config (route.abort() would fail test if attempted)
3. **SDK initialization:** window.DD_RUM is available and initialized
4. **Configuration:** Embedded config values are accessible to SDK
5. **No regressions:** Other E2E tests still pass

---

## Success Criteria

- [x] embedded-config.spec.ts created with E2E tests
- [x] Tests use actual generateBundle() API from Plan 01
- [x] Network blocking proves zero-request goal
- [x] 5+ test cases covering happy path and error scenarios
- [x] SDK initialization verified in real browser (Playwright)
- [x] Configuration values checked and accessible
- [x] All E2E tests passing

---

## Notes

**Dependency:** Plan 03 depends on Plan 01 (generateBundle() must be exported). Both Plans 01 and 02 complete first (Wave 1), then Plan 03 runs (Wave 2) after verification.

**Test execution:** E2E tests require Playwright to be initialized:
```bash
yarn test:e2e:init    # One-time setup
yarn test:e2e         # Run all E2E tests
yarn test:e2e -g "embedded-config"  # Run only embedded-config tests
```

---

## Output

After completion, create `.planning/phases/06-programmatic-api-integration/06-03-SUMMARY.md` with:
- E2E test scenarios covered
- Test count (5+ tests)
- Network blocking verification
- Files created
- Commits made
