---
phase: 06-programmatic-api-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/build/lib/bundleGenerator.ts
  - scripts/build/lib/bundleGenerator.spec.ts
autonomous: true

must_haves:
  truths:
    - 'Function `generateBundle()` can be imported and called from external code'
    - 'Function accepts options object with applicationId, remoteConfigurationId, variant'
    - 'Function validates all required inputs and returns descriptive error messages'
    - 'Function returns Promise<string> containing generated JavaScript code'
    - 'Same inputs always produce identical outputs (deterministic)'
  artifacts:
    - path: 'scripts/build/lib/bundleGenerator.ts'
      provides: 'generateBundle() export with input validation'
      must_contain: 'export async function generateBundle'
    - path: 'scripts/build/lib/bundleGenerator.spec.ts'
      provides: 'Tests for new API function and validation'
      must_contain: 'describe.*generateBundle'
  key_links:
    - from: 'scripts/build/lib/bundleGenerator.ts'
      to: '@datadog/browser-remote-config'
      via: 'fetchRemoteConfiguration() function'
      pattern: 'await fetchRemoteConfiguration'
    - from: 'scripts/build/lib/bundleGenerator.ts'
      to: 'downloadSDK()'
      via: 'called sequentially in generateBundle()'
      pattern: 'await downloadSDK'
---

## Objective

Export a programmatic async API function from the bundleGenerator library that build tools can call directly. The function combines the existing generator workflow (fetch config → download SDK → generate bundle) into a single high-level interface with input validation and improved error handling.

**Purpose:** Enables webpack, Vite, and custom build scripts to integrate the generator without CLI overhead. API validation catches misconfiguration early.

**Output:**

- `generateBundle()` exported function
- Input validation with clear error messages
- Unit tests for API and validation
- TypeScript types for consumers

---

## Execution Context

@/Users/adrian.delarosa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adrian.delarosa/.claude/get-shit-done/templates/summary.md

## Context

@.planning/phases/06-programmatic-api-integration/06-RESEARCH.md
@.planning/phases/05-core-generator/SUMMARY.md
@/Users/adrian.delarosa/go/src/github.com/DataDog/b-ssi/scripts/build/lib/bundleGenerator.ts

---

## Tasks

<task type="auto">
  <name>Task 1: Implement generateBundle() API function with input validation</name>
  <files>scripts/build/lib/bundleGenerator.ts</files>
  <action>
    Add a new exported async function `generateBundle()` to bundleGenerator.ts that wraps the existing workflow. This is the primary API entry point.

    **Function signature:**
    ```typescript
    export async function generateBundle(options: GenerateBundleOptions): Promise<string>
    ```

    **Where GenerateBundleOptions replaces the current low-level options with a high-level interface:**
    ```typescript
    export interface GenerateBundleOptions {
      applicationId: string
      remoteConfigurationId: string
      variant: 'rum' | 'rum-slim'
      site?: string
      datacenter?: string
    }
    ```

    **Implementation steps:**
    1. Keep existing functions (`fetchConfig()`, `downloadSDK()`, `generateCombinedBundle()`) unchanged — they are internal
    2. Create new `generateBundle()` function that orchestrates the workflow:
       - Validate inputs (all required fields present, variant is valid)
       - Call `fetchConfig()` to get remote configuration
       - Call `downloadSDK()` to fetch SDK code
       - Call `generateCombinedBundle()` to create final bundle
       - Return the bundle string
    3. Add comprehensive input validation BEFORE calling existing functions:
       - Check `applicationId` is non-empty string
       - Check `remoteConfigurationId` is non-empty string
       - Check `variant` is exactly 'rum' or 'rum-slim'
       - Check optional `site` is string if provided
       - Check optional `datacenter` is string if provided
    4. Wrap validation checks with clear, actionable error messages (2-3 sentences each)
    5. Export new types: `GenerateBundleOptions`, `SdkVariant` (already exists, ensure it's exported)
    6. Keep existing internal interfaces (`FetchConfigOptions`, `DownloadSDKOptions`, `GenerateBundleOptions` for the low-level wrapper) but consider renaming the low-level one to avoid collision (e.g., `CombineBundleOptions`)

    **Error message examples (DO implement these patterns):**
    - Missing applicationId: "Option 'applicationId' is required and must be a non-empty string."
    - Invalid variant: "Option 'variant' must be 'rum' or 'rum-slim', got 'xyz'. Check your build configuration."
    - Missing remoteConfigurationId: "Option 'remoteConfigurationId' is required and must be a non-empty string. Get this from Datadog UI > Remote Configuration."

    **Why this approach:**
      - Keeps existing tested code (`downloadSDK`, `fetchConfig`, `generateCombinedBundle`) unchanged
      - Validation at API boundary prevents cascading errors downstream
      - High-level function is easier for build tools to use
      - Determinism preserved: same inputs → same outputs (no timestamps, no random data)

  </action>
  <verify>
    - TypeScript compilation succeeds: `yarn typecheck`
    - Function can be imported: `import { generateBundle } from 'scripts/build/lib/bundleGenerator.ts'`
    - Test case passes: Call function with valid options and verify Promise<string> is returned
    - Error message test passes: Call with missing applicationId and verify error message contains "applicationId is required"
  </verify>
  <done>
    - `generateBundle()` exported and callable with `GenerateBundleOptions`
    - All required options validated with clear error messages
    - Optional options accepted and passed through
    - Function returns Promise<string> (JavaScript bundle code)
    - TypeScript types compile cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for generateBundle() API and validation</name>
  <files>scripts/build/lib/bundleGenerator.spec.ts</files>
  <action>
    Expand bundleGenerator.spec.ts with comprehensive tests for the new `generateBundle()` API function and its validation logic. Tests should cover:

    **Validation tests (5-6 tests):**
    1. Valid options → returns Promise<string> (happy path)
    2. Missing applicationId → throws error with "applicationId is required" in message
    3. Empty applicationId → throws error
    4. Missing remoteConfigurationId → throws error with "remoteConfigurationId is required"
    5. Invalid variant (not 'rum' or 'rum-slim') → throws error with helpful suggestion
    6. Invalid site (not a string when provided) → throws error

    **Integration tests (2-3 tests):**
    1. Full workflow: Valid options → calls fetchConfig → downloads SDK → returns bundle
    2. Error propagation: Network error in downloadSDK is re-thrown
    3. Error propagation: Invalid config ID causes fetchConfig to fail

    **Implementation notes:**
    - Use mocking/spying on `fetchConfig()` and `downloadSDK()` to avoid real network calls
    - Mock return values to represent successful config fetch and SDK download
    - Verify error messages are human-readable (not raw HTTP errors)
    - Each test should be focused on a single behavior
    - Use `expect()` patterns consistent with existing Jasmine tests in bundleGenerator.spec.ts

    **Test structure example (adapt to existing test style):**
    ```typescript
    describe('generateBundle()', () => {
      describe('input validation', () => {
        it('throws if applicationId is missing', async () => {
          await expect(
            generateBundle({
              remoteConfigurationId: 'cfg-1',
              variant: 'rum'
            })
          ).toReject().withMessage(/applicationId is required/)
        })

        it('throws if variant is invalid', async () => {
          await expect(
            generateBundle({
              applicationId: 'app-1',
              remoteConfigurationId: 'cfg-1',
              variant: 'invalid'
            })
          ).toReject().withMessage(/variant.*rum.*rum-slim/)
        })
      })

      describe('workflow', () => {
        it('fetches config, downloads SDK, and generates bundle', async () => {
          const result = await generateBundle({...})
          expect(result).toBeDefined()
          expect(typeof result).toBe('string')
        })
      })
    })
    ```

    **Why this approach:**
      - Tests verify API contract (what callers expect)
      - Validation tests catch user errors before they reach CDN
      - Integration tests ensure workflow still works through new wrapper
      - Mocking network calls keeps tests fast and deterministic

  </action>
  <verify>
    - `yarn test:unit --spec scripts/build/lib/bundleGenerator.spec.ts` passes all new tests
    - New test count: at least 8+ tests added (6 validation + 2+ integration)
    - No existing tests broken
    - Error messages are human-readable (test output shows clear assertions)
  </verify>
  <done>
    - At least 8 new tests added to bundleGenerator.spec.ts
    - All validation scenarios covered
    - Workflow integration tested
    - All tests passing
    - Error messages verified in test expectations
  </done>
</task>

</tasks>

---

## Verification

After completing both tasks:

1. **Compilation:** `yarn typecheck` passes cleanly
2. **Tests:** `yarn test:unit --spec scripts/build/lib/bundleGenerator.spec.ts` shows all tests passing
3. **API contract:**
   - Function signature: `async function generateBundle(options: GenerateBundleOptions): Promise<string>`
   - Types exported: `GenerateBundleOptions`, `SdkVariant`
   - Determinism: Same options always produce identical output
4. **Error handling:** Invalid inputs throw descriptive errors (tested in Unit tests)
5. **Integration:** Function internally uses existing `fetchConfig()`, `downloadSDK()`, `generateCombinedBundle()`

---

## Success Criteria

- [x] `generateBundle()` function exported and type-safe
- [x] All required options validated with clear messages
- [x] Full unit test coverage for API and validation logic
- [x] No breaking changes to existing Phase 5 code
- [x] TypeScript compilation succeeds
- [x] All existing tests still pass
- [x] New tests (8+) all pass

---

## Output

After completion, create `.planning/phases/06-programmatic-api-integration/06-01-SUMMARY.md` with:

- API function signature and types
- Test coverage summary
- Files modified
- Commits made
