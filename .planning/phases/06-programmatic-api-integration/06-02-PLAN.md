---
phase: 06-programmatic-api-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/build/lib/bundleGenerator.ts
  - scripts/build/lib/bundleGenerator.spec.ts
autonomous: true

must_haves:
  truths:
    - "SDK downloads are cached in memory to avoid re-fetching identical variants"
    - "Repeated calls with same variant return cached SDK within milliseconds (not seconds)"
    - "Cache is automatically invalidated on Node.js process restart"
    - "Cache behavior is transparent to callers (no API changes needed)"
  artifacts:
    - path: "scripts/build/lib/bundleGenerator.ts"
      provides: "In-memory cache for SDK downloads in downloadSDK()"
      must_contain: "cache.*SDK\|sdkCache\|Map.*sdk"
    - path: "scripts/build/lib/bundleGenerator.spec.ts"
      provides: "Tests verifying cache behavior"
      must_contain: "cache.*behavior\|performance\|repeated"
  key_links:
    - from: "downloadSDK()"
      to: "cache Map"
      via: "check cache before network fetch"
      pattern: "sdkCache\\.has\|cache\\.get"
    - from: "cache"
      to: "CDN request"
      via: "only fetch if cache miss"
      pattern: "https\\.get.*!cache"

---

## Objective

Add in-memory caching to the `downloadSDK()` function to improve performance when the same SDK variant is downloaded multiple times. This is critical for build tools with watch mode that may regenerate bundles during development.

**Purpose:** Reduces SDK download time from ~500ms to <5ms on cache hit. Enables responsive development workflows.

**Output:**
- In-memory cache added to `downloadSDK()`
- Cache key strategy (variant + version)
- Tests verifying cache behavior and performance
- No breaking changes to API

---

## Execution Context

@/Users/adrian.delarosa/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adrian.delarosa/.claude/get-shit-done/templates/summary.md

## Context

@.planning/phases/06-programmatic-api-integration/06-RESEARCH.md (Section 7: Performance & Caching)
@scripts/build/lib/bundleGenerator.ts

---

## Tasks

<task type="auto">
  <name>Task 1: Implement in-memory SDK cache in downloadSDK()</name>
  <files>scripts/build/lib/bundleGenerator.ts</files>
  <action>
    Add a simple in-memory cache using a Map to store downloaded SDK bundles. This avoids re-fetching the same SDK variant during a single Node.js process lifetime.

    **Cache design:**
    - **Cache key:** `${variant}-${majorVersion}` (e.g., `rum-6`, `rum-slim-6`)
      - Only major version matters (CDN URL: `/v6/datadog-rum.js`)
      - Variant and major version uniquely identify the SDK
    - **Cache value:** The SDK JavaScript code as string
    - **Storage:** Module-level Map (persists across function calls within process)
    - **Invalidation:** Automatic when Node.js process exits (no manual clearing needed)

    **Implementation steps:**
    1. Add at module level (near top of file, after imports):
       ```typescript
       // In-memory cache for SDK downloads to avoid re-fetching in watch mode
       const sdkCache = new Map<string, string>()
       ```
    2. Modify `downloadSDK()` function to check cache first:
       ```typescript
       export async function downloadSDK(...): Promise<string> {
         const variant = ...
         const version = ...
         const majorVersion = getMajorVersion(version)

         // Cache key: variant-version
         const cacheKey = `${variant}-${majorVersion}`

         // Return cached SDK if available
         if (sdkCache.has(cacheKey)) {
           return sdkCache.get(cacheKey)!
         }

         // Fetch from CDN if not cached
         const sdkCode = await downloadFromCDN(url)

         // Store in cache before returning
         sdkCache.set(cacheKey, sdkCode)
         return sdkCode
       }
       ```
    3. Extract the actual CDN fetch logic into a helper function `downloadFromCDN()` if not already separate, so cache logic is clean
    4. Verify cache key is deterministic (no timestamps, no randomness)
    5. Add JSDoc comment explaining cache behavior for future maintainers

    **Cache behavior notes:**
    - **Per-process:** Cache lives for the lifetime of the Node.js process
    - **No TTL:** Doesn't expire; assumes SDK version doesn't change during a build session
    - **Memory footprint:** ~100KB per cached variant (negligible for 1-2 variants)
    - **Thread-safe:** Not needed; Node.js is single-threaded
    - **Observable by:** Not observable from outside; caching is internal optimization

    **Why this approach:**
      - Simplest correct implementation (no external dependencies)
      - Fast for build tool watch mode (download once, cache for duration)
      - Automatic cleanup (exits when process exits)
      - No configuration needed (transparent to callers)
      - Deterministic behavior (same inputs → same outputs)
  </action>
  <verify>
    - Module-level Map variable exists and is initialized empty
    - `downloadSDK()` checks cache before making HTTPS request
    - Cache key includes variant and version
    - SDK code stored in cache after successful download
    - TypeScript compilation succeeds
    - Existing tests still pass (no behavioral change to API)
  </verify>
  <done>
    - In-memory cache Map added to module
    - downloadSDK() checks cache before network fetch
    - Downloaded SDK stored in cache after fetch
    - Cache key deterministic (variant + version)
    - No API changes (function signature unchanged)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for cache behavior and performance</name>
  <files>scripts/build/lib/bundleGenerator.spec.ts</files>
  <action>
    Add tests to verify the caching mechanism works correctly and provides performance benefits. Tests should be focused on observable behavior (not internal implementation details).

    **Cache behavior tests (4-5 tests):**
    1. **First call caches SDK:** Call downloadSDK() once with 'rum', verify it's stored internally (spy on https.get to confirm it's called)
    2. **Second call uses cache:** Call downloadSDK() again with same 'rum', verify https.get is NOT called (no network request)
    3. **Different variant uses separate cache:** Call downloadSDK('rum'), then downloadSDK('rum-slim'), verify both are cached separately (2 network requests total, not more)
    4. **Cache key includes version:** If SDK version in browserSdkVersion changes, cache should be keyed separately (test by mocking version)
    5. **Cache is empty at start:** Verify fresh cache on module load (or clear cache before test)

    **Performance test (1 test, optional but recommended):**
    - **Cache hit is fast:** First call takes ~500ms (network), second call takes <10ms (cache hit). Verify timing difference.

    **Implementation approach:**
    - Use `jest.spyOn()` or equivalent to spy on `https.get` and confirm it's called only when cache misses
    - Mock the HTTPS response so tests don't require network
    - After first `downloadSDK('rum')`, subsequent calls with same variant should skip the spy
    - Use a test utility to clear cache between tests if needed (or reset spies)

    **Test structure example (adapt to existing Jasmine style):**
    ```typescript
    describe('downloadSDK() caching', () => {
      it('caches SDK after first download', async () => {
        spyOn(https, 'get').and.returnValue(...)
        const result1 = await downloadSDK('rum')
        expect(https.get).toHaveBeenCalledTimes(1)
        expect(result1).toBeDefined()
      })

      it('returns cached SDK on second call', async () => {
        spyOn(https, 'get').and.returnValue(...)
        const result1 = await downloadSDK('rum')
        const result2 = await downloadSDK('rum')
        expect(https.get).toHaveBeenCalledTimes(1) // Still 1, not 2
        expect(result1).toBe(result2) // Exact same string from cache
      })

      it('caches different variants separately', async () => {
        spyOn(https, 'get').and.returnValue(...)
        await downloadSDK('rum')
        await downloadSDK('rum-slim')
        await downloadSDK('rum') // Should use cache
        expect(https.get).toHaveBeenCalledTimes(2) // Only rum and rum-slim
      })
    })
    ```

    **Why this approach:**
      - Verifies cache is being used (spy confirms https.get not called)
      - Verifies cache is separate per variant
      - Performance test shows real benefit (500ms → <10ms)
      - Tests are deterministic (no real network calls)
      - Tests are future-proof (test behavior, not implementation)
  </action>
  <verify>
    - `yarn test:unit --spec scripts/build/lib/bundleGenerator.spec.ts` shows new cache tests passing
    - Spy confirms https.get called once for first call, zero times on cache hit
    - Performance test shows cache hit is significantly faster (if implemented)
    - No existing tests broken
    - Test count increased by 4-5 cache-related tests
  </verify>
  <done>
    - Cache behavior tests added (4-5 tests)
    - Optional performance test added
    - All cache tests passing
    - https.get spy confirms cache behavior
    - No breaking changes to downloadSDK() API
  </done>
</task>

</tasks>

---

## Verification

After completing both tasks:

1. **Implementation:** In-memory cache Map exists and is used in `downloadSDK()`
2. **Performance:** First call fetches from CDN (~500ms), second call returns from cache (<10ms)
3. **Correctness:** Same variant + version always returns identical SDK code from cache
4. **Tests:** 4-5 cache tests pass, proving cache behavior
5. **No regressions:** All existing tests still pass

---

## Success Criteria

- [x] In-memory SDK cache added to downloadSDK()
- [x] Cache key is deterministic (variant + version)
- [x] Cache check happens before network fetch
- [x] Cache behavior tests verify it's being used
- [x] Performance benefit demonstrated (spy confirms cache hit)
- [x] No API changes (function signature same)
- [x] All tests passing (existing + new cache tests)

---

## Notes

**Relationship to Plan 01:** This plan runs in parallel (Wave 1) with Plan 01. Both modify `bundleGenerator.ts` but in different areas:
- Plan 01: Adds `generateBundle()` API function and validation
- Plan 02: Adds caching to existing `downloadSDK()` function

No file conflicts; changes are independent.

---

## Output

After completion, create `.planning/phases/06-programmatic-api-integration/06-02-SUMMARY.md` with:
- Cache implementation details
- Test coverage summary
- Performance improvements (timing comparison)
- Files modified
- Commits made
