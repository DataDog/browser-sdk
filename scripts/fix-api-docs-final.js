const fs = require('fs')
const path = require('path')
const { globSync } = require('glob')

const TYPE_DESCRIPTIONS = {
  RumActionEventDomainContext: {
    main: 'Additional information available when the SDK dispatches a RUM **Action** event.',
    properties: {
      events: 'DOM events that triggered this action.',
      handlingStack: 'Stack trace of where the action was handled by the SDK.',
    },
  },
  RumViewEventDomainContext: {
    main: 'Additional information available when the SDK dispatches a RUM **View** event.',
    properties: {
      location: 'The browser location object at the time the view was created.',
    },
  },
  RumFetchResourceEventDomainContext: {
    main: 'Additional information available when the SDK dispatches a **Fetch** resource event.',
    properties: {
      requestInit: 'Init object passed to the fetch call.',
      requestInput: 'Input parameter passed to the fetch call.',
      response: 'Response object returned by the fetch call.',
      error: 'Error that occurred during the fetch call.',
      performanceEntry: 'Browser performance entry for this resource.',
      isAborted: 'Whether the fetch call was aborted.',
      handlingStack: 'Stack trace of where the resource was handled by the SDK.',
    },
  },
  RumXhrResourceEventDomainContext: {
    main: 'Additional information available when the SDK dispatches an **XHR** resource event.',
    properties: {
      xhr: 'The XMLHttpRequest object that made the request.',
      performanceEntry: 'Browser performance entry for this resource.',
      isAborted: 'Whether the XHR request was aborted.',
      handlingStack: 'Stack trace of where the resource was handled by the SDK.',
    },
  },
  RumOtherResourceEventDomainContext: {
    main: 'Additional information available when the SDK dispatches a **Resource** event that is neither fetch nor XHR.',
    properties: {
      performanceEntry: 'Browser performance entry for this resource.',
    },
  },
  RumErrorEventDomainContext: {
    main: 'Additional information available when the SDK dispatches an **Error** event.',
    properties: {
      error: 'The original error object that was captured.',
      handlingStack: 'Stack trace of where the error was handled by the SDK.',
    },
  },
  RumLongTaskEventDomainContext: {
    main: 'Additional information available when the SDK dispatches a **Long Task** event.',
    properties: {
      performanceEntry: 'Browser performance entry for this long task.',
    },
  },
}

function cleanupStyles(content) {
  // Supprime tous les blocs de styles existants
  content = content.replace(/<!-- Custom styles for better GitHub Pages rendering -->[\s\S]*?<\/style>\s*/g, '')

  // Ajoute un seul bloc de styles au début
  const styleBlock = `
<!-- Custom styles for better GitHub Pages rendering -->
<style>
.api-table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}
.api-table th {
  background-color: #f6f8fa;
  border: 1px solid #d1d5da;
  padding: 12px;
  text-align: left;
  font-weight: 600;
}
.api-table td {
  border: 1px solid #d1d5da;
  padding: 12px;
  vertical-align: top;
}
.api-table tr:nth-child(even) {
  background-color: #f6f8fa;
}
code {
  background-color: #f3f4f6;
  padding: 2px 4px;
  border-radius: 3px;
  font-size: 90%;
}
pre {
  background-color: #f6f8fa;
  padding: 16px;
  border-radius: 6px;
  overflow-x: auto;
}
</style>

`

  // Ajoute le style après le commentaire de non-édition
  if (content.includes('<!-- Do not edit this file.') && !content.includes('<!-- Custom styles')) {
    content = content.replace(
      '<!-- Do not edit this file. It is automatically generated by API Documenter. -->',
      `<!-- Do not edit this file. It is automatically generated by API Documenter. -->${styleBlock}`
    )
  }

  return content
}

function fixArrayTypes(content) {
  // Corrige les types de tableaux avec backslashes
  return content.replace(/(\w+)\\\[\\]/g, '$1[]')
}

function convertMarkdownLinks(content) {
  // Convertit les liens markdown en HTML
  return content.replace(/\[([^\]]+)]\(([^)]+)\)/g, (_match, text, url) => {
    let newUrl = url
    if (url.endsWith('.md')) {
      newUrl = url.replace(/\.md$/, '.html')
    }
    return `<a href="${newUrl}">${text}</a>`
  })
}

function enhanceDescriptions(content, fileName) {
  // Extrait le nom du type depuis le nom du fichier
  let typeName = null

  // Cherche le nom du type dans TYPE_DESCRIPTIONS
  for (const type of Object.keys(TYPE_DESCRIPTIONS)) {
    if (fileName.includes(type.toLowerCase())) {
      typeName = type
      break
    }
  }

  if (!typeName || !TYPE_DESCRIPTIONS[typeName]) {
    return content
  }

  console.log(`  Enhancing ${typeName}`)

  // Ajoute la description principale de l'interface
  const mainDescPattern = new RegExp(`## ${typeName} interface\\s*\\n\\n`, 'i')
  const typeInfo = TYPE_DESCRIPTIONS[typeName]

  if (typeInfo.main) {
    content = content.replace(mainDescPattern, (match) => `${match}${typeInfo.main}\n\n`)
  }

  // Améliore les descriptions des propriétés
  if (typeInfo.properties) {
    // Pour chaque propriété connue
    for (const [propName, propDesc] of Object.entries(typeInfo.properties)) {
      // Pattern plus simple pour trouver la propriété dans le tableau
      const propPattern = new RegExp(
        `<a href="[^"]+${propName}[^"]*">${propName}\\??</a>\\s*</td><td>\\s*</td><td>\\s*([^<]+)\\s*</td><td>\\s*(?:\\(Optional\\))?\\s*</td>`,
        'i'
      )

      content = content.replace(propPattern, (match, _type) => {
        const isOptional = match.includes('?') || match.includes('Optional')
        const desc = isOptional ? `${propDesc} (Optional)` : propDesc
        return match.replace(/<td>\s*(?:\(Optional\))?\s*<\/td>$/, `<td>${desc}</td>`)
      })
    }
  }

  return content
}

function processDocFile(file) {
  console.log(`Processing: ${file}`)

  let content = fs.readFileSync(file, 'utf8')
  const fileName = path.basename(file)

  // Applique toutes les transformations
  content = cleanupStyles(content)
  content = fixArrayTypes(content)
  content = convertMarkdownLinks(content)
  content = enhanceDescriptions(content, fileName)

  // Améliore les tableaux
  content = content.replace(/<table>/g, '<table class="api-table">')

  fs.writeFileSync(file, content, 'utf8')
}

function runMain() {
  const docsDir = path.join(__dirname, '..', 'docs')
  const docFiles = globSync(`${docsDir}/*.md`)

  console.log(`Found ${docFiles.length} documentation files`)

  for (const file of docFiles) {
    try {
      processDocFile(file)
    } catch (error) {
      console.error(`Error processing ${file}:`, error.message)
    }
  }

  console.log('Documentation fix complete!')
}

if (require.main === module) {
  runMain()
}
