const fs = require('fs')
const path = require('path')
const glob = require('glob')
const { printLog, printError, runMain } = require('./lib/execution-utils')
const { command } = require('./lib/command')

const PACKAGE_OPTIONS = {
  'packages/worker': {
    builtWithTypeScript: false,
    extraFiles: [
      // This file is not built with TypeScript and not listed by package.json entry points, so we
      // need to list it here.
      'esm/entries/string.d.ts',
    ],
  },
  'packages/rum-slim': {
    extraFiles: ['bundle/datadog-rum-slim.js'],
  },
  'packages/rum': {
    extraFiles: ['bundle/datadog-rum.js'],
  },
  'packages/logs': {
    extraFiles: ['bundle/datadog-logs.js'],
  },
}

runMain(() => {
  let success = true
  for (const packagePath of glob.globSync('packages/*')) {
    success = checkPackage(packagePath) && success
  }

  if (success) {
    printLog('Packages check done.')
  } else {
    printError('Packages check failed.')
    process.exitCode = 1
  }
})

function checkPackage(packagePath) {
  printLog(`Checking ${packagePath}`)
  const actualFiles = getActualPackageFiles(packagePath).sort()
  const expectedFiles = getExpectedPackageFiles(packagePath).sort()
  let success = true

  for (
    let actualFilesIndex = 0, expectedFilesIndex = 0;
    actualFilesIndex < actualFiles.length && expectedFilesIndex < expectedFiles.length;

  ) {
    const actualFile = actualFiles[actualFilesIndex]
    const expectedFile = expectedFiles[expectedFilesIndex]

    if (actualFile === expectedFile) {
      actualFilesIndex += 1
      expectedFilesIndex += 1
    } else if (actualFile < expectedFile) {
      printError(`  Extra file ${actualFile}`)
      success = false
      actualFilesIndex += 1
    } else {
      printError(`  Missing file ${expectedFile}`)
      success = false
      expectedFilesIndex += 1
    }
  }

  return success
}

function getActualPackageFiles(packagePath) {
  // Yarn behavior is a bit different from npm regarding `.npmignore` globs. Since we are publishing
  // packages using npm through Lerna[1], let's use npm to list files here.
  //
  // [1]: Quoting Lerna doc: "Lerna always uses npm to publish packages."
  // https://lerna.js.org/docs/features/version-and-publish#from-package
  const output = command`npm pack --dry-run --json`.withCurrentWorkingDirectory(packagePath).run()
  return JSON.parse(output)[0].files.map((file) => file.path)
}

function getExpectedPackageFiles(packagePath) {
  const options = PACKAGE_OPTIONS[packagePath] || {}

  // Some files are directly taken from the git repository. Most rules are coming from various
  // `.npmignore` files, but beside that NPM will [always include some files][1] like `package.json`
  // and `README.md`.
  //
  // [1]: https://docs.npmjs.com/cli/v9/using-npm/developers#keeping-files-out-of-your-package
  const globFilesFromRepository = [
    'README.md',
    'package.json',
    '*/package.json',
    'src/*.ts',
    'src/*.js',
    ':!src/*.spec.ts',
    ':!src/*.specHelper.ts',
  ]
  const filesFromRepository = command`git ls-files ${globFilesFromRepository}`
    .withCurrentWorkingDirectory(packagePath)
    .run()
    .split('\n')
    .filter(Boolean)

  // Some files are generated by TypeScript when building the package, including the corresponding
  // JavaScript file, typings and sourcemap.
  let filesBuiltWithTypeScript =
    options.builtWithTypeScript === false
      ? []
      : filesFromRepository
          .filter((file) => file.startsWith('src/') && file.endsWith('.ts'))
          .flatMap((file) => {
            const trimmedFile = file.slice(4, -3)
            return [
              `esm/${trimmedFile}.js`,
              `esm/${trimmedFile}.d.ts`,
              `esm/${trimmedFile}.js.map`,
              `cjs/${trimmedFile}.js`,
              `cjs/${trimmedFile}.d.ts`,
              `cjs/${trimmedFile}.js.map`,
            ]
          })

  // Some files are expected to exist because they are specified as entry point in a package.json.
  const filesFromPackageJsonEntryPoints = filesFromRepository
    .filter((file) => file.endsWith('package.json'))
    .flatMap((packageJsonPath) => {
      const content = JSON.parse(fs.readFileSync(path.join(packagePath, packageJsonPath)))
      return [content.main, content.module, content.types]
        .filter(Boolean)
        .map((entryPointPath) => path.join(path.dirname(packageJsonPath), entryPointPath))
    })

  return Array.from(
    new Set([
      ...filesFromRepository,
      ...filesBuiltWithTypeScript,
      ...filesFromPackageJsonEntryPoints,
      ...(options.extraFiles || []),
    ])
  )
}
