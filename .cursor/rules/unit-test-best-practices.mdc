---
description: For writing or refactoring unit tests
globs: 
alwaysApply: true
---
## Running Unit Tests

### Basic Commands

- **Run all unit tests**: `yarn test:unit`
- **Run a specific spec file**: `yarn test:unit --spec <file-path>`
- **Focus on specific tests**: Prepend `f` to `describe` and `it` (e.g., `fdescribe`, `fit`)

### Examples

#### Run All Tests
```bash
yarn test:unit
```

#### Run Single File
```bash
# Full path
yarn test:unit --spec packages/core/src/browser/addEventListener.spec.ts

# Pattern matching (if filename is unique)
yarn test:unit --spec "**/addEventListener.spec.ts"

# Multiple files with wildcards
yarn test:unit --spec "packages/core/**/browser/*.spec.ts"
```

#### Focus on Specific Tests
```typescript
// Run only this describe block
fdescribe('addEventListener', () => {
  // All tests in this block will run
  it('should add event listener', () => {})
  it('should remove event listener', () => {})
})

// Run only this single test
describe('addEventListener', () => {
  fit('should add event listener', () => {
    // Only this test will run
  })

  it('should remove event listener', () => {
    // This test will be skipped
  })
})
```

## Debugging Flaky Tests

```bash
# 1. Check test output for randomization seed
yarn test:unit
# Look for: "Randomized with seed 65781"

# 2. Set seed in karma configuration
# Edit test/unit/karma.base.conf.js:
module.exports = {
  // ... other config
  client: {
    jasmine: {
      // ... other jasmine config
      seed: 65781  // Use the seed from step 1
    }
  }
}

# 3. Run tests with the same order
yarn test:unit

# 4. Remove seed after debugging
```

## Test Structure Best Practices

### Descriptive Test Names
Use test names that follow clear patterns:

```typescript
describe('functionOrClassName', () => {
  // Setup variables with proper types
  let variable: Type
  let mockObject: MockType

  beforeEach(() => {
    // Setup for each test
    variable = setupVariable()
    mockObject = createMock()
    registerCleanupTask(() => cleanUpResources())
  })

  describe('when condition is met', () => {
    // Group related tests by behavior/context

    it('should perform expected action', () => {
      // Arrange
      const input = 'test-data'

      // Act
      const result = variable.process(input)

      // Assert
      expect(result).toBe('expected-output')
    })

    it('should handle edge cases', () => {
      // Test boundary conditions
      expect(variable.process('')).toBe('')
      expect(variable.process(null)).toThrow()
    })
  })

  describe('when condition is not met', () => {
    it('should handle alternative behavior', () => {
      // Test alternative paths
    })
  })
})
```

### File Organization
- **Co-location**: Test files use `.spec.ts` extension and are placed next to source files
- **Naming pattern**: `sourceFile.ts` → `sourceFile.spec.ts`
- **Auto-discovery**: Tests are found via glob: `packages/*/@(src|test)/**/*.spec.@(ts|tsx)`

## Test Utilities & Helpers

### Resource Cleanup Management
**Always use `registerCleanupTask`** for automatic cleanup:

```typescript
import { registerCleanupTask } from '@datadog/browser-core/test'

beforeEach(() => {
  // Subscribe to lifecycle events
  const subscription = lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, callback)

  // Register cleanup - runs even if test fails
  registerCleanupTask(() => {
    subscription.unsubscribe()
    resetGlobalState()
    clearDataStructures()
  })

  // Setup DOM elements
  const button = document.createElement('button')
  document.body.appendChild(button)
  registerCleanupTask(() => {
    button.parentNode?.removeChild(button)
  })
})
```

### Time & Clock Mocking

```typescript
import { mockClock } from '@datadog/browser-core/test'
import type { Clock } from '@datadog/browser-core/test'

describe('time-dependent functionality', () => {
  let clock: Clock

  beforeEach(() => {
    clock = mockClock()
    // Cleanup is handled automatically via registerCleanupTask
  })

  it('should handle delayed operations', () => {
    const callback = jasmine.createSpy('callback')

    // Trigger time-dependent code
    setTimeout(callback, 1000)

    // Verify callback hasn't been called yet
    expect(callback).not.toHaveBeenCalled()

    // Advance time by 1 second
    clock.tick(1000)

    // Now callback should have been called
    expect(callback).toHaveBeenCalled()
  })

  it('should handle multiple time intervals', () => {
    const results: number[] = []

    // Set up recurring timer
    setInterval(() => results.push(Date.now()), 500)

    // Advance time in steps
    clock.tick(500)  // First call
    clock.tick(500)  // Second call
    clock.tick(1000) // Third and fourth calls

    expect(results).toHaveLength(4)
  })
})
```

### Event Creation & DOM Testing

```typescript
import { createNewEvent } from '@datadog/browser-core/test'

describe('DOM interactions', () => {
  let container: HTMLDivElement
  let button: HTMLButtonElement

  beforeEach(() => {
    // Create test DOM structure
    container = document.createElement('div')
    button = document.createElement('button')
    button.id = 'test-button'
    button.textContent = 'Click me'
    button.style.width = '100px'
    button.style.height = '50px'

    container.appendChild(button)
    document.body.appendChild(container)

    // Register cleanup
    registerCleanupTask(() => {
      container.parentNode?.removeChild(container)
    })
  })

  it('should handle click events with proper event properties', () => {
    const clickHandler = jasmine.createSpy('clickHandler')
    button.addEventListener('click', clickHandler)

    // Create realistic click event
    const clickEvent = createNewEvent('click', {
      target: button,
      clientX: 50,
      clientY: 25,
      __ddIsTrusted: true  // Mark as trusted DataDog event
    })

    // Dispatch event
    button.dispatchEvent(clickEvent)

    // Verify handler was called with correct event
    expect(clickHandler).toHaveBeenCalledTimes(1)
    expect(clickHandler).toHaveBeenCalledWith(jasmine.objectContaining({
      target: button,
      type: 'click'
    }))
  })

  it('should handle keyboard events', () => {
    const keyHandler = jasmine.createSpy('keyHandler')
    button.addEventListener('keydown', keyHandler)

    const keyEvent = createNewEvent('keydown', {
      target: button,
      key: 'Enter',
      keyCode: 13,
      __ddIsTrusted: true
    })

    button.dispatchEvent(keyEvent)

    expect(keyHandler).toHaveBeenCalledWith(jasmine.objectContaining({
      key: 'Enter',
      keyCode: 13
    }))
  })
})
```

### Function Spying & Mocking

```typescript
describe('service interactions', () => {
  let service: MyService
  let dependency: ExternalDependency

  beforeEach(() => {
    dependency = {
      fetchData: jasmine.createSpy('fetchData').and.returnValue(Promise.resolve('data')),
      processData: jasmine.createSpy('processData').and.callFake((data) => `processed-${data}`)
    }
    service = new MyService(dependency)
  })

  it('should call dependencies with correct parameters', async () => {
    const input = 'test-input'

    // Execute method under test
    const result = await service.handleRequest(input)

    // Verify all interactions
    expect(dependency.fetchData).toHaveBeenCalledTimes(1)
    expect(dependency.fetchData).toHaveBeenCalledWith(input)
    expect(dependency.processData).toHaveBeenCalledWith('data')
    expect(result).toBe('processed-data')
  })

  it('should handle errors gracefully', async () => {
    // Configure spy to throw error
    dependency.fetchData.and.rejectWith(new Error('Network error'))

    // Verify error handling
    await expectAsync(service.handleRequest('input')).toBeRejectedWith(jasmine.any(Error))
    expect(dependency.fetchData).toHaveBeenCalled()
    expect(dependency.processData).not.toHaveBeenCalled()
  })

  it('should spy on existing object methods', () => {
    const existingObject = { method: () => 'original' }

    // Spy on existing method
    const spy = spyOn(existingObject, 'method').and.returnValue('mocked')

    const result = existingObject.method()

    expect(spy).toHaveBeenCalled()
    expect(result).toBe('mocked')

    // Restore original implementation if needed
    spy.and.callThrough()
    expect(existingObject.method()).toBe('original')
  })
})
```
## Async Testing Patterns

### Activity Validation

```typescript
describe('page activity tracking', () => {
  const BEFORE_PAGE_ACTIVITY_VALIDATION_DELAY = PAGE_ACTIVITY_VALIDATION_DELAY * 0.8
  const EXPIRE_DELAY = CLICK_ACTION_MAX_DURATION * 10
  let clock: Clock

  beforeEach(() => {
    clock = mockClock()
  })

  it('should wait for page activity to complete before finalizing action', () => {
    // Start activity that will trigger validation
    emulateClick({
      activity: {
        loadingTime: 500,
        resourceCount: 2
      }
    })

    // Before validation delay - action should still be pending
    clock.tick(BEFORE_PAGE_ACTIVITY_VALIDATION_DELAY)
    expect(findActionId()).toBeDefined()
    expect(events).toHaveLength(0)

    // After full validation delay - action should be completed
    clock.tick(PAGE_ACTIVITY_VALIDATION_DELAY - BEFORE_PAGE_ACTIVITY_VALIDATION_DELAY)
    expect(events).toHaveLength(1)
    expect(events[0].loadingTime).toBe(500)
  })

  it('should expire actions that take too long', () => {
    emulateClick({ activity: { loadingTime: Infinity } })

    // Fast forward to expiration
    clock.tick(EXPIRE_DELAY)

    expect(events).toHaveLength(1)
    expect(events[0].duration).toBe(CLICK_ACTION_MAX_DURATION)
    expect(events[0].frustrationTypes).toContain('dead_click')
  })
})
```

### Observable Testing

```typescript
describe('observable streams', () => {
  it('should handle observable emissions', () => {
    const observable = new Observable<UserAction>()
    const subscriber = jasmine.createSpy('subscriber')

    // Subscribe with cleanup
    const subscription = observable.subscribe(subscriber)
    registerCleanupTask(() => subscription.unsubscribe())

    // Test emission
    const testAction: UserAction = { type: 'CLICK', target: 'button' }
    observable.notify(testAction)

    expect(subscriber).toHaveBeenCalledTimes(1)
    expect(subscriber).toHaveBeenCalledWith(testAction)
  })

  it('should handle observable errors', () => {
    const observable = new Observable<string>()
    const errorHandler = jasmine.createSpy('errorHandler')

    const subscription = observable.subscribe({
      next: jasmine.createSpy('next'),
      error: errorHandler
    })
    registerCleanupTask(() => subscription.unsubscribe())

    // Trigger error
    const testError = new Error('Test error')
    observable.error(testError)

    expect(errorHandler).toHaveBeenCalledWith(testError)
  })
})
```

## Test Organization Patterns

### Parameterized Tests

```typescript
describe('event type handling', () => {
  // Test data
  const eventTypesWithActions = [
    RumEventType.RESOURCE,
    RumEventType.LONG_TASK,
    RumEventType.ERROR,
    RumEventType.VITAL
  ]

  const eventTypesWithoutActions = [
    RumEventType.VIEW,
    RumEventType.ACTION
  ]

  // Test multiple event types with same logic
  eventTypesWithActions.forEach((eventType) => {
    it(`should add action context to ${eventType} events`, () => {
      const actionId = 'test-action-id-123'
      spyOn(actionContexts, 'findActionId').and.returnValue(actionId)

      const attributes = hooks.triggerHook(HookNames.BEFORE_SEND, {
        eventType,
        startTime: 0 as RelativeTime,
        rawRumEvent: createMockRumEvent(eventType)
      })

      expect(attributes).toEqual(jasmine.objectContaining({
        action: { id: actionId }
      }))
    })

    it(`should handle missing action context for ${eventType}`, () => {
      spyOn(actionContexts, 'findActionId').and.returnValue(undefined)

      const attributes = hooks.triggerHook(HookNames.BEFORE_SEND, {
        eventType,
        startTime: 0 as RelativeTime,
        rawRumEvent: createMockRumEvent(eventType)
      })

      expect(attributes?.action).toBeUndefined()
    })
  })

  // Test exclusions
  eventTypesWithoutActions.forEach((eventType) => {
    it(`should not add action context to ${eventType} events`, () => {
      spyOn(actionContexts, 'findActionId').and.returnValue('some-action-id')

      const attributes = hooks.triggerHook(HookNames.BEFORE_SEND, {
        eventType,
        startTime: 0 as RelativeTime,
        rawRumEvent: createMockRumEvent(eventType)
      })

      expect(attributes?.action).toBeUndefined()
    })
  })

  // Helper function
  function createMockRumEvent(type: RumEventType): RawRumEvent {
    return {
      type,
      date: Date.now(),
      _dd: { format_version: 2 }
    } as RawRumEvent
  }
})
```

## Memory Leak Prevention

### Cleanup Checklist
✅ **Always do:**
- Use `registerCleanupTask()` for all resource cleanup
- Unsubscribe from observables and event listeners
- Remove DOM elements after tests
- Reset global state in `beforeEach`
- Stop managers and services properly
- Clear intervals/timeouts (handled by clock cleanup)

❌ **Never do:**
- Rely on `afterEach` for critical cleanup (may not run if test fails)
- Leave DOM elements attached to document
- Use real timers in tests
- Test multiple unrelated behaviors in one test

### Cleanup Examples

```typescript
describe('comprehensive cleanup example', () => {
  let manager: ResourceManager
  let element: HTMLElement
  let subscription: Subscription
  let intervalId: number

  beforeEach(() => {
    // Setup with proper cleanup registration
    manager = new ResourceManager()
    registerCleanupTask(() => manager.destroy())

    element = document.createElement('div')
    document.body.appendChild(element)
    registerCleanupTask(() => element.parentNode?.removeChild(element))

    subscription = eventStream.subscribe(handler)
    registerCleanupTask(() => subscription.unsubscribe())

    intervalId = setInterval(periodicTask, 1000)
    registerCleanupTask(() => clearInterval(intervalId))
  })

  it('should handle all resources properly', () => {
    // Test implementation
    // All cleanup happens automatically via registerCleanupTask
  })
})
```

## Common Anti-Patterns to Avoid

### ❌ Don't Do This

```typescript
// DON'T: Use afterEach for cleanup - may not run if test fails
afterEach(() => {
  subscription.unsubscribe()  // Might not execute
  element.remove()           // Memory leak potential
})

// DON'T: Create DOM manually
it('should test DOM interaction', () => {
  const element = document.createElement('div')
  document.body.appendChild(element)
  // Missing cleanup - memory leak!
  // use appendElement helper!
})

// DON'T: Use real timers - makes tests slow and flaky
it('should handle delayed action', (done) => {
  setTimeout(() => {
    expect(something).toBeTruthy()
    done()
  }, 1000) // Real 1-second delay!
})

// DON'T: Test multiple unrelated behaviors
it('should do everything', () => {
  // Setup user
  const user = createUser()
  expect(user.id).toBeDefined()

  // Test login
  user.login()
  expect(user.isLoggedIn).toBeTruthy()

  // Test permissions
  expect(user.hasPermission('admin')).toBeFalsy()

  // Test logout
  user.logout()
  expect(user.isLoggedIn).toBeFalsy()
  // Hard to debug when one part fails!
})

// DON'T: Use vague test names
it('should work', () => {
  // What should work? How?
})

it('should test the function', () => {
  // Which function? What aspect?
})
```

### ✅ Do This Instead

```typescript
// DO: Use registerCleanupTask for reliable cleanup
beforeEach(() => {
  const subscription = observable.subscribe(handler)
  registerCleanupTask(() => subscription.unsubscribe())

  const element = document.createElement('div')
  document.body.appendChild(element)
  registerCleanupTask(() => element.parentNode?.removeChild(element))
})

// DO: use existing helpers
  it('should add DOM with appendElement helper', () => {
  appendElement('<input type="checkbox" id="test-checkbox" />')
  const label = appendElement('<label for="test-checkbox">Check me</label>')
})

// DO: Use mocked clock for time-based tests
beforeEach(() => {
  clock = mockClock()
})
it('should handle delayed operations', () => {
  const callback = jasmine.createSpy()
  setTimeout(callback, 1000)

  clock.tick(1000) // Instant!
  expect(callback).toHaveBeenCalled()
})

// DO: One focused assertion per test
describe('User', () => {
  it('should generate unique ID on creation', () => {
    const user = createUser()
    expect(user.id).toMatch(/^user-\d+$/)
  })

  it('should start in logged-out state', () => {
    const user = createUser()
    expect(user.isLoggedIn).toBeFalsy()
  })

  it('should allow login with valid credentials', () => {
    const user = createUser()
    user.login('valid@email.com', 'password')
    expect(user.isLoggedIn).toBeTruthy()
  })

  it('should deny admin permissions to regular user', () => {
    const user = createUser()
    expect(user.hasPermission('admin')).toBeFalsy()
  })
})

// DO: Use descriptive, specific test names
it('should generate SHA-256 hash for user password', () => {
  // Clear what's being tested
})

it('should throw ValidationError when email format is invalid', () => {
  // Clear behavior and expected outcome
})
```
