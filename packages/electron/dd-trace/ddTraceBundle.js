var __getOwnPropNames = Object.getOwnPropertyNames
var __commonJS = (cb, mod2) =>
  function __require() {
    return (mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports)
  }

// node_modules/dd-trace/packages/dd-trace/src/util.js
var require_util = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/util.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    function isTrue(str) {
      str = String(str).toLowerCase()
      return str === 'true' || str === '1'
    }
    function isFalse(str) {
      str = String(str).toLowerCase()
      return str === 'false' || str === '0'
    }
    function isError(value) {
      return Boolean(value?.message || value instanceof Error)
    }
    function globMatch(pattern, subject) {
      if (typeof pattern === 'string') pattern = pattern.toLowerCase()
      if (typeof subject === 'string') subject = subject.toLowerCase()
      if (typeof subject === 'number' && Number.isInteger(subject)) subject = String(subject)
      let px = 0
      let sx = 0
      let nextPx = 0
      let nextSx = 0
      while (px < pattern.length || sx < subject.length) {
        if (px < pattern.length) {
          const c = pattern[px]
          switch (c) {
            case '?':
              if (sx < subject.length) {
                px++
                sx++
                continue
              }
              break
            case '*':
              nextPx = px
              nextSx = sx + 1
              px++
              continue
            default:
              if (sx < subject.length && subject[sx] === c) {
                px++
                sx++
                continue
              }
              break
          }
        }
        if (nextSx > 0 && nextSx <= subject.length) {
          px = nextPx
          sx = nextSx
          continue
        }
        return false
      }
      return true
    }
    function calculateDDBasePath(dirname) {
      const dirSteps = dirname.split(path.sep)
      const packagesIndex = dirSteps.lastIndexOf('packages')
      return dirSteps.slice(0, packagesIndex).join(path.sep) + path.sep
    }
    function normalizeProfilingEnabledValue(configValue) {
      return isTrue(configValue) ? 'true' : isFalse(configValue) ? 'false' : configValue === 'auto' ? 'auto' : void 0
    }
    function normalizePluginEnvName(envPluginName, makeLowercase = false) {
      if (envPluginName.startsWith('@')) {
        envPluginName = envPluginName.slice(1)
      }
      envPluginName = envPluginName.replaceAll(/[^a-z0-9_]/gi, '_')
      return makeLowercase ? envPluginName.toLowerCase() : envPluginName
    }
    module2.exports = {
      isTrue,
      isFalse,
      isError,
      globMatch,
      ddBasePath: globalThis.__DD_ESBUILD_BASEPATH || calculateDDBasePath(__dirname),
      normalizeProfilingEnabledValue,
      normalizePluginEnvName,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/supported-configurations.json
var require_supported_configurations = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/supported-configurations.json'(exports2, module2) {
    module2.exports = {
      supportedConfigurations: {
        DD_AAS_DOTNET_EXTENSION_VERSION: ['A'],
        DD_ACTION_EXECUTION_ID: ['A'],
        DD_AGENT_HOST: ['A'],
        DD_AGENTLESS_LOG_SUBMISSION_ENABLED: ['A'],
        DD_AGENTLESS_LOG_SUBMISSION_URL: ['A'],
        DD_AI_GUARD_ENABLED: ['A'],
        DD_AI_GUARD_ENDPOINT: ['A'],
        DD_AI_GUARD_MAX_CONTENT_SIZE: ['A'],
        DD_AI_GUARD_MAX_MESSAGES_LENGTH: ['A'],
        DD_AI_GUARD_TIMEOUT: ['A'],
        DD_API_KEY: ['A'],
        DD_API_SECURITY_ENABLED: ['A'],
        DD_API_SECURITY_SAMPLE_DELAY: ['A'],
        DD_API_SECURITY_ENDPOINT_COLLECTION_ENABLED: ['A'],
        DD_API_SECURITY_ENDPOINT_COLLECTION_MESSAGE_LIMIT: ['A'],
        DD_APM_FLUSH_DEADLINE_MILLISECONDS: ['A'],
        DD_APM_TRACING_ENABLED: ['A'],
        DD_APP_KEY: ['A'],
        DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE: ['A'],
        DD_APPSEC_COLLECT_ALL_HEADERS: ['A'],
        DD_APPSEC_ENABLED: ['A'],
        DD_APPSEC_GRAPHQL_BLOCKED_TEMPLATE_JSON: ['A'],
        DD_APPSEC_HEADER_COLLECTION_REDACTION_ENABLED: ['A'],
        DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML: ['A'],
        DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON: ['A'],
        DD_APPSEC_MAX_COLLECTED_HEADERS: ['A'],
        DD_APPSEC_MAX_STACK_TRACE_DEPTH: ['A'],
        DD_APPSEC_MAX_STACK_TRACES: ['A'],
        DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP: ['A'],
        DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP: ['A'],
        DD_APPSEC_RASP_COLLECT_REQUEST_BODY: ['A'],
        DD_APPSEC_RASP_ENABLED: ['A'],
        DD_APPSEC_RULES: ['A'],
        DD_APPSEC_SCA_ENABLED: ['A'],
        DD_APPSEC_STACK_TRACE_ENABLED: ['A'],
        DD_APPSEC_TRACE_RATE_LIMIT: ['A'],
        DD_APPSEC_WAF_TIMEOUT: ['A'],
        DD_CIVISIBILITY_AGENTLESS_ENABLED: ['A'],
        DD_CIVISIBILITY_AGENTLESS_URL: ['A'],
        DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER: ['A'],
        DD_CIVISIBILITY_DANGEROUSLY_FORCE_COVERAGE: ['A'],
        DD_CIVISIBILITY_DANGEROUSLY_FORCE_TEST_SKIPPING: ['A'],
        DD_CIVISIBILITY_EARLY_FLAKE_DETECTION_ENABLED: ['A'],
        DD_CIVISIBILITY_ENABLED: ['A'],
        DD_CIVISIBILITY_FLAKY_RETRY_COUNT: ['A'],
        DD_CIVISIBILITY_FLAKY_RETRY_ENABLED: ['A'],
        DD_CIVISIBILITY_GIT_UNSHALLOW_ENABLED: ['A'],
        DD_CIVISIBILITY_GIT_UPLOAD_ENABLED: ['A'],
        DD_CIVISIBILITY_IMPACTED_TESTS_DETECTION_ENABLED: ['A'],
        DD_CIVISIBILITY_ITR_ENABLED: ['A'],
        DD_CIVISIBILITY_RUM_FLUSH_WAIT_MILLIS: ['A'],
        DD_CIVISIBILITY_MANUAL_API_ENABLED: ['A'],
        DD_CIVISIBILITY_TEST_COMMAND: ['A'],
        DD_CIVISIBILITY_TEST_MODULE_ID: ['A'],
        DD_CIVISIBILITY_TEST_SESSION_ID: ['A'],
        DD_CODE_ORIGIN_FOR_SPANS_ENABLED: ['A'],
        DD_CODE_ORIGIN_FOR_SPANS_EXPERIMENTAL_EXIT_SPANS_ENABLED: ['A'],
        DD_CRASHTRACKING_ENABLED: ['A'],
        DD_CUSTOM_TRACE_ID: ['A'],
        DD_DATA_STREAMS_ENABLED: ['A'],
        DD_DBM_PROPAGATION_MODE: ['A'],
        DD_DOGSTATSD_HOST: ['A'],
        DD_DOGSTATSD_PORT: ['A'],
        DD_DYNAMIC_INSTRUMENTATION_CAPTURE_TIMEOUT_MS: ['A'],
        DD_DYNAMIC_INSTRUMENTATION_ENABLED: ['A'],
        DD_DYNAMIC_INSTRUMENTATION_PROBE_FILE: ['A'],
        DD_DYNAMIC_INSTRUMENTATION_REDACTED_IDENTIFIERS: ['A'],
        DD_DYNAMIC_INSTRUMENTATION_REDACTION_EXCLUDED_IDENTIFIERS: ['A'],
        DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS: ['A'],
        DD_ENV: ['A'],
        DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED: ['A'],
        DD_EXPERIMENTAL_FLAGGING_PROVIDER_ENABLED: ['A'],
        DD_EXPERIMENTAL_PROPAGATE_PROCESS_TAGS_ENABLED: ['A'],
        DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_ENABLED: ['A'],
        DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_DIR: ['A'],
        DD_EXTERNAL_ENV: ['A'],
        DD_FLAGGING_PROVIDER_ENABLED: ['A'],
        DD_GIT_BRANCH: ['A'],
        DD_GIT_COMMIT_AUTHOR_DATE: ['A'],
        DD_GIT_COMMIT_AUTHOR_EMAIL: ['A'],
        DD_GIT_COMMIT_AUTHOR_NAME: ['A'],
        DD_GIT_COMMIT_COMMITTER_DATE: ['A'],
        DD_GIT_COMMIT_COMMITTER_EMAIL: ['A'],
        DD_GIT_COMMIT_COMMITTER_NAME: ['A'],
        DD_GIT_COMMIT_MESSAGE: ['A'],
        DD_GIT_COMMIT_SHA: ['A'],
        DD_GIT_PROPERTIES_FILE: ['A'],
        DD_GIT_FOLDER_PATH: ['A'],
        DD_GIT_REPOSITORY_URL: ['A'],
        DD_GIT_TAG: ['A'],
        DD_GIT_PULL_REQUEST_BASE_BRANCH: ['A'],
        DD_GIT_PULL_REQUEST_BASE_BRANCH_SHA: ['A'],
        DD_GRPC_CLIENT_ERROR_STATUSES: ['A'],
        DD_GRPC_SERVER_ERROR_STATUSES: ['A'],
        DD_HEAP_SNAPSHOT_COUNT: ['A'],
        DD_HEAP_SNAPSHOT_INTERVAL: ['A'],
        DD_HEAP_SNAPSHOT_DESTINATION: ['A'],
        DD_IAST_DB_ROWS_TO_TAINT: ['A'],
        DD_IAST_DEDUPLICATION_ENABLED: ['A'],
        DD_IAST_ENABLED: ['A'],
        DD_IAST_MAX_CONCURRENT_REQUESTS: ['A'],
        DD_IAST_MAX_CONTEXT_OPERATIONS: ['A'],
        DD_IAST_REDACTION_ENABLED: ['A'],
        DD_IAST_REDACTION_NAME_PATTERN: ['A'],
        DD_IAST_REDACTION_VALUE_PATTERN: ['A'],
        DD_IAST_REQUEST_SAMPLING: ['A'],
        DD_IAST_SECURITY_CONTROLS_CONFIGURATION: ['A'],
        DD_IAST_STACK_TRACE_ENABLED: ['A'],
        DD_IAST_TELEMETRY_VERBOSITY: ['A'],
        DD_INJECT_FORCE: ['A'],
        DD_INJECTION_ENABLED: ['A'],
        DD_INSTRUMENTATION_CONFIG_ID: ['A'],
        DD_INSTRUMENTATION_INSTALL_ID: ['A'],
        DD_INSTRUMENTATION_INSTALL_TIME: ['A'],
        DD_INSTRUMENTATION_INSTALL_TYPE: ['A'],
        DD_INSTRUMENTATION_TELEMETRY_ENABLED: ['A'],
        DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD: ['A'],
        DD_INTERNAL_PROFILING_TIMELINE_SAMPLING_ENABLED: ['A'],
        DD_LAMBDA_HANDLER: ['A'],
        DD_LANGCHAIN_SPAN_CHAR_LIMIT: ['A'],
        DD_LANGCHAIN_SPAN_PROMPT_COMPLETION_SAMPLE_RATE: ['A'],
        DD_LLMOBS_AGENTLESS_ENABLED: ['A'],
        DD_LLMOBS_ENABLED: ['A'],
        DD_LLMOBS_ML_APP: ['A'],
        DD_LOG_LEVEL: ['A'],
        DD_LOGS_INJECTION: ['A'],
        DD_LOGS_OTEL_ENABLED: ['A'],
        DD_METRICS_OTEL_ENABLED: ['A'],
        DD_MINI_AGENT_PATH: ['A'],
        DD_OPENAI_LOGS_ENABLED: ['A'],
        DD_OPENAI_SPAN_CHAR_LIMIT: ['A'],
        DD_PIPELINE_EXECUTION_ID: ['A'],
        DD_PLAYWRIGHT_WORKER: ['A'],
        DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED: ['A'],
        DD_PROFILING_CODEHOTSPOTS_ENABLED: ['A'],
        DD_PROFILING_CPU_ENABLED: ['A'],
        DD_PROFILING_DEBUG_SOURCE_MAPS: ['A'],
        DD_PROFILING_DEBUG_UPLOAD_COMPRESSION: ['A'],
        DD_PROFILING_ENABLED: ['A'],
        DD_PROFILING_ENDPOINT_COLLECTION_ENABLED: ['A'],
        DD_PROFILING_EXPERIMENTAL_OOM_EXPORT_STRATEGIES: ['A'],
        DD_PROFILING_EXPERIMENTAL_OOM_HEAP_LIMIT_EXTENSION_SIZE: ['A'],
        DD_PROFILING_EXPERIMENTAL_OOM_MAX_HEAP_EXTENSION_COUNT: ['A'],
        DD_PROFILING_EXPERIMENTAL_OOM_MONITORING_ENABLED: ['A'],
        DD_PROFILING_EXPORTERS: ['A'],
        DD_PROFILING_HEAP_ENABLED: ['A'],
        DD_PROFILING_HEAP_SAMPLING_INTERVAL: ['A'],
        DD_PROFILING_PPROF_PREFIX: ['A'],
        DD_PROFILING_PROFILERS: ['A'],
        DD_PROFILING_SOURCE_MAP: ['A'],
        DD_PROFILING_TIMELINE_ENABLED: ['A'],
        DD_PROFILING_UPLOAD_PERIOD: ['A'],
        DD_PROFILING_UPLOAD_TIMEOUT: ['A'],
        DD_PROFILING_V8_PROFILER_BUG_WORKAROUND: ['A'],
        DD_PROFILING_WALLTIME_ENABLED: ['A'],
        DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS: ['A'],
        DD_REMOTE_CONFIGURATION_ENABLED: ['A'],
        DD_RUNTIME_METRICS_ENABLED: ['A'],
        DD_RUNTIME_METRICS_EVENT_LOOP_ENABLED: ['A'],
        DD_RUNTIME_METRICS_GC_ENABLED: ['A'],
        DD_RUNTIME_METRICS_FLUSH_INTERVAL: ['A'],
        DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED: ['A'],
        DD_SERVICE_MAPPING: ['A'],
        DD_SERVICE: ['A'],
        DD_SITE: ['A'],
        DD_SPAN_SAMPLING_RULES_FILE: ['A'],
        DD_SPAN_SAMPLING_RULES: ['A'],
        DD_TAGS: ['A'],
        DD_TELEMETRY_DEBUG: ['A'],
        DD_TELEMETRY_DEPENDENCY_COLLECTION_ENABLED: ['A'],
        DD_TELEMETRY_FORWARDER_PATH: ['A'],
        DD_TELEMETRY_HEARTBEAT_INTERVAL: ['A'],
        DD_TELEMETRY_LOG_COLLECTION_ENABLED: ['A'],
        DD_TELEMETRY_METRICS_ENABLED: ['A'],
        DD_TEST_FAILED_TEST_REPLAY_ENABLED: ['A'],
        DD_TEST_FLEET_CONFIG_PATH: ['A'],
        DD_TEST_LOCAL_CONFIG_PATH: ['A'],
        DD_TEST_MANAGEMENT_ATTEMPT_TO_FIX_RETRIES: ['A'],
        DD_TEST_MANAGEMENT_ENABLED: ['A'],
        DD_TEST_SESSION_NAME: ['A'],
        DD_TRACE_128_BIT_TRACEID_GENERATION_ENABLED: ['A'],
        DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED: ['A'],
        DD_TRACE_AEROSPIKE_ENABLED: ['A'],
        DD_TRACE_AI_ENABLED: ['A'],
        DD_TRACE_ANTHROPIC_ENABLED: ['A'],
        DD_TRACE_AGENT_PORT: ['A'],
        DD_TRACE_AGENT_PROTOCOL_VERSION: ['A'],
        DD_TRACE_AGENT_URL: ['A'],
        DD_TRACE_AMQP10_ENABLED: ['A'],
        DD_TRACE_AMQPLIB_ENABLED: ['A'],
        DD_TRACE_APOLLO_ENABLED: ['A'],
        DD_TRACE_APOLLO_GATEWAY_ENABLED: ['A'],
        DD_TRACE_APOLLO_SERVER_CORE_ENABLED: ['A'],
        DD_TRACE_APOLLO_SERVER_ENABLED: ['A'],
        DD_TRACE_APOLLO_SERVER_EXPRESS_ENABLED: ['A'],
        DD_TRACE_APOLLO_SERVER_FASTIFY_ENABLED: ['A'],
        DD_TRACE_APOLLO_SUBGRAPH_ENABLED: ['A'],
        DD_TRACE_AVSC_ENABLED: ['A'],
        DD_TRACE_AWS_ADD_SPAN_POINTERS: ['A'],
        DD_TRACE_AWS_SDK_AWS_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_AWS_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_BEDROCKRUNTIME_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_BEDROCKRUNTIME_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_CLOUDWATCHLOGS_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_CLOUDWATCHLOGS_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_DYNAMODB_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_DYNAMODB_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_EVENTBRIDGE_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_EVENTBRIDGE_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_KINESIS_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_KINESIS_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_LAMBDA_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_LAMBDA_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_NODE_HTTP_HANDLER_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_REDSHIFT_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_REDSHIFT_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_S3_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_S3_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SFN_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SFN_CLIENT_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SFN_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SMITHY_CLIENT_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SNS_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SNS_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SQS_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_SQS_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_STATES_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_STATES_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_STEPFUNCTIONS_BATCH_PROPAGATION_ENABLED: ['A'],
        DD_TRACE_AWS_SDK_STEPFUNCTIONS_ENABLED: ['A'],
        DD_TRACE_AXIOS_ENABLED: ['A'],
        DD_TRACE_AZURE_EVENT_HUBS_ENABLED: ['A'],
        DD_TRACE_AZURE_EVENTHUBS_BATCH_LINKS_ENABLED: ['A'],
        DD_TRACE_AZURE_FUNCTIONS_ENABLED: ['A'],
        DD_TRACE_AZURE_SERVICE_BUS_ENABLED: ['A'],
        DD_TRACE_AZURE_SERVICEBUS_BATCH_LINKS_ENABLED: ['A'],
        DD_TRACE_BAGGAGE_MAX_BYTES: ['A'],
        DD_TRACE_BAGGAGE_MAX_ITEMS: ['A'],
        DD_TRACE_BAGGAGE_TAG_KEYS: ['A'],
        DD_TRACE_BEAUTIFUL_LOGS: ['A'],
        DD_TRACE_BLUEBIRD_ENABLED: ['A'],
        DD_TRACE_BODY_PARSER_ENABLED: ['A'],
        DD_TRACE_BSON_ENABLED: ['A'],
        DD_TRACE_BUNYAN_ENABLED: ['A'],
        DD_TRACE_CASSANDRA_DRIVER_ENABLED: ['A'],
        DD_TRACE_CHILD_PROCESS_ENABLED: ['A'],
        DD_TRACE_CLIENT_IP_ENABLED: ['A'],
        DD_TRACE_CLIENT_IP_HEADER: ['A'],
        DD_TRACE_CLOUD_PAYLOAD_TAGGING_MAX_DEPTH: ['A'],
        DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING: ['A'],
        DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING: ['A'],
        DD_TRACE_COLLECTIONS_ENABLED: ['A'],
        DD_TRACE_COMMONPLUGIN_ENABLED: ['A'],
        DD_TRACE_CONFLUENTINC_KAFKA_JAVASCRIPT_ENABLED: ['A'],
        DD_TRACE_CONNECT_ENABLED: ['A'],
        DD_TRACE_COOKIE_ENABLED: ['A'],
        DD_TRACE_COOKIE_PARSER_ENABLED: ['A'],
        DD_TRACE_COUCHBASE_ENABLED: ['A'],
        DD_TRACE_CRYPTO_ENABLED: ['A'],
        DD_TRACE_CUCUMBER_CUCUMBER_ENABLED: ['A'],
        DD_TRACE_CUCUMBER_ENABLED: ['A'],
        DD_TRACE_CYPRESS_ENABLED: ['A'],
        DD_TRACE_DD_TRACE_API_ENABLED: ['A'],
        DD_TRACE_DEBUG: ['A'],
        DD_TRACE_DISABLED_INSTRUMENTATIONS: ['A'],
        DD_TRACE_DISABLED_PLUGINS: ['A'],
        DD_TRACE_DNS_ENABLED: ['A'],
        DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS: ['A'],
        DD_TRACE_ELASTIC_ELASTICSEARCH_ENABLED: ['A'],
        DD_TRACE_ELASTIC_TRANSPORT_ENABLED: ['A'],
        DD_TRACE_ELASTICSEARCH_ENABLED: ['A'],
        DD_TRACE_ENABLED: ['A'],
        DD_TRACE_ENCODING_DEBUG: ['A'],
        DD_TRACE_EXPERIMENTAL_B3_ENABLED: ['A'],
        DD_TRACE_EXPERIMENTAL_EXPORTER: ['A'],
        DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED: ['A'],
        DD_TRACE_EXPERIMENTAL_SPAN_COUNTS: ['A'],
        DD_TRACE_EXPERIMENTAL_STATE_TRACKING: ['A'],
        DD_TRACE_EXPRESS_ENABLED: ['A'],
        DD_TRACE_EXPRESS_MONGO_SANITIZE_ENABLED: ['A'],
        DD_TRACE_EXPRESS_SESSION_ENABLED: ['A'],
        DD_TRACE_FASTIFY_ENABLED: ['A'],
        DD_TRACE_FETCH_ENABLED: ['A'],
        DD_TRACE_FIND_MY_WAY_ENABLED: ['A'],
        DD_TRACE_FLUSH_INTERVAL: ['A'],
        DD_TRACE_FS_ENABLED: ['A'],
        DD_TRACE_GENERIC_POOL_ENABLED: ['A'],
        DD_TRACE_GIT_METADATA_ENABLED: ['A'],
        DD_TRACE_GLOBAL_TAGS: ['A'],
        DD_TRACE_GOOGLE_CLOUD_PUBSUB_ENABLED: ['A'],
        DD_TRACE_GOOGLE_CLOUD_VERTEXAI_ENABLED: ['A'],
        DD_TRACE_GOOGLE_GAX_ENABLED: ['A'],
        DD_TRACE_GOOGLE_GENAI_ENABLED: ['A'],
        DD_TRACE_GRAPHQL_ENABLED: ['A'],
        DD_TRACE_GRAPHQL_ERROR_EXTENSIONS: ['A'],
        DD_TRACE_GRAPHQL_TAG_ENABLED: ['A'],
        DD_TRACE_GRAPHQL_TOOLS_ENABLED: ['A'],
        DD_TRACE_GRAPHQL_TOOLS_EXECUTOR_ENABLED: ['A'],
        DD_TRACE_GRAPHQL_YOGA_ENABLED: ['A'],
        DD_TRACE_GRPC_ENABLED: ['A'],
        DD_TRACE_GRPC_GRPC_JS_ENABLED: ['A'],
        DD_TRACE_GRPC_PROTO_LOADER_ENABLED: ['A'],
        DD_TRACE_HANDLEBARS_ENABLED: ['A'],
        DD_TRACE_HAPI_BOOM_ENABLED: ['A'],
        DD_TRACE_HAPI_ENABLED: ['A'],
        DD_TRACE_HAPI_HAPI_ENABLED: ['A'],
        DD_TRACE_HEADER_TAGS: ['A'],
        DD_TRACE_HONO_ENABLED: ['A'],
        DD_TRACE_HTTP_ENABLED: ['A'],
        DD_TRACE_HTTP2_ENABLED: ['A'],
        DD_TRACE_HTTPS_ENABLED: ['A'],
        DD_TRACE_INFERRED_PROXY_SERVICES_ENABLED: ['A'],
        DD_TRACE_IOREDIS_ENABLED: ['A'],
        DD_TRACE_IOVALKEY_ENABLED: ['A'],
        DD_TRACE_JEST_CIRCUS_ENABLED: ['A'],
        DD_TRACE_JEST_CONFIG_ENABLED: ['A'],
        DD_TRACE_JEST_CORE_ENABLED: ['A'],
        DD_TRACE_JEST_ENABLED: ['A'],
        DD_TRACE_JEST_ENVIRONMENT_JSDOM_ENABLED: ['A'],
        DD_TRACE_JEST_ENVIRONMENT_NODE_ENABLED: ['A'],
        DD_TRACE_JEST_GLOBALS_ENABLED: ['A'],
        DD_TRACE_JEST_REPORTERS_ENABLED: ['A'],
        DD_TRACE_JEST_RUNTIME_ENABLED: ['A'],
        DD_TRACE_JEST_TEST_SEQUENCER_ENABLED: ['A'],
        DD_TRACE_JEST_TRANSFORM_ENABLED: ['A'],
        DD_TRACE_JEST_WORKER_ENABLED: ['A'],
        DD_TRACE_KAFKAJS_ENABLED: ['A'],
        DD_TRACE_KNEX_ENABLED: ['A'],
        DD_TRACE_KOA_ENABLED: ['A'],
        DD_TRACE_KOA_ROUTE_ENABLED: ['A'],
        DD_TRACE_KOA_ROUTER_ENABLED: ['A'],
        DD_TRACE_KOA_WEBSOCKET_ENABLED: ['A'],
        DD_TRACE_LANGCHAIN_ANTHROPIC_ENABLED: ['A'],
        DD_TRACE_LANGCHAIN_COHERE_ENABLED: ['A'],
        DD_TRACE_LANGCHAIN_CORE_ENABLED: ['A'],
        DD_TRACE_LANGCHAIN_ENABLED: ['A'],
        DD_TRACE_LANGCHAIN_GOOGLE_GENAI_ENABLED: ['A'],
        DD_TRACE_LANGCHAIN_OPENAI_ENABLED: ['A'],
        DD_TRACE_LDAPJS_ENABLED: ['A'],
        DD_TRACE_LDAPJS_PROMISE_ENABLED: ['A'],
        DD_TRACE_LEGACY_BAGGAGE_ENABLED: ['A'],
        DD_TRACE_LIMITD_CLIENT_ENABLED: ['A'],
        DD_TRACE_LODASH_ENABLED: ['A'],
        DD_TRACE_LOG_LEVEL: ['A'],
        DD_TRACE_LOOPBACK_ENABLED: ['A'],
        DD_TRACE_MARIADB_ENABLED: ['A'],
        DD_TRACE_MEMCACHED_COMMAND_ENABLED: ['A'],
        DD_TRACE_MEMCACHED_ENABLED: ['A'],
        DD_TRACE_MICROGATEWAY_CORE_ENABLED: ['A'],
        DD_TRACE_MIDDIE_ENABLED: ['A'],
        DD_TRACE_MIDDLEWARE_TRACING_ENABLED: ['A'],
        DD_TRACE_MOCHA_EACH_ENABLED: ['A'],
        DD_TRACE_MOCHA_ENABLED: ['A'],
        DD_TRACE_MOLECULER_ENABLED: ['A'],
        DD_TRACE_MONGODB_CORE_ENABLED: ['A'],
        DD_TRACE_MONGODB_ENABLED: ['A'],
        DD_TRACE_MONGODB_HEARTBEAT_ENABLED: ['A'],
        DD_TRACE_MONGOOSE_ENABLED: ['A'],
        DD_TRACE_MQUERY_ENABLED: ['A'],
        DD_TRACE_MULTER_ENABLED: ['A'],
        DD_TRACE_MYSQL_ENABLED: ['A'],
        DD_TRACE_MYSQL2_ENABLED: ['A'],
        DD_TRACE_NATIVE_SPAN_EVENTS: ['A'],
        DD_TRACE_NET_ENABLED: ['A'],
        DD_TRACE_NEXT_ENABLED: ['A'],
        DD_TRACE_NODE_CHILD_PROCESS_ENABLED: ['A'],
        DD_TRACE_NODE_REDIS_CLIENT_ENABLED: ['A'],
        DD_TRACE_NODE_SERIALIZE_ENABLED: ['A'],
        DD_TRACE_NYC_ENABLED: ['A'],
        DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP: ['A'],
        DD_TRACE_OPENAI_ENABLED: ['A'],
        DD_TRACE_OPENSEARCH_ENABLED: ['A'],
        DD_TRACE_OPENSEARCH_PROJECT_OPENSEARCH_ENABLED: ['A'],
        DD_TRACE_OPENTELEMETRY_SDK_TRACE_NODE_ENABLED: ['A'],
        DD_TRACE_ORACLEDB_ENABLED: ['A'],
        DD_TRACE_OTEL_ENABLED: ['A'],
        DD_TRACE_PARTIAL_FLUSH_MIN_SPANS: ['A'],
        DD_TRACE_PASSPORT_ENABLED: ['A'],
        DD_TRACE_PASSPORT_HTTP_ENABLED: ['A'],
        DD_TRACE_PASSPORT_LOCAL_ENABLED: ['A'],
        DD_TRACE_PEER_SERVICE_DEFAULTS_ENABLED: ['A'],
        DD_TRACE_PEER_SERVICE_MAPPING: ['A'],
        DD_TRACE_PG_CURSOR_ENABLED: ['A'],
        DD_TRACE_PG_ENABLED: ['A'],
        DD_TRACE_PG_NATIVE_ENABLED: ['A'],
        DD_TRACE_PG_QUERY_STREAM_ENABLED: ['A'],
        DD_TRACE_PINO_ENABLED: ['A'],
        DD_TRACE_PINO_PRETTY_ENABLED: ['A'],
        DD_TRACE_PLAYWRIGHT_CORE_ENABLED: ['A'],
        DD_TRACE_PLAYWRIGHT_ENABLED: ['A'],
        DD_TRACE_PLAYWRIGHT_TEST_ENABLED: ['A'],
        DD_TRACE_PRISMA_ENABLED: ['A'],
        DD_TRACE_PROCESS_ENABLED: ['A'],
        DD_TRACE_PROMISE_ENABLED: ['A'],
        DD_TRACE_PROMISE_JS_ENABLED: ['A'],
        DD_TRACE_PROPAGATION_BEHAVIOR_EXTRACT: ['A'],
        DD_TRACE_PROPAGATION_EXTRACT_FIRST: ['A'],
        DD_TRACE_PROPAGATION_STYLE_EXTRACT: ['A'],
        DD_TRACE_PROPAGATION_STYLE_INJECT: ['A'],
        DD_TRACE_PROPAGATION_STYLE: ['A'],
        DD_TRACE_PROTOBUFJS_ENABLED: ['A'],
        DD_TRACE_PUG_ENABLED: ['A'],
        DD_TRACE_Q_ENABLED: ['A'],
        DD_TRACE_RATE_LIMIT: ['A'],
        DD_TRACE_REACT_DOM_ENABLED: ['A'],
        DD_TRACE_REACT_ENABLED: ['A'],
        DD_TRACE_REDIS_CLIENT_ENABLED: ['A'],
        DD_TRACE_REDIS_ENABLED: ['A'],
        DD_TRACE_REMOVE_INTEGRATION_SERVICE_NAMES_ENABLED: ['A'],
        DD_TRACE_REPORT_HOSTNAME: ['A'],
        DD_TRACE_REQUEST_ENABLED: ['A'],
        DD_TRACE_RESOURCE_RENAMING_ENABLED: ['A'],
        DD_TRACE_RESTIFY_ENABLED: ['A'],
        DD_TRACE_RHEA_ENABLED: ['A'],
        DD_TRACE_ROUTER_ENABLED: ['A'],
        DD_TRACE_SAMPLE_RATE: ['A'],
        DD_TRACE_SAMPLING_RULES: ['A'],
        DD_TRACE_SCOPE: ['A'],
        DD_TRACE_SELENIUM_ENABLED: ['A'],
        DD_TRACE_SELENIUM_WEBDRIVER_ENABLED: ['A'],
        DD_TRACE_SEQUELIZE_ENABLED: ['A'],
        DD_TRACE_SHAREDB_ENABLED: ['A'],
        DD_TRACE_SMITHY_SMITHY_CLIENT_ENABLED: ['A'],
        DD_TRACE_SPAN_ATTRIBUTE_SCHEMA: ['A'],
        DD_TRACE_SPAN_LEAK_DEBUG: ['A'],
        DD_TRACE_SQLITE3_ENABLED: ['A'],
        DD_TRACE_STARTUP_LOGS: ['A'],
        DD_TRACE_STATS_COMPUTATION_ENABLED: ['A'],
        DD_TRACE_SUFFIXPLUGIN_ENABLED: ['A'],
        DD_TRACE_TAGS: ['A'],
        DD_TRACE_TEDIOUS_ENABLED: ['A'],
        DD_TRACE_UNDICI_ENABLED: ['A'],
        DD_TRACE_URL_ENABLED: ['A'],
        DD_TRACE_VITEST_ENABLED: ['A'],
        DD_TRACE_VITEST_RUNNER_ENABLED: ['A'],
        DD_TRACE_VM_ENABLED: ['A'],
        DD_TRACE_WEBSOCKET_MESSAGES_ENABLED: ['A'],
        DD_TRACE_WEBSOCKET_MESSAGES_INHERIT_SAMPLING: ['A'],
        DD_TRACE_WEBSOCKET_MESSAGES_SEPARATE_TRACES: ['A'],
        DD_TRACE_WHEN_ENABLED: ['A'],
        DD_TRACE_WINSTON_ENABLED: ['A'],
        DD_TRACE_WORKERPOOL_ENABLED: ['A'],
        DD_TRACE_WS_ENABLED: ['A'],
        DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH: ['A'],
        DD_TRACING_ENABLED: ['A'],
        DD_VERSION: ['A'],
        DD_VERTEXAI_SPAN_CHAR_LIMIT: ['A'],
        DD_VERTEXAI_SPAN_PROMPT_COMPLETION_SAMPLE_RATE: ['A'],
        DD_VITEST_WORKER: ['A'],
        OTEL_LOG_LEVEL: ['A'],
        OTEL_LOGS_EXPORTER: ['A'],
        OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: ['A'],
        OTEL_EXPORTER_OTLP_LOGS_HEADERS: ['A'],
        OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: ['A'],
        OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: ['A'],
        OTEL_EXPORTER_OTLP_ENDPOINT: ['A'],
        OTEL_EXPORTER_OTLP_HEADERS: ['A'],
        OTEL_EXPORTER_OTLP_PROTOCOL: ['A'],
        OTEL_EXPORTER_OTLP_TIMEOUT: ['A'],
        OTEL_BSP_SCHEDULE_DELAY: ['A'],
        OTEL_BSP_MAX_EXPORT_BATCH_SIZE: ['A'],
        OTEL_BSP_MAX_QUEUE_SIZE: ['A'],
        OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: ['A'],
        OTEL_EXPORTER_OTLP_METRICS_HEADERS: ['A'],
        OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: ['A'],
        OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: ['A'],
        OTEL_METRIC_EXPORT_INTERVAL: ['A'],
        OTEL_METRIC_EXPORT_TIMEOUT: ['A'],
        OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: ['A'],
        OTEL_METRICS_EXPORTER: ['A'],
        OTEL_PROPAGATORS: ['A'],
        OTEL_RESOURCE_ATTRIBUTES: ['A'],
        OTEL_SDK_DISABLED: ['A'],
        OTEL_SERVICE_NAME: ['A'],
        OTEL_TRACES_EXPORTER: ['A'],
        OTEL_TRACES_SAMPLER_ARG: ['A'],
        OTEL_TRACES_SAMPLER: ['A'],
      },
      aliases: {
        DD_AGENT_HOST: ['DD_TRACE_AGENT_HOSTNAME'],
        DD_API_KEY: ['DATADOG_API_KEY'],
        DD_API_SECURITY_ENABLED: ['DD_EXPERIMENTAL_API_SECURITY_ENABLED'],
        DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE: ['DD_APPSEC_AUTOMATED_USER_EVENTS_TRACKING'],
        DD_DOGSTATSD_HOST: ['DD_DOGSTATSD_HOSTNAME'],
        DD_INSTRUMENTATION_TELEMETRY_ENABLED: ['DD_TRACE_TELEMETRY_ENABLED'],
        DD_PROFILING_CODEHOTSPOTS_ENABLED: ['DD_PROFILING_EXPERIMENTAL_CODEHOTSPOTS_ENABLED'],
        DD_PROFILING_CPU_ENABLED: ['DD_PROFILING_EXPERIMENTAL_CPU_ENABLED'],
        DD_PROFILING_ENABLED: ['DD_EXPERIMENTAL_PROFILING_ENABLED'],
        DD_PROFILING_ENDPOINT_COLLECTION_ENABLED: ['DD_PROFILING_EXPERIMENTAL_ENDPOINT_COLLECTION_ENABLED'],
        DD_PROFILING_TIMELINE_ENABLED: ['DD_PROFILING_EXPERIMENTAL_TIMELINE_ENABLED'],
        DD_REMOTE_CONFIGURATION_ENABLED: ['DD_REMOTE_CONFIG_ENABLED'],
        DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED: ['DD_TRACE_EXPERIMENTAL_RUNTIME_ID_ENABLED'],
        DD_SERVICE: ['DD_SERVICE_NAME'],
        DD_TRACE_AGENT_URL: ['DD_TRACE_URL'],
      },
      deprecations: {
        DD_PROFILING_EXPERIMENTAL_ENDPOINT_COLLECTION_ENABLED: 'DD_PROFILING_ENDPOINT_COLLECTION_ENABLED',
        DD_PROFILING_EXPERIMENTAL_CPU_ENABLED: 'DD_PROFILING_CPU_ENABLED',
        DD_EXPERIMENTAL_PROFILING_ENABLED: 'DD_PROFILING_ENABLED',
        DD_PROFILING_EXPERIMENTAL_CODEHOTSPOTS_ENABLED: 'DD_PROFILING_CODEHOTSPOTS_ENABLED',
        DD_PROFILING_EXPERIMENTAL_TIMELINE_ENABLED: 'DD_PROFILING_TIMELINE_ENABLED',
        DD_TRACE_EXPERIMENTAL_RUNTIME_ID_ENABLED: 'DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED',
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/config-helper.js
var require_config_helper = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/config-helper.js'(exports2, module2) {
    'use strict'
    var { deprecate } = require('util')
    var { supportedConfigurations, aliases, deprecations } = require_supported_configurations()
    var aliasToCanonical = {}
    for (const canonical of Object.keys(aliases)) {
      for (const alias of aliases[canonical]) {
        if (aliasToCanonical[alias]) {
          throw new Error(`The alias ${alias} is already used for ${aliasToCanonical[alias]}.`)
        }
        aliasToCanonical[alias] = canonical
      }
    }
    var deprecationMethods = {}
    for (const deprecation of Object.keys(deprecations)) {
      deprecationMethods[deprecation] = deprecate(
        () => {},
        `The environment variable ${deprecation} is deprecated.` +
          (aliasToCanonical[deprecation]
            ? ` Please use ${aliasToCanonical[deprecation]} instead.`
            : ` ${deprecations[deprecation]}`),
        `DATADOG_${deprecation}`
      )
    }
    module2.exports = {
      /**
       * Returns the environment variables that are supported by the tracer
       * (including all non-Datadog/OTEL specific environment variables).
       *
       * This should only be called once in config.js to avoid copying the object frequently.
       *
       * @returns {TracerEnv} The environment variables
       */
      getEnvironmentVariables() {
        const configs = {}
        for (const [key, value] of Object.entries(process.env)) {
          if (key.startsWith('DD_') || key.startsWith('OTEL_') || aliasToCanonical[key]) {
            if (supportedConfigurations[key]) {
              configs[key] = value
            } else if (aliasToCanonical[key] && configs[aliasToCanonical[key]] === void 0) {
              for (const alias of aliases[aliasToCanonical[key]]) {
                if (process.env[alias] !== void 0) {
                  configs[aliasToCanonical[key]] = value
                  break
                }
              }
            }
            deprecationMethods[key]?.()
          } else {
            configs[key] = value
          }
        }
        return configs
      },
      /**
       * Returns the environment variable, if it's supported or a non Datadog
       * configuration. Otherwise, it throws an error.
       *
       * @param {string} name Environment variable name
       * @returns {string|undefined}
       * @throws {Error} if the configuration is not supported
       */
      // This method, and callers of this method, need to be updated to check for declarative config sources as well.
      getEnvironmentVariable(name) {
        if (
          (name.startsWith('DD_') || name.startsWith('OTEL_') || aliasToCanonical[name]) &&
          !supportedConfigurations[name]
        ) {
          throw new Error(`Missing ${name} env/configuration in "supported-configurations.json" file.`)
        }
        const config = process.env[name]
        if (config === void 0 && aliases[name]) {
          for (const alias of aliases[name]) {
            if (process.env[alias] !== void 0) {
              return process.env[alias]
            }
          }
        }
        return config
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/noop/scope.js
var require_scope = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/noop/scope.js'(exports2, module2) {
    'use strict'
    var Scope = class {
      active() {
        return null
      }
      activate(span, callback) {
        if (typeof callback !== 'function') return callback
        return callback()
      }
      bind(fn, span) {
        return fn
      }
    }
    module2.exports = Scope
  },
})

// node_modules/dd-trace/ext/priority.js
var require_priority = __commonJS({
  'node_modules/dd-trace/ext/priority.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      USER_REJECT: -1,
      AUTO_REJECT: 0,
      AUTO_KEEP: 1,
      USER_KEEP: 2,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js
var require_span_context = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js'(exports2, module2) {
    'use strict'
    var util = require('util')
    var { AUTO_KEEP } = require_priority()
    var TRACE_ID_128 = '_dd.p.tid'
    var DatadogSpanContext = class {
      constructor(props) {
        props = props || {}
        this._traceId = props.traceId
        this._spanId = props.spanId
        this._isRemote = props.isRemote ?? true
        this._parentId = props.parentId || null
        this._name = props.name
        this._isFinished = props.isFinished || false
        this._tags = props.tags || {}
        this._sampling = props.sampling || {}
        this._spanSampling = void 0
        this._links = props.links || []
        this._baggageItems = props.baggageItems || {}
        this._traceparent = props.traceparent
        this._tracestate = props.tracestate
        this._noop = props.noop || null
        this._trace = props.trace || {
          started: [],
          finished: [],
          tags: {},
        }
        this._otelSpanContext = void 0
      }
      [util.inspect.custom]() {
        return {
          ...this,
          _trace: {
            ...this._trace,
            started: '[Array]',
            finished: '[Array]',
          },
        }
      }
      toTraceId(get128bitId = false) {
        if (get128bitId) {
          return this._traceId.toBuffer().length <= 8 && this._trace.tags[TRACE_ID_128]
            ? this._trace.tags[TRACE_ID_128] + this._traceId.toString(16).padStart(16, '0')
            : this._traceId.toString(16).padStart(32, '0')
        }
        return this._traceId.toString(10)
      }
      toSpanId(get128bitId = false) {
        if (get128bitId) {
          return this._spanId.toString(16).padStart(16, '0')
        }
        return this._spanId.toString(10)
      }
      toBigIntSpanId() {
        return this._spanId.toBigInt()
      }
      toTraceparent() {
        const flags = this._sampling.priority >= AUTO_KEEP ? '01' : '00'
        const traceId = this.toTraceId(true)
        const spanId = this.toSpanId(true)
        const version = (this._traceparent && this._traceparent.version) || '00'
        return `${version}-${traceId}-${spanId}-${flags}`
      }
    }
    module2.exports = DatadogSpanContext
  },
})

// node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js
var require_span_context2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js'(exports2, module2) {
    'use strict'
    var DatadogSpanContext = require_span_context()
    var priority = require_priority()
    var USER_REJECT = priority.USER_REJECT
    var NoopSpanContext = class extends DatadogSpanContext {
      constructor(props) {
        super(props)
        this._sampling.priority = USER_REJECT
      }
    }
    module2.exports = NoopSpanContext
  },
})

// node_modules/dd-trace/packages/dd-trace/src/id.js
var require_id = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/id.js'(exports2, module2) {
    'use strict'
    var { randomFillSync } = require('crypto')
    var UINT_MAX = 4294967296
    var data = new Uint8Array(8 * 8192)
    var zeroId = new Uint8Array(8)
    var map = Array.prototype.map
    var pad = (byte) => `${byte < 16 ? '0' : ''}${byte.toString(16)}`
    var batch = 0
    var Identifier = class {
      /**
       * @param {string} value
       * @param {number} [radix]
       */
      constructor(value, radix = 16) {
        this._buffer = radix === 16 ? createBuffer(value) : fromString(value, radix)
      }
      /**
       * @param {number} [radix]
       * @returns {string}
       */
      toString(radix = 16) {
        return radix === 16 ? toHexString(this._buffer) : toNumberString(this._buffer, radix)
      }
      /**
       * @returns {bigint}
       */
      toBigInt() {
        return Buffer.from(this._buffer).readBigUInt64BE(0)
      }
      /**
       * @returns {number[] | Uint8Array}
       */
      toBuffer() {
        return this._buffer
      }
      /**
       * @returns {number[] | Uint8Array}
       */
      toArray() {
        if (this._buffer.length === 8) {
          return this._buffer
        }
        return this._buffer.slice(-8)
      }
      /**
       * @returns {string}
       */
      toJSON() {
        return this.toString()
      }
      /**
       * @param {Identifier} other
       * @returns {boolean}
       */
      equals(other) {
        const length = this._buffer.length
        const otherLength = other._buffer.length
        for (let i = length, j = otherLength; i >= 0 && j >= 0; i--, j--) {
          if (this._buffer[i] !== other._buffer[j]) return false
        }
        return true
      }
    }
    function createBuffer(value) {
      if (value === '0') return zeroId
      if (!value) return pseudoRandom()
      const size = Math.ceil(value.length / 16) * 16
      const bytes = size / 2
      const buffer = []
      value = value.padStart(size, '0')
      for (let i = 0; i < bytes; i++) {
        buffer[i] = Number.parseInt(value.slice(i * 2, i * 2 + 2), 16)
      }
      return buffer
    }
    function fromString(str, raddix) {
      const buffer = new Array(8)
      const len = str.length
      let pos = 0
      let high = 0
      let low = 0
      if (str[0] === '-') pos++
      const sign = pos
      while (pos < len) {
        const chr = Number.parseInt(str[pos++], raddix)
        if (!(chr >= 0)) break
        low = low * raddix + chr
        high = high * raddix + Math.floor(low / UINT_MAX)
        low %= UINT_MAX
      }
      if (sign) {
        high = ~high
        if (low) {
          low = UINT_MAX - low
        } else {
          high++
        }
      }
      writeUInt32BE(buffer, high, 0)
      writeUInt32BE(buffer, low, 4)
      return buffer
    }
    function toNumberString(buffer, radix) {
      let high = readInt32(buffer, buffer.length - 8)
      let low = readInt32(buffer, buffer.length - 4)
      let str = ''
      radix = radix || 10
      while (1) {
        const mod2 = (high % radix) * UINT_MAX + low
        high = Math.floor(high / radix)
        low = Math.floor(mod2 / radix)
        str = (mod2 % radix).toString(radix) + str
        if (!high && !low) break
      }
      return str
    }
    function toHexString(buffer) {
      return map.call(buffer, pad).join('')
    }
    function pseudoRandom() {
      if (batch === 0) {
        randomFillSync(data)
      }
      batch = (batch + 1) % 8192
      const offset = batch * 8
      return [
        data[offset] & 127,
        // only positive int64,
        data[offset + 1],
        data[offset + 2],
        data[offset + 3],
        data[offset + 4],
        data[offset + 5],
        data[offset + 6],
        data[offset + 7],
      ]
    }
    function readInt32(buffer, offset) {
      return buffer[offset + 0] * 16777216 + (buffer[offset + 1] << 16) + (buffer[offset + 2] << 8) + buffer[offset + 3]
    }
    function writeUInt32BE(buffer, value, offset) {
      buffer[3 + offset] = value & 255
      value >>= 8
      buffer[2 + offset] = value & 255
      value >>= 8
      buffer[1 + offset] = value & 255
      value >>= 8
      buffer[0 + offset] = value & 255
    }
    module2.exports = function createIdentifier(value, radix) {
      return new Identifier(value, radix)
    }
  },
})

// node_modules/dd-trace/packages/datadog-core/src/storage.js
var require_storage = __commonJS({
  'node_modules/dd-trace/packages/datadog-core/src/storage.js'(exports2, module2) {
    'use strict'
    var { AsyncLocalStorage } = require('async_hooks')
    var DatadogStorage = class extends AsyncLocalStorage {
      /**
       *
       * @param {Store} [store]
       * @override
       */
      enterWith(store) {
        const handle = {}
        stores.set(handle, store)
        super.enterWith(handle)
      }
      /**
       * This is method is a passthrough to the real `getStore()`, so that, when we
       * need it, we can use the handle rather than our mapped store.
       *
       * It's only here because stores are currently used for a bunch of things,
       * and we don't want to hold on to all of them in spans
       * (see opentracing/span.js). Using a namespaced storage for spans would
       * solve this.
       *
       * TODO: Refactor the Scope class to use a span-only store and remove this.
       *
       * @returns {Store}
       */
      getHandle() {
        return super.getStore()
      }
      /**
       * Here, we replicate the behavior of the original `getStore()` method by
       * passing in the handle, which we retrieve by calling it on super. Handles
       * retrieved through `getHandle()` can also be passed in to be used as the
       * key. This is useful if you've stashed a handle somewhere and want to
       * retrieve the store with it.
       * @param {object} [handle]
       * @returns {Store | undefined}
       * @override
       */
      getStore(handle) {
        if (!handle) {
          handle = super.getStore()
        }
        if (handle) {
          return stores.get(handle)
        }
      }
      /**
       * Here, we replicate the behavior of the original `run()` method. We ensure
       * that our `enterWith()` is called internally, so that the handle to the
       * store is set. As an optimization, we use super for getStore and enterWith
       * when dealing with the parent store, so that we don't have to access the
       * WeakMap.
       * @template R
       * @template TArgs = unknown[]
       * @param {Store} store
       * @param {() => R} fn
       * @param {...TArgs} args
       * @returns {R}
       * @override
       */
      run(store, fn, ...args) {
        const prior = super.getStore()
        this.enterWith(store)
        try {
          return Reflect.apply(fn, null, args)
        } finally {
          super.enterWith(prior)
        }
      }
    }
    var stores = /* @__PURE__ */ new WeakMap()
    var storages = /* @__PURE__ */ Object.create(null)
    function storage(namespace) {
      if (!storages[namespace]) {
        storages[namespace] = new DatadogStorage()
      }
      return storages[namespace]
    }
    module2.exports = { storage }
  },
})

// node_modules/dd-trace/packages/datadog-core/index.js
var require_datadog_core = __commonJS({
  'node_modules/dd-trace/packages/datadog-core/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_storage()
    module2.exports = { storage }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/noop/span.js
var require_span = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/noop/span.js'(exports2, module2) {
    'use strict'
    var NoopSpanContext = require_span_context2()
    var id = require_id()
    var { storage } = require_datadog_core()
    var NoopSpan = class {
      constructor(tracer2, parent) {
        this._store = storage('legacy').getHandle()
        this._noopTracer = tracer2
        this._noopContext = this._createContext(parent)
      }
      context() {
        return this._noopContext
      }
      tracer() {
        return this._noopTracer
      }
      setOperationName(name) {
        return this
      }
      setBaggageItem(key, value) {
        return this
      }
      getBaggageItem(key) {}
      getAllBaggageItems() {}
      removeBaggageItem(key) {
        return this
      }
      removeAllBaggageItems() {
        return this
      }
      setTag(key, value) {
        return this
      }
      addTags(keyValueMap) {
        return this
      }
      addLink(link) {
        return this
      }
      addLinks(links) {
        return this
      }
      addSpanPointer(ptrKind, ptrDir, ptrHash) {
        return this
      }
      log() {
        return this
      }
      logEvent() {}
      finish(finishTime) {}
      _createContext(parent) {
        const spanId = id()
        return parent
          ? new NoopSpanContext({
              noop: this,
              traceId: parent._traceId,
              spanId,
              parentId: parent._spanId,
              baggageItems: { ...parent._baggageItems },
            })
          : new NoopSpanContext({
              noop: this,
              traceId: spanId,
              spanId,
            })
      }
    }
    module2.exports = NoopSpan
  },
})

// node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js
var require_tracer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js'(exports2, module2) {
    'use strict'
    var Scope = require_scope()
    var Span = require_span()
    var NoopTracer = class {
      constructor(config) {
        this._scope = new Scope()
        this._span = new Span(this)
      }
      configure(options) {}
      trace(name, options, fn) {
        return fn(this._span, () => {})
      }
      wrap(name, options, fn) {
        return fn
      }
      scope() {
        return this._scope
      }
      getRumData() {
        return ''
      }
      setUrl() {}
      startSpan(name, options) {
        return this._span
      }
      inject(spanContext, format, carrier) {}
      extract(format, carrier) {
        return this._span.context()
      }
      setUser() {
        return this
      }
    }
    module2.exports = NoopTracer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/noop.js
var require_noop = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/noop.js'(exports2, module2) {
    'use strict'
    var NoopEventTrackingV2 = class {
      trackUserLoginSuccess() {}
      trackUserLoginFailure() {}
    }
    var NoopAppsecSdk = class {
      constructor() {
        this.eventTrackingV2 = new NoopEventTrackingV2()
      }
      trackUserLoginSuccessEvent() {}
      trackUserLoginFailureEvent() {}
      trackCustomEvent() {}
      isUserBlocked() {}
      blockRequest() {}
      setUser() {}
    }
    module2.exports = NoopAppsecSdk
  },
})

// node_modules/dd-trace/packages/dd-trace/src/noop/dogstatsd.js
var require_dogstatsd = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/noop/dogstatsd.js'(exports2, module2) {
    'use strict'
    module2.exports = class NoopDogStatsDClient {
      increment() {}
      decrement() {}
      gauge() {}
      distribution() {}
      histogram() {}
      flush() {}
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/noop.js
var require_noop2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/noop.js'(exports2, module2) {
    'use strict'
    var NoopLLMObs = class {
      constructor(noopTracer) {
        this._tracer = noopTracer
      }
      get enabled() {
        return false
      }
      enable(options) {}
      disable() {}
      trace(options = {}, fn) {
        if (typeof options === 'function') {
          fn = options
          options = {}
        }
        const name = options.name || options.kind || fn.name
        return this._tracer.trace(name, options, fn)
      }
      wrap(options = {}, fn) {
        if (typeof options === 'function') {
          fn = options
          options = {}
        }
        const name = options.name || options.kind || fn.name
        return this._tracer.wrap(name, options, fn)
      }
      decorate(options = {}) {
        const llmobs = this
        return function (target, ctxOrPropertyKey, descriptor) {
          if (!ctxOrPropertyKey) return target
          if (typeof ctxOrPropertyKey === 'object') {
            const ctx = ctxOrPropertyKey
            if (ctx.kind !== 'method') return target
            return llmobs.wrap({ name: ctx.name, _decorator: true, ...options }, target)
          }
          const propertyKey = ctxOrPropertyKey
          if (descriptor) {
            if (typeof descriptor.value !== 'function') return descriptor
            const original2 = descriptor.value
            descriptor.value = llmobs.wrap({ name: propertyKey, _decorator: true, ...options }, original2)
            return descriptor
          }
          if (typeof target[propertyKey] !== 'function') return target[propertyKey]
          const original = target[propertyKey]
          Object.defineProperty(target, propertyKey, {
            ...Object.getOwnPropertyDescriptor(target, propertyKey),
            value: llmobs.wrap({ name: propertyKey, _decorator: true, ...options }, original),
          })
          return target
        }
      }
      annotate(span, options) {}
      exportSpan(span) {
        return {}
      }
      submitEvaluation(llmobsSpanContext, options) {}
      flush() {}
      registerProcessor(processor) {}
      deregisterProcessor() {}
      annotationContext(options, fn) {
        return fn()
      }
    }
    module2.exports = NoopLLMObs
  },
})

// node_modules/dd-trace/packages/dd-trace/src/openfeature/constants/constants.js
var require_constants = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/openfeature/constants/constants.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      /**
       * @constant
       * @type {string} Base path for EVP proxy agent endpoint
       */
      EVP_PROXY_AGENT_BASE_PATH: '/evp_proxy/v2/',
      /**
       * @constant
       * @type {string} HTTP header name for EVP subdomain routing
       */
      EVP_SUBDOMAIN_HEADER_NAME: 'X-Datadog-EVP-Subdomain',
      /**
       * @constant
       * @type {string} EVP subdomain value for event platform intake
       */
      EVP_SUBDOMAIN_VALUE: 'event-platform-intake',
      /**
       * @constant
       * @type {string} API endpoint for exposure events EVP track
       */
      EXPOSURES_ENDPOINT: '/api/v2/exposures',
      /**
       * @constant
       * @type {number} Maximum payload size for EVP intake (5MB, actual limit is 5.1MB)
       */
      EVP_PAYLOAD_SIZE_LIMIT: 5 << 20,
      /**
       * @constant
       * @type {number} Maximum individual event size (999KB, actual limit is 1MB)
       */
      EVP_EVENT_SIZE_LIMIT: (1 << 20) - 1024,
      /**
       * @constant
       * @type {string} Channel name for exposure event submission
       */
      EXPOSURE_CHANNEL: 'ffe:exposure:submit',
      /**
       * @constant
       * @type {string} Reason code for noop provider evaluations
       */
      NOOP_REASON: 'STATIC',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/openfeature/noop.js
var require_noop3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/openfeature/noop.js'(exports2, module2) {
    'use strict'
    var { NOOP_REASON } = require_constants()
    var NoopFlaggingProvider = class {
      /**
       * @param {Object} [noopTracer] - Optional noop tracer instance
       */
      constructor(noopTracer) {
        this._tracer = noopTracer
        this._config = {}
        this.metadata = { name: 'NoopFlaggingProvider' }
        this.status = 'NOT_READY'
        this.runsOn = 'server'
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {boolean} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: boolean, reason: string}>} Resolution details
       */
      resolveBooleanEvaluation(flagKey, defaultValue, context, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON,
        })
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {string} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: string, reason: string}>} Resolution details
       */
      resolveStringEvaluation(flagKey, defaultValue, context, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON,
        })
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {number} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: number, reason: string}>} Resolution details
       */
      resolveNumberEvaluation(flagKey, defaultValue, context, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON,
        })
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {Object} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: Object, reason: string}>} Resolution details
       */
      resolveObjectEvaluation(flagKey, defaultValue, context, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON,
        })
      }
      /**
       * @returns {Object} Current configuration
       */
      getConfiguration() {
        return this._config
      }
      /**
       * @param {Object} config - Configuration to set
       */
      setConfiguration(config) {
        this._config = config
      }
      /**
       * @internal
       * @param {Object} ufc - Universal Flag Configuration object
       */
      _setConfiguration(ufc) {
        this.setConfiguration(ufc)
      }
    }
    module2.exports = NoopFlaggingProvider
  },
})

// node_modules/dd-trace/packages/dd-trace/src/aiguard/noop.js
var require_noop4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/aiguard/noop.js'(exports2, module2) {
    'use strict'
    var NoopAIGuard = class {
      evaluate(messages, opts) {
        return Promise.resolve({ action: 'ALLOW', reason: 'AI Guard is not enabled' })
      }
    }
    module2.exports = NoopAIGuard
  },
})

// node_modules/dd-trace/vendor/dist/@opentelemetry/core/index.js
var require_core = __commonJS({
  'node_modules/dd-trace/vendor/dist/@opentelemetry/core/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e,
        t,
        r,
        n,
        o,
        i,
        a,
        _,
        T,
        E = {}
      ;((E.d = (e7, t2) => {
        for (var r2 in t2)
          E.o(t2, r2) && !E.o(e7, r2) && Object.defineProperty(e7, r2, { enumerable: true, get: t2[r2] })
      }),
        (E.o = (e7, t2) => Object.prototype.hasOwnProperty.call(e7, t2)),
        (E.r = (e7) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e7, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(e7, '__esModule', { value: true }))
        }))
      var u = {}
      ;(E.r(u),
        E.d(u, {
          baggageUtils: () => e6,
          hrTime: () => w,
          timeInputToHrTime: () => X,
          W3CTraceContextPropagator: () => eI,
          callWithTimeout: () => eQ,
          AlwaysOnSampler: () => eb,
          isTracingSuppressed: () => O,
          AlwaysOffSampler: () => eN,
          loggingErrorHandler: () => C,
          DEFAULT_ATTRIBUTE_COUNT_LIMIT: () => eo,
          deleteRPCMetadata: () => ev,
          suppressTracing: () => f,
          RPCType: () => T,
          RandomIdGenerator: () => Z,
          setRPCMetadata: () => eA,
          unrefTimer: () => ef,
          hrTimeToMilliseconds: () => V,
          TRACE_PARENT_HEADER: () => ey,
          unsuppressTracing: () => s,
          globalErrorHandler: () => U,
          _globalThis: () => q,
          getEnvWithoutDefaults: () => el,
          ParentBasedSampler: () => eU,
          millisToHrTime: () => D,
          isTimeInputHrTime: () => F,
          otperformance: () => M,
          internal: () => e5,
          urlMatches: () => eq,
          BindOnceFuture: () => e8,
          DEFAULT_ENVIRONMENT: () => e_,
          SDK_INFO: () => $,
          isWrapped: () => e1,
          isAttributeKey: () => m,
          TraceState: () => eP,
          hexToBase64: () => ec,
          TRACE_STATE_HEADER: () => ed,
          getEnv: () => eu,
          getTimeOrigin: () => B,
          TraceIdRatioBasedSampler: () => eM,
          hrTimeDuration: () => j,
          DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: () => ei,
          isTimeInput: () => K,
          hexToBinary: () => Y,
          DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: () => ea,
          parseTraceParent: () => eh,
          isUrlIgnored: () => e0,
          parseEnvironment: () => eE,
          setGlobalErrorHandler: () => b,
          DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: () => en,
          isAttributeValue: () => A,
          CompositePropagator: () => eO,
          hrTimeToMicroseconds: () => H,
          AnchoredClock: () => d,
          TracesSamplerValues: () => _,
          ExportResultCode: () => i,
          hrTimeToNanoseconds: () => G,
          merge: () => eH,
          TimeoutError: () => eJ,
          W3CBaggagePropagator: () => y,
          addHrTimes: () => k,
          getRPCMetadata: () => eC,
          sanitizeAttributes: () => I,
          hrTimeToTimeStamp: () => x,
          VERSION: () => Q,
        }))
      let l = require('@opentelemetry/api')
      var c = (0, l.createContextKey)('OpenTelemetry SDK Context Key SUPPRESS_TRACING')
      function f(e7) {
        return e7.setValue(c, true)
      }
      function s(e7) {
        return e7.deleteValue(c)
      }
      function O(e7) {
        return true === e7.getValue(c)
      }
      var p = 'baggage',
        R = function (e7, t2) {
          var r2 = 'function' == typeof Symbol && e7[Symbol.iterator]
          if (!r2) return e7
          var n2,
            o2,
            i2 = r2.call(e7),
            a2 = []
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = i2.next()).done; ) a2.push(n2.value)
          } catch (e9) {
            o2 = { error: e9 }
          } finally {
            try {
              n2 && !n2.done && (r2 = i2.return) && r2.call(i2)
            } finally {
              if (o2) throw o2.error
            }
          }
          return a2
        }
      function L(e7) {
        return e7.reduce(function (e9, t2) {
          var r2 = '' + e9 + ('' !== e9 ? ',' : '') + t2
          return r2.length > 8192 ? e9 : r2
        }, '')
      }
      function S(e7) {
        return e7.getAllEntries().map(function (e9) {
          var t2 = R(e9, 2),
            r2 = t2[0],
            n2 = t2[1],
            o2 = encodeURIComponent(r2) + '=' + encodeURIComponent(n2.value)
          return (void 0 !== n2.metadata && (o2 += ';' + n2.metadata.toString()), o2)
        })
      }
      function P(e7) {
        var t2,
          r2 = e7.split(';')
        if (!(r2.length <= 0)) {
          var n2 = r2.shift()
          if (n2) {
            var o2 = n2.indexOf('=')
            if (!(o2 <= 0)) {
              var i2 = decodeURIComponent(n2.substring(0, o2).trim()),
                a2 = decodeURIComponent(n2.substring(o2 + 1).trim())
              return (
                r2.length > 0 && (t2 = (0, l.baggageEntryMetadataFromString)(r2.join(';'))),
                { key: i2, value: a2, metadata: t2 }
              )
            }
          }
        }
      }
      var y = (function () {
          function e7() {}
          return (
            (e7.prototype.inject = function (e9, t2, r2) {
              var n2 = l.propagation.getBaggage(e9)
              if (!(!n2 || O(e9))) {
                var o2 = L(
                  S(n2)
                    .filter(function (e10) {
                      return e10.length <= 4096
                    })
                    .slice(0, 180)
                )
                o2.length > 0 && r2.set(t2, p, o2)
              }
            }),
            (e7.prototype.extract = function (e9, t2, r2) {
              var n2 = r2.get(t2, p),
                o2 = Array.isArray(n2) ? n2.join(',') : n2
              if (!o2) return e9
              var i2 = {}
              return 0 === o2.length ||
                (o2.split(',').forEach(function (e10) {
                  var t3 = P(e10)
                  if (t3) {
                    var r3 = { value: t3.value }
                    ;(t3.metadata && (r3.metadata = t3.metadata), (i2[t3.key] = r3))
                  }
                }),
                0 === Object.entries(i2).length)
                ? e9
                : l.propagation.setBaggage(e9, l.propagation.createBaggage(i2))
            }),
            (e7.prototype.fields = function () {
              return [p]
            }),
            e7
          )
        })(),
        d = (function () {
          function e7(e9, t2) {
            ;((this._monotonicClock = t2), (this._epochMillis = e9.now()), (this._performanceMillis = t2.now()))
          }
          return (
            (e7.prototype.now = function () {
              var e9 = this._monotonicClock.now() - this._performanceMillis
              return this._epochMillis + e9
            }),
            e7
          )
        })(),
        g = function (e7) {
          var t2 = 'function' == typeof Symbol && Symbol.iterator,
            r2 = t2 && e7[t2],
            n2 = 0
          if (r2) return r2.call(e7)
          if (e7 && 'number' == typeof e7.length)
            return {
              next: function () {
                return (e7 && n2 >= e7.length && (e7 = void 0), { value: e7 && e7[n2++], done: !e7 })
              },
            }
          throw TypeError(t2 ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
        },
        h = function (e7, t2) {
          var r2 = 'function' == typeof Symbol && e7[Symbol.iterator]
          if (!r2) return e7
          var n2,
            o2,
            i2 = r2.call(e7),
            a2 = []
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = i2.next()).done; ) a2.push(n2.value)
          } catch (e9) {
            o2 = { error: e9 }
          } finally {
            try {
              n2 && !n2.done && (r2 = i2.return) && r2.call(i2)
            } finally {
              if (o2) throw o2.error
            }
          }
          return a2
        }
      function I(e7) {
        var t2,
          r2,
          n2 = {}
        if ('object' != typeof e7 || null == e7) return n2
        try {
          for (var o2 = g(Object.entries(e7)), i2 = o2.next(); !i2.done; i2 = o2.next()) {
            var a2 = h(i2.value, 2),
              _2 = a2[0],
              T2 = a2[1]
            if (!m(_2)) {
              l.diag.warn('Invalid attribute key: ' + _2)
              continue
            }
            if (!A(T2)) {
              l.diag.warn('Invalid attribute value set for key: ' + _2)
              continue
            }
            Array.isArray(T2) ? (n2[_2] = T2.slice()) : (n2[_2] = T2)
          }
        } catch (e9) {
          t2 = { error: e9 }
        } finally {
          try {
            i2 && !i2.done && (r2 = o2.return) && r2.call(o2)
          } finally {
            if (t2) throw t2.error
          }
        }
        return n2
      }
      function m(e7) {
        return 'string' == typeof e7 && e7.length > 0
      }
      function A(e7) {
        return (
          null == e7 ||
          (Array.isArray(e7)
            ? (function (e9) {
                try {
                  for (var t2, r2, n2, o2 = g(e9), i2 = o2.next(); !i2.done; i2 = o2.next()) {
                    var a2 = i2.value
                    if (null != a2) {
                      if (!n2) {
                        if (v(a2)) {
                          n2 = typeof a2
                          continue
                        }
                        return false
                      }
                      if (typeof a2 !== n2) return false
                    }
                  }
                } catch (e10) {
                  t2 = { error: e10 }
                } finally {
                  try {
                    i2 && !i2.done && (r2 = o2.return) && r2.call(o2)
                  } finally {
                    if (t2) throw t2.error
                  }
                }
                return true
              })(e7)
            : v(e7))
        )
      }
      function v(e7) {
        switch (typeof e7) {
          case 'number':
          case 'boolean':
          case 'string':
            return true
        }
        return false
      }
      function C() {
        return function (e7) {
          var t2
          l.diag.error(
            'string' == typeof (t2 = e7)
              ? t2
              : JSON.stringify(
                  (function (e9) {
                    for (var t3 = {}, r2 = e9; null !== r2; )
                      (Object.getOwnPropertyNames(r2).forEach(function (e10) {
                        if (!t3[e10]) {
                          var n2 = r2[e10]
                          n2 && (t3[e10] = String(n2))
                        }
                      }),
                        (r2 = Object.getPrototypeOf(r2)))
                    return t3
                  })(t2)
                )
          )
        }
      }
      var N = C()
      function b(e7) {
        N = e7
      }
      function U(e7) {
        try {
          N(e7)
        } catch (e9) {}
      }
      var M = require('perf_hooks').performance
      function D(e7) {
        return [Math.trunc(e7 / 1e3), Math.round((e7 % 1e3) * 1e6)]
      }
      function B() {
        var e7 = M.timeOrigin
        return ('number' != typeof e7 && (e7 = M.timing && M.timing.fetchStart), e7)
      }
      function w(e7) {
        return k(D(B()), D('number' == typeof e7 ? e7 : M.now()))
      }
      function X(e7) {
        if (F(e7)) return e7
        if ('number' == typeof e7)
          if (e7 < B()) return w(e7)
          else return D(e7)
        if (e7 instanceof Date) return D(e7.getTime())
        throw TypeError('Invalid input type')
      }
      function j(e7, t2) {
        var r2 = t2[0] - e7[0],
          n2 = t2[1] - e7[1]
        return (n2 < 0 && ((r2 -= 1), (n2 += 1e9)), [r2, n2])
      }
      function x(e7) {
        var t2 = '' + '0'.repeat(9) + e7[1] + 'Z',
          r2 = t2.substring(t2.length - 9 - 1)
        return new Date(1e3 * e7[0]).toISOString().replace('000Z', r2)
      }
      function G(e7) {
        return 1e9 * e7[0] + e7[1]
      }
      function V(e7) {
        return 1e3 * e7[0] + e7[1] / 1e6
      }
      function H(e7) {
        return 1e6 * e7[0] + e7[1] / 1e3
      }
      function F(e7) {
        return Array.isArray(e7) && 2 === e7.length && 'number' == typeof e7[0] && 'number' == typeof e7[1]
      }
      function K(e7) {
        return F(e7) || 'number' == typeof e7 || e7 instanceof Date
      }
      function k(e7, t2) {
        var r2 = [e7[0] + t2[0], e7[1] + t2[1]]
        return (r2[1] >= 1e9 && ((r2[1] -= 1e9), (r2[0] += 1)), r2)
      }
      function z(e7) {
        return e7 >= 48 && e7 <= 57 ? e7 - 48 : e7 >= 97 && e7 <= 102 ? e7 - 87 : e7 - 55
      }
      function Y(e7) {
        for (var t2 = new Uint8Array(e7.length / 2), r2 = 0, n2 = 0; n2 < e7.length; n2 += 2) {
          var o2 = z(e7.charCodeAt(n2)),
            i2 = z(e7.charCodeAt(n2 + 1))
          t2[r2++] = (o2 << 4) | i2
        }
        return t2
      }
      ;(((r = i || (i = {}))[(r.SUCCESS = 0)] = 'SUCCESS'), (r[(r.FAILED = 1)] = 'FAILED'))
      var Z = function () {
          ;((this.generateTraceId = J(16)), (this.generateSpanId = J(8)))
        },
        W = Buffer.allocUnsafe(16)
      function J(e7) {
        return function () {
          for (var t2 = 0; t2 < e7 / 4; t2++) W.writeUInt32BE((4294967296 * Math.random()) >>> 0, 4 * t2)
          for (var t2 = 0; t2 < e7; t2++)
            if (W[t2] > 0) break
            else t2 === e7 - 1 && (W[e7 - 1] = 1)
          return W.toString('hex', 0, e7)
        }
      }
      var Q = '1.30.1',
        $ =
          (((a = {})['telemetry.sdk.name'] = 'opentelemetry'),
          (a['process.runtime.name'] = 'node'),
          (a['telemetry.sdk.language'] = 'nodejs'),
          (a['telemetry.sdk.version'] = Q),
          a),
        q = 'object' == typeof globalThis ? globalThis : global
      ;(((n = _ || (_ = {})).AlwaysOff = 'always_off'),
        (n.AlwaysOn = 'always_on'),
        (n.ParentBasedAlwaysOff = 'parentbased_always_off'),
        (n.ParentBasedAlwaysOn = 'parentbased_always_on'),
        (n.ParentBasedTraceIdRatio = 'parentbased_traceidratio'),
        (n.TraceIdRatio = 'traceidratio'))
      var ee = ['OTEL_SDK_DISABLED'],
        et = [
          'OTEL_BSP_EXPORT_TIMEOUT',
          'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
          'OTEL_BSP_MAX_QUEUE_SIZE',
          'OTEL_BSP_SCHEDULE_DELAY',
          'OTEL_BLRP_EXPORT_TIMEOUT',
          'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE',
          'OTEL_BLRP_MAX_QUEUE_SIZE',
          'OTEL_BLRP_SCHEDULE_DELAY',
          'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
          'OTEL_ATTRIBUTE_COUNT_LIMIT',
          'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
          'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
          'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT',
          'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT',
          'OTEL_SPAN_EVENT_COUNT_LIMIT',
          'OTEL_SPAN_LINK_COUNT_LIMIT',
          'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT',
          'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT',
          'OTEL_EXPORTER_OTLP_TIMEOUT',
          'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
          'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
          'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT',
          'OTEL_EXPORTER_JAEGER_AGENT_PORT',
        ],
        er = ['OTEL_NO_PATCH_MODULES', 'OTEL_PROPAGATORS', 'OTEL_SEMCONV_STABILITY_OPT_IN'],
        en = 1 / 0,
        eo = 128,
        ei = 128,
        ea = 128,
        e_ = {
          OTEL_SDK_DISABLED: false,
          CONTAINER_NAME: '',
          ECS_CONTAINER_METADATA_URI_V4: '',
          ECS_CONTAINER_METADATA_URI: '',
          HOSTNAME: '',
          KUBERNETES_SERVICE_HOST: '',
          NAMESPACE: '',
          OTEL_BSP_EXPORT_TIMEOUT: 3e4,
          OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
          OTEL_BSP_MAX_QUEUE_SIZE: 2048,
          OTEL_BSP_SCHEDULE_DELAY: 5e3,
          OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
          OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
          OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
          OTEL_BLRP_SCHEDULE_DELAY: 5e3,
          OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
          OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
          OTEL_EXPORTER_JAEGER_ENDPOINT: '',
          OTEL_EXPORTER_JAEGER_PASSWORD: '',
          OTEL_EXPORTER_JAEGER_USER: '',
          OTEL_EXPORTER_OTLP_ENDPOINT: '',
          OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
          OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
          OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
          OTEL_EXPORTER_OTLP_HEADERS: '',
          OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
          OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
          OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
          OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
          OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
          OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
          OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
          OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
          OTEL_LOG_LEVEL: l.DiagLogLevel.INFO,
          OTEL_NO_PATCH_MODULES: [],
          OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
          OTEL_RESOURCE_ATTRIBUTES: '',
          OTEL_SERVICE_NAME: '',
          OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: en,
          OTEL_ATTRIBUTE_COUNT_LIMIT: eo,
          OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: en,
          OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: eo,
          OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: en,
          OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: eo,
          OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
          OTEL_SPAN_LINK_COUNT_LIMIT: 128,
          OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: ei,
          OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: ea,
          OTEL_TRACES_EXPORTER: '',
          OTEL_TRACES_SAMPLER: _.ParentBasedAlwaysOn,
          OTEL_TRACES_SAMPLER_ARG: '',
          OTEL_LOGS_EXPORTER: '',
          OTEL_EXPORTER_OTLP_INSECURE: '',
          OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
          OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
          OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
          OTEL_EXPORTER_OTLP_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_COMPRESSION: '',
          OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
          OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
          OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
          OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
          OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
          OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
          OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
          OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
          OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
          OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
          OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
          OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
          OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative',
          OTEL_SEMCONV_STABILITY_OPT_IN: [],
        },
        eT = {
          ALL: l.DiagLogLevel.ALL,
          VERBOSE: l.DiagLogLevel.VERBOSE,
          DEBUG: l.DiagLogLevel.DEBUG,
          INFO: l.DiagLogLevel.INFO,
          WARN: l.DiagLogLevel.WARN,
          ERROR: l.DiagLogLevel.ERROR,
          NONE: l.DiagLogLevel.NONE,
        }
      function eE(e7) {
        var t2 = {}
        for (var r2 in e_)
          if ('OTEL_LOG_LEVEL' === r2)
            !(function (e9, t3, r3) {
              var n3 = r3[e9]
              if ('string' == typeof n3) {
                var o2 = eT[n3.toUpperCase()]
                null != o2 && (t3[e9] = o2)
              }
            })(r2, t2, e7)
          else if (ee.indexOf(r2) > -1)
            !(function (e9, t3, r3) {
              if (void 0 !== r3[e9]) {
                var n3 = String(r3[e9])
                t3[e9] = 'true' === n3.toLowerCase()
              }
            })(r2, t2, e7)
          else if (et.indexOf(r2) > -1)
            !(function (e9, t3, r3, n3, o2) {
              if ((void 0 === n3 && (n3 = -1 / 0), void 0 === o2 && (o2 = 1 / 0), void 0 !== r3[e9])) {
                var i2 = Number(r3[e9])
                isNaN(i2) || (i2 < n3 ? (t3[e9] = n3) : i2 > o2 ? (t3[e9] = o2) : (t3[e9] = i2))
              }
            })(r2, t2, e7)
          else if (er.indexOf(r2) > -1)
            !(function (e9, t3, r3, n3) {
              void 0 === n3 && (n3 = ',')
              var o2 = r3[e9]
              'string' == typeof o2 &&
                (t3[e9] = o2.split(n3).map(function (e10) {
                  return e10.trim()
                }))
            })(r2, t2, e7)
          else {
            var n2 = e7[r2]
            null != n2 && (t2[r2] = String(n2))
          }
        return t2
      }
      function eu() {
        return Object.assign({}, e_, eE(process.env))
      }
      function el() {
        return eE(process.env)
      }
      function ec(e7) {
        return Buffer.from(Y(e7)).toString('base64')
      }
      function ef(e7) {
        e7.unref()
      }
      var es = function (e7) {
          var t2 = 'function' == typeof Symbol && Symbol.iterator,
            r2 = t2 && e7[t2],
            n2 = 0
          if (r2) return r2.call(e7)
          if (e7 && 'number' == typeof e7.length)
            return {
              next: function () {
                return (e7 && n2 >= e7.length && (e7 = void 0), { value: e7 && e7[n2++], done: !e7 })
              },
            }
          throw TypeError(t2 ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
        },
        eO = (function () {
          function e7(e9) {
            var t2
            ;(void 0 === e9 && (e9 = {}),
              (this._propagators = null != (t2 = e9.propagators) ? t2 : []),
              (this._fields = Array.from(
                new Set(
                  this._propagators
                    .map(function (e10) {
                      return 'function' == typeof e10.fields ? e10.fields() : []
                    })
                    .reduce(function (e10, t3) {
                      return e10.concat(t3)
                    }, [])
                )
              )))
          }
          return (
            (e7.prototype.inject = function (e9, t2, r2) {
              var n2, o2
              try {
                for (var i2 = es(this._propagators), a2 = i2.next(); !a2.done; a2 = i2.next()) {
                  var _2 = a2.value
                  try {
                    _2.inject(e9, t2, r2)
                  } catch (e10) {
                    l.diag.warn('Failed to inject with ' + _2.constructor.name + '. Err: ' + e10.message)
                  }
                }
              } catch (e10) {
                n2 = { error: e10 }
              } finally {
                try {
                  a2 && !a2.done && (o2 = i2.return) && o2.call(i2)
                } finally {
                  if (n2) throw n2.error
                }
              }
            }),
            (e7.prototype.extract = function (e9, t2, r2) {
              return this._propagators.reduce(function (e10, n2) {
                try {
                  return n2.extract(e10, t2, r2)
                } catch (e11) {
                  l.diag.warn('Failed to extract with ' + n2.constructor.name + '. Err: ' + e11.message)
                }
                return e10
              }, e9)
            }),
            (e7.prototype.fields = function () {
              return this._fields.slice()
            }),
            e7
          )
        })(),
        ep = '[_0-9a-z-*/]',
        eR = RegExp('^(?:[a-z]' + ep + '{0,255}|' + ('[a-z0-9]' + ep + '{0,240}@[a-z]') + ep + '{0,13})$'),
        eL = /^[ -~]{0,255}[!-~]$/,
        eS = /,|=/,
        eP = (function () {
          function e7(e9) {
            ;((this._internalState = /* @__PURE__ */ new Map()), e9 && this._parse(e9))
          }
          return (
            (e7.prototype.set = function (e9, t2) {
              var r2 = this._clone()
              return (r2._internalState.has(e9) && r2._internalState.delete(e9), r2._internalState.set(e9, t2), r2)
            }),
            (e7.prototype.unset = function (e9) {
              var t2 = this._clone()
              return (t2._internalState.delete(e9), t2)
            }),
            (e7.prototype.get = function (e9) {
              return this._internalState.get(e9)
            }),
            (e7.prototype.serialize = function () {
              var e9 = this
              return this._keys()
                .reduce(function (t2, r2) {
                  return (t2.push(r2 + '=' + e9.get(r2)), t2)
                }, [])
                .join(',')
            }),
            (e7.prototype._parse = function (e9) {
              !(e9.length > 512) &&
                ((this._internalState = e9
                  .split(',')
                  .reverse()
                  .reduce(function (e10, t2) {
                    var r2 = t2.trim(),
                      n2 = r2.indexOf('=')
                    if (-1 !== n2) {
                      var o2 = r2.slice(0, n2),
                        i2 = r2.slice(n2 + 1, t2.length)
                      eR.test(o2) && eL.test(i2) && !eS.test(i2) && e10.set(o2, i2)
                    }
                    return e10
                  }, /* @__PURE__ */ new Map())),
                this._internalState.size > 32 &&
                  (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, 32))))
            }),
            (e7.prototype._keys = function () {
              return Array.from(this._internalState.keys()).reverse()
            }),
            (e7.prototype._clone = function () {
              var t2 = new e7()
              return ((t2._internalState = new Map(this._internalState)), t2)
            }),
            e7
          )
        })(),
        ey = 'traceparent',
        ed = 'tracestate',
        eg = RegExp(
          '^\\s?((?!ff)[\\da-f]{2})-((?![0]{32})[\\da-f]{32})-((?![0]{16})[\\da-f]{16})-([\\da-f]{2})(-.*)?\\s?$'
        )
      function eh(e7) {
        var t2 = eg.exec(e7)
        return !t2 || ('00' === t2[1] && t2[5])
          ? null
          : { traceId: t2[2], spanId: t2[3], traceFlags: parseInt(t2[4], 16) }
      }
      var eI = (function () {
          function e7() {}
          return (
            (e7.prototype.inject = function (e9, t2, r2) {
              var n2 = l.trace.getSpanContext(e9)
              if (!(!n2 || O(e9)) && (0, l.isSpanContextValid)(n2)) {
                var o2 =
                  '00-' + n2.traceId + '-' + n2.spanId + '-0' + Number(n2.traceFlags || l.TraceFlags.NONE).toString(16)
                ;(r2.set(t2, ey, o2), n2.traceState && r2.set(t2, ed, n2.traceState.serialize()))
              }
            }),
            (e7.prototype.extract = function (e9, t2, r2) {
              var n2 = r2.get(t2, ey)
              if (!n2) return e9
              var o2 = Array.isArray(n2) ? n2[0] : n2
              if ('string' != typeof o2) return e9
              var i2 = eh(o2)
              if (!i2) return e9
              i2.isRemote = true
              var a2 = r2.get(t2, ed)
              if (a2) {
                var _2 = Array.isArray(a2) ? a2.join(',') : a2
                i2.traceState = new eP('string' == typeof _2 ? _2 : void 0)
              }
              return l.trace.setSpanContext(e9, i2)
            }),
            (e7.prototype.fields = function () {
              return [ey, ed]
            }),
            e7
          )
        })(),
        em = (0, l.createContextKey)('OpenTelemetry SDK Context Key RPC_METADATA')
      function eA(e7, t2) {
        return e7.setValue(em, t2)
      }
      function ev(e7) {
        return e7.deleteValue(em)
      }
      function eC(e7) {
        return e7.getValue(em)
      }
      ;(T || (T = {})).HTTP = 'http'
      var eN = (function () {
          function e7() {}
          return (
            (e7.prototype.shouldSample = function () {
              return { decision: l.SamplingDecision.NOT_RECORD }
            }),
            (e7.prototype.toString = function () {
              return 'AlwaysOffSampler'
            }),
            e7
          )
        })(),
        eb = (function () {
          function e7() {}
          return (
            (e7.prototype.shouldSample = function () {
              return { decision: l.SamplingDecision.RECORD_AND_SAMPLED }
            }),
            (e7.prototype.toString = function () {
              return 'AlwaysOnSampler'
            }),
            e7
          )
        })(),
        eU = (function () {
          function e7(e9) {
            var t2, r2, n2, o2
            ;((this._root = e9.root),
              this._root ||
                (U(Error('ParentBasedSampler must have a root sampler configured')), (this._root = new eb())),
              (this._remoteParentSampled = null != (t2 = e9.remoteParentSampled) ? t2 : new eb()),
              (this._remoteParentNotSampled = null != (r2 = e9.remoteParentNotSampled) ? r2 : new eN()),
              (this._localParentSampled = null != (n2 = e9.localParentSampled) ? n2 : new eb()),
              (this._localParentNotSampled = null != (o2 = e9.localParentNotSampled) ? o2 : new eN()))
          }
          return (
            (e7.prototype.shouldSample = function (e9, t2, r2, n2, o2, i2) {
              var a2 = l.trace.getSpanContext(e9)
              return a2 && (0, l.isSpanContextValid)(a2)
                ? a2.isRemote
                  ? a2.traceFlags & l.TraceFlags.SAMPLED
                    ? this._remoteParentSampled.shouldSample(e9, t2, r2, n2, o2, i2)
                    : this._remoteParentNotSampled.shouldSample(e9, t2, r2, n2, o2, i2)
                  : a2.traceFlags & l.TraceFlags.SAMPLED
                    ? this._localParentSampled.shouldSample(e9, t2, r2, n2, o2, i2)
                    : this._localParentNotSampled.shouldSample(e9, t2, r2, n2, o2, i2)
                : this._root.shouldSample(e9, t2, r2, n2, o2, i2)
            }),
            (e7.prototype.toString = function () {
              return (
                'ParentBased{root=' +
                this._root.toString() +
                ', remoteParentSampled=' +
                this._remoteParentSampled.toString() +
                ', remoteParentNotSampled=' +
                this._remoteParentNotSampled.toString() +
                ', localParentSampled=' +
                this._localParentSampled.toString() +
                ', localParentNotSampled=' +
                this._localParentNotSampled.toString() +
                '}'
              )
            }),
            e7
          )
        })(),
        eM = (function () {
          function e7(e9) {
            ;(void 0 === e9 && (e9 = 0),
              (this._ratio = e9),
              (this._ratio = this._normalize(e9)),
              (this._upperBound = Math.floor(4294967295 * this._ratio)))
          }
          return (
            (e7.prototype.shouldSample = function (e9, t2) {
              return {
                decision:
                  (0, l.isValidTraceId)(t2) && this._accumulate(t2) < this._upperBound
                    ? l.SamplingDecision.RECORD_AND_SAMPLED
                    : l.SamplingDecision.NOT_RECORD,
              }
            }),
            (e7.prototype.toString = function () {
              return 'TraceIdRatioBased{' + this._ratio + '}'
            }),
            (e7.prototype._normalize = function (e9) {
              return 'number' != typeof e9 || isNaN(e9) ? 0 : e9 >= 1 ? 1 : e9 <= 0 ? 0 : e9
            }),
            (e7.prototype._accumulate = function (e9) {
              for (var t2 = 0, r2 = 0; r2 < e9.length / 8; r2++) {
                var n2 = 8 * r2
                t2 = (t2 ^ parseInt(e9.slice(n2, n2 + 8), 16)) >>> 0
              }
              return t2
            }),
            e7
          )
        })(),
        eD = Function.prototype.toString,
        eB = eD.call(Object),
        ew =
          ((e = Object.getPrototypeOf),
          (t = Object),
          function (r2) {
            return e(t(r2))
          }),
        eX = Object.prototype,
        ej = eX.hasOwnProperty,
        ex = Symbol ? Symbol.toStringTag : void 0,
        eG = eX.toString
      function eV(e7) {
        if (
          null == (t2 = e7) ||
          'object' != typeof t2 ||
          '[object Object]' !==
            (null == (r2 = e7)
              ? void 0 === r2
                ? '[object Undefined]'
                : '[object Null]'
              : ex && ex in Object(r2)
                ? (function (e9) {
                    var t3 = ej.call(e9, ex),
                      r3 = e9[ex],
                      n3 = false
                    try {
                      ;((e9[ex] = void 0), (n3 = true))
                    } catch (e10) {}
                    var o3 = eG.call(e9)
                    return (n3 && (t3 ? (e9[ex] = r3) : delete e9[ex]), o3)
                  })(r2)
                : ((n2 = r2), eG.call(n2)))
        )
          return false
        var t2,
          r2,
          n2,
          o2 = ew(e7)
        if (null === o2) return true
        var i2 = ej.call(o2, 'constructor') && o2.constructor
        return 'function' == typeof i2 && i2 instanceof i2 && eD.call(i2) === eB
      }
      function eH() {
        for (var e7 = [], t2 = 0; t2 < arguments.length; t2++) e7[t2] = arguments[t2]
        for (var r2 = e7.shift(), n2 = /* @__PURE__ */ new WeakMap(); e7.length > 0; )
          r2 = (function e9(t3, r3, n3, o2) {
            if ((void 0 === n3 && (n3 = 0), !(n3 > 20))) {
              if ((n3++, eZ(t3) || eZ(r3) || ez(r3))) _2 = eF(r3)
              else if (ek(t3)) {
                if (((_2 = t3.slice()), ek(r3)))
                  for (var i2, a2, _2, T2 = 0, E2 = r3.length; T2 < E2; T2++) _2.push(eF(r3[T2]))
                else if (eY(r3))
                  for (var u2 = Object.keys(r3), T2 = 0, E2 = u2.length; T2 < E2; T2++) {
                    var l2 = u2[T2]
                    _2[l2] = eF(r3[l2])
                  }
              } else if (eY(t3))
                if (eY(r3)) {
                  if (((i2 = t3), (a2 = r3), !(eV(i2) && eV(a2)))) return r3
                  _2 = Object.assign({}, t3)
                  for (var u2 = Object.keys(r3), T2 = 0, E2 = u2.length; T2 < E2; T2++) {
                    var l2 = u2[T2],
                      c2 = r3[l2]
                    if (eZ(c2)) void 0 === c2 ? delete _2[l2] : (_2[l2] = c2)
                    else {
                      var f2 = _2[l2]
                      if (eK(t3, l2, o2) || eK(r3, l2, o2)) delete _2[l2]
                      else {
                        if (eY(f2) && eY(c2)) {
                          var s2 = o2.get(f2) || [],
                            O2 = o2.get(c2) || []
                          ;(s2.push({ obj: t3, key: l2 }),
                            O2.push({ obj: r3, key: l2 }),
                            o2.set(f2, s2),
                            o2.set(c2, O2))
                        }
                        _2[l2] = e9(_2[l2], c2, n3, o2)
                      }
                    }
                  }
                } else _2 = r3
              return _2
            }
          })(r2, e7.shift(), 0, n2)
        return r2
      }
      function eF(e7) {
        return ek(e7) ? e7.slice() : e7
      }
      function eK(e7, t2, r2) {
        for (var n2 = r2.get(e7[t2]) || [], o2 = 0, i2 = n2.length; o2 < i2; o2++) {
          var a2 = n2[o2]
          if (a2.key === t2 && a2.obj === e7) return true
        }
        return false
      }
      function ek(e7) {
        return Array.isArray(e7)
      }
      function ez(e7) {
        return 'function' == typeof e7
      }
      function eY(e7) {
        return !eZ(e7) && !ek(e7) && !ez(e7) && 'object' == typeof e7
      }
      function eZ(e7) {
        return (
          'string' == typeof e7 ||
          'number' == typeof e7 ||
          'boolean' == typeof e7 ||
          void 0 === e7 ||
          e7 instanceof Date ||
          e7 instanceof RegExp ||
          null === e7
        )
      }
      var eW =
          ((o = function (e7, t2) {
            return (o =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (e9, t3) {
                  e9.__proto__ = t3
                }) ||
              function (e9, t3) {
                for (var r2 in t3) Object.prototype.hasOwnProperty.call(t3, r2) && (e9[r2] = t3[r2])
              })(e7, t2)
          }),
          function (e7, t2) {
            if ('function' != typeof t2 && null !== t2)
              throw TypeError('Class extends value ' + String(t2) + ' is not a constructor or null')
            function r2() {
              this.constructor = e7
            }
            ;(o(e7, t2), (e7.prototype = null === t2 ? Object.create(t2) : ((r2.prototype = t2.prototype), new r2())))
          }),
        eJ = (function (e7) {
          function t2(r2) {
            var n2 = e7.call(this, r2) || this
            return (Object.setPrototypeOf(n2, t2.prototype), n2)
          }
          return (eW(t2, e7), t2)
        })(Error)
      function eQ(e7, t2) {
        var r2
        return Promise.race([
          e7,
          new Promise(function (e9, n2) {
            r2 = setTimeout(function () {
              n2(new eJ('Operation timed out.'))
            }, t2)
          }),
        ]).then(
          function (e9) {
            return (clearTimeout(r2), e9)
          },
          function (e9) {
            throw (clearTimeout(r2), e9)
          }
        )
      }
      var e$ = function (e7) {
        var t2 = 'function' == typeof Symbol && Symbol.iterator,
          r2 = t2 && e7[t2],
          n2 = 0
        if (r2) return r2.call(e7)
        if (e7 && 'number' == typeof e7.length)
          return {
            next: function () {
              return (e7 && n2 >= e7.length && (e7 = void 0), { value: e7 && e7[n2++], done: !e7 })
            },
          }
        throw TypeError(t2 ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
      }
      function eq(e7, t2) {
        return 'string' == typeof t2 ? e7 === t2 : !!e7.match(t2)
      }
      function e0(e7, t2) {
        var r2, n2
        if (!t2) return false
        try {
          for (var o2 = e$(t2), i2 = o2.next(); !i2.done; i2 = o2.next()) {
            var a2 = i2.value
            if (eq(e7, a2)) return true
          }
        } catch (e9) {
          r2 = { error: e9 }
        } finally {
          try {
            i2 && !i2.done && (n2 = o2.return) && n2.call(o2)
          } finally {
            if (r2) throw r2.error
          }
        }
        return false
      }
      function e1(e7) {
        return (
          'function' == typeof e7 &&
          'function' == typeof e7.__original &&
          'function' == typeof e7.__unwrap &&
          true === e7.__wrapped
        )
      }
      var e2 = (function () {
          function e7() {
            var e9 = this
            this._promise = new Promise(function (t2, r2) {
              ;((e9._resolve = t2), (e9._reject = r2))
            })
          }
          return (
            Object.defineProperty(e7.prototype, 'promise', {
              get: function () {
                return this._promise
              },
              enumerable: false,
              configurable: true,
            }),
            (e7.prototype.resolve = function (e9) {
              this._resolve(e9)
            }),
            (e7.prototype.reject = function (e9) {
              this._reject(e9)
            }),
            e7
          )
        })(),
        e3 = function (e7, t2) {
          var r2 = 'function' == typeof Symbol && e7[Symbol.iterator]
          if (!r2) return e7
          var n2,
            o2,
            i2 = r2.call(e7),
            a2 = []
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = i2.next()).done; ) a2.push(n2.value)
          } catch (e9) {
            o2 = { error: e9 }
          } finally {
            try {
              n2 && !n2.done && (r2 = i2.return) && r2.call(i2)
            } finally {
              if (o2) throw o2.error
            }
          }
          return a2
        },
        e4 = function (e7, t2, r2) {
          if (r2 || 2 == arguments.length)
            for (var n2, o2 = 0, i2 = t2.length; o2 < i2; o2++)
              (!n2 && o2 in t2) || (n2 || (n2 = Array.prototype.slice.call(t2, 0, o2)), (n2[o2] = t2[o2]))
          return e7.concat(n2 || Array.prototype.slice.call(t2))
        },
        e8 = (function () {
          function e7(e9, t2) {
            ;((this._callback = e9), (this._that = t2), (this._isCalled = false), (this._deferred = new e2()))
          }
          return (
            Object.defineProperty(e7.prototype, 'isCalled', {
              get: function () {
                return this._isCalled
              },
              enumerable: false,
              configurable: true,
            }),
            Object.defineProperty(e7.prototype, 'promise', {
              get: function () {
                return this._deferred.promise
              },
              enumerable: false,
              configurable: true,
            }),
            (e7.prototype.call = function () {
              for (var e9, t2 = this, r2 = [], n2 = 0; n2 < arguments.length; n2++) r2[n2] = arguments[n2]
              if (!this._isCalled) {
                this._isCalled = true
                try {
                  Promise.resolve((e9 = this._callback).call.apply(e9, e4([this._that], e3(r2), false))).then(
                    function (e10) {
                      return t2._deferred.resolve(e10)
                    },
                    function (e10) {
                      return t2._deferred.reject(e10)
                    }
                  )
                } catch (e10) {
                  this._deferred.reject(e10)
                }
              }
              return this._deferred.promise
            }),
            e7
          )
        })(),
        e6 = {
          getKeyPairs: S,
          serializeKeyPairs: L,
          parseKeyPairsIntoRecord: function (e7) {
            return 'string' != typeof e7 || 0 === e7.length
              ? {}
              : e7
                  .split(',')
                  .map(function (e9) {
                    return P(e9)
                  })
                  .filter(function (e9) {
                    return void 0 !== e9 && e9.value.length > 0
                  })
                  .reduce(function (e9, t2) {
                    return ((e9[t2.key] = t2.value), e9)
                  }, {})
          },
          parsePairKeyValue: P,
        },
        e5 = {
          _export: function (e7, t2) {
            return new Promise(function (r2) {
              l.context.with(f(l.context.active()), function () {
                e7.export(t2, function (e9) {
                  r2(e9)
                })
              })
            })
          },
        }
      module2.exports = u
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/span_context.js
var require_span_context3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/span_context.js'(exports2, module2) {
    'use strict'
    var api = require('@opentelemetry/api')
    var { AUTO_KEEP } = require_priority()
    var DatadogSpanContext = require_span_context()
    var id = require_id()
    function newContext() {
      const spanId = id()
      return new DatadogSpanContext({
        traceId: spanId,
        spanId,
      })
    }
    var SpanContext = class {
      constructor(context) {
        if (!(context instanceof DatadogSpanContext)) {
          context = context ? new DatadogSpanContext(context) : newContext()
        }
        this._ddContext = context
      }
      get traceId() {
        return this._ddContext.toTraceId(true)
      }
      get spanId() {
        return this._ddContext.toSpanId(true)
      }
      get traceFlags() {
        return this._ddContext._sampling.priority >= AUTO_KEEP ? 1 : 0
      }
      get traceState() {
        const ts = this._ddContext._tracestate
        return api.createTraceState(ts ? ts.toString() : '')
      }
    }
    module2.exports = SpanContext
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/context_manager.js
var require_context_manager = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/context_manager.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var { trace, ROOT_CONTEXT, propagation } = require('@opentelemetry/api')
    var DataDogSpanContext = require_span_context()
    var SpanContext = require_span_context3()
    var tracer2 = require_dd_trace()
    var ContextManager = class {
      constructor() {
        this._store = storage('opentelemetry')
      }
      // converts dd to otel
      active() {
        const activeSpan = tracer2.scope().active()
        const store = this._store.getStore()
        const context = (activeSpan && activeSpan.context()) || store || ROOT_CONTEXT
        if (!(context instanceof DataDogSpanContext)) {
          const span = trace.getSpan(context)
          if (span && span._spanContext && span._spanContext._ddContext && span._spanContext._ddContext._baggageItems) {
            const baggages2 = span._spanContext._ddContext._baggageItems
            const entries2 = {}
            for (const [key, value] of Object.entries(baggages2)) {
              entries2[key] = { value }
            }
            const otelBaggages2 = propagation.createBaggage(entries2)
            return propagation.setBaggage(context, otelBaggages2)
          }
          return context
        }
        const baggages = JSON.parse(activeSpan.getAllBaggageItems())
        const entries = {}
        for (const [key, value] of Object.entries(baggages)) {
          entries[key] = { value }
        }
        const otelBaggages = propagation.createBaggage(entries)
        if (!context._otelSpanContext) {
          const newSpanContext = new SpanContext(context)
          context._otelSpanContext = newSpanContext
        }
        if (store && trace.getSpanContext(store) === context._otelSpanContext) {
          return otelBaggages ? propagation.setBaggage(store, otelBaggages) : store
        }
        const wrappedContext = trace.setSpanContext(store || ROOT_CONTEXT, context._otelSpanContext)
        return otelBaggages ? propagation.setBaggage(wrappedContext, otelBaggages) : wrappedContext
      }
      // converts otel to dd
      with(context, fn, thisArg, ...args) {
        const span = trace.getSpan(context)
        const ddScope = tracer2.scope()
        const run = () => {
          const cb = thisArg == null ? fn : fn.bind(thisArg)
          return this._store.run(context, cb, ...args)
        }
        const baggages = propagation.getBaggage(context)
        let baggageItems = []
        if (baggages) {
          baggageItems = baggages.getAllEntries()
        }
        if (span && span._ddSpan) {
          span._ddSpan.removeAllBaggageItems()
          for (const baggage of baggageItems) {
            span._ddSpan.setBaggageItem(baggage[0], baggage[1].value)
          }
          return ddScope.activate(span._ddSpan, run)
        }
        if (span && span._spanContext && span._spanContext._ddContext && span._spanContext._ddContext._baggageItems) {
          span._spanContext._ddContext._baggageItems = {}
          for (const baggage of baggageItems) {
            span._spanContext._ddContext._baggageItems[baggage[0]] = baggage[1].value
          }
        }
        return run()
      }
      bind(context, target) {
        const self2 = this
        return function (...args) {
          return self2.with(context, target, this, ...args)
        }
      }
      enable() {}
      disable() {}
    }
    module2.exports = ContextManager
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/span_processor.js
var require_span_processor = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/span_processor.js'(exports2, module2) {
    'use strict'
    var NoopSpanProcessor = class {
      forceFlush() {
        return Promise.resolve()
      }
      onStart(span, context) {}
      onEnd(span) {}
      shutdown() {
        return Promise.resolve()
      }
    }
    var MultiSpanProcessor = class extends NoopSpanProcessor {
      constructor(spanProcessors) {
        super()
        this._processors = spanProcessors
      }
      forceFlush() {
        return Promise.all(this._processors.map((p) => p.forceFlush()))
      }
      onStart(span, context) {
        for (const processor of this._processors) {
          processor.onStart(span, context)
        }
      }
      onEnd(span) {
        for (const processor of this._processors) {
          processor.onEnd(span)
        }
      }
      shutdown() {
        return Promise.all(this._processors.map((p) => p.shutdown()))
      }
    }
    module2.exports = {
      MultiSpanProcessor,
      NoopSpanProcessor,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/sampler.js
var require_sampler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/sampler.js'(exports2, module2) {
    'use strict'
    var Sampler = class {
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        return { decision: 2 }
      }
      /** Returns the sampler name or short description with the configuration. */
      toString() {
        return 'DatadogSampler'
      }
    }
    module2.exports = Sampler
  },
})

// node_modules/dc-polyfill/checks.js
var require_checks = __commonJS({
  'node_modules/dc-polyfill/checks.js'(exports2, module2) {
    var [MAJOR, MINOR, PATCH] = process.versions.node.split('.').map(Number)
    module2.exports.MAJOR = MAJOR
    module2.exports.MINOR = MINOR
    module2.exports.PATCH = PATCH
    function hasFullSupport() {
      return MAJOR > 20 || (MAJOR >= 20 && MINOR >= 6)
    }
    module2.exports.hasFullSupport = hasFullSupport
    function hasTracingChannel() {
      return MAJOR >= 20 || (MAJOR === 18 && MINOR >= 19)
    }
    module2.exports.hasTracingChannel = hasTracingChannel
    function hasDiagnosticsChannel() {
      return MAJOR >= 16 || (MAJOR === 15 && MINOR >= 1) || (MAJOR === 14 && MINOR >= 17)
    }
    module2.exports.hasDiagnosticsChannel = hasDiagnosticsChannel
    function hasTopSubscribeUnsubscribe() {
      return MAJOR >= 20 || (MAJOR === 16 && MINOR >= 17) || (MAJOR === 18 && MINOR >= 7)
    }
    module2.exports.hasTopSubscribeUnsubscribe = hasTopSubscribeUnsubscribe
    function hasGarbageCollectionBug() {
      return hasDiagnosticsChannel() && !hasFullSupport()
    }
    module2.exports.hasGarbageCollectionBug = hasGarbageCollectionBug
    function hasChannelStoreMethods() {
      return MAJOR >= 20 || (MAJOR === 19 && MINOR >= 9)
    }
    module2.exports.hasChannelStoreMethods = hasChannelStoreMethods
    function hasChUnsubscribeReturn() {
      return (
        MAJOR >= 18 || (MAJOR === 14 && MINOR >= 19) || (MAJOR === 16 && MINOR >= 14) || (MAJOR === 17 && MINOR >= 1)
      )
    }
    module2.exports.hasChUnsubscribeReturn = hasChUnsubscribeReturn
    function hasSyncUnsubscribeBug() {
      return MAJOR === 20 && MINOR <= 5
    }
    module2.exports.hasSyncUnsubscribeBug = hasSyncUnsubscribeBug
    function hasTracingChannelHasSubscribers() {
      return MAJOR >= 22 || (MAJOR == 20 && MINOR >= 13)
    }
    module2.exports.hasTracingChannelHasSubscribers = hasTracingChannelHasSubscribers
  },
})

// node_modules/dc-polyfill/primordials.js
var require_primordials = __commonJS({
  'node_modules/dc-polyfill/primordials.js'(exports2, module2) {
    var makeCall =
      (fn) =>
      (...args) =>
        fn.call(...args)
    function arrayAtPolyfill(n) {
      n = Math.trunc(n) || 0
      if (n < 0) n += this.length
      if (n < 0 || n >= this.length) return void 0
      return this[n]
    }
    var ReflectApply = Reflect.apply
    var PromiseReject = Promise.reject.bind(Promise)
    var PromiseResolve = Promise.resolve
    var PromisePrototypeThen = makeCall(Promise.prototype.then)
    var ArrayPrototypeSplice = makeCall(Array.prototype.splice)
    var ArrayPrototypeAt = makeCall(Array.prototype.at || arrayAtPolyfill)
    var ObjectDefineProperty = Object.defineProperty
    var ObjectDefineProperties = Object.defineProperties
    var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
    var ObjectGetPrototypeOf = Object.getPrototypeOf
    var ObjectSetPrototypeOf = Object.setPrototypeOf
    var SymbolFor = Symbol.for
    module2.exports = {
      ReflectApply,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      ArrayPrototypeSplice,
      ArrayPrototypeAt,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectGetPrototypeOf,
      ObjectSetPrototypeOf,
      SymbolFor,
    }
  },
})

// node_modules/dc-polyfill/errors.js
var require_errors = __commonJS({
  'node_modules/dc-polyfill/errors.js'(exports2, module2) {
    var util = require('util')
    var { ObjectDefineProperties } = require_primordials()
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(message, actual) {
        super()
        if (actual == null) {
          message += `. Received ${actual}`
        } else if (typeof actual === 'function' && actual.name) {
          message += `. Received function ${actual.name}`
        } else if (typeof actual === 'object') {
          if (actual.constructor && actual.constructor.name) {
            message += `. Received an instance of ${actual.constructor.name}`
          } else {
            const inspected = util.inspect(actual, { depth: -1 })
            message += `. Received ${inspected}`
          }
        } else {
          let inspected = util.inspect(actual, { colors: false })
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`
          }
          message += `. Received type ${typeof actual} (${inspected})`
        }
        this.code = this.constructor.name
        ObjectDefineProperties(this, {
          message: {
            value: message,
            enumerable: false,
            writable: true,
            configurable: true,
          },
          toString: {
            value() {
              return `${this.name} [${this.code}]: ${this.message}`
            },
            enumerable: false,
            writable: true,
            configurable: true,
          },
        })
      }
    }
    module2.exports = {
      ERR_INVALID_ARG_TYPE,
    }
  },
})

// node_modules/dc-polyfill/acquire-channel-registry.js
var require_acquire_channel_registry = __commonJS({
  'node_modules/dc-polyfill/acquire-channel-registry.js'(exports2, module2) {
    var { ObjectDefineProperty, SymbolFor } = require_primordials()
    var REGISTRY_SYMBOL = SymbolFor('dc-polyfill-v1')
    if (!process[REGISTRY_SYMBOL]) {
      ObjectDefineProperty(process, REGISTRY_SYMBOL, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: {},
      })
    }
    module2.exports = process[REGISTRY_SYMBOL]
  },
})

// node_modules/dc-polyfill/reimplementation.js
var require_reimplementation = __commonJS({
  'node_modules/dc-polyfill/reimplementation.js'(exports2, module2) {
    'use strict'
    var { ObjectSetPrototypeOf, ObjectGetPrototypeOf } = require_primordials()
    var { ERR_INVALID_ARG_TYPE } = require_errors()
    var channels = require_acquire_channel_registry()
    var ActiveChannel = class {
      subscribe(subscription) {
        if (typeof subscription !== 'function') {
          throw new ERR_INVALID_ARG_TYPE('The "subscription" argument must be of type function', subscription)
        }
        this._subscribers.push(subscription)
      }
      unsubscribe(subscription) {
        const index = this._subscribers.indexOf(subscription)
        if (index === -1) return false
        this._subscribers.splice(index, 1)
        if (!this._subscribers.length) {
          ObjectSetPrototypeOf(this, Channel.prototype)
        }
        return true
      }
      get hasSubscribers() {
        return true
      }
      publish(data) {
        for (let i = 0; i < this._subscribers.length; i++) {
          try {
            const onMessage = this._subscribers[i]
            onMessage(data, this.name)
          } catch (err) {
            process.nextTick(() => {
              throw err
            })
          }
        }
      }
    }
    var Channel = class _Channel {
      constructor(name) {
        this._subscribers = void 0
        this.name = name
      }
      static [Symbol.hasInstance](instance) {
        const prototype = ObjectGetPrototypeOf(instance)
        return prototype === _Channel.prototype || prototype === ActiveChannel.prototype
      }
      subscribe(subscription) {
        ObjectSetPrototypeOf(this, ActiveChannel.prototype)
        this._subscribers = []
        this.subscribe(subscription)
      }
      unsubscribe() {
        return false
      }
      get hasSubscribers() {
        return false
      }
      publish() {}
    }
    function channel(name) {
      const channel2 = channels[name]
      if (channel2) return channel2
      if (typeof name !== 'string' && typeof name !== 'symbol') {
        throw new ERR_INVALID_ARG_TYPE('The "channel" argument must be one of type string or symbol', name)
      }
      return (channels[name] = new Channel(name))
    }
    function hasSubscribers(name) {
      const channel2 = channels[name]
      if (!channel2) {
        return false
      }
      return channel2.hasSubscribers
    }
    function deleteChannel(name) {
      if (channels[name]) {
        channels[name] = null
        return true
      }
      return false
    }
    module2.exports = {
      channel,
      hasSubscribers,
      Channel,
      deleteChannel,
    }
  },
})

// node_modules/dc-polyfill/patch-garbage-collection-bug.js
var require_patch_garbage_collection_bug = __commonJS({
  'node_modules/dc-polyfill/patch-garbage-collection-bug.js'(exports2, module2) {
    var PHONY_SUBSCRIBE = function AVOID_GARBAGE_COLLECTION() {}
    var { ObjectDefineProperty, ObjectGetOwnPropertyDescriptor } = require_primordials()
    module2.exports = function (unpatched) {
      const dc_channel = unpatched.channel
      const channels = /* @__PURE__ */ new WeakSet()
      const dc = { ...unpatched }
      dc.channel = function () {
        const ch = dc_channel.apply(this, arguments)
        if (channels.has(ch)) return ch
        dc_channel(arguments[0]).subscribe(PHONY_SUBSCRIBE)
        channels.add(ch)
        if (!ObjectGetOwnPropertyDescriptor(ch, 'hasSubscribers')) {
          ObjectDefineProperty(ch, 'hasSubscribers', {
            get: function () {
              const subscribers = ch._subscribers
              if (subscribers.length > 1) return true
              const stores = ch._stores
              if (stores.size > 0) return true
              if (subscribers.length < 1) return false
              if (subscribers[0] === PHONY_SUBSCRIBE) return false
              return true
            },
          })
        }
        return ch
      }
      return dc
    }
  },
})

// node_modules/dc-polyfill/patch-top-subscribe-unsubscribe.js
var require_patch_top_subscribe_unsubscribe = __commonJS({
  'node_modules/dc-polyfill/patch-top-subscribe-unsubscribe.js'(exports2, module2) {
    module2.exports = function (unpatched) {
      const dc = { ...unpatched }
      dc.subscribe = (channel, cb) => {
        return dc.channel(channel).subscribe(cb)
      }
      dc.unsubscribe = (channel, cb) => {
        return dc.channel(channel).unsubscribe(cb)
      }
      return dc
    }
  },
})

// node_modules/dc-polyfill/patch-channel-unsubscribe-return.js
var require_patch_channel_unsubscribe_return = __commonJS({
  'node_modules/dc-polyfill/patch-channel-unsubscribe-return.js'(exports2, module2) {
    var { ObjectGetPrototypeOf } = require_primordials()
    module2.exports = function (unpatched) {
      const channels = /* @__PURE__ */ new WeakSet()
      const dc_channel = unpatched.channel
      const dc = { ...unpatched }
      dc.channel = function () {
        const ch = dc_channel.apply(this, arguments)
        if (channels.has(ch)) return ch
        ch.unsubscribe = function () {
          delete ch.unsubscribe
          const oldSubscriberCount = this._subscribers.length
          ObjectGetPrototypeOf(ch).unsubscribe.apply(this, arguments)
          return this._subscribers.length < oldSubscriberCount
        }
        channels.add(ch)
        return ch
      }
      return dc
    }
  },
})

// node_modules/dc-polyfill/patch-channel-store-methods.js
var require_patch_channel_store_methods = __commonJS({
  'node_modules/dc-polyfill/patch-channel-store-methods.js'(exports2, module2) {
    var { ReflectApply, ObjectDefineProperty, ObjectGetOwnPropertyDescriptor } = require_primordials()
    module2.exports = function (unpatched) {
      const channels = /* @__PURE__ */ new WeakSet()
      const dc_channel = unpatched.channel
      const dc = { ...unpatched }
      dc.channel = function () {
        const ch = dc_channel.apply(this, arguments)
        if (channels.has(ch)) return ch
        ch._stores = /* @__PURE__ */ new Map()
        ch.bindStore = function (store, transform) {
          this._stores.set(store, transform)
        }
        ch.unbindStore = function (store) {
          if (!this._stores.has(store)) {
            return false
          }
          this._stores.delete(store)
          return true
        }
        ch.runStores = function (data, fn, thisArg, ...args) {
          let run = () => {
            this.publish(data)
            return ReflectApply(fn, thisArg, args)
          }
          for (const entry of this._stores.entries()) {
            const store = entry[0]
            const transform = entry[1]
            run = wrapStoreRun(store, data, run, transform)
          }
          return run()
        }
        if (!ObjectGetOwnPropertyDescriptor(ch, 'hasSubscribers')) {
          ObjectDefineProperty(ch, 'hasSubscribers', {
            get: function () {
              return this.__proto__.hasSubscribers || ch._stores.size > 0
            },
          })
        }
        channels.add(ch)
        return ch
      }
      return dc
    }
    function wrapStoreRun(store, data, next, transform = defaultTransform) {
      return () => {
        let context
        try {
          context = transform(data)
        } catch (err) {
          process.nextTick(() => {
            throw err
          })
          return next()
        }
        return store.run(context, next)
      }
    }
    function defaultTransform(data) {
      return data
    }
  },
})

// node_modules/dc-polyfill/patch-tracing-channel.js
var require_patch_tracing_channel = __commonJS({
  'node_modules/dc-polyfill/patch-tracing-channel.js'(exports2, module2) {
    var { ReflectApply, PromiseReject, PromiseResolve, PromisePrototypeThen, ArrayPrototypeSplice, ArrayPrototypeAt } =
      require_primordials()
    var { ERR_INVALID_ARG_TYPE } = require_errors()
    var traceEvents = ['start', 'end', 'asyncStart', 'asyncEnd', 'error']
    module2.exports = function (unpatched) {
      const { channel } = unpatched
      const dc = { ...unpatched }
      class TracingChannel {
        constructor(nameOrChannels) {
          if (typeof nameOrChannels === 'string') {
            this.start = channel(`tracing:${nameOrChannels}:start`)
            this.end = channel(`tracing:${nameOrChannels}:end`)
            this.asyncStart = channel(`tracing:${nameOrChannels}:asyncStart`)
            this.asyncEnd = channel(`tracing:${nameOrChannels}:asyncEnd`)
            this.error = channel(`tracing:${nameOrChannels}:error`)
          } else if (typeof nameOrChannels === 'object') {
            const { start, end, asyncStart, asyncEnd, error } = nameOrChannels
            this.start = start
            this.end = end
            this.asyncStart = asyncStart
            this.asyncEnd = asyncEnd
            this.error = error
          } else {
            throw new ERR_INVALID_ARG_TYPE('nameOrChannels', ['string', 'object', 'Channel'], nameOrChannels)
          }
        }
        subscribe(handlers) {
          for (const name of traceEvents) {
            if (!handlers[name]) continue
            if (this[name]) this[name].subscribe(handlers[name])
          }
        }
        unsubscribe(handlers) {
          let done = true
          for (const name of traceEvents) {
            if (!handlers[name]) continue
            if (!(this[name] && this[name].unsubscribe(handlers[name]))) {
              done = false
            }
          }
          return done
        }
        traceSync(fn, context = {}, thisArg, ...args) {
          const { start, end, error } = this
          return start.runStores(context, () => {
            try {
              const result = ReflectApply(fn, thisArg, args)
              context.result = result
              return result
            } catch (err) {
              context.error = err
              error.publish(context)
              throw err
            } finally {
              end.publish(context)
            }
          })
        }
        tracePromise(fn, context = {}, thisArg, ...args) {
          const { start, end, asyncStart, asyncEnd, error } = this
          function reject(err) {
            context.error = err
            error.publish(context)
            asyncStart.publish(context)
            asyncEnd.publish(context)
            return PromiseReject(err)
          }
          function resolve(result) {
            context.result = result
            asyncStart.publish(context)
            asyncEnd.publish(context)
            return result
          }
          return start.runStores(context, () => {
            try {
              let promise = ReflectApply(fn, thisArg, args)
              if (!(promise instanceof Promise)) {
                promise = PromiseResolve(promise)
              }
              return PromisePrototypeThen(promise, resolve, reject)
            } catch (err) {
              context.error = err
              error.publish(context)
              throw err
            } finally {
              end.publish(context)
            }
          })
        }
        traceCallback(fn, position = -1, context = {}, thisArg, ...args) {
          const { start, end, asyncStart, asyncEnd, error } = this
          function wrappedCallback(err, res) {
            if (err) {
              context.error = err
              error.publish(context)
            } else {
              context.result = res
            }
            asyncStart.runStores(context, () => {
              try {
                if (callback) {
                  return ReflectApply(callback, this, arguments)
                }
              } finally {
                asyncEnd.publish(context)
              }
            })
          }
          const callback = ArrayPrototypeAt(args, position)
          if (typeof callback !== 'function') {
            throw new ERR_INVALID_ARG_TYPE('callback', ['function'], callback)
          }
          ArrayPrototypeSplice(args, position, 1, wrappedCallback)
          return start.runStores(context, () => {
            try {
              return ReflectApply(fn, thisArg, args)
            } catch (err) {
              context.error = err
              error.publish(context)
              throw err
            } finally {
              end.publish(context)
            }
          })
        }
      }
      function tracingChannel(nameOrChannels) {
        return new TracingChannel(nameOrChannels)
      }
      dc.tracingChannel = tracingChannel
      return dc
    }
  },
})

// node_modules/dc-polyfill/patch-sync-unsubscribe-bug.js
var require_patch_sync_unsubscribe_bug = __commonJS({
  'node_modules/dc-polyfill/patch-sync-unsubscribe-bug.js'(exports2, module2) {
    module2.exports = function (unpatched) {
      const channels = /* @__PURE__ */ new WeakSet()
      const dc_channel = unpatched.channel
      const dc = { ...unpatched }
      dc.channel = function () {
        const ch = dc_channel.apply(this, arguments)
        if (channels.has(ch)) return ch
        const publish = ch.publish
        ch.publish = function () {
          if (!ch._subscribers) {
            ch._subscribers = []
          }
          return publish.apply(ch, arguments)
        }
        return ch
      }
      return dc
    }
  },
})

// node_modules/dc-polyfill/patch-tracing-channel-has-subscribers.js
var require_patch_tracing_channel_has_subscribers = __commonJS({
  'node_modules/dc-polyfill/patch-tracing-channel-has-subscribers.js'(exports2, module2) {
    var { ObjectDefineProperty, ObjectGetPrototypeOf } = require_primordials()
    module2.exports = function (unpatched) {
      const dc = { ...unpatched }
      {
        const fauxTrCh = dc.tracingChannel('dc-polyfill-faux')
        const protoTrCh = ObjectGetPrototypeOf(fauxTrCh)
        ObjectDefineProperty(protoTrCh, 'hasSubscribers', {
          get: function () {
            return (
              this.start.hasSubscribers ||
              this.end.hasSubscribers ||
              this.asyncStart.hasSubscribers ||
              this.asyncEnd.hasSubscribers ||
              this.error.hasSubscribers
            )
          },
          configurable: true,
        })
      }
      return dc
    }
  },
})

// node_modules/dc-polyfill/dc-polyfill.js
var require_dc_polyfill = __commonJS({
  'node_modules/dc-polyfill/dc-polyfill.js'(exports2, module2) {
    var checks = require_checks()
    require_primordials()
    var dc = checks.hasDiagnosticsChannel() ? require('diagnostics_channel') : require_reimplementation()
    if (checks.hasGarbageCollectionBug()) {
      dc = require_patch_garbage_collection_bug()(dc)
    }
    if (!checks.hasTopSubscribeUnsubscribe()) {
      dc = require_patch_top_subscribe_unsubscribe()(dc)
    }
    if (!checks.hasChUnsubscribeReturn()) {
      dc = require_patch_channel_unsubscribe_return()(dc)
    }
    if (!checks.hasChannelStoreMethods()) {
      dc = require_patch_channel_store_methods()(dc)
    }
    if (!checks.hasTracingChannel()) {
      dc = require_patch_tracing_channel()(dc)
    }
    if (checks.hasSyncUnsubscribeBug()) {
      dc = require_patch_sync_unsubscribe_bug()(dc)
    }
    if (!checks.hasTracingChannelHasSubscribers()) {
      dc = require_patch_tracing_channel_has_subscribers()(dc)
    }
    module2.exports = dc
  },
})

// node_modules/dd-trace/packages/dd-trace/src/log/channels.js
var require_channels = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/log/channels.js'(exports2, module2) {
    'use strict'
    var { channel } = require_dc_polyfill()
    var Level = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      critical: 50,
      off: 100,
    }
    var traceChannel = channel('datadog:log:trace')
    var debugChannel = channel('datadog:log:debug')
    var infoChannel = channel('datadog:log:info')
    var warnChannel = channel('datadog:log:warn')
    var errorChannel = channel('datadog:log:error')
    var defaultLevel = Level.debug
    function getChannelLogLevel(level) {
      return level && typeof level === 'string' ? Level[level.toLowerCase().trim()] || defaultLevel : defaultLevel
    }
    var LogChannel = class {
      constructor(level) {
        this._level = getChannelLogLevel(level)
      }
      subscribe(logger) {
        if (Level.trace >= this._level) {
          traceChannel.subscribe(logger.trace)
        }
        if (Level.debug >= this._level) {
          debugChannel.subscribe(logger.debug)
        }
        if (Level.info >= this._level) {
          infoChannel.subscribe(logger.info)
        }
        if (Level.warn >= this._level) {
          warnChannel.subscribe(logger.warn)
        }
        if (Level.error >= this._level) {
          errorChannel.subscribe(logger.error)
        }
      }
      unsubscribe(logger) {
        if (traceChannel.hasSubscribers) {
          traceChannel.unsubscribe(logger.trace)
        }
        if (debugChannel.hasSubscribers) {
          debugChannel.unsubscribe(logger.debug)
        }
        if (infoChannel.hasSubscribers) {
          infoChannel.unsubscribe(logger.info)
        }
        if (warnChannel.hasSubscribers) {
          warnChannel.unsubscribe(logger.warn)
        }
        if (errorChannel.hasSubscribers) {
          errorChannel.unsubscribe(logger.error)
        }
      }
    }
    module2.exports = {
      LogChannel,
      traceChannel,
      debugChannel,
      infoChannel,
      warnChannel,
      errorChannel,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/log/log.js
var require_log = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/log/log.js'(exports2, module2) {
    'use strict'
    var { format } = require('util')
    var NoTransmitError = class extends Error {}
    var Log = class _Log {
      constructor(message, args, cause, delegate, sendViaTelemetry = true) {
        this.message = message
        this.args = args
        this.cause = cause
        this.delegate = delegate
        this.sendViaTelemetry = sendViaTelemetry
      }
      get formatted() {
        const { message, args } = this
        let formatted = message
        if (message && args && args.length) {
          formatted = format(message, ...args)
        }
        return formatted
      }
      static parse(...args) {
        let message, cause, delegate
        let sendViaTelemetry = true
        const maybeLogConfig = args.at(-1)
        if (maybeLogConfig instanceof LogConfig) {
          args.pop()
          sendViaTelemetry = maybeLogConfig.transmit
        }
        const maybeError = args.at(-1)
        if (maybeError && typeof maybeError === 'object' && maybeError.stack) {
          cause = args.pop()
          if (cause instanceof NoTransmitError) sendViaTelemetry = false
        }
        const firstArg = args.shift()
        if (firstArg) {
          if (typeof firstArg === 'string') {
            message = firstArg
          } else if (typeof firstArg === 'object') {
            message = String(firstArg.message || firstArg)
          } else if (typeof firstArg === 'function') {
            delegate = firstArg
          } else {
            message = String(firstArg)
          }
        } else if (!cause) {
          message = String(firstArg)
        }
        return new _Log(message, args, cause, delegate, sendViaTelemetry)
      }
    }
    var LogConfig = class {
      constructor(transmit = true) {
        this.transmit = transmit
      }
    }
    module2.exports = {
      Log,
      LogConfig,
      NoTransmitError,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/log/writer.js
var require_writer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/log/writer.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var { LogChannel } = require_channels()
    var { Log } = require_log()
    var defaultLogger = {
      debug: (msg) => console.debug(msg),
      /* eslint-disable-line no-console */
      info: (msg) => console.info(msg),
      /* eslint-disable-line no-console */
      warn: (msg) => console.warn(msg),
      /* eslint-disable-line no-console */
      error: (msg) => console.error(msg),
      /* eslint-disable-line no-console */
    }
    var enabled = false
    var logger = defaultLogger
    var logChannel = new LogChannel()
    var stackTraceLimitFunction = onError
    function withNoop(fn) {
      const store = storage('legacy').getStore()
      storage('legacy').enterWith({ noop: true })
      fn()
      storage('legacy').enterWith(store)
    }
    function unsubscribeAll() {
      logChannel.unsubscribe({ trace: onTrace, debug: onDebug, info: onInfo, warn: onWarn, error: onError })
    }
    function toggleSubscription(enable, level) {
      unsubscribeAll()
      if (enable) {
        logChannel = new LogChannel(level)
        logChannel.subscribe({ trace: onTrace, debug: onDebug, info: onInfo, warn: onWarn, error: onError })
      }
    }
    function toggle(enable, level) {
      enabled = enable
      toggleSubscription(enabled, level)
    }
    function use(newLogger) {
      if (typeof newLogger?.debug === 'function' && typeof newLogger.error === 'function') {
        logger = newLogger
      }
    }
    function reset() {
      logger = defaultLogger
      enabled = false
      toggleSubscription(false)
    }
    function getErrorLog(err) {
      if (typeof err?.delegate === 'function') {
        const result = err.delegate()
        return Array.isArray(result) ? Log.parse(...result) : Log.parse(result)
      }
      return err
    }
    function setStackTraceLimitFunction(fn) {
      if (typeof fn !== 'function') {
        throw new TypeError('stackTraceLimitFunction must be a function')
      }
      stackTraceLimitFunction = fn
    }
    function onError(err) {
      const { formatted, cause } = getErrorLog(err)
      if (formatted) {
        withNoop(() => {
          const stackTraceLimitBackup = Error.stackTraceLimit
          Error.stackTraceLimit = 0
          const newError = new Error(formatted)
          Error.stackTraceLimit = stackTraceLimitBackup
          Error.captureStackTrace(newError, stackTraceLimitFunction)
          logger.error(newError)
        })
      }
      if (cause) withNoop(() => logger.error(cause))
    }
    function onWarn(log) {
      const { formatted, cause } = getErrorLog(log)
      if (formatted) withNoop(() => logger.warn(formatted))
      if (cause) withNoop(() => logger.warn(cause))
    }
    function onInfo(log) {
      const { formatted, cause } = getErrorLog(log)
      if (formatted) withNoop(() => logger.info(formatted))
      if (cause) withNoop(() => logger.info(cause))
    }
    function onDebug(log) {
      const { formatted, cause } = getErrorLog(log)
      if (formatted) withNoop(() => logger.debug(formatted))
      if (cause) withNoop(() => logger.debug(cause))
    }
    function onTrace(log) {
      const { formatted, cause } = getErrorLog(log)
      if (formatted) withNoop(() => logger.debug(formatted))
      if (cause) withNoop(() => logger.debug(cause))
    }
    function error(...args) {
      onError(Log.parse(...args))
    }
    function warn(...args) {
      const log = Log.parse(...args)
      if (!logger.warn) return onDebug(log)
      onWarn(log)
    }
    function info(...args) {
      const log = Log.parse(...args)
      if (!logger.info) return onDebug(log)
      onInfo(log)
    }
    function debug(...args) {
      onDebug(Log.parse(...args))
    }
    function trace(...args) {
      onTrace(Log.parse(...args))
    }
    module2.exports = { use, toggle, reset, error, warn, info, debug, trace, setStackTraceLimitFunction }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/log/utils.js
var require_utils = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/log/utils.js'(exports2, module2) {
    'use strict'
    var memoize = (func) => {
      const cache = {}
      const memoized = function (key) {
        if (!cache[key]) {
          cache[key] = func.apply(this, arguments)
        }
        return cache[key]
      }
      return memoized
    }
    module2.exports = { memoize }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/log/index.js
var require_log2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/log/index.js'(exports2, module2) {
    'use strict'
    var { inspect } = require('util')
    var { isTrue } = require_util()
    var { traceChannel, debugChannel, infoChannel, warnChannel, errorChannel } = require_channels()
    var logWriter = require_writer()
    var { Log, LogConfig, NoTransmitError } = require_log()
    var { memoize } = require_utils()
    var { getEnvironmentVariable } = require_config_helper()
    var config = {
      enabled: false,
      logger: void 0,
      logLevel: 'debug',
    }
    var NO_TRANSMIT = new LogConfig(false)
    var log = {
      LogConfig,
      NO_TRANSMIT,
      NoTransmitError,
      /**
       * @returns Read-only version of logging config. To modify config, call `log.use` and `log.toggle`
       */
      getConfig() {
        return { ...config }
      },
      use(logger) {
        config.logger = logger
        logWriter.use(logger)
        return this
      },
      toggle(enabled, logLevel) {
        config.enabled = enabled
        config.logLevel = logLevel
        logWriter.toggle(enabled, logLevel)
        return this
      },
      reset() {
        logWriter.reset()
        this._deprecate = memoize((code, message) => {
          errorChannel.publish(Log.parse(message))
          return true
        })
        return this
      },
      trace(...args) {
        if (traceChannel.hasSubscribers) {
          const logRecord = {}
          Error.captureStackTrace(logRecord, this.trace)
          const stack = logRecord.stack.split('\n')
          const fn = stack[1].replace(/^\s+at ([^\s]+) .+/, '$1')
          const options = { depth: 2, breakLength: Infinity, compact: true, maxArrayLength: Infinity }
          const params = args.map((a) => inspect(a, options)).join(', ')
          stack[0] = `Trace: ${fn}(${params})`
          traceChannel.publish(Log.parse(stack.join('\n')))
        }
        return this
      },
      debug(...args) {
        if (debugChannel.hasSubscribers) {
          debugChannel.publish(Log.parse(...args))
        }
        return this
      },
      info(...args) {
        if (infoChannel.hasSubscribers) {
          infoChannel.publish(Log.parse(...args))
        }
        return this
      },
      warn(...args) {
        if (warnChannel.hasSubscribers) {
          warnChannel.publish(Log.parse(...args))
        }
        return this
      },
      error(...args) {
        if (errorChannel.hasSubscribers) {
          errorChannel.publish(Log.parse(...args))
        }
        return this
      },
      errorWithoutTelemetry(...args) {
        args.push(NO_TRANSMIT)
        if (errorChannel.hasSubscribers) {
          errorChannel.publish(Log.parse(...args))
        }
        return this
      },
      deprecate(code, message) {
        return this._deprecate(code, message)
      },
      isEnabled(fleetStableConfigValue, localStableConfigValue) {
        return isTrue(
          fleetStableConfigValue ??
            getEnvironmentVariable('DD_TRACE_DEBUG') ??
            (getEnvironmentVariable('OTEL_LOG_LEVEL') === 'debug' || void 0) ??
            localStableConfigValue ??
            config.enabled
        )
      },
      getLogLevel(optionsValue, fleetStableConfigValue, localStableConfigValue) {
        return (
          optionsValue ??
          fleetStableConfigValue ??
          getEnvironmentVariable('DD_TRACE_LOG_LEVEL') ??
          getEnvironmentVariable('OTEL_LOG_LEVEL') ??
          localStableConfigValue ??
          config.logLevel
        )
      },
    }
    logWriter.setStackTraceLimitFunction(log.error)
    log.reset()
    log.toggle(log.isEnabled(), log.getLogLevel())
    module2.exports = log
  },
})

// node_modules/dd-trace/packages/dd-trace/src/tagger.js
var require_tagger = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/tagger.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    function addNonEmpty(carrier, key, value) {
      if (key !== '') {
        carrier[key] = value
      }
    }
    function add(carrier, keyValuePairs) {
      if (!carrier) return
      try {
        if (typeof keyValuePairs === 'string') {
          let valueStart = 0
          let keyStart = 0
          for (let i = 0; i < keyValuePairs.length; i++) {
            const char = keyValuePairs[i]
            if (char === ':') {
              if (valueStart === 0) {
                valueStart = i
              }
            } else if (char === ',') {
              valueStart ||= i
              addNonEmpty(
                carrier,
                keyValuePairs.slice(keyStart, valueStart).trim(),
                keyValuePairs.slice(valueStart + 1, i).trim()
              )
              keyStart = i + 1
              valueStart = 0
            }
          }
          if (keyValuePairs.at(-1) !== ',') {
            valueStart ||= keyValuePairs.length
            addNonEmpty(
              carrier,
              keyValuePairs.slice(keyStart, valueStart).trim(),
              keyValuePairs.slice(valueStart + 1).trim()
            )
          }
        } else if (Array.isArray(keyValuePairs)) {
          return keyValuePairs.forEach((tags) => add(carrier, tags))
        } else {
          Object.assign(carrier, keyValuePairs)
        }
      } catch (error) {
        log.error('Error adding tags', error)
      }
    }
    module2.exports = { add }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/url-to-http-options-polyfill.js
var require_url_to_http_options_polyfill = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/url-to-http-options-polyfill.js'(exports2, module2) {
    'use strict'
    var { urlToHttpOptions } = require('url')
    module2.exports = {
      urlToHttpOptions:
        urlToHttpOptions ??
        function (url) {
          const { hostname, pathname, port, username, password, search } = url
          const options = {
            __proto__: null,
            ...url,
            // In case the url object was extended by the user.
            protocol: url.protocol,
            hostname: typeof hostname === 'string' && hostname.startsWith('[') ? hostname.slice(1, -1) : hostname,
            hash: url.hash,
            search,
            pathname,
            path: `${pathname || ''}${search || ''}`,
            href: url.href,
          }
          if (port !== '') {
            options.port = Number(port)
          }
          if (username || password) {
            options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`
          }
          return options
        },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js
var require_docker = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var { getEnvironmentVariable } = require_config_helper()
    var DD_EXTERNAL_ENV = getEnvironmentVariable('DD_EXTERNAL_ENV')
    var uuidSource =
      '[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}|[0-9a-f]{8}(?:-[0-9a-f]{4}){4}$'
    var containerSource = '[0-9a-f]{64}'
    var taskSource = String.raw`[0-9a-f]{32}-\d+`
    var lineReg = /^(\d+):([^:]*):(.+)$/m
    var entityReg = new RegExp(String.raw`.*(${uuidSource}|${containerSource}|${taskSource})(?:\.scope)?$`, 'm')
    var inode = 0
    var cgroup = ''
    var entityId
    try {
      cgroup = fs.readFileSync('/proc/self/cgroup', 'utf8').trim()
      entityId = cgroup.match(entityReg)?.[1]
    } catch {}
    var inodePath = cgroup.match(lineReg)?.[3]
    if (inodePath) {
      const strippedPath = inodePath.replaceAll(/^\/|\/$/g, '')
      try {
        inode = fs.statSync(`/sys/fs/cgroup/${strippedPath}`).ino
      } catch {}
    }
    module2.exports = {
      inject(carrier) {
        if (entityId) {
          carrier['Datadog-Container-Id'] = entityId
          carrier['Datadog-Entity-ID'] = `ci-${entityId}`
        } else if (inode) {
          carrier['Datadog-Entity-ID'] = `in-${inode}`
        }
        if (DD_EXTERNAL_ENV) {
          carrier['Datadog-External-Env'] = DD_EXTERNAL_ENV
        }
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/agents.js
var require_agents = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/agents.js'(exports2, module2) {
    'use strict'
    var http = require('http')
    var https = require('https')
    var { storage } = require_datadog_core()
    var keepAlive = true
    var maxSockets = 1
    function createAgentClass(BaseAgent) {
      class CustomAgent extends BaseAgent {
        constructor() {
          super({ keepAlive, maxSockets })
        }
        createConnection(...args) {
          return this._noop(() => super.createConnection(...args))
        }
        keepSocketAlive(...args) {
          return this._noop(() => super.keepSocketAlive(...args))
        }
        reuseSocket(...args) {
          return this._noop(() => super.reuseSocket(...args))
        }
        _noop(callback) {
          return storage('legacy').run({ noop: true }, callback)
        }
      }
      return CustomAgent
    }
    var HttpAgent = createAgentClass(http.Agent)
    var HttpsAgent = createAgentClass(https.Agent)
    module2.exports = {
      httpAgent: new HttpAgent(),
      HttpsAgent: new HttpsAgent(),
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js
var require_request = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js'(exports2, module2) {
    'use strict'
    var { Readable } = require('stream')
    var http = require('http')
    var https = require('https')
    var zlib = require('zlib')
    var { urlToHttpOptions } = require_url_to_http_options_polyfill()
    var docker = require_docker()
    var { httpAgent, httpsAgent } = require_agents()
    var { storage } = require_datadog_core()
    var log = require_log2()
    var maxActiveRequests = 8
    var activeRequests = 0
    function parseUrl(urlObjOrString) {
      if (urlObjOrString !== null && typeof urlObjOrString === 'object') return urlToHttpOptions(urlObjOrString)
      const url = urlToHttpOptions(new URL(urlObjOrString))
      if (url.protocol === 'unix:' && url.hostname === '.') {
        const udsPath = urlObjOrString.slice(5)
        url.path = udsPath
        url.pathname = udsPath
      }
      return url
    }
    function request(data, options, callback) {
      if (!options.headers) {
        options.headers = {}
      }
      if (options.url) {
        const url = parseUrl(options.url)
        if (url.protocol === 'unix:') {
          options.socketPath = url.pathname
        } else {
          if (!options.path) options.path = url.path
          options.protocol = url.protocol
          options.hostname = url.hostname
          options.port = url.port
        }
      }
      const isReadable = data instanceof Readable
      const timeout = options.timeout || 2e3
      const isSecure = options.protocol === 'https:'
      const client = isSecure ? https : http
      let dataArray = data
      if (!isReadable) {
        if (!Array.isArray(data)) {
          dataArray = [data]
        }
        options.headers['Content-Length'] = byteLength(dataArray)
      }
      docker.inject(options.headers)
      options.agent = isSecure ? httpsAgent : httpAgent
      const onResponse = (res) => {
        const chunks = []
        res.setTimeout(timeout)
        res.on('data', (chunk) => {
          chunks.push(chunk)
        })
        res.on('end', () => {
          activeRequests--
          const buffer = Buffer.concat(chunks)
          if (res.statusCode >= 200 && res.statusCode <= 299) {
            const isGzip = res.headers['content-encoding'] === 'gzip'
            if (isGzip) {
              zlib.gunzip(buffer, (err, result) => {
                if (err) {
                  log.error('Could not gunzip response: %s', err.message)
                  callback(null, '', res.statusCode)
                } else {
                  callback(null, result.toString(), res.statusCode)
                }
              })
            } else {
              callback(null, buffer.toString(), res.statusCode)
            }
          } else {
            let errorMessage = ''
            try {
              const fullUrl = new URL(
                options.path,
                options.url || options.hostname || `http://localhost:${options.port}`
              ).href
              errorMessage = `Error from ${fullUrl}: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}.`
            } catch {}
            const responseData = buffer.toString()
            if (responseData) {
              errorMessage += ` Response from the endpoint: "${responseData}"`
            }
            const error = new log.NoTransmitError(errorMessage)
            error.status = res.statusCode
            callback(error, null, res.statusCode)
          }
        })
      }
      const makeRequest = (onError) => {
        if (!request.writable) {
          log.debug('Maximum number of active requests reached: payload is discarded.')
          return callback(null)
        }
        activeRequests++
        const store = storage('legacy').getStore()
        storage('legacy').enterWith({ noop: true })
        const req = client.request(options, onResponse)
        req.once('error', (err) => {
          activeRequests--
          onError(err)
        })
        req.setTimeout(timeout, req.abort)
        if (isReadable) {
          data.pipe(req)
        } else {
          dataArray.forEach((buffer) => req.write(buffer))
          req.end()
        }
        storage('legacy').enterWith(store)
      }
      makeRequest(() => setTimeout(() => makeRequest(callback)))
    }
    function byteLength(data) {
      return data.length > 0 ? data.reduce((prev, next) => prev + Buffer.byteLength(next, 'utf8'), 0) : 0
    }
    Object.defineProperty(request, 'writable', {
      get() {
        return activeRequests < maxActiveRequests
      },
    })
    module2.exports = request
  },
})

// node_modules/dd-trace/vendor/dist/@datadog/sketches-js/index.js
var require_sketches_js = __commonJS({
  'node_modules/dd-trace/vendor/dist/@datadog/sketches-js/index.js'(exports, module) {
    ;(() => {
      'use strict'
      var __webpack_modules__ = {
          './@datadog/sketches-js/dist/ddsketch/DDSketch.js': function (t, e, n) {
            var i =
              (this && this.__extends) ||
              /* @__PURE__ */ (function () {
                var t2 = function (e2, n2) {
                  return (t2 =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                      function (t3, e3) {
                        t3.__proto__ = e3
                      }) ||
                    function (t3, e3) {
                      for (var n3 in e3) Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3])
                    })(e2, n2)
                }
                return function (e2, n2) {
                  if ('function' != typeof n2 && null !== n2)
                    throw TypeError('Class extends value ' + String(n2) + ' is not a constructor or null')
                  function i2() {
                    this.constructor = e2
                  }
                  ;(t2(e2, n2),
                    (e2.prototype = null === n2 ? Object.create(n2) : ((i2.prototype = n2.prototype), new i2())))
                }
              })()
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              (e.LogCollapsingHighestDenseDDSketch = e.LogCollapsingLowestDenseDDSketch = e.DDSketch = void 0))
            var o = n('./@datadog/sketches-js/dist/ddsketch/store/index.js'),
              r = n('./@datadog/sketches-js/dist/ddsketch/mapping/index.js'),
              s = 0.01,
              u = 2048,
              a = (function () {
                function t2(t3) {
                  var e2 = t3.mapping,
                    n2 = t3.store,
                    i2 = t3.negativeStore,
                    o2 = t3.zeroCount
                  ;((this.mapping = e2),
                    (this.store = n2),
                    (this.negativeStore = i2),
                    (this.zeroCount = o2),
                    (this.count = this.negativeStore.count + this.zeroCount + this.store.count),
                    (this.min = 1 / 0),
                    (this.max = -1 / 0),
                    (this.sum = 0))
                }
                return (
                  (t2.prototype.accept = function (t3, e2) {
                    if ((void 0 === e2 && (e2 = 1), e2 <= 0)) throw Error('Weight must be a positive number')
                    if (t3 > this.mapping.minPossible) {
                      var n2 = this.mapping.key(t3)
                      this.store.add(n2, e2)
                    } else if (t3 < -this.mapping.minPossible) {
                      var n2 = this.mapping.key(-t3)
                      this.negativeStore.add(n2, e2)
                    } else this.zeroCount += e2
                    ;((this.count += e2),
                      (this.sum += t3 * e2),
                      t3 < this.min && (this.min = t3),
                      t3 > this.max && (this.max = t3))
                  }),
                  (t2.prototype.getValueAtQuantile = function (t3) {
                    if (t3 < 0 || t3 > 1 || 0 === this.count) return NaN
                    var e2 = t3 * (this.count - 1),
                      n2 = 0
                    if (e2 < this.negativeStore.count) {
                      var i2 = this.negativeStore.count - e2 - 1,
                        o2 = this.negativeStore.keyAtRank(i2, false)
                      n2 = -this.mapping.value(o2)
                    } else {
                      if (e2 < this.zeroCount + this.negativeStore.count) return 0
                      var o2 = this.store.keyAtRank(e2 - this.zeroCount - this.negativeStore.count)
                      n2 = this.mapping.value(o2)
                    }
                    return n2
                  }),
                  (t2.prototype.merge = function (t3) {
                    if (!this.mergeable(t3))
                      throw Error('Cannot merge two DDSketches with different `relativeAccuracy` parameters')
                    if (0 !== t3.count) {
                      if (0 === this.count) return void this._copy(t3)
                      ;(this.store.merge(t3.store),
                        (this.zeroCount += t3.zeroCount),
                        (this.count += t3.count),
                        (this.sum += t3.sum),
                        t3.min < this.min && (this.min = t3.min),
                        t3.max > this.max && (this.max = t3.max))
                    }
                  }),
                  (t2.prototype.mergeable = function (t3) {
                    return this.mapping.gamma === t3.mapping.gamma
                  }),
                  (t2.prototype._copy = function (t3) {
                    ;(this.store.copy(t3.store),
                      this.negativeStore.copy(t3.negativeStore),
                      (this.zeroCount = t3.zeroCount),
                      (this.min = t3.min),
                      (this.max = t3.max),
                      (this.count = t3.count),
                      (this.sum = t3.sum))
                  }),
                  (t2.prototype.toProto = function () {
                    var t3 = n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').DDSketch,
                      e2 = t3.create({
                        mapping: this.mapping.toProto(),
                        positiveValues: this.store.toProto(),
                        negativeValues: this.negativeStore.toProto(),
                        zeroCount: this.zeroCount,
                      })
                    return t3.encode(e2).finish()
                  }),
                  (t2.fromProto = function (e2) {
                    var i2 = n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').DDSketch.decode(e2)
                    return new t2({
                      mapping: r.KeyMapping.fromProto(i2.mapping),
                      store: o.DenseStore.fromProto(i2.positiveValues),
                      negativeStore: o.DenseStore.fromProto(i2.negativeValues),
                      zeroCount: i2.zeroCount,
                    })
                  }),
                  t2
                )
              })(),
              f = { relativeAccuracy: s }
            ;((e.DDSketch = (function (t2) {
              function e2(e3) {
                var n2 = (void 0 === e3 ? f : e3).relativeAccuracy,
                  i2 = void 0 === n2 ? s : n2,
                  u2 = new r.LogarithmicMapping(i2),
                  a2 = new o.DenseStore(),
                  c = new o.DenseStore()
                return t2.call(this, { mapping: u2, store: a2, negativeStore: c, zeroCount: 0 }) || this
              }
              return (i(e2, t2), e2)
            })(a)),
              (e.LogCollapsingLowestDenseDDSketch = (function (t2) {
                function e2(e3) {
                  var n2 = void 0 === e3 ? f : e3,
                    i2 = n2.relativeAccuracy,
                    a2 = void 0 === i2 ? s : i2,
                    c = n2.binLimit,
                    p = void 0 === c ? u : c,
                    l = new r.LogarithmicMapping(a2),
                    h = new o.CollapsingLowestDenseStore(p),
                    d = new o.CollapsingLowestDenseStore(p)
                  return t2.call(this, { mapping: l, store: h, negativeStore: d, zeroCount: 0 }) || this
                }
                return (i(e2, t2), e2)
              })(a)),
              (e.LogCollapsingHighestDenseDDSketch = (function (t2) {
                function e2(e3) {
                  var n2 = void 0 === e3 ? f : e3,
                    i2 = n2.relativeAccuracy,
                    a2 = void 0 === i2 ? s : i2,
                    c = n2.binLimit,
                    p = void 0 === c ? u : c,
                    l = new r.LogarithmicMapping(a2),
                    h = new o.CollapsingHighestDenseStore(p),
                    d = new o.CollapsingHighestDenseStore(p)
                  return t2.call(this, { mapping: l, store: h, negativeStore: d, zeroCount: 0 }) || this
                }
                return (i(e2, t2), e2)
              })(a)))
          },
          './@datadog/sketches-js/dist/ddsketch/index.js': function (t, e, n) {
            var i =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (t2, e2, n2, i2) {
                      void 0 === i2 && (i2 = n2)
                      var o2 = Object.getOwnPropertyDescriptor(e2, n2)
                      ;((!o2 || ('get' in o2 ? !e2.__esModule : o2.writable || o2.configurable)) &&
                        (o2 = {
                          enumerable: true,
                          get: function () {
                            return e2[n2]
                          },
                        }),
                        Object.defineProperty(t2, i2, o2))
                    }
                  : function (t2, e2, n2, i2) {
                      ;(void 0 === i2 && (i2 = n2), (t2[i2] = e2[n2]))
                    }),
              o =
                (this && this.__exportStar) ||
                function (t2, e2) {
                  for (var n2 in t2) 'default' === n2 || Object.prototype.hasOwnProperty.call(e2, n2) || i(e2, t2, n2)
                }
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              o(n('./@datadog/sketches-js/dist/ddsketch/DDSketch.js'), e))
          },
          './@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js': function (t, e, n) {
            var i =
              (this && this.__extends) ||
              /* @__PURE__ */ (function () {
                var t2 = function (e2, n2) {
                  return (t2 =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                      function (t3, e3) {
                        t3.__proto__ = e3
                      }) ||
                    function (t3, e3) {
                      for (var n3 in e3) Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3])
                    })(e2, n2)
                }
                return function (e2, n2) {
                  if ('function' != typeof n2 && null !== n2)
                    throw TypeError('Class extends value ' + String(n2) + ' is not a constructor or null')
                  function i2() {
                    this.constructor = e2
                  }
                  ;(t2(e2, n2),
                    (e2.prototype = null === n2 ? Object.create(n2) : ((i2.prototype = n2.prototype), new i2())))
                }
              })()
            ;(Object.defineProperty(e, '__esModule', { value: true }), (e.CubicallyInterpolatedMapping = void 0))
            var o = n('./@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js'),
              r = n('./@datadog/sketches-js/dist/ddsketch/math.js')
            e.CubicallyInterpolatedMapping = (function (t2) {
              function e2(e3, n2) {
                void 0 === n2 && (n2 = 0)
                var i2 = t2.call(this, e3, n2) || this
                return ((i2.A = 6 / 35), (i2.B = -0.6), (i2.C = 10 / 7), (i2._multiplier /= i2.C), i2)
              }
              return (
                i(e2, t2),
                (e2.prototype._cubicLog2Approx = function (t3) {
                  var e3 = (0, r.frexp)(t3),
                    n2 = e3[0],
                    i2 = e3[1],
                    o2 = 2 * n2 - 1
                  return ((this.A * o2 + this.B) * o2 + this.C) * o2 + (i2 - 1)
                }),
                (e2.prototype._cubicExp2Approx = function (t3) {
                  var e3 = Math.floor(t3),
                    n2 = this.B * this.B - 3 * this.A * this.C,
                    i2 = 2 * this.B * this.B * this.B - 9 * this.A * this.B * this.C - 27 * this.A * this.A * (t3 - e3),
                    o2 = Math.cbrt((i2 - Math.sqrt(i2 * i2 - 4 * n2 * n2 * n2)) / 2),
                    s = (-(this.B + o2 + n2 / o2) / (3 * this.A) + 1) / 2
                  return (0, r.ldexp)(s, e3 + 1)
                }),
                (e2.prototype._logGamma = function (t3) {
                  return this._cubicLog2Approx(t3) * this._multiplier
                }),
                (e2.prototype._powGamma = function (t3) {
                  return this._cubicExp2Approx(t3 / this._multiplier)
                }),
                (e2.prototype._protoInterpolation = function () {
                  return n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').IndexMapping.Interpolation.CUBIC
                }),
                e2
              )
            })(o.KeyMapping)
          },
          './@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js': function (t, e, n) {
            ;(Object.defineProperty(e, '__esModule', { value: true }), (e.KeyMapping = void 0))
            var i = n('./@datadog/sketches-js/dist/ddsketch/mapping/index.js'),
              o = 11125369292536007e-324,
              r = Number.MAX_VALUE
            e.KeyMapping = (function () {
              function t2(t3, e2) {
                if ((void 0 === e2 && (e2 = 0), t3 <= 0 || t3 >= 1))
                  throw Error('Relative accuracy must be between 0 and 1 when initializing a KeyMapping')
                ;((this.relativeAccuracy = t3), (this._offset = e2))
                var n2 = (2 * t3) / (1 - t3)
                ;((this.gamma = 1 + n2),
                  (this._multiplier = 1 / Math.log1p(n2)),
                  (this.minPossible = o * this.gamma),
                  (this.maxPossible = r / this.gamma))
              }
              return (
                (t2.fromGammaOffset = function (t3, e2) {
                  return new this((t3 - 1) / (t3 + 1), e2)
                }),
                (t2.prototype.key = function (t3) {
                  return Math.ceil(this._logGamma(t3)) + this._offset
                }),
                (t2.prototype.value = function (t3) {
                  return this._powGamma(t3 - this._offset) * (2 / (1 + this.gamma))
                }),
                (t2.prototype.toProto = function () {
                  return n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').IndexMapping.create({
                    gamma: this.gamma,
                    indexOffset: this._offset,
                    interpolation: this._protoInterpolation(),
                  })
                }),
                (t2.fromProto = function (t3) {
                  if (!t3 || null == t3.gamma || null == t3.indexOffset)
                    throw Error('Failed to decode mapping from protobuf')
                  var e2 = n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').IndexMapping.Interpolation,
                    o2 = t3.interpolation,
                    r2 = t3.gamma,
                    s = t3.indexOffset
                  switch (o2) {
                    case e2.NONE:
                      return i.LogarithmicMapping.fromGammaOffset(r2, s)
                    case e2.LINEAR:
                      return i.LinearlyInterpolatedMapping.fromGammaOffset(r2, s)
                    case e2.CUBIC:
                      return i.CubicallyInterpolatedMapping.fromGammaOffset(r2, s)
                    default:
                      throw Error('Unrecognized mapping when decoding from protobuf')
                  }
                }),
                (t2.prototype._logGamma = function (t3) {
                  return Math.log2(t3) * this._multiplier
                }),
                (t2.prototype._powGamma = function (t3) {
                  return Math.pow(2, t3 / this._multiplier)
                }),
                (t2.prototype._protoInterpolation = function () {
                  return n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').IndexMapping.Interpolation.NONE
                }),
                t2
              )
            })()
          },
          './@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js': function (t, e, n) {
            var i =
              (this && this.__extends) ||
              /* @__PURE__ */ (function () {
                var t2 = function (e2, n2) {
                  return (t2 =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                      function (t3, e3) {
                        t3.__proto__ = e3
                      }) ||
                    function (t3, e3) {
                      for (var n3 in e3) Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3])
                    })(e2, n2)
                }
                return function (e2, n2) {
                  if ('function' != typeof n2 && null !== n2)
                    throw TypeError('Class extends value ' + String(n2) + ' is not a constructor or null')
                  function i2() {
                    this.constructor = e2
                  }
                  ;(t2(e2, n2),
                    (e2.prototype = null === n2 ? Object.create(n2) : ((i2.prototype = n2.prototype), new i2())))
                }
              })()
            ;(Object.defineProperty(e, '__esModule', { value: true }), (e.LinearlyInterpolatedMapping = void 0))
            var o = n('./@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js'),
              r = n('./@datadog/sketches-js/dist/ddsketch/math.js')
            e.LinearlyInterpolatedMapping = (function (t2) {
              function e2(e3, n2) {
                return (void 0 === n2 && (n2 = 0), t2.call(this, e3, n2) || this)
              }
              return (
                i(e2, t2),
                (e2.prototype._log2Approx = function (t3) {
                  var e3 = (0, r.frexp)(t3)
                  return 2 * e3[0] - 1 + (e3[1] - 1)
                }),
                (e2.prototype._exp2Approx = function (t3) {
                  var e3 = Math.floor(t3) + 1,
                    n2 = (t3 - e3 + 2) / 2
                  return (0, r.ldexp)(n2, e3)
                }),
                (e2.prototype._logGamma = function (t3) {
                  return Math.log2(t3) * this._multiplier
                }),
                (e2.prototype._powGamma = function (t3) {
                  return Math.pow(2, t3 / this._multiplier)
                }),
                (e2.prototype._protoInterpolation = function () {
                  return n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').IndexMapping.Interpolation.LINEAR
                }),
                e2
              )
            })(o.KeyMapping)
          },
          './@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js': function (t, e, n) {
            var i =
              (this && this.__extends) ||
              /* @__PURE__ */ (function () {
                var t2 = function (e2, n2) {
                  return (t2 =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                      function (t3, e3) {
                        t3.__proto__ = e3
                      }) ||
                    function (t3, e3) {
                      for (var n3 in e3) Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3])
                    })(e2, n2)
                }
                return function (e2, n2) {
                  if ('function' != typeof n2 && null !== n2)
                    throw TypeError('Class extends value ' + String(n2) + ' is not a constructor or null')
                  function i2() {
                    this.constructor = e2
                  }
                  ;(t2(e2, n2),
                    (e2.prototype = null === n2 ? Object.create(n2) : ((i2.prototype = n2.prototype), new i2())))
                }
              })()
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              (e.LogarithmicMapping = void 0),
              (e.LogarithmicMapping = (function (t2) {
                function e2(e3, n2) {
                  void 0 === n2 && (n2 = 0)
                  var i2 = t2.call(this, e3, n2) || this
                  return ((i2._multiplier *= Math.log(2)), i2)
                }
                return (
                  i(e2, t2),
                  (e2.prototype._logGamma = function (t3) {
                    return Math.log2(t3) * this._multiplier
                  }),
                  (e2.prototype._powGamma = function (t3) {
                    return Math.pow(2, t3 / this._multiplier)
                  }),
                  (e2.prototype._protoInterpolation = function () {
                    return n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').IndexMapping.Interpolation.NONE
                  }),
                  e2
                )
              })(n('./@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js').KeyMapping)))
          },
          './@datadog/sketches-js/dist/ddsketch/mapping/index.js': function (t, e, n) {
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              (e.CubicallyInterpolatedMapping =
                e.LinearlyInterpolatedMapping =
                e.LogarithmicMapping =
                e.KeyMapping =
                  void 0))
            var i = n('./@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js')
            Object.defineProperty(e, 'KeyMapping', {
              enumerable: true,
              get: function () {
                return i.KeyMapping
              },
            })
            var o = n('./@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js')
            Object.defineProperty(e, 'LogarithmicMapping', {
              enumerable: true,
              get: function () {
                return o.LogarithmicMapping
              },
            })
            var r = n('./@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js')
            Object.defineProperty(e, 'LinearlyInterpolatedMapping', {
              enumerable: true,
              get: function () {
                return r.LinearlyInterpolatedMapping
              },
            })
            var s = n('./@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js')
            Object.defineProperty(e, 'CubicallyInterpolatedMapping', {
              enumerable: true,
              get: function () {
                return s.CubicallyInterpolatedMapping
              },
            })
          },
          './@datadog/sketches-js/dist/ddsketch/math.js': function (t, e) {
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              (e.ldexp = e.frexp = void 0),
              (e.frexp = function (t2) {
                if (0 === t2 || !Number.isFinite(t2)) return [t2, 0]
                for (
                  var e2 = Math.abs(t2), n = Math.max(-1023, Math.floor(Math.log2(e2)) + 1), i = e2 * Math.pow(2, -n);
                  i < 0.5;
                )
                  ((i *= 2), n--)
                for (; i >= 1; ) ((i *= 0.5), n++)
                return (t2 < 0 && (i = -i), [i, n])
              }),
              (e.ldexp = function (t2, e2) {
                for (var n = Math.min(3, Math.ceil(Math.abs(e2) / 1023)), i = t2, o = 0; o < n; o++)
                  i *= Math.pow(2, Math.floor((e2 + o) / n))
                return i
              }))
          },
          './@datadog/sketches-js/dist/ddsketch/proto/compiled.js': function (t, e, n) {
            var i = n('./protobufjs/minimal.js'),
              o = i.Reader,
              r = i.Writer,
              s = i.util,
              u = i.roots.default || (i.roots.default = {})
            ;((u.DDSketch = (function () {
              function t2(t3) {
                if (t3)
                  for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                    null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]])
              }
              return (
                (t2.prototype.mapping = null),
                (t2.prototype.positiveValues = null),
                (t2.prototype.negativeValues = null),
                (t2.prototype.zeroCount = 0),
                (t2.create = function (e2) {
                  return new t2(e2)
                }),
                (t2.encode = function (t3, e2) {
                  return (
                    e2 || (e2 = r.create()),
                    null != t3.mapping &&
                      Object.hasOwnProperty.call(t3, 'mapping') &&
                      u.IndexMapping.encode(t3.mapping, e2.uint32(10).fork()).ldelim(),
                    null != t3.positiveValues &&
                      Object.hasOwnProperty.call(t3, 'positiveValues') &&
                      u.Store.encode(t3.positiveValues, e2.uint32(18).fork()).ldelim(),
                    null != t3.negativeValues &&
                      Object.hasOwnProperty.call(t3, 'negativeValues') &&
                      u.Store.encode(t3.negativeValues, e2.uint32(26).fork()).ldelim(),
                    null != t3.zeroCount &&
                      Object.hasOwnProperty.call(t3, 'zeroCount') &&
                      e2.uint32(33).double(t3.zeroCount),
                    e2
                  )
                }),
                (t2.encodeDelimited = function (t3, e2) {
                  return this.encode(t3, e2).ldelim()
                }),
                (t2.decode = function (t3, e2) {
                  t3 instanceof o || (t3 = o.create(t3))
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, i2 = new u.DDSketch(); t3.pos < n2; ) {
                    var r2 = t3.uint32()
                    switch (r2 >>> 3) {
                      case 1:
                        i2.mapping = u.IndexMapping.decode(t3, t3.uint32())
                        break
                      case 2:
                        i2.positiveValues = u.Store.decode(t3, t3.uint32())
                        break
                      case 3:
                        i2.negativeValues = u.Store.decode(t3, t3.uint32())
                        break
                      case 4:
                        i2.zeroCount = t3.double()
                        break
                      default:
                        t3.skipType(7 & r2)
                    }
                  }
                  return i2
                }),
                (t2.decodeDelimited = function (t3) {
                  return (t3 instanceof o || (t3 = new o(t3)), this.decode(t3, t3.uint32()))
                }),
                (t2.verify = function (t3) {
                  if ('object' != typeof t3 || null === t3) return 'object expected'
                  if (null != t3.mapping && t3.hasOwnProperty('mapping')) {
                    var e2 = u.IndexMapping.verify(t3.mapping)
                    if (e2) return 'mapping.' + e2
                  }
                  if (null != t3.positiveValues && t3.hasOwnProperty('positiveValues')) {
                    var e2 = u.Store.verify(t3.positiveValues)
                    if (e2) return 'positiveValues.' + e2
                  }
                  if (null != t3.negativeValues && t3.hasOwnProperty('negativeValues')) {
                    var e2 = u.Store.verify(t3.negativeValues)
                    if (e2) return 'negativeValues.' + e2
                  }
                  return null != t3.zeroCount && t3.hasOwnProperty('zeroCount') && 'number' != typeof t3.zeroCount
                    ? 'zeroCount: number expected'
                    : null
                }),
                (t2.fromObject = function (t3) {
                  if (t3 instanceof u.DDSketch) return t3
                  var e2 = new u.DDSketch()
                  if (null != t3.mapping) {
                    if ('object' != typeof t3.mapping) throw TypeError('.DDSketch.mapping: object expected')
                    e2.mapping = u.IndexMapping.fromObject(t3.mapping)
                  }
                  if (null != t3.positiveValues) {
                    if ('object' != typeof t3.positiveValues)
                      throw TypeError('.DDSketch.positiveValues: object expected')
                    e2.positiveValues = u.Store.fromObject(t3.positiveValues)
                  }
                  if (null != t3.negativeValues) {
                    if ('object' != typeof t3.negativeValues)
                      throw TypeError('.DDSketch.negativeValues: object expected')
                    e2.negativeValues = u.Store.fromObject(t3.negativeValues)
                  }
                  return (null != t3.zeroCount && (e2.zeroCount = Number(t3.zeroCount)), e2)
                }),
                (t2.toObject = function (t3, e2) {
                  e2 || (e2 = {})
                  var n2 = {}
                  return (
                    e2.defaults &&
                      ((n2.mapping = null), (n2.positiveValues = null), (n2.negativeValues = null), (n2.zeroCount = 0)),
                    null != t3.mapping &&
                      t3.hasOwnProperty('mapping') &&
                      (n2.mapping = u.IndexMapping.toObject(t3.mapping, e2)),
                    null != t3.positiveValues &&
                      t3.hasOwnProperty('positiveValues') &&
                      (n2.positiveValues = u.Store.toObject(t3.positiveValues, e2)),
                    null != t3.negativeValues &&
                      t3.hasOwnProperty('negativeValues') &&
                      (n2.negativeValues = u.Store.toObject(t3.negativeValues, e2)),
                    null != t3.zeroCount &&
                      t3.hasOwnProperty('zeroCount') &&
                      (n2.zeroCount = e2.json && !isFinite(t3.zeroCount) ? String(t3.zeroCount) : t3.zeroCount),
                    n2
                  )
                }),
                (t2.prototype.toJSON = function () {
                  return this.constructor.toObject(this, i.util.toJSONOptions)
                }),
                t2
              )
            })()),
              (u.IndexMapping = (function () {
                function t2(t3) {
                  if (t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]])
                }
                return (
                  (t2.prototype.gamma = 0),
                  (t2.prototype.indexOffset = 0),
                  (t2.prototype.interpolation = 0),
                  (t2.create = function (e2) {
                    return new t2(e2)
                  }),
                  (t2.encode = function (t3, e2) {
                    return (
                      e2 || (e2 = r.create()),
                      null != t3.gamma && Object.hasOwnProperty.call(t3, 'gamma') && e2.uint32(9).double(t3.gamma),
                      null != t3.indexOffset &&
                        Object.hasOwnProperty.call(t3, 'indexOffset') &&
                        e2.uint32(17).double(t3.indexOffset),
                      null != t3.interpolation &&
                        Object.hasOwnProperty.call(t3, 'interpolation') &&
                        e2.uint32(24).int32(t3.interpolation),
                      e2
                    )
                  }),
                  (t2.encodeDelimited = function (t3, e2) {
                    return this.encode(t3, e2).ldelim()
                  }),
                  (t2.decode = function (t3, e2) {
                    t3 instanceof o || (t3 = o.create(t3))
                    for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, i2 = new u.IndexMapping(); t3.pos < n2; ) {
                      var r2 = t3.uint32()
                      switch (r2 >>> 3) {
                        case 1:
                          i2.gamma = t3.double()
                          break
                        case 2:
                          i2.indexOffset = t3.double()
                          break
                        case 3:
                          i2.interpolation = t3.int32()
                          break
                        default:
                          t3.skipType(7 & r2)
                      }
                    }
                    return i2
                  }),
                  (t2.decodeDelimited = function (t3) {
                    return (t3 instanceof o || (t3 = new o(t3)), this.decode(t3, t3.uint32()))
                  }),
                  (t2.verify = function (t3) {
                    if ('object' != typeof t3 || null === t3) return 'object expected'
                    if (null != t3.gamma && t3.hasOwnProperty('gamma') && 'number' != typeof t3.gamma)
                      return 'gamma: number expected'
                    if (null != t3.indexOffset && t3.hasOwnProperty('indexOffset') && 'number' != typeof t3.indexOffset)
                      return 'indexOffset: number expected'
                    if (null != t3.interpolation && t3.hasOwnProperty('interpolation'))
                      switch (t3.interpolation) {
                        default:
                          return 'interpolation: enum value expected'
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                      }
                    return null
                  }),
                  (t2.fromObject = function (t3) {
                    if (t3 instanceof u.IndexMapping) return t3
                    var e2 = new u.IndexMapping()
                    switch (
                      (null != t3.gamma && (e2.gamma = Number(t3.gamma)),
                      null != t3.indexOffset && (e2.indexOffset = Number(t3.indexOffset)),
                      t3.interpolation)
                    ) {
                      case 'NONE':
                      case 0:
                        e2.interpolation = 0
                        break
                      case 'LINEAR':
                      case 1:
                        e2.interpolation = 1
                        break
                      case 'QUADRATIC':
                      case 2:
                        e2.interpolation = 2
                        break
                      case 'CUBIC':
                      case 3:
                        e2.interpolation = 3
                    }
                    return e2
                  }),
                  (t2.toObject = function (t3, e2) {
                    e2 || (e2 = {})
                    var n2 = {}
                    return (
                      e2.defaults &&
                        ((n2.gamma = 0), (n2.indexOffset = 0), (n2.interpolation = e2.enums === String ? 'NONE' : 0)),
                      null != t3.gamma &&
                        t3.hasOwnProperty('gamma') &&
                        (n2.gamma = e2.json && !isFinite(t3.gamma) ? String(t3.gamma) : t3.gamma),
                      null != t3.indexOffset &&
                        t3.hasOwnProperty('indexOffset') &&
                        (n2.indexOffset =
                          e2.json && !isFinite(t3.indexOffset) ? String(t3.indexOffset) : t3.indexOffset),
                      null != t3.interpolation &&
                        t3.hasOwnProperty('interpolation') &&
                        (n2.interpolation =
                          e2.enums === String ? u.IndexMapping.Interpolation[t3.interpolation] : t3.interpolation),
                      n2
                    )
                  }),
                  (t2.prototype.toJSON = function () {
                    return this.constructor.toObject(this, i.util.toJSONOptions)
                  }),
                  (t2.Interpolation = (function () {
                    var t3 = {},
                      e2 = Object.create(t3)
                    return (
                      (e2[(t3[0] = 'NONE')] = 0),
                      (e2[(t3[1] = 'LINEAR')] = 1),
                      (e2[(t3[2] = 'QUADRATIC')] = 2),
                      (e2[(t3[3] = 'CUBIC')] = 3),
                      e2
                    )
                  })()),
                  t2
                )
              })()),
              (u.Store = (function () {
                function t2(t3) {
                  if (((this.binCounts = {}), (this.contiguousBinCounts = []), t3))
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]])
                }
                return (
                  (t2.prototype.binCounts = s.emptyObject),
                  (t2.prototype.contiguousBinCounts = s.emptyArray),
                  (t2.prototype.contiguousBinIndexOffset = 0),
                  (t2.create = function (e2) {
                    return new t2(e2)
                  }),
                  (t2.encode = function (t3, e2) {
                    if ((e2 || (e2 = r.create()), null != t3.binCounts && Object.hasOwnProperty.call(t3, 'binCounts')))
                      for (var n2 = Object.keys(t3.binCounts), i2 = 0; i2 < n2.length; ++i2)
                        e2.uint32(10).fork().uint32(8).sint32(n2[i2]).uint32(17).double(t3.binCounts[n2[i2]]).ldelim()
                    if (null != t3.contiguousBinCounts && t3.contiguousBinCounts.length) {
                      e2.uint32(18).fork()
                      for (var i2 = 0; i2 < t3.contiguousBinCounts.length; ++i2) e2.double(t3.contiguousBinCounts[i2])
                      e2.ldelim()
                    }
                    return (
                      null != t3.contiguousBinIndexOffset &&
                        Object.hasOwnProperty.call(t3, 'contiguousBinIndexOffset') &&
                        e2.uint32(24).sint32(t3.contiguousBinIndexOffset),
                      e2
                    )
                  }),
                  (t2.encodeDelimited = function (t3, e2) {
                    return this.encode(t3, e2).ldelim()
                  }),
                  (t2.decode = function (t3, e2) {
                    t3 instanceof o || (t3 = o.create(t3))
                    for (var n2, i2, r2 = void 0 === e2 ? t3.len : t3.pos + e2, a = new u.Store(); t3.pos < r2; ) {
                      var f = t3.uint32()
                      switch (f >>> 3) {
                        case 1:
                          a.binCounts === s.emptyObject && (a.binCounts = {})
                          var c = t3.uint32() + t3.pos
                          for (n2 = 0, i2 = 0; t3.pos < c; ) {
                            var p = t3.uint32()
                            switch (p >>> 3) {
                              case 1:
                                n2 = t3.sint32()
                                break
                              case 2:
                                i2 = t3.double()
                                break
                              default:
                                t3.skipType(7 & p)
                            }
                          }
                          a.binCounts[n2] = i2
                          break
                        case 2:
                          if (
                            ((a.contiguousBinCounts && a.contiguousBinCounts.length) || (a.contiguousBinCounts = []),
                            (7 & f) == 2)
                          )
                            for (var c = t3.uint32() + t3.pos; t3.pos < c; ) a.contiguousBinCounts.push(t3.double())
                          else a.contiguousBinCounts.push(t3.double())
                          break
                        case 3:
                          a.contiguousBinIndexOffset = t3.sint32()
                          break
                        default:
                          t3.skipType(7 & f)
                      }
                    }
                    return a
                  }),
                  (t2.decodeDelimited = function (t3) {
                    return (t3 instanceof o || (t3 = new o(t3)), this.decode(t3, t3.uint32()))
                  }),
                  (t2.verify = function (t3) {
                    if ('object' != typeof t3 || null === t3) return 'object expected'
                    if (null != t3.binCounts && t3.hasOwnProperty('binCounts')) {
                      if (!s.isObject(t3.binCounts)) return 'binCounts: object expected'
                      for (var e2 = Object.keys(t3.binCounts), n2 = 0; n2 < e2.length; ++n2) {
                        if (!s.key32Re.test(e2[n2])) return 'binCounts: integer key{k:sint32} expected'
                        if ('number' != typeof t3.binCounts[e2[n2]]) return 'binCounts: number{k:sint32} expected'
                      }
                    }
                    if (null != t3.contiguousBinCounts && t3.hasOwnProperty('contiguousBinCounts')) {
                      if (!Array.isArray(t3.contiguousBinCounts)) return 'contiguousBinCounts: array expected'
                      for (var n2 = 0; n2 < t3.contiguousBinCounts.length; ++n2)
                        if ('number' != typeof t3.contiguousBinCounts[n2])
                          return 'contiguousBinCounts: number[] expected'
                    }
                    return null != t3.contiguousBinIndexOffset &&
                      t3.hasOwnProperty('contiguousBinIndexOffset') &&
                      !s.isInteger(t3.contiguousBinIndexOffset)
                      ? 'contiguousBinIndexOffset: integer expected'
                      : null
                  }),
                  (t2.fromObject = function (t3) {
                    if (t3 instanceof u.Store) return t3
                    var e2 = new u.Store()
                    if (t3.binCounts) {
                      if ('object' != typeof t3.binCounts) throw TypeError('.Store.binCounts: object expected')
                      e2.binCounts = {}
                      for (var n2 = Object.keys(t3.binCounts), i2 = 0; i2 < n2.length; ++i2)
                        e2.binCounts[n2[i2]] = Number(t3.binCounts[n2[i2]])
                    }
                    if (t3.contiguousBinCounts) {
                      if (!Array.isArray(t3.contiguousBinCounts))
                        throw TypeError('.Store.contiguousBinCounts: array expected')
                      e2.contiguousBinCounts = []
                      for (var i2 = 0; i2 < t3.contiguousBinCounts.length; ++i2)
                        e2.contiguousBinCounts[i2] = Number(t3.contiguousBinCounts[i2])
                    }
                    return (
                      null != t3.contiguousBinIndexOffset &&
                        (e2.contiguousBinIndexOffset = 0 | t3.contiguousBinIndexOffset),
                      e2
                    )
                  }),
                  (t2.toObject = function (t3, e2) {
                    e2 || (e2 = {})
                    var n2,
                      i2 = {}
                    if (
                      ((e2.arrays || e2.defaults) && (i2.contiguousBinCounts = []),
                      (e2.objects || e2.defaults) && (i2.binCounts = {}),
                      e2.defaults && (i2.contiguousBinIndexOffset = 0),
                      t3.binCounts && (n2 = Object.keys(t3.binCounts)).length)
                    ) {
                      i2.binCounts = {}
                      for (var o2 = 0; o2 < n2.length; ++o2)
                        i2.binCounts[n2[o2]] =
                          e2.json && !isFinite(t3.binCounts[n2[o2]])
                            ? String(t3.binCounts[n2[o2]])
                            : t3.binCounts[n2[o2]]
                    }
                    if (t3.contiguousBinCounts && t3.contiguousBinCounts.length) {
                      i2.contiguousBinCounts = []
                      for (var o2 = 0; o2 < t3.contiguousBinCounts.length; ++o2)
                        i2.contiguousBinCounts[o2] =
                          e2.json && !isFinite(t3.contiguousBinCounts[o2])
                            ? String(t3.contiguousBinCounts[o2])
                            : t3.contiguousBinCounts[o2]
                    }
                    return (
                      null != t3.contiguousBinIndexOffset &&
                        t3.hasOwnProperty('contiguousBinIndexOffset') &&
                        (i2.contiguousBinIndexOffset = t3.contiguousBinIndexOffset),
                      i2
                    )
                  }),
                  (t2.prototype.toJSON = function () {
                    return this.constructor.toObject(this, i.util.toJSONOptions)
                  }),
                  t2
                )
              })()),
              (t.exports = u))
          },
          './@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js': function (t, e, n) {
            var i =
              (this && this.__extends) ||
              /* @__PURE__ */ (function () {
                var t2 = function (e2, n2) {
                  return (t2 =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                      function (t3, e3) {
                        t3.__proto__ = e3
                      }) ||
                    function (t3, e3) {
                      for (var n3 in e3) Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3])
                    })(e2, n2)
                }
                return function (e2, n2) {
                  if ('function' != typeof n2 && null !== n2)
                    throw TypeError('Class extends value ' + String(n2) + ' is not a constructor or null')
                  function i2() {
                    this.constructor = e2
                  }
                  ;(t2(e2, n2),
                    (e2.prototype = null === n2 ? Object.create(n2) : ((i2.prototype = n2.prototype), new i2())))
                }
              })()
            ;(Object.defineProperty(e, '__esModule', { value: true }), (e.CollapsingHighestDenseStore = void 0))
            var o = n('./@datadog/sketches-js/dist/ddsketch/store/DenseStore.js'),
              r = n('./@datadog/sketches-js/dist/ddsketch/store/util.js')
            e.CollapsingHighestDenseStore = (function (t2) {
              function e2(e3, n2) {
                var i2 = t2.call(this, n2) || this
                return ((i2.binLimit = e3), (i2.isCollapsed = false), i2)
              }
              return (
                i(e2, t2),
                (e2.prototype.merge = function (t3) {
                  if (0 !== t3.count) {
                    if (0 === this.count) return void this.copy(t3)
                    ;(t3.minKey < this.minKey || t3.maxKey > this.maxKey) && this._extendRange(t3.minKey, t3.maxKey)
                    var e3 = t3.maxKey - t3.offset + 1,
                      n2 = Math.max(this.maxKey + 1, t3.minKey) - t3.offset
                    if (e3 > n2) {
                      var i2 = (0, r.sumOfRange)(t3.bins, n2, e3)
                      this.bins[this.length() - 1] += i2
                    } else n2 = e3
                    for (var o2 = t3.minKey; o2 < n2 + t3.offset; o2++)
                      this.bins[o2 - this.offset] += t3.bins[o2 - t3.offset]
                    this.count += t3.count
                  }
                }),
                (e2.prototype.copy = function (e3) {
                  ;(t2.prototype.copy.call(this, e3), (this.isCollapsed = e3.isCollapsed))
                }),
                (e2.prototype._getNewLength = function (t3, e3) {
                  var n2 = e3 - t3 + 1
                  return Math.min(this.chunkSize * Math.ceil(n2 / this.chunkSize), this.binLimit)
                }),
                (e2.prototype._adjust = function (t3, e3) {
                  if (e3 - t3 + 1 > this.length())
                    if ((e3 = t3 + this.length() + 1) <= this.minKey)
                      ((this.offset = t3),
                        (this.maxKey = e3),
                        this.bins.fill(0),
                        (this.bins[this.length() - 1] = this.count))
                    else {
                      var n2 = this.offset - t3
                      if (n2 > 0) {
                        var i2 = e3 - this.offset + 1,
                          o2 = this.maxKey - this.offset + 1,
                          s = (0, r.sumOfRange)(this.bins, i2, o2)
                        ;(this.bins.fill(0, i2, o2), (this.bins[i2 - 1] += s), (this.maxKey = e3), this._shiftBins(n2))
                      } else ((this.maxKey = e3), this._shiftBins(n2))
                      ;((this.minKey = t3), (this.isCollapsed = true))
                    }
                  else (this._centerBins(t3, e3), (this.minKey = t3), (this.maxKey = e3))
                }),
                (e2.prototype._getIndex = function (t3) {
                  if (t3 < this.minKey) {
                    if (this.isCollapsed || (this._extendRange(t3), this.isCollapsed)) return this.length() - 1
                  } else t3 > this.maxKey && this._extendRange(t3)
                  return t3 - this.offset
                }),
                e2
              )
            })(o.DenseStore)
          },
          './@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js': function (t, e, n) {
            var i =
              (this && this.__extends) ||
              /* @__PURE__ */ (function () {
                var t2 = function (e2, n2) {
                  return (t2 =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                      function (t3, e3) {
                        t3.__proto__ = e3
                      }) ||
                    function (t3, e3) {
                      for (var n3 in e3) Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3])
                    })(e2, n2)
                }
                return function (e2, n2) {
                  if ('function' != typeof n2 && null !== n2)
                    throw TypeError('Class extends value ' + String(n2) + ' is not a constructor or null')
                  function i2() {
                    this.constructor = e2
                  }
                  ;(t2(e2, n2),
                    (e2.prototype = null === n2 ? Object.create(n2) : ((i2.prototype = n2.prototype), new i2())))
                }
              })()
            ;(Object.defineProperty(e, '__esModule', { value: true }), (e.CollapsingLowestDenseStore = void 0))
            var o = n('./@datadog/sketches-js/dist/ddsketch/store/DenseStore.js'),
              r = n('./@datadog/sketches-js/dist/ddsketch/store/util.js')
            e.CollapsingLowestDenseStore = (function (t2) {
              function e2(e3, n2) {
                var i2 = t2.call(this, n2) || this
                return ((i2.binLimit = e3), (i2.isCollapsed = false), i2)
              }
              return (
                i(e2, t2),
                (e2.prototype.merge = function (t3) {
                  if (0 !== t3.count) {
                    if (0 === this.count) return void this.copy(t3)
                    ;(t3.minKey < this.minKey || t3.maxKey > this.maxKey) && this._extendRange(t3.minKey, t3.maxKey)
                    var e3 = t3.minKey - t3.offset,
                      n2 = Math.min(this.minKey, t3.maxKey + 1) - t3.offset
                    if (n2 > e3) {
                      var i2 = (0, r.sumOfRange)(t3.bins, e3, n2)
                      this.bins[0] += i2
                    } else n2 = e3
                    for (var o2 = n2 + t3.offset; o2 < t3.maxKey + 1; o2++)
                      this.bins[o2 - this.offset] += t3.bins[o2 - t3.offset]
                    this.count += t3.count
                  }
                }),
                (e2.prototype.copy = function (e3) {
                  ;(t2.prototype.copy.call(this, e3), (this.isCollapsed = e3.isCollapsed))
                }),
                (e2.prototype._getNewLength = function (t3, e3) {
                  var n2 = e3 - t3 + 1
                  return Math.min(this.chunkSize * Math.ceil(n2 / this.chunkSize), this.binLimit)
                }),
                (e2.prototype._adjust = function (t3, e3) {
                  if (e3 - t3 + 1 > this.length()) {
                    if ((t3 = e3 - this.length() + 1) >= this.maxKey)
                      ((this.offset = t3), (this.minKey = t3), this.bins.fill(0), (this.bins[0] = this.count))
                    else {
                      var n2 = this.offset - t3
                      if (n2 < 0) {
                        var i2 = this.minKey - this.offset,
                          o2 = t3 - this.offset,
                          s = (0, r.sumOfRange)(this.bins, i2, o2)
                        ;(this.bins.fill(0, i2, o2), (this.bins[o2] += s), (this.minKey = t3), this._shiftBins(n2))
                      } else ((this.minKey = t3), this._shiftBins(n2))
                    }
                    ;((this.maxKey = e3), (this.isCollapsed = true))
                  } else (this._centerBins(t3, e3), (this.minKey = t3), (this.maxKey = e3))
                }),
                (e2.prototype._getIndex = function (t3) {
                  if (t3 < this.minKey) {
                    if (this.isCollapsed || (this._extendRange(t3), this.isCollapsed)) return 0
                  } else t3 > this.maxKey && this._extendRange(t3)
                  return t3 - this.offset
                }),
                e2
              )
            })(o.DenseStore)
          },
          './@datadog/sketches-js/dist/ddsketch/store/DenseStore.js': function (t, e, n) {
            var i =
              (this && this.__spreadArray) ||
              function (t2, e2, n2) {
                if (n2 || 2 == arguments.length)
                  for (var i2, o2 = 0, r2 = e2.length; o2 < r2; o2++)
                    (!i2 && o2 in e2) || (i2 || (i2 = Array.prototype.slice.call(e2, 0, o2)), (i2[o2] = e2[o2]))
                return t2.concat(i2 || Array.prototype.slice.call(e2))
              }
            ;(Object.defineProperty(e, '__esModule', { value: true }), (e.DenseStore = void 0))
            var o = n('./@datadog/sketches-js/dist/ddsketch/store/util.js'),
              r = 128
            e.DenseStore = (function () {
              function t2(t3) {
                ;(void 0 === t3 && (t3 = r),
                  (this.chunkSize = t3),
                  (this.bins = []),
                  (this.count = 0),
                  (this.minKey = 1 / 0),
                  (this.maxKey = -1 / 0),
                  (this.offset = 0))
              }
              return (
                (t2.prototype.add = function (t3, e2) {
                  void 0 === e2 && (e2 = 1)
                  var n2 = this._getIndex(t3)
                  ;((this.bins[n2] += e2), (this.count += e2))
                }),
                (t2.prototype.keyAtRank = function (t3, e2) {
                  void 0 === e2 && (e2 = true)
                  for (var n2 = 0, i2 = 0; i2 < this.length(); i2++)
                    if (((n2 += this.bins[i2]), (e2 && n2 > t3) || (!e2 && n2 >= t3 + 1))) return i2 + this.offset
                  return this.maxKey
                }),
                (t2.prototype.merge = function (t3) {
                  if (0 !== t3.count) {
                    if (0 === this.count) return void this.copy(t3)
                    ;(t3.minKey < this.minKey || t3.maxKey > this.maxKey) && this._extendRange(t3.minKey, t3.maxKey)
                    var e2 = t3.minKey - t3.offset,
                      n2 = Math.min(this.minKey, t3.maxKey + 1) - t3.offset
                    if (n2 > e2) {
                      var i2 = (0, o.sumOfRange)(t3.bins, e2, n2)
                      this.bins[0] += i2
                    } else n2 = e2
                    for (var r2 = n2 + t3.offset; r2 < t3.maxKey + 1; r2++)
                      this.bins[r2 - this.offset] += t3.bins[r2 - t3.offset]
                    this.count += t3.count
                  }
                }),
                (t2.prototype.copy = function (t3) {
                  ;((this.bins = i([], t3.bins, true)),
                    (this.count = t3.count),
                    (this.minKey = t3.minKey),
                    (this.maxKey = t3.maxKey),
                    (this.offset = t3.offset))
                }),
                (t2.prototype.length = function () {
                  return this.bins.length
                }),
                (t2.prototype._getNewLength = function (t3, e2) {
                  var n2 = e2 - t3 + 1
                  return this.chunkSize * Math.ceil(n2 / this.chunkSize)
                }),
                (t2.prototype._adjust = function (t3, e2) {
                  ;(this._centerBins(t3, e2), (this.minKey = t3), (this.maxKey = e2))
                }),
                (t2.prototype._shiftBins = function (t3) {
                  var e2, n2
                  ;(t3 > 0
                    ? ((this.bins = this.bins.slice(0, -t3)), (e2 = this.bins).unshift.apply(e2, Array(t3).fill(0)))
                    : ((this.bins = this.bins.slice(Math.abs(t3))),
                      (n2 = this.bins).push.apply(n2, Array(Math.abs(t3)).fill(0))),
                    (this.offset -= t3))
                }),
                (t2.prototype._centerBins = function (t3, e2) {
                  var n2 = t3 + Math.floor((e2 - t3 + 1) / 2)
                  this._shiftBins(Math.floor(this.offset + this.length() / 2) - n2)
                }),
                (t2.prototype._extendRange = function (t3, e2) {
                  e2 = e2 || t3
                  var n2,
                    i2 = Math.min(t3, e2, this.minKey),
                    o2 = Math.max(t3, e2, this.maxKey)
                  if (0 === this.length())
                    ((this.bins = Array(this._getNewLength(i2, o2)).fill(0)), (this.offset = i2), this._adjust(i2, o2))
                  else if (i2 >= this.minKey && o2 < this.offset + this.length())
                    ((this.minKey = i2), (this.maxKey = o2))
                  else {
                    var r2 = this._getNewLength(i2, o2)
                    ;(r2 > this.length() && (n2 = this.bins).push.apply(n2, Array(r2 - this.length()).fill(0)),
                      this._adjust(i2, o2))
                  }
                }),
                (t2.prototype._getIndex = function (t3) {
                  return (
                    t3 < this.minKey ? this._extendRange(t3) : t3 > this.maxKey && this._extendRange(t3),
                    t3 - this.offset
                  )
                }),
                (t2.prototype.toProto = function () {
                  return n('./@datadog/sketches-js/dist/ddsketch/proto/compiled.js').Store.create({
                    contiguousBinCounts: this.bins,
                    contiguousBinIndexOffset: this.offset,
                  })
                }),
                (t2.fromProto = function (t3) {
                  if (!t3 || null == t3.contiguousBinCounts || null == t3.contiguousBinIndexOffset)
                    throw Error('Failed to decode store from protobuf')
                  var e2 = new this(),
                    n2 = t3.contiguousBinIndexOffset
                  e2.offset = n2
                  for (var i2 = 0, o2 = t3.contiguousBinCounts; i2 < o2.length; i2++) {
                    var r2 = o2[i2]
                    ;(e2.add(n2, r2), (n2 += 1))
                  }
                  return e2
                }),
                t2
              )
            })()
          },
          './@datadog/sketches-js/dist/ddsketch/store/index.js': function (t, e, n) {
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              (e.CollapsingHighestDenseStore = e.CollapsingLowestDenseStore = e.DenseStore = void 0))
            var i = n('./@datadog/sketches-js/dist/ddsketch/store/DenseStore.js')
            Object.defineProperty(e, 'DenseStore', {
              enumerable: true,
              get: function () {
                return i.DenseStore
              },
            })
            var o = n('./@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js')
            Object.defineProperty(e, 'CollapsingLowestDenseStore', {
              enumerable: true,
              get: function () {
                return o.CollapsingLowestDenseStore
              },
            })
            var r = n('./@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js')
            Object.defineProperty(e, 'CollapsingHighestDenseStore', {
              enumerable: true,
              get: function () {
                return r.CollapsingHighestDenseStore
              },
            })
          },
          './@datadog/sketches-js/dist/ddsketch/store/util.js': function (t, e) {
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              (e.sumOfRange = void 0),
              (e.sumOfRange = function (t2, e2, n) {
                for (var i = 0, o = e2; o <= n; o++) i += t2[o]
                return i
              }))
          },
          './@datadog/sketches-js/dist/index.js': function (t, e, n) {
            var i =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (t2, e2, n2, i2) {
                      void 0 === i2 && (i2 = n2)
                      var o2 = Object.getOwnPropertyDescriptor(e2, n2)
                      ;((!o2 || ('get' in o2 ? !e2.__esModule : o2.writable || o2.configurable)) &&
                        (o2 = {
                          enumerable: true,
                          get: function () {
                            return e2[n2]
                          },
                        }),
                        Object.defineProperty(t2, i2, o2))
                    }
                  : function (t2, e2, n2, i2) {
                      ;(void 0 === i2 && (i2 = n2), (t2[i2] = e2[n2]))
                    }),
              o =
                (this && this.__exportStar) ||
                function (t2, e2) {
                  for (var n2 in t2) 'default' === n2 || Object.prototype.hasOwnProperty.call(e2, n2) || i(e2, t2, n2)
                }
            ;(Object.defineProperty(e, '__esModule', { value: true }),
              o(n('./@datadog/sketches-js/dist/ddsketch/index.js'), e))
          },
          './@protobufjs/aspromise/index.js': function (t) {
            t.exports = e
            function e(t2, e2) {
              for (var n = Array(arguments.length - 1), i = 0, o = 2, r = true; o < arguments.length; )
                n[i++] = arguments[o++]
              return new Promise(function (o2, s) {
                n[i] = function (t3) {
                  if (r)
                    if (((r = false), t3)) s(t3)
                    else {
                      for (var e3 = Array(arguments.length - 1), n2 = 0; n2 < e3.length; ) e3[n2++] = arguments[n2]
                      o2.apply(null, e3)
                    }
                }
                try {
                  t2.apply(e2 || null, n)
                } catch (t3) {
                  r && ((r = false), s(t3))
                }
              })
            }
          },
          './@protobufjs/base64/index.js': function (t, e) {
            var n = e
            n.length = function (t2) {
              var e2 = t2.length
              if (!e2) return 0
              for (var n2 = 0; --e2 % 4 > 1 && '=' === t2.charAt(e2); ) ++n2
              return Math.ceil(3 * t2.length) / 4 - n2
            }
            for (var i = Array(64), o = Array(123), r = 0; r < 64; )
              o[(i[r] = r < 26 ? r + 65 : r < 52 ? r + 71 : r < 62 ? r - 4 : (r - 59) | 43)] = r++
            n.encode = function (t2, e2, n2) {
              for (var o2, r2 = null, s2 = [], u = 0, a = 0; e2 < n2; ) {
                var f = t2[e2++]
                switch (a) {
                  case 0:
                    ;((s2[u++] = i[f >> 2]), (o2 = (3 & f) << 4), (a = 1))
                    break
                  case 1:
                    ;((s2[u++] = i[o2 | (f >> 4)]), (o2 = (15 & f) << 2), (a = 2))
                    break
                  case 2:
                    ;((s2[u++] = i[o2 | (f >> 6)]), (s2[u++] = i[63 & f]), (a = 0))
                }
                u > 8191 && ((r2 || (r2 = [])).push(String.fromCharCode.apply(String, s2)), (u = 0))
              }
              return (a && ((s2[u++] = i[o2]), (s2[u++] = 61), 1 === a && (s2[u++] = 61)), r2)
                ? (u && r2.push(String.fromCharCode.apply(String, s2.slice(0, u))), r2.join(''))
                : String.fromCharCode.apply(String, s2.slice(0, u))
            }
            var s = 'invalid encoding'
            ;((n.decode = function (t2, e2, n2) {
              for (var i2, r2 = n2, u = 0, a = 0; a < t2.length; ) {
                var f = t2.charCodeAt(a++)
                if (61 === f && u > 1) break
                if (void 0 === (f = o[f])) throw Error(s)
                switch (u) {
                  case 0:
                    ;((i2 = f), (u = 1))
                    break
                  case 1:
                    ;((e2[n2++] = (i2 << 2) | ((48 & f) >> 4)), (i2 = f), (u = 2))
                    break
                  case 2:
                    ;((e2[n2++] = ((15 & i2) << 4) | ((60 & f) >> 2)), (i2 = f), (u = 3))
                    break
                  case 3:
                    ;((e2[n2++] = ((3 & i2) << 6) | f), (u = 0))
                }
              }
              if (1 === u) throw Error(s)
              return n2 - r2
            }),
              (n.test = function (t2) {
                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t2)
              }))
          },
          './@protobufjs/eventemitter/index.js': function (t) {
            function e() {
              this._listeners = {}
            }
            ;((t.exports = e),
              (e.prototype.on = function (t2, e2, n) {
                return ((this._listeners[t2] || (this._listeners[t2] = [])).push({ fn: e2, ctx: n || this }), this)
              }),
              (e.prototype.off = function (t2, e2) {
                if (void 0 === t2) this._listeners = {}
                else if (void 0 === e2) this._listeners[t2] = []
                else for (var n = this._listeners[t2], i = 0; i < n.length; ) n[i].fn === e2 ? n.splice(i, 1) : ++i
                return this
              }),
              (e.prototype.emit = function (t2) {
                var e2 = this._listeners[t2]
                if (e2) {
                  for (var n = [], i = 1; i < arguments.length; ) n.push(arguments[i++])
                  for (i = 0; i < e2.length; ) e2[i].fn.apply(e2[i++].ctx, n)
                }
                return this
              }))
          },
          './@protobufjs/float/index.js': function (t) {
            function e(t2) {
              return (
                'undefined' != typeof Float32Array
                  ? !(function () {
                      var e2 = new Float32Array([-0]),
                        n2 = new Uint8Array(e2.buffer),
                        i2 = 128 === n2[3]
                      function o2(t3, i3, o3) {
                        ;((e2[0] = t3),
                          (i3[o3] = n2[0]),
                          (i3[o3 + 1] = n2[1]),
                          (i3[o3 + 2] = n2[2]),
                          (i3[o3 + 3] = n2[3]))
                      }
                      function r2(t3, i3, o3) {
                        ;((e2[0] = t3),
                          (i3[o3] = n2[3]),
                          (i3[o3 + 1] = n2[2]),
                          (i3[o3 + 2] = n2[1]),
                          (i3[o3 + 3] = n2[0]))
                      }
                      function s(t3, i3) {
                        return (
                          (n2[0] = t3[i3]),
                          (n2[1] = t3[i3 + 1]),
                          (n2[2] = t3[i3 + 2]),
                          (n2[3] = t3[i3 + 3]),
                          e2[0]
                        )
                      }
                      function u(t3, i3) {
                        return (
                          (n2[3] = t3[i3]),
                          (n2[2] = t3[i3 + 1]),
                          (n2[1] = t3[i3 + 2]),
                          (n2[0] = t3[i3 + 3]),
                          e2[0]
                        )
                      }
                      ;((t2.writeFloatLE = i2 ? o2 : r2),
                        (t2.writeFloatBE = i2 ? r2 : o2),
                        (t2.readFloatLE = i2 ? s : u),
                        (t2.readFloatBE = i2 ? u : s))
                    })()
                  : !(function () {
                      function e2(t3, e3, n2, i2) {
                        var o2 = +(e3 < 0)
                        if ((o2 && (e3 = -e3), 0 === e3)) t3(1 / e3 > 0 ? 0 : 2147483648, n2, i2)
                        else if (isNaN(e3)) t3(2143289344, n2, i2)
                        else if (e3 > 34028234663852886e22) t3(((o2 << 31) | 2139095040) >>> 0, n2, i2)
                        else if (e3 < 11754943508222875e-54)
                          t3(((o2 << 31) | Math.round(e3 / 1401298464324817e-60)) >>> 0, n2, i2)
                        else {
                          var r2 = Math.floor(Math.log(e3) / Math.LN2),
                            s2 = 8388607 & Math.round(e3 * Math.pow(2, -r2) * 8388608)
                          t3(((o2 << 31) | ((r2 + 127) << 23) | s2) >>> 0, n2, i2)
                        }
                      }
                      function s(t3, e3, n2) {
                        var i2 = t3(e3, n2),
                          o2 = (i2 >> 31) * 2 + 1,
                          r2 = (i2 >>> 23) & 255,
                          s2 = 8388607 & i2
                        return 255 === r2
                          ? s2
                            ? NaN
                            : (1 / 0) * o2
                          : 0 === r2
                            ? 1401298464324817e-60 * o2 * s2
                            : o2 * Math.pow(2, r2 - 150) * (s2 + 8388608)
                      }
                      ;((t2.writeFloatLE = e2.bind(null, n)),
                        (t2.writeFloatBE = e2.bind(null, i)),
                        (t2.readFloatLE = s.bind(null, o)),
                        (t2.readFloatBE = s.bind(null, r)))
                    })(),
                'undefined' != typeof Float64Array
                  ? !(function () {
                      var e2 = new Float64Array([-0]),
                        n2 = new Uint8Array(e2.buffer),
                        i2 = 128 === n2[7]
                      function o2(t3, i3, o3) {
                        ;((e2[0] = t3),
                          (i3[o3] = n2[0]),
                          (i3[o3 + 1] = n2[1]),
                          (i3[o3 + 2] = n2[2]),
                          (i3[o3 + 3] = n2[3]),
                          (i3[o3 + 4] = n2[4]),
                          (i3[o3 + 5] = n2[5]),
                          (i3[o3 + 6] = n2[6]),
                          (i3[o3 + 7] = n2[7]))
                      }
                      function r2(t3, i3, o3) {
                        ;((e2[0] = t3),
                          (i3[o3] = n2[7]),
                          (i3[o3 + 1] = n2[6]),
                          (i3[o3 + 2] = n2[5]),
                          (i3[o3 + 3] = n2[4]),
                          (i3[o3 + 4] = n2[3]),
                          (i3[o3 + 5] = n2[2]),
                          (i3[o3 + 6] = n2[1]),
                          (i3[o3 + 7] = n2[0]))
                      }
                      function s(t3, i3) {
                        return (
                          (n2[0] = t3[i3]),
                          (n2[1] = t3[i3 + 1]),
                          (n2[2] = t3[i3 + 2]),
                          (n2[3] = t3[i3 + 3]),
                          (n2[4] = t3[i3 + 4]),
                          (n2[5] = t3[i3 + 5]),
                          (n2[6] = t3[i3 + 6]),
                          (n2[7] = t3[i3 + 7]),
                          e2[0]
                        )
                      }
                      function u(t3, i3) {
                        return (
                          (n2[7] = t3[i3]),
                          (n2[6] = t3[i3 + 1]),
                          (n2[5] = t3[i3 + 2]),
                          (n2[4] = t3[i3 + 3]),
                          (n2[3] = t3[i3 + 4]),
                          (n2[2] = t3[i3 + 5]),
                          (n2[1] = t3[i3 + 6]),
                          (n2[0] = t3[i3 + 7]),
                          e2[0]
                        )
                      }
                      ;((t2.writeDoubleLE = i2 ? o2 : r2),
                        (t2.writeDoubleBE = i2 ? r2 : o2),
                        (t2.readDoubleLE = i2 ? s : u),
                        (t2.readDoubleBE = i2 ? u : s))
                    })()
                  : !(function () {
                      function e2(t3, e3, n2, i2, o2, r2) {
                        var s2,
                          u = +(i2 < 0)
                        if ((u && (i2 = -i2), 0 === i2))
                          (t3(0, o2, r2 + e3), t3(1 / i2 > 0 ? 0 : 2147483648, o2, r2 + n2))
                        else if (isNaN(i2)) (t3(0, o2, r2 + e3), t3(2146959360, o2, r2 + n2))
                        else if (i2 > 17976931348623157e292)
                          (t3(0, o2, r2 + e3), t3(((u << 31) | 2146435072) >>> 0, o2, r2 + n2))
                        else if (i2 < 22250738585072014e-324)
                          (t3((s2 = i2 / 5e-324) >>> 0, o2, r2 + e3),
                            t3(((u << 31) | (s2 / 4294967296)) >>> 0, o2, r2 + n2))
                        else {
                          var a = Math.floor(Math.log(i2) / Math.LN2)
                          ;(1024 === a && (a = 1023),
                            t3((4503599627370496 * (s2 = i2 * Math.pow(2, -a))) >>> 0, o2, r2 + e3),
                            t3(((u << 31) | ((a + 1023) << 20) | ((1048576 * s2) & 1048575)) >>> 0, o2, r2 + n2))
                        }
                      }
                      function s(t3, e3, n2, i2, o2) {
                        var r2 = t3(i2, o2 + e3),
                          s2 = t3(i2, o2 + n2),
                          u = (s2 >> 31) * 2 + 1,
                          a = (s2 >>> 20) & 2047,
                          f = 4294967296 * (1048575 & s2) + r2
                        return 2047 === a
                          ? f
                            ? NaN
                            : (1 / 0) * u
                          : 0 === a
                            ? 5e-324 * u * f
                            : u * Math.pow(2, a - 1075) * (f + 4503599627370496)
                      }
                      ;((t2.writeDoubleLE = e2.bind(null, n, 0, 4)),
                        (t2.writeDoubleBE = e2.bind(null, i, 4, 0)),
                        (t2.readDoubleLE = s.bind(null, o, 0, 4)),
                        (t2.readDoubleBE = s.bind(null, r, 4, 0)))
                    })(),
                t2
              )
            }
            function n(t2, e2, n2) {
              ;((e2[n2] = 255 & t2),
                (e2[n2 + 1] = (t2 >>> 8) & 255),
                (e2[n2 + 2] = (t2 >>> 16) & 255),
                (e2[n2 + 3] = t2 >>> 24))
            }
            function i(t2, e2, n2) {
              ;((e2[n2] = t2 >>> 24),
                (e2[n2 + 1] = (t2 >>> 16) & 255),
                (e2[n2 + 2] = (t2 >>> 8) & 255),
                (e2[n2 + 3] = 255 & t2))
            }
            function o(t2, e2) {
              return (t2[e2] | (t2[e2 + 1] << 8) | (t2[e2 + 2] << 16) | (t2[e2 + 3] << 24)) >>> 0
            }
            function r(t2, e2) {
              return ((t2[e2] << 24) | (t2[e2 + 1] << 16) | (t2[e2 + 2] << 8) | t2[e2 + 3]) >>> 0
            }
            t.exports = e(e)
          },
          './@protobufjs/inquire/index.js': function (module) {
            module.exports = inquire
            function inquire(moduleName) {
              try {
                var mod = eval('quire'.replace(/^/, 're'))(moduleName)
                if (mod && (mod.length || Object.keys(mod).length)) return mod
              } catch (e) {}
              return null
            }
          },
          './@protobufjs/pool/index.js': function (t) {
            t.exports = e
            function e(t2, e2, n) {
              var i = n || 8192,
                o = i >>> 1,
                r = null,
                s = i
              return function (n2) {
                if (n2 < 1 || n2 > o) return t2(n2)
                s + n2 > i && ((r = t2(i)), (s = 0))
                var u = e2.call(r, s, (s += n2))
                return (7 & s && (s = (7 | s) + 1), u)
              }
            }
          },
          './@protobufjs/utf8/index.js': function (t, e) {
            var n = e
            ;((n.length = function (t2) {
              for (var e2 = 0, n2 = 0, i = 0; i < t2.length; ++i)
                (n2 = t2.charCodeAt(i)) < 128
                  ? (e2 += 1)
                  : n2 < 2048
                    ? (e2 += 2)
                    : (64512 & n2) == 55296 && (64512 & t2.charCodeAt(i + 1)) == 56320
                      ? (++i, (e2 += 4))
                      : (e2 += 3)
              return e2
            }),
              (n.read = function (t2, e2, n2) {
                if (n2 - e2 < 1) return ''
                for (var i, o = null, r = [], s = 0; e2 < n2; )
                  ((i = t2[e2++]) < 128
                    ? (r[s++] = i)
                    : i > 191 && i < 224
                      ? (r[s++] = ((31 & i) << 6) | (63 & t2[e2++]))
                      : i > 239 && i < 365
                        ? ((i =
                            (((7 & i) << 18) | ((63 & t2[e2++]) << 12) | ((63 & t2[e2++]) << 6) | (63 & t2[e2++])) -
                            65536),
                          (r[s++] = 55296 + (i >> 10)),
                          (r[s++] = 56320 + (1023 & i)))
                        : (r[s++] = ((15 & i) << 12) | ((63 & t2[e2++]) << 6) | (63 & t2[e2++])),
                    s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, r)), (s = 0)))
                return o
                  ? (s && o.push(String.fromCharCode.apply(String, r.slice(0, s))), o.join(''))
                  : String.fromCharCode.apply(String, r.slice(0, s))
              }),
              (n.write = function (t2, e2, n2) {
                for (var i, o, r = n2, s = 0; s < t2.length; ++s)
                  (i = t2.charCodeAt(s)) < 128
                    ? (e2[n2++] = i)
                    : (i < 2048
                        ? (e2[n2++] = (i >> 6) | 192)
                        : ((64512 & i) == 55296 && (64512 & (o = t2.charCodeAt(s + 1))) == 56320
                            ? ((i = 65536 + ((1023 & i) << 10) + (1023 & o)),
                              ++s,
                              (e2[n2++] = (i >> 18) | 240),
                              (e2[n2++] = ((i >> 12) & 63) | 128))
                            : (e2[n2++] = (i >> 12) | 224),
                          (e2[n2++] = ((i >> 6) & 63) | 128)),
                      (e2[n2++] = (63 & i) | 128))
                return n2 - r
              }))
          },
          './protobufjs/minimal.js': function (t, e, n) {
            t.exports = n('./protobufjs/src/index-minimal.js')
          },
          './protobufjs/src/index-minimal.js': function (t, e, n) {
            var i = e
            function o() {
              ;(i.util._configure(), i.Writer._configure(i.BufferWriter), i.Reader._configure(i.BufferReader))
            }
            ;((i.build = 'minimal'),
              (i.Writer = n('./protobufjs/src/writer.js')),
              (i.BufferWriter = n('./protobufjs/src/writer_buffer.js')),
              (i.Reader = n('./protobufjs/src/reader.js')),
              (i.BufferReader = n('./protobufjs/src/reader_buffer.js')),
              (i.util = n('./protobufjs/src/util/minimal.js')),
              (i.rpc = n('./protobufjs/src/rpc.js')),
              (i.roots = n('./protobufjs/src/roots.js')),
              (i.configure = o),
              o())
          },
          './protobufjs/src/reader.js': function (t, e, n) {
            t.exports = a
            var i,
              o = n('./protobufjs/src/util/minimal.js'),
              r = o.LongBits,
              s = o.utf8
            function u(t2, e2) {
              return RangeError('index out of range: ' + t2.pos + ' + ' + (e2 || 1) + ' > ' + t2.len)
            }
            function a(t2) {
              ;((this.buf = t2), (this.pos = 0), (this.len = t2.length))
            }
            var f =
                'undefined' != typeof Uint8Array
                  ? function (t2) {
                      if (t2 instanceof Uint8Array || Array.isArray(t2)) return new a(t2)
                      throw Error('illegal buffer')
                    }
                  : function (t2) {
                      if (Array.isArray(t2)) return new a(t2)
                      throw Error('illegal buffer')
                    },
              c = function () {
                return o.Buffer
                  ? function (t2) {
                      return (a.create = function (t3) {
                        return o.Buffer.isBuffer(t3) ? new i(t3) : f(t3)
                      })(t2)
                    }
                  : f
              }
            function p() {
              var t2 = new r(0, 0),
                e2 = 0
              if (this.len - this.pos > 4) {
                for (; e2 < 4; ++e2)
                  if (((t2.lo = (t2.lo | ((127 & this.buf[this.pos]) << (7 * e2))) >>> 0), this.buf[this.pos++] < 128))
                    return t2
                if (
                  ((t2.lo = (t2.lo | ((127 & this.buf[this.pos]) << 28)) >>> 0),
                  (t2.hi = (t2.hi | ((127 & this.buf[this.pos]) >> 4)) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return t2
                e2 = 0
              } else {
                for (; e2 < 3; ++e2) {
                  if (this.pos >= this.len) throw u(this)
                  if (((t2.lo = (t2.lo | ((127 & this.buf[this.pos]) << (7 * e2))) >>> 0), this.buf[this.pos++] < 128))
                    return t2
                }
                return ((t2.lo = (t2.lo | ((127 & this.buf[this.pos++]) << (7 * e2))) >>> 0), t2)
              }
              if (this.len - this.pos > 4) {
                for (; e2 < 5; ++e2)
                  if (
                    ((t2.hi = (t2.hi | ((127 & this.buf[this.pos]) << (7 * e2 + 3))) >>> 0), this.buf[this.pos++] < 128)
                  )
                    return t2
              } else
                for (; e2 < 5; ++e2) {
                  if (this.pos >= this.len) throw u(this)
                  if (
                    ((t2.hi = (t2.hi | ((127 & this.buf[this.pos]) << (7 * e2 + 3))) >>> 0), this.buf[this.pos++] < 128)
                  )
                    return t2
                }
              throw Error('invalid varint encoding')
            }
            function l(t2, e2) {
              return (t2[e2 - 4] | (t2[e2 - 3] << 8) | (t2[e2 - 2] << 16) | (t2[e2 - 1] << 24)) >>> 0
            }
            function h() {
              if (this.pos + 8 > this.len) throw u(this, 8)
              return new r(l(this.buf, (this.pos += 4)), l(this.buf, (this.pos += 4)))
            }
            ;((a.create = c()),
              (a.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice),
              (a.prototype.uint32 = /* @__PURE__ */ (function () {
                var t2 = 4294967295
                return function () {
                  if (
                    ((t2 = (127 & this.buf[this.pos]) >>> 0),
                    this.buf[this.pos++] < 128 ||
                      ((t2 = (t2 | ((127 & this.buf[this.pos]) << 7)) >>> 0), this.buf[this.pos++] < 128) ||
                      ((t2 = (t2 | ((127 & this.buf[this.pos]) << 14)) >>> 0), this.buf[this.pos++] < 128) ||
                      ((t2 = (t2 | ((127 & this.buf[this.pos]) << 21)) >>> 0), this.buf[this.pos++] < 128) ||
                      ((t2 = (t2 | ((15 & this.buf[this.pos]) << 28)) >>> 0), this.buf[this.pos++] < 128))
                  )
                    return t2
                  if ((this.pos += 5) > this.len) throw ((this.pos = this.len), u(this, 10))
                  return t2
                }
              })()),
              (a.prototype.int32 = function () {
                return 0 | this.uint32()
              }),
              (a.prototype.sint32 = function () {
                var t2 = this.uint32()
                return (t2 >>> 1) ^ -(1 & t2)
              }),
              (a.prototype.bool = function () {
                return 0 !== this.uint32()
              }),
              (a.prototype.fixed32 = function () {
                if (this.pos + 4 > this.len) throw u(this, 4)
                return l(this.buf, (this.pos += 4))
              }),
              (a.prototype.sfixed32 = function () {
                if (this.pos + 4 > this.len) throw u(this, 4)
                return 0 | l(this.buf, (this.pos += 4))
              }),
              (a.prototype.float = function () {
                if (this.pos + 4 > this.len) throw u(this, 4)
                var t2 = o.float.readFloatLE(this.buf, this.pos)
                return ((this.pos += 4), t2)
              }),
              (a.prototype.double = function () {
                if (this.pos + 8 > this.len) throw u(this, 4)
                var t2 = o.float.readDoubleLE(this.buf, this.pos)
                return ((this.pos += 8), t2)
              }),
              (a.prototype.bytes = function () {
                var t2 = this.uint32(),
                  e2 = this.pos,
                  n2 = this.pos + t2
                if (n2 > this.len) throw u(this, t2)
                if (((this.pos += t2), Array.isArray(this.buf))) return this.buf.slice(e2, n2)
                if (e2 === n2) {
                  var i2 = o.Buffer
                  return i2 ? i2.alloc(0) : new this.buf.constructor(0)
                }
                return this._slice.call(this.buf, e2, n2)
              }),
              (a.prototype.string = function () {
                var t2 = this.bytes()
                return s.read(t2, 0, t2.length)
              }),
              (a.prototype.skip = function (t2) {
                if ('number' == typeof t2) {
                  if (this.pos + t2 > this.len) throw u(this, t2)
                  this.pos += t2
                } else
                  do if (this.pos >= this.len) throw u(this)
                  while (128 & this.buf[this.pos++])
                return this
              }),
              (a.prototype.skipType = function (t2) {
                switch (t2) {
                  case 0:
                    this.skip()
                    break
                  case 1:
                    this.skip(8)
                    break
                  case 2:
                    this.skip(this.uint32())
                    break
                  case 3:
                    for (; 4 != (t2 = 7 & this.uint32()); ) this.skipType(t2)
                    break
                  case 5:
                    this.skip(4)
                    break
                  default:
                    throw Error('invalid wire type ' + t2 + ' at offset ' + this.pos)
                }
                return this
              }),
              (a._configure = function (t2) {
                ;((i = t2), (a.create = c()), i._configure())
                var e2 = o.Long ? 'toLong' : 'toNumber'
                o.merge(a.prototype, {
                  int64: function () {
                    return p.call(this)[e2](false)
                  },
                  uint64: function () {
                    return p.call(this)[e2](true)
                  },
                  sint64: function () {
                    return p.call(this).zzDecode()[e2](false)
                  },
                  fixed64: function () {
                    return h.call(this)[e2](true)
                  },
                  sfixed64: function () {
                    return h.call(this)[e2](false)
                  },
                })
              }))
          },
          './protobufjs/src/reader_buffer.js': function (t, e, n) {
            t.exports = r
            var i = n('./protobufjs/src/reader.js')
            ;(r.prototype = Object.create(i.prototype)).constructor = r
            var o = n('./protobufjs/src/util/minimal.js')
            function r(t2) {
              i.call(this, t2)
            }
            ;((r._configure = function () {
              o.Buffer && (r.prototype._slice = o.Buffer.prototype.slice)
            }),
              (r.prototype.string = function () {
                var t2 = this.uint32()
                return this.buf.utf8Slice
                  ? this.buf.utf8Slice(this.pos, (this.pos = Math.min(this.pos + t2, this.len)))
                  : this.buf.toString('utf-8', this.pos, (this.pos = Math.min(this.pos + t2, this.len)))
              }),
              r._configure())
          },
          './protobufjs/src/roots.js': function (t) {
            t.exports = {}
          },
          './protobufjs/src/rpc.js': function (t, e, n) {
            e.Service = n('./protobufjs/src/rpc/service.js')
          },
          './protobufjs/src/rpc/service.js': function (t, e, n) {
            t.exports = o
            var i = n('./protobufjs/src/util/minimal.js')
            function o(t2, e2, n2) {
              if ('function' != typeof t2) throw TypeError('rpcImpl must be a function')
              ;(i.EventEmitter.call(this),
                (this.rpcImpl = t2),
                (this.requestDelimited = !!e2),
                (this.responseDelimited = !!n2))
            }
            ;(((o.prototype = Object.create(i.EventEmitter.prototype)).constructor = o),
              (o.prototype.rpcCall = function t2(e2, n2, o2, r, s) {
                if (!r) throw TypeError('request must be specified')
                var u = this
                if (!s) return i.asPromise(t2, u, e2, n2, o2, r)
                if (!u.rpcImpl)
                  return void setTimeout(function () {
                    s(Error('already ended'))
                  }, 0)
                try {
                  return u.rpcImpl(
                    e2,
                    n2[u.requestDelimited ? 'encodeDelimited' : 'encode'](r).finish(),
                    function (t3, n3) {
                      if (t3) return (u.emit('error', t3, e2), s(t3))
                      if (null === n3) return void u.end(true)
                      if (!(n3 instanceof o2))
                        try {
                          n3 = o2[u.responseDelimited ? 'decodeDelimited' : 'decode'](n3)
                        } catch (t4) {
                          return (u.emit('error', t4, e2), s(t4))
                        }
                      return (u.emit('data', n3, e2), s(null, n3))
                    }
                  )
                } catch (t3) {
                  ;(u.emit('error', t3, e2),
                    setTimeout(function () {
                      s(t3)
                    }, 0))
                  return
                }
              }),
              (o.prototype.end = function (t2) {
                return (
                  this.rpcImpl && (t2 || this.rpcImpl(null, null, null), (this.rpcImpl = null), this.emit('end').off()),
                  this
                )
              }))
          },
          './protobufjs/src/util/longbits.js': function (t, e, n) {
            t.exports = o
            var i = n('./protobufjs/src/util/minimal.js')
            function o(t2, e2) {
              ;((this.lo = t2 >>> 0), (this.hi = e2 >>> 0))
            }
            var r = (o.zero = new o(0, 0))
            ;((r.toNumber = function () {
              return 0
            }),
              (r.zzEncode = r.zzDecode =
                function () {
                  return this
                }),
              (r.length = function () {
                return 1
              }))
            var s = (o.zeroHash = '\0\0\0\0\0\0\0\0')
            ;((o.fromNumber = function (t2) {
              if (0 === t2) return r
              var e2 = t2 < 0
              e2 && (t2 = -t2)
              var n2 = t2 >>> 0,
                i2 = ((t2 - n2) / 4294967296) >>> 0
              return (
                e2 &&
                  ((i2 = ~i2 >>> 0), (n2 = ~n2 >>> 0), ++n2 > 4294967295 && ((n2 = 0), ++i2 > 4294967295 && (i2 = 0))),
                new o(n2, i2)
              )
            }),
              (o.from = function (t2) {
                if ('number' == typeof t2) return o.fromNumber(t2)
                if (i.isString(t2))
                  if (!i.Long) return o.fromNumber(parseInt(t2, 10))
                  else t2 = i.Long.fromString(t2)
                return t2.low || t2.high ? new o(t2.low >>> 0, t2.high >>> 0) : r
              }),
              (o.prototype.toNumber = function (t2) {
                if (!t2 && this.hi >>> 31) {
                  var e2 = (~this.lo + 1) >>> 0,
                    n2 = ~this.hi >>> 0
                  return (e2 || (n2 = (n2 + 1) >>> 0), -(e2 + 4294967296 * n2))
                }
                return this.lo + 4294967296 * this.hi
              }),
              (o.prototype.toLong = function (t2) {
                return i.Long
                  ? new i.Long(0 | this.lo, 0 | this.hi, !!t2)
                  : { low: 0 | this.lo, high: 0 | this.hi, unsigned: !!t2 }
              }))
            var u = String.prototype.charCodeAt
            ;((o.fromHash = function (t2) {
              return t2 === s
                ? r
                : new o(
                    (u.call(t2, 0) | (u.call(t2, 1) << 8) | (u.call(t2, 2) << 16) | (u.call(t2, 3) << 24)) >>> 0,
                    (u.call(t2, 4) | (u.call(t2, 5) << 8) | (u.call(t2, 6) << 16) | (u.call(t2, 7) << 24)) >>> 0
                  )
            }),
              (o.prototype.toHash = function () {
                return String.fromCharCode(
                  255 & this.lo,
                  (this.lo >>> 8) & 255,
                  (this.lo >>> 16) & 255,
                  this.lo >>> 24,
                  255 & this.hi,
                  (this.hi >>> 8) & 255,
                  (this.hi >>> 16) & 255,
                  this.hi >>> 24
                )
              }),
              (o.prototype.zzEncode = function () {
                var t2 = this.hi >> 31
                return (
                  (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ t2) >>> 0),
                  (this.lo = ((this.lo << 1) ^ t2) >>> 0),
                  this
                )
              }),
              (o.prototype.zzDecode = function () {
                var t2 = -(1 & this.lo)
                return (
                  (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ t2) >>> 0),
                  (this.hi = ((this.hi >>> 1) ^ t2) >>> 0),
                  this
                )
              }),
              (o.prototype.length = function () {
                var t2 = this.lo,
                  e2 = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
                  n2 = this.hi >>> 24
                return 0 === n2
                  ? 0 === e2
                    ? t2 < 16384
                      ? t2 < 128
                        ? 1
                        : 2
                      : t2 < 2097152
                        ? 3
                        : 4
                    : e2 < 16384
                      ? e2 < 128
                        ? 5
                        : 6
                      : e2 < 2097152
                        ? 7
                        : 8
                  : n2 < 128
                    ? 9
                    : 10
              }))
          },
          './protobufjs/src/util/minimal.js': function (t, e, n) {
            var i = e
            function o(t2, e2, n2) {
              for (var i2 = Object.keys(e2), o2 = 0; o2 < i2.length; ++o2)
                (void 0 !== t2[i2[o2]] && n2) || (t2[i2[o2]] = e2[i2[o2]])
              return t2
            }
            function r(t2) {
              function e2(t3, n2) {
                if (!(this instanceof e2)) return new e2(t3, n2)
                ;(Object.defineProperty(this, 'message', {
                  get: function () {
                    return t3
                  },
                }),
                  Error.captureStackTrace
                    ? Error.captureStackTrace(this, e2)
                    : Object.defineProperty(this, 'stack', { value: Error().stack || '' }),
                  n2 && o(this, n2))
              }
              return (
                (e2.prototype = Object.create(Error.prototype, {
                  constructor: { value: e2, writable: true, enumerable: false, configurable: true },
                  name: {
                    get: function () {
                      return t2
                    },
                    set: void 0,
                    enumerable: false,
                    configurable: true,
                  },
                  toString: {
                    value: function () {
                      return this.name + ': ' + this.message
                    },
                    writable: true,
                    enumerable: false,
                    configurable: true,
                  },
                })),
                e2
              )
            }
            ;((i.asPromise = n('./@protobufjs/aspromise/index.js')),
              (i.base64 = n('./@protobufjs/base64/index.js')),
              (i.EventEmitter = n('./@protobufjs/eventemitter/index.js')),
              (i.float = n('./@protobufjs/float/index.js')),
              (i.inquire = n('./@protobufjs/inquire/index.js')),
              (i.utf8 = n('./@protobufjs/utf8/index.js')),
              (i.pool = n('./@protobufjs/pool/index.js')),
              (i.LongBits = n('./protobufjs/src/util/longbits.js')),
              (i.isNode = !!(
                'undefined' != typeof global &&
                global &&
                global.process &&
                global.process.versions &&
                global.process.versions.node
              )),
              (i.global =
                (i.isNode && global) ||
                ('undefined' != typeof window && window) ||
                ('undefined' != typeof self && self) ||
                this),
              (i.emptyArray = Object.freeze ? Object.freeze([]) : []),
              (i.emptyObject = Object.freeze ? Object.freeze({}) : {}),
              (i.isInteger =
                Number.isInteger ||
                function (t2) {
                  return 'number' == typeof t2 && isFinite(t2) && Math.floor(t2) === t2
                }),
              (i.isString = function (t2) {
                return 'string' == typeof t2 || t2 instanceof String
              }),
              (i.isObject = function (t2) {
                return t2 && 'object' == typeof t2
              }),
              (i.isset = i.isSet =
                function (t2, e2) {
                  var n2 = t2[e2]
                  return (
                    !!(null != n2 && t2.hasOwnProperty(e2)) &&
                    ('object' != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0)
                  )
                }),
              (i.Buffer = (function () {
                try {
                  var t2 = i.inquire('buffer').Buffer
                  return t2.prototype.utf8Write ? t2 : null
                } catch (t3) {
                  return null
                }
              })()),
              (i._Buffer_from = null),
              (i._Buffer_allocUnsafe = null),
              (i.newBuffer = function (t2) {
                return 'number' == typeof t2
                  ? i.Buffer
                    ? i._Buffer_allocUnsafe(t2)
                    : new i.Array(t2)
                  : i.Buffer
                    ? i._Buffer_from(t2)
                    : 'undefined' == typeof Uint8Array
                      ? t2
                      : new Uint8Array(t2)
              }),
              (i.Array = 'undefined' != typeof Uint8Array ? Uint8Array : Array),
              (i.Long = (i.global.dcodeIO && i.global.dcodeIO.Long) || i.global.Long || i.inquire('long')),
              (i.key2Re = /^true|false|0|1$/),
              (i.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
              (i.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
              (i.longToHash = function (t2) {
                return t2 ? i.LongBits.from(t2).toHash() : i.LongBits.zeroHash
              }),
              (i.longFromHash = function (t2, e2) {
                var n2 = i.LongBits.fromHash(t2)
                return i.Long ? i.Long.fromBits(n2.lo, n2.hi, e2) : n2.toNumber(!!e2)
              }),
              (i.merge = o),
              (i.lcFirst = function (t2) {
                return t2.charAt(0).toLowerCase() + t2.substring(1)
              }),
              (i.newError = r),
              (i.ProtocolError = r('ProtocolError')),
              (i.oneOfGetter = function (t2) {
                for (var e2 = {}, n2 = 0; n2 < t2.length; ++n2) e2[t2[n2]] = 1
                return function () {
                  for (var t3 = Object.keys(this), n3 = t3.length - 1; n3 > -1; --n3)
                    if (1 === e2[t3[n3]] && void 0 !== this[t3[n3]] && null !== this[t3[n3]]) return t3[n3]
                }
              }),
              (i.oneOfSetter = function (t2) {
                return function (e2) {
                  for (var n2 = 0; n2 < t2.length; ++n2) t2[n2] !== e2 && delete this[t2[n2]]
                }
              }),
              (i.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }),
              (i._configure = function () {
                var t2 = i.Buffer
                if (!t2) {
                  i._Buffer_from = i._Buffer_allocUnsafe = null
                  return
                }
                ;((i._Buffer_from =
                  (t2.from !== Uint8Array.from && t2.from) ||
                  function (e2, n2) {
                    return new t2(e2, n2)
                  }),
                  (i._Buffer_allocUnsafe =
                    t2.allocUnsafe ||
                    function (e2) {
                      return new t2(e2)
                    }))
              }))
          },
          './protobufjs/src/writer.js': function (t, e, n) {
            t.exports = p
            var i,
              o = n('./protobufjs/src/util/minimal.js'),
              r = o.LongBits,
              s = o.base64,
              u = o.utf8
            function a(t2, e2, n2) {
              ;((this.fn = t2), (this.len = e2), (this.next = void 0), (this.val = n2))
            }
            function f() {}
            function c(t2) {
              ;((this.head = t2.head), (this.tail = t2.tail), (this.len = t2.len), (this.next = t2.states))
            }
            function p() {
              ;((this.len = 0), (this.head = new a(f, 0, 0)), (this.tail = this.head), (this.states = null))
            }
            var l = function () {
              return o.Buffer
                ? function () {
                    return (p.create = function () {
                      return new i()
                    })()
                  }
                : function () {
                    return new p()
                  }
            }
            function h(t2, e2, n2) {
              e2[n2] = 255 & t2
            }
            function d(t2, e2, n2) {
              for (; t2 > 127; ) ((e2[n2++] = (127 & t2) | 128), (t2 >>>= 7))
              e2[n2] = t2
            }
            function g(t2, e2) {
              ;((this.len = t2), (this.next = void 0), (this.val = e2))
            }
            function y(t2, e2, n2) {
              for (; t2.hi; )
                ((e2[n2++] = (127 & t2.lo) | 128), (t2.lo = ((t2.lo >>> 7) | (t2.hi << 25)) >>> 0), (t2.hi >>>= 7))
              for (; t2.lo > 127; ) ((e2[n2++] = (127 & t2.lo) | 128), (t2.lo = t2.lo >>> 7))
              e2[n2++] = t2.lo
            }
            function m(t2, e2, n2) {
              ;((e2[n2] = 255 & t2),
                (e2[n2 + 1] = (t2 >>> 8) & 255),
                (e2[n2 + 2] = (t2 >>> 16) & 255),
                (e2[n2 + 3] = t2 >>> 24))
            }
            ;((p.create = l()),
              (p.alloc = function (t2) {
                return new o.Array(t2)
              }),
              o.Array !== Array && (p.alloc = o.pool(p.alloc, o.Array.prototype.subarray)),
              (p.prototype._push = function (t2, e2, n2) {
                return ((this.tail = this.tail.next = new a(t2, e2, n2)), (this.len += e2), this)
              }),
              (g.prototype = Object.create(a.prototype)),
              (g.prototype.fn = d),
              (p.prototype.uint32 = function (t2) {
                return (
                  (this.len += (this.tail = this.tail.next =
                    new g((t2 >>>= 0) < 128 ? 1 : t2 < 16384 ? 2 : t2 < 2097152 ? 3 : t2 < 268435456 ? 4 : 5, t2)).len),
                  this
                )
              }),
              (p.prototype.int32 = function (t2) {
                return t2 < 0 ? this._push(y, 10, r.fromNumber(t2)) : this.uint32(t2)
              }),
              (p.prototype.sint32 = function (t2) {
                return this.uint32(((t2 << 1) ^ (t2 >> 31)) >>> 0)
              }),
              (p.prototype.uint64 = function (t2) {
                var e2 = r.from(t2)
                return this._push(y, e2.length(), e2)
              }),
              (p.prototype.int64 = p.prototype.uint64),
              (p.prototype.sint64 = function (t2) {
                var e2 = r.from(t2).zzEncode()
                return this._push(y, e2.length(), e2)
              }),
              (p.prototype.bool = function (t2) {
                return this._push(h, 1, +!!t2)
              }),
              (p.prototype.fixed32 = function (t2) {
                return this._push(m, 4, t2 >>> 0)
              }),
              (p.prototype.sfixed32 = p.prototype.fixed32),
              (p.prototype.fixed64 = function (t2) {
                var e2 = r.from(t2)
                return this._push(m, 4, e2.lo)._push(m, 4, e2.hi)
              }),
              (p.prototype.sfixed64 = p.prototype.fixed64),
              (p.prototype.float = function (t2) {
                return this._push(o.float.writeFloatLE, 4, t2)
              }),
              (p.prototype.double = function (t2) {
                return this._push(o.float.writeDoubleLE, 8, t2)
              }))
            var b = o.Array.prototype.set
              ? function (t2, e2, n2) {
                  e2.set(t2, n2)
                }
              : function (t2, e2, n2) {
                  for (var i2 = 0; i2 < t2.length; ++i2) e2[n2 + i2] = t2[i2]
                }
            ;((p.prototype.bytes = function (t2) {
              var e2 = t2.length >>> 0
              if (!e2) return this._push(h, 1, 0)
              if (o.isString(t2)) {
                var n2 = p.alloc((e2 = s.length(t2)))
                ;(s.decode(t2, n2, 0), (t2 = n2))
              }
              return this.uint32(e2)._push(b, e2, t2)
            }),
              (p.prototype.string = function (t2) {
                var e2 = u.length(t2)
                return e2 ? this.uint32(e2)._push(u.write, e2, t2) : this._push(h, 1, 0)
              }),
              (p.prototype.fork = function () {
                return ((this.states = new c(this)), (this.head = this.tail = new a(f, 0, 0)), (this.len = 0), this)
              }),
              (p.prototype.reset = function () {
                return (
                  this.states
                    ? ((this.head = this.states.head),
                      (this.tail = this.states.tail),
                      (this.len = this.states.len),
                      (this.states = this.states.next))
                    : ((this.head = this.tail = new a(f, 0, 0)), (this.len = 0)),
                  this
                )
              }),
              (p.prototype.ldelim = function () {
                var t2 = this.head,
                  e2 = this.tail,
                  n2 = this.len
                return (
                  this.reset().uint32(n2),
                  n2 && ((this.tail.next = t2.next), (this.tail = e2), (this.len += n2)),
                  this
                )
              }),
              (p.prototype.finish = function () {
                for (var t2 = this.head.next, e2 = this.constructor.alloc(this.len), n2 = 0; t2; )
                  (t2.fn(t2.val, e2, n2), (n2 += t2.len), (t2 = t2.next))
                return e2
              }),
              (p._configure = function (t2) {
                ;((i = t2), (p.create = l()), i._configure())
              }))
          },
          './protobufjs/src/writer_buffer.js': function (t, e, n) {
            t.exports = r
            var i = n('./protobufjs/src/writer.js')
            ;(r.prototype = Object.create(i.prototype)).constructor = r
            var o = n('./protobufjs/src/util/minimal.js')
            function r() {
              i.call(this)
            }
            function s(t2, e2, n2) {
              t2.length < 40 ? o.utf8.write(t2, e2, n2) : e2.utf8Write ? e2.utf8Write(t2, n2) : e2.write(t2, n2)
            }
            ;((r._configure = function () {
              ;((r.alloc = o._Buffer_allocUnsafe),
                (r.writeBytesBuffer =
                  o.Buffer && o.Buffer.prototype instanceof Uint8Array && 'set' === o.Buffer.prototype.set.name
                    ? function (t2, e2, n2) {
                        e2.set(t2, n2)
                      }
                    : function (t2, e2, n2) {
                        if (t2.copy) t2.copy(e2, n2, 0, t2.length)
                        else for (var i2 = 0; i2 < t2.length; ) e2[n2++] = t2[i2++]
                      }))
            }),
              (r.prototype.bytes = function (t2) {
                o.isString(t2) && (t2 = o._Buffer_from(t2, 'base64'))
                var e2 = t2.length >>> 0
                return (this.uint32(e2), e2 && this._push(r.writeBytesBuffer, e2, t2), this)
              }),
              (r.prototype.string = function (t2) {
                var e2 = o.Buffer.byteLength(t2)
                return (this.uint32(e2), e2 && this._push(s, e2, t2), this)
              }),
              r._configure())
          },
        },
        __webpack_module_cache__ = {}
      function __webpack_require__(t) {
        var e = __webpack_module_cache__[t]
        if (void 0 !== e) return e.exports
        var n = (__webpack_module_cache__[t] = { exports: {} })
        return (__webpack_modules__[t].call(n.exports, n, n.exports, __webpack_require__), n.exports)
      }
      var __webpack_exports__ = __webpack_require__('./@datadog/sketches-js/dist/index.js')
      module.exports = __webpack_exports__
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/histogram.js
var require_histogram = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/histogram.js'(exports2, module2) {
    'use strict'
    var { DDSketch } = require_sketches_js()
    var Histogram = class {
      constructor() {
        this.reset()
      }
      get min() {
        return this._sketch.count === 0 ? 0 : this._sketch.min
      }
      get max() {
        return this._sketch.count === 0 ? 0 : this._sketch.max
      }
      get avg() {
        return this._sketch.count === 0 ? 0 : this._sketch.sum / this._sketch.count
      }
      get sum() {
        return this._sketch.sum
      }
      get count() {
        return this._sketch.count
      }
      get median() {
        return this.percentile(50)
      }
      get p95() {
        return this.percentile(95)
      }
      percentile(percentile) {
        return this._sketch.getValueAtQuantile(percentile / 100) || 0
      }
      merge(histogram) {
        return this._sketch.merge(histogram._sketch)
      }
      record(value) {
        this._sketch.accept(value)
      }
      reset() {
        this._sketch = new DDSketch()
      }
    }
    module2.exports = Histogram
  },
})

// node_modules/dd-trace/packages/dd-trace/src/pkg.js
var require_pkg = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/pkg.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var path = require('path')
    function findRoot() {
      return require.main && require.main.filename ? path.dirname(require.main.filename) : process.cwd()
    }
    function findPkg() {
      const cwd = findRoot()
      const directory = path.resolve(cwd)
      const res = path.parse(directory)
      if (!res) return {}
      const { root } = res
      const filePath = findUp('package.json', root, directory)
      if (filePath === void 0) return {}
      try {
        return require(filePath)
      } catch {
        return {}
      }
    }
    function findUp(name, root, directory) {
      while (true) {
        const current = path.resolve(directory, name)
        if (fs.existsSync(current)) return current
        if (directory === root) return
        directory = path.dirname(directory)
      }
    }
    module2.exports = Object.assign(findPkg(), { findRoot, findUp })
  },
})

// node_modules/dd-trace/packages/dd-trace/src/constants.js
var require_constants2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/constants.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      SAMPLING_PRIORITY_KEY: '_sampling_priority_v1',
      ANALYTICS_KEY: '_dd1.sr.eausr',
      ORIGIN_KEY: '_dd.origin',
      HOSTNAME_KEY: '_dd.hostname',
      TOP_LEVEL_KEY: '_dd.top_level',
      SAMPLING_RULE_DECISION: '_dd.rule_psr',
      SAMPLING_LIMIT_DECISION: '_dd.limit_psr',
      SAMPLING_AGENT_DECISION: '_dd.agent_psr',
      SAMPLING_MECHANISM_DEFAULT: 0,
      SAMPLING_MECHANISM_AGENT: 1,
      SAMPLING_MECHANISM_RULE: 3,
      SAMPLING_MECHANISM_MANUAL: 4,
      SAMPLING_MECHANISM_APPSEC: 5,
      SAMPLING_MECHANISM_SPAN: 8,
      SAMPLING_MECHANISM_REMOTE_USER: 11,
      SAMPLING_MECHANISM_REMOTE_DYNAMIC: 12,
      SPAN_SAMPLING_MECHANISM: '_dd.span_sampling.mechanism',
      SPAN_SAMPLING_RULE_RATE: '_dd.span_sampling.rule_rate',
      SPAN_SAMPLING_MAX_PER_SECOND: '_dd.span_sampling.max_per_second',
      DATADOG_LAMBDA_EXTENSION_PATH: '/opt/extensions/datadog-agent',
      DECISION_MAKER_KEY: '_dd.p.dm',
      PROCESS_ID: 'process_id',
      ERROR_TYPE: 'error.type',
      ERROR_MESSAGE: 'error.message',
      ERROR_STACK: 'error.stack',
      IGNORE_OTEL_ERROR: /* @__PURE__ */ Symbol('ignore.otel.error'),
      COMPONENT: 'component',
      CLIENT_PORT_KEY: 'network.destination.port',
      PEER_SERVICE_KEY: 'peer.service',
      PEER_SERVICE_SOURCE_KEY: '_dd.peer.service.source',
      PEER_SERVICE_REMAP_KEY: '_dd.peer.service.remapped_from',
      SCI_REPOSITORY_URL: '_dd.git.repository_url',
      SCI_COMMIT_SHA: '_dd.git.commit.sha',
      APM_TRACING_ENABLED_KEY: '_dd.apm.enabled',
      TRACE_SOURCE_PROPAGATION_KEY: '_dd.p.ts',
      PAYLOAD_TAG_REQUEST_PREFIX: 'aws.request.body',
      PAYLOAD_TAG_RESPONSE_PREFIX: 'aws.response.body',
      PAYLOAD_TAGGING_MAX_TAGS: 758,
      SCHEMA_DEFINITION: 'schema.definition',
      SCHEMA_WEIGHT: 'schema.weight',
      SCHEMA_TYPE: 'schema.type',
      SCHEMA_ID: 'schema.id',
      SCHEMA_TOPIC: 'schema.topic',
      SCHEMA_OPERATION: 'schema.operation',
      SCHEMA_NAME: 'schema.name',
      GRPC_CLIENT_ERROR_STATUSES: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
      GRPC_SERVER_ERROR_STATUSES: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
      DYNAMODB_PTR_KIND: 'aws.dynamodb.item',
      S3_PTR_KIND: 'aws.s3.object',
      SPAN_POINTER_DIRECTION: Object.freeze({
        UPSTREAM: 'u',
        DOWNSTREAM: 'd',
      }),
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/config_defaults.js
var require_config_defaults = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/config_defaults.js'(exports2, module2) {
    'use strict'
    var pkg = require_pkg()
    var { GRPC_CLIENT_ERROR_STATUSES, GRPC_SERVER_ERROR_STATUSES } = require_constants2()
    var { getEnvironmentVariable: getEnv } = require_config_helper()
    var qsRegex = String.raw`(?:p(?:ass)?w(?:or)?d|pass(?:_?phrase)?|secret|(?:api_?|private_?|public_?|access_?|secret_?)key(?:_?id)?|token|consumer_?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?)(?:(?:\s|%20)*(?:=|%3D)[^&]+|(?:"|%22)(?:\s|%20)*(?::|%3A)(?:\s|%20)*(?:"|%22)(?:%2[^2]|%[^2]|[^"%])+(?:"|%22))|bearer(?:\s|%20)+[a-z0-9\._\-]+|token(?::|%3A)[a-z0-9]{13}|gh[opsu]_[0-9a-zA-Z]{36}|ey[I-L](?:[\w=-]|%3D)+\.ey[I-L](?:[\w=-]|%3D)+(?:\.(?:[\w.+\/=-]|%3D|%2F|%2B)+)?|[\-]{5}BEGIN(?:[a-z\s]|%20)+PRIVATE(?:\s|%20)KEY[\-]{5}[^\-]+[\-]{5}END(?:[a-z\s]|%20)+PRIVATE(?:\s|%20)KEY|ssh-rsa(?:\s|%20)*(?:[a-z0-9\/\.+]|%2F|%5C|%2B){100,}`
    var defaultWafObfuscatorKeyRegex = String.raw`(?i)pass|pw(?:or)?d|secret|(?:api|private|public|access)[_-]?key|token|consumer[_-]?(?:id|key|secret)|sign(?:ed|ature)|bearer|authorization|jsessionid|phpsessid|asp\.net[_-]sessionid|sid|jwt`
    var defaultWafObfuscatorValueRegex = String.raw`(?i)(?:p(?:ass)?w(?:or)?d|pass(?:[_-]?phrase)?|secret(?:[_-]?key)?|(?:(?:api|private|public|access)[_-]?)key(?:[_-]?id)?|(?:(?:auth|access|id|refresh)[_-]?)?token|consumer[_-]?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?|jsessionid|phpsessid|asp\.net(?:[_-]|-)sessionid|sid|jwt)(?:\s*=([^;&]+)|"\s*:\s*("[^"]+"|\d+))|bearer\s+([a-z0-9\._\-]+)|token\s*:\s*([a-z0-9]{13})|gh[opsu]_([0-9a-zA-Z]{36})|ey[I-L][\w=-]+\.(ey[I-L][\w=-]+(?:\.[\w.+\/=-]+)?)|[\-]{5}BEGIN[a-z\s]+PRIVATE\sKEY[\-]{5}([^\-]+)[\-]{5}END[a-z\s]+PRIVATE\sKEY|ssh-rsa\s*([a-z0-9\/\.+]{100,})`
    var service =
      getEnv('AWS_LAMBDA_FUNCTION_NAME') ||
      getEnv('FUNCTION_NAME') || // Google Cloud Function Name set by deprecated runtimes
      getEnv('K_SERVICE') || // Google Cloud Function Name set by newer runtimes
      getEnv('WEBSITE_SITE_NAME') || // set by Azure Functions
      pkg.name ||
      'node'
    module2.exports = {
      apiKey: void 0,
      appKey: void 0,
      apmTracingEnabled: true,
      'appsec.apiSecurity.enabled': true,
      'appsec.apiSecurity.sampleDelay': 30,
      'appsec.apiSecurity.endpointCollectionEnabled': true,
      'appsec.apiSecurity.endpointCollectionMessageLimit': 300,
      'appsec.blockedTemplateGraphql': void 0,
      'appsec.blockedTemplateHtml': void 0,
      'appsec.blockedTemplateJson': void 0,
      'appsec.enabled': void 0,
      'appsec.eventTracking.mode': 'identification',
      // TODO appsec.extendedHeadersCollection is deprecated, to delete in a major
      'appsec.extendedHeadersCollection.enabled': false,
      'appsec.extendedHeadersCollection.redaction': true,
      'appsec.extendedHeadersCollection.maxHeaders': 50,
      'appsec.obfuscatorKeyRegex': defaultWafObfuscatorKeyRegex,
      'appsec.obfuscatorValueRegex': defaultWafObfuscatorValueRegex,
      'appsec.rasp.enabled': true,
      // TODO Deprecated, to delete in a major
      'appsec.rasp.bodyCollection': false,
      'appsec.rateLimit': 100,
      'appsec.rules': void 0,
      'appsec.sca.enabled': null,
      'appsec.stackTrace.enabled': true,
      'appsec.stackTrace.maxDepth': 32,
      'appsec.stackTrace.maxStackTraces': 2,
      'appsec.wafTimeout': 5e3,
      // s
      baggageMaxBytes: 8192,
      baggageMaxItems: 64,
      baggageTagKeys: 'user.id,session.id,account.id',
      clientIpEnabled: false,
      clientIpHeader: null,
      'cloudPayloadTagging.requestsEnabled': false,
      'cloudPayloadTagging.responsesEnabled': false,
      'cloudPayloadTagging.maxDepth': 10,
      'cloudPayloadTagging.rules': [],
      'crashtracking.enabled': true,
      'codeOriginForSpans.enabled': true,
      'codeOriginForSpans.experimental.exit_spans.enabled': false,
      dbmPropagationMode: 'disabled',
      'dogstatsd.hostname': '127.0.0.1',
      'dogstatsd.port': '8125',
      dsmEnabled: false,
      'dynamicInstrumentation.captureTimeoutMs': 15,
      'dynamicInstrumentation.enabled': false,
      'dynamicInstrumentation.probeFile': void 0,
      'dynamicInstrumentation.redactedIdentifiers': [],
      'dynamicInstrumentation.redactionExcludedIdentifiers': [],
      'dynamicInstrumentation.uploadIntervalSeconds': 1,
      env: void 0,
      'experimental.aiguard.enabled': false,
      'experimental.aiguard.endpoint': void 0,
      'experimental.aiguard.maxMessagesLength': 16,
      'experimental.aiguard.maxContentSize': 512 * 1024,
      'experimental.aiguard.timeout': 1e4,
      // ms
      'experimental.enableGetRumData': false,
      'experimental.exporter': void 0,
      'experimental.flaggingProvider.enabled': false,
      'experimental.flaggingProvider.initializationTimeoutMs': 3e4,
      flushInterval: 2e3,
      flushMinSpans: 1e3,
      gitMetadataEnabled: true,
      graphqlErrorExtensions: [],
      'grpc.client.error.statuses': GRPC_CLIENT_ERROR_STATUSES,
      'grpc.server.error.statuses': GRPC_SERVER_ERROR_STATUSES,
      headerTags: [],
      'heapSnapshot.count': 0,
      'heapSnapshot.destination': '',
      'heapSnapshot.interval': 3600,
      hostname: '127.0.0.1',
      'iast.dbRowsToTaint': 1,
      'iast.deduplicationEnabled': true,
      'iast.enabled': false,
      'iast.maxConcurrentRequests': 2,
      'iast.maxContextOperations': 2,
      'iast.redactionEnabled': true,
      'iast.redactionNamePattern': null,
      'iast.redactionValuePattern': null,
      'iast.requestSampling': 30,
      'iast.securityControlsConfiguration': null,
      'iast.telemetryVerbosity': 'INFORMATION',
      'iast.stackTrace.enabled': true,
      injectionEnabled: [],
      'installSignature.id': null,
      'installSignature.time': null,
      'installSignature.type': null,
      instrumentationSource: 'manual',
      injectForce: null,
      isAzureFunction: false,
      isCiVisibility: false,
      isEarlyFlakeDetectionEnabled: false,
      isFlakyTestRetriesEnabled: false,
      flakyTestRetriesCount: 5,
      isGCPFunction: false,
      isGitUploadEnabled: false,
      isIntelligentTestRunnerEnabled: false,
      isManualApiEnabled: false,
      'langchain.spanCharLimit': 128,
      'langchain.spanPromptCompletionSampleRate': 1,
      'llmobs.agentlessEnabled': void 0,
      'llmobs.enabled': false,
      'llmobs.mlApp': void 0,
      ciVisibilityTestSessionName: '',
      ciVisAgentlessLogSubmissionEnabled: false,
      legacyBaggageEnabled: true,
      isTestDynamicInstrumentationEnabled: false,
      isServiceUserProvided: false,
      testManagementAttemptToFixRetries: 20,
      isTestManagementEnabled: false,
      isImpactedTestsEnabled: false,
      logInjection: true,
      otelLogsEnabled: false,
      otelUrl: void 0,
      otelLogsUrl: void 0,
      // Will be computed using agent host
      otelHeaders: void 0,
      otelLogsHeaders: '',
      otelProtocol: 'http/protobuf',
      otelLogsProtocol: 'http/protobuf',
      otelLogsTimeout: 1e4,
      otelTimeout: 1e4,
      otelBatchTimeout: 5e3,
      otelMaxExportBatchSize: 512,
      otelMaxQueueSize: 2048,
      otelMetricsEnabled: false,
      otelMetricsUrl: void 0,
      // Will be computed using agent host
      otelMetricsHeaders: '',
      otelMetricsProtocol: 'http/protobuf',
      otelMetricsTimeout: 1e4,
      otelMetricsExportTimeout: 7500,
      otelMetricsExportInterval: 1e4,
      otelMetricsTemporalityPreference: 'DELTA',
      // DELTA, CUMULATIVE, or LOWMEMORY
      lookup: void 0,
      inferredProxyServicesEnabled: false,
      memcachedCommandEnabled: false,
      middlewareTracingEnabled: true,
      openAiLogsEnabled: false,
      'openai.spanCharLimit': 128,
      peerServiceMapping: {},
      plugins: true,
      port: '8126',
      'profiling.enabled': void 0,
      'propagateProcessTags.enabled': void 0,
      'profiling.exporters': 'agent',
      'profiling.sourceMap': true,
      'profiling.longLivedThreshold': void 0,
      protocolVersion: '0.4',
      queryStringObfuscation: qsRegex,
      'remoteConfig.enabled': true,
      'remoteConfig.pollInterval': 5,
      // seconds
      reportHostname: false,
      resourceRenamingEnabled: false,
      'runtimeMetrics.enabled': false,
      'runtimeMetrics.eventLoop': true,
      'runtimeMetrics.gc': true,
      runtimeMetricsRuntimeId: false,
      sampleRate: void 0,
      'sampler.rateLimit': 100,
      'sampler.rules': [],
      'sampler.spanSamplingRules': [],
      scope: void 0,
      service,
      serviceMapping: {},
      site: 'datadoghq.com',
      spanAttributeSchema: 'v0',
      spanComputePeerService: false,
      spanLeakDebug: 0,
      spanRemoveIntegrationFromService: false,
      startupLogs: false,
      'stats.enabled': false,
      tags: {},
      tagsHeaderMaxLength: 512,
      'telemetry.debug': false,
      'telemetry.dependencyCollection': true,
      'telemetry.enabled': true,
      'telemetry.heartbeatInterval': 6e4,
      'telemetry.logCollection': true,
      'telemetry.metrics': true,
      traceEnabled: true,
      traceId128BitGenerationEnabled: true,
      traceId128BitLoggingEnabled: true,
      tracePropagationExtractFirst: false,
      tracePropagationBehaviorExtract: 'continue',
      'tracePropagationStyle.inject': ['datadog', 'tracecontext', 'baggage'],
      'tracePropagationStyle.extract': ['datadog', 'tracecontext', 'baggage'],
      'tracePropagationStyle.otelPropagators': false,
      traceWebsocketMessagesEnabled: false,
      traceWebsocketMessagesInheritSampling: true,
      traceWebsocketMessagesSeparateTraces: true,
      tracing: true,
      url: void 0,
      version: pkg.version,
      instrumentation_config_id: void 0,
      'vertexai.spanCharLimit': 128,
      'vertexai.spanPromptCompletionSampleRate': 1,
      'trace.aws.addSpanPointers': true,
      'trace.dynamoDb.tablePrimaryKeys': void 0,
      'trace.nativeSpanEvents': false,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js
var require_dogstatsd2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js'(exports2, module2) {
    'use strict'
    var lookup = require('dns').lookup
    var request = require_request()
    var dgram = require('dgram')
    var isIP = require('net').isIP
    var log = require_log2()
    var { URL: URL2, format } = require('url')
    var Histogram = require_histogram()
    var defaults = require_config_defaults()
    var MAX_BUFFER_SIZE = 1024
    var TYPE_COUNTER = 'c'
    var TYPE_GAUGE = 'g'
    var TYPE_DISTRIBUTION = 'd'
    var TYPE_HISTOGRAM = 'h'
    var DogStatsDClient = class {
      constructor(options = {}) {
        if (options.metricsProxyUrl) {
          this._httpOptions = {
            url: options.metricsProxyUrl.toString(),
            path: '/dogstatsd/v2/proxy',
          }
        }
        this._host = options.host || defaults['dogstatsd.hostname']
        this._family = isIP(this._host)
        this._port = options.port || defaults['dogstatsd.port']
        this._prefix = options.prefix || ''
        this._tags = options.tags || []
        this._queue = []
        this._buffer = ''
        this._offset = 0
        this._udp4 = this._socket('udp4')
        this._udp6 = this._socket('udp6')
      }
      increment(stat, value, tags) {
        this._add(stat, value, TYPE_COUNTER, tags)
      }
      decrement(stat, value, tags) {
        this._add(stat, -value, TYPE_COUNTER, tags)
      }
      gauge(stat, value, tags) {
        this._add(stat, value, TYPE_GAUGE, tags)
      }
      distribution(stat, value, tags) {
        this._add(stat, value, TYPE_DISTRIBUTION, tags)
      }
      histogram(stat, value, tags) {
        this._add(stat, value, TYPE_HISTOGRAM, tags)
      }
      flush() {
        const queue = this._enqueue()
        log.debug('Flushing %s metrics via', queue.length, this._httpOptions ? 'HTTP' : 'UDP')
        if (this._queue.length === 0) return
        this._queue = []
        if (this._httpOptions) {
          this._sendHttp(queue)
        } else {
          this._sendUdp(queue)
        }
      }
      _sendHttp(queue) {
        const buffer = Buffer.concat(queue)
        request(buffer, this._httpOptions, (err) => {
          if (err) {
            log.error('DogStatsDClient: HTTP error from agent: %s', err.message, err)
            if (err.status === 404) {
              this._httpOptions = void 0
            }
            this._sendUdp(queue)
          }
        })
      }
      _sendUdp(queue) {
        if (this._family === 0) {
          lookup(this._host, (err, address, family) => {
            if (err) return log.error('DogStatsDClient: Host not found', err)
            this._sendUdpFromQueue(queue, address, family)
          })
        } else {
          this._sendUdpFromQueue(queue, this._host, this._family)
        }
      }
      _sendUdpFromQueue(queue, address, family) {
        const socket = family === 6 ? this._udp6 : this._udp4
        queue.forEach((buffer) => {
          log.debug('Sending to DogStatsD: %s', buffer)
          socket.send(buffer, 0, buffer.length, this._port, address)
        })
      }
      _add(stat, value, type, tags) {
        const message = `${this._prefix + stat}:${value}|${type}`
        tags = tags ? [...this._tags, ...tags] : this._tags
        if (tags.length > 0) {
          this._write(`${message}|#${tags.join(',')}
`)
        } else {
          this._write(`${message}
`)
        }
      }
      _write(message) {
        const offset = Buffer.byteLength(message)
        if (this._offset + offset > MAX_BUFFER_SIZE) {
          this._enqueue()
        }
        this._offset += offset
        this._buffer += message
      }
      _enqueue() {
        if (this._offset > 0) {
          this._queue.push(Buffer.from(this._buffer))
          this._buffer = ''
          this._offset = 0
        }
        return this._queue
      }
      _socket(type) {
        const socket = dgram.createSocket(type)
        socket.on('error', () => {})
        socket.unref()
        return socket
      }
      static generateClientConfig(config) {
        const tags = []
        if (config.tags) {
          for (const [key, value] of Object.entries(config.tags)) {
            if (typeof value === 'string' && (key !== 'runtime-id' || config.runtimeMetricsRuntimeId)) {
              const valueStripped = value.replaceAll(/[^a-z0-9_:./-]/gi, '_')
              tags.push(`${key}:${valueStripped}`)
            }
          }
        }
        const clientConfig = {
          host: config.dogstatsd.hostname,
          port: config.dogstatsd.port,
          tags,
        }
        if (config.url) {
          clientConfig.metricsProxyUrl = config.url
        } else if (config.port) {
          clientConfig.metricsProxyUrl = new URL2(
            format({
              protocol: 'http:',
              hostname: config.hostname || defaults.hostname,
              port: config.port,
            })
          )
        }
        return clientConfig
      }
    }
    var MetricsAggregationClient = class {
      constructor(client) {
        this._client = client
        this.reset()
      }
      flush() {
        this._captureCounters()
        this._captureGauges()
        this._captureHistograms()
        this._client.flush()
      }
      reset() {
        this._counters = /* @__PURE__ */ new Map()
        this._gauges = /* @__PURE__ */ new Map()
        this._histograms = /* @__PURE__ */ new Map()
      }
      // TODO: Aggregate with a histogram and send the buckets to the client.
      distribution(name, value, tags) {
        this._client.distribution(name, value, tags)
      }
      boolean(name, value, tags) {
        this.gauge(name, value ? 1 : 0, tags)
      }
      histogram(name, value, tags) {
        const node = this._ensureTree(this._histograms, name, tags, null)
        if (!node.value) {
          node.value = new Histogram()
        }
        node.value.record(value)
      }
      count(name, count, tags = [], monotonic = true) {
        if (typeof tags === 'boolean') {
          monotonic = tags
          tags = []
        }
        const container = monotonic ? this._counters : this._gauges
        const node = this._ensureTree(container, name, tags, 0)
        node.value += count
      }
      gauge(name, value, tags) {
        const node = this._ensureTree(this._gauges, name, tags, 0)
        node.value = value
      }
      increment(name, count = 1, tags) {
        this.count(name, count, tags)
      }
      decrement(name, count = 1, tags) {
        this.count(name, -count, tags)
      }
      _captureGauges() {
        this._captureTree(this._gauges, (node, name, tags) => {
          this._client.gauge(name, node.value, tags)
        })
      }
      _captureCounters() {
        this._captureTree(this._counters, (node, name, tags) => {
          this._client.increment(name, node.value, tags)
        })
        this._counters.clear()
      }
      _captureHistograms() {
        this._captureTree(this._histograms, (node, name, tags) => {
          let stats = node.value
          if (stats.count === 0) {
            stats = { max: 0, min: 0, sum: 0, avg: 0, median: 0, p95: 0, count: 0 }
          }
          this._client.gauge(`${name}.min`, stats.min, tags)
          this._client.gauge(`${name}.max`, stats.max, tags)
          this._client.increment(`${name}.sum`, stats.sum, tags)
          this._client.increment(`${name}.total`, stats.sum, tags)
          this._client.gauge(`${name}.avg`, stats.avg, tags)
          this._client.increment(`${name}.count`, stats.count, tags)
          this._client.gauge(`${name}.median`, stats.median, tags)
          this._client.gauge(`${name}.95percentile`, stats.p95, tags)
          node.value.reset()
        })
      }
      _captureTree(tree, fn) {
        for (const [name, root] of tree) {
          this._captureNode(root, name, [], fn)
        }
      }
      _captureNode(node, name, tags, fn) {
        if (node.touched) {
          fn(node, name, tags)
        }
        for (const [tag, next] of node.nodes) {
          tags.push(tag)
          this._captureNode(next, name, tags, fn)
          tags.pop()
        }
      }
      _ensureTree(tree, name, tags = [], value) {
        if (!Array.isArray(tags)) {
          tags = [tags]
        }
        let node = this._ensureNode(tree, name, value)
        for (const tag of tags) {
          node = this._ensureNode(node.nodes, tag, value)
        }
        node.touched = true
        return node
      }
      _ensureNode(container, key, value) {
        let node = container.get(key)
        if (!node) {
          node = { nodes: /* @__PURE__ */ new Map(), touched: false, value }
          if (typeof key === 'string') {
            container.set(key, node)
          }
        }
        return node
      }
    }
    var CustomMetrics = class _CustomMetrics {
      #client
      constructor(config) {
        const clientConfig = DogStatsDClient.generateClientConfig(config)
        this.#client = new MetricsAggregationClient(new DogStatsDClient(clientConfig))
        const flush = this.flush.bind(this)
        setInterval(flush, 10 * 1e3).unref()
        process.once('beforeExit', flush)
      }
      increment(stat, value = 1, tags) {
        this.#client.increment(stat, value, _CustomMetrics.tagTranslator(tags))
      }
      decrement(stat, value = 1, tags) {
        this.#client.decrement(stat, value, _CustomMetrics.tagTranslator(tags))
      }
      gauge(stat, value, tags) {
        this.#client.gauge(stat, value, _CustomMetrics.tagTranslator(tags))
      }
      distribution(stat, value, tags) {
        this.#client.distribution(stat, value, _CustomMetrics.tagTranslator(tags))
      }
      histogram(stat, value, tags) {
        this.#client.histogram(stat, value, _CustomMetrics.tagTranslator(tags))
      }
      flush() {
        return this.#client.flush()
      }
      /**
       * Exposing { tagName: 'tagValue' } to the end user
       * These are translated into [ 'tagName:tagValue' ] for internal use
       */
      static tagTranslator(objTags) {
        if (Array.isArray(objTags)) return objTags
        const arrTags = []
        if (!objTags) return arrTags
        for (const [key, value] of Object.entries(objTags)) {
          arrTags.push(`${key}:${value}`)
        }
        return arrTags
      }
    }
    module2.exports = {
      DogStatsDClient,
      CustomMetrics,
      MetricsAggregationClient,
    }
  },
})

// node_modules/dd-trace/package.json
var require_package = __commonJS({
  'node_modules/dd-trace/package.json'(exports2, module2) {
    module2.exports = {
      name: 'dd-trace',
      version: '6.0.0-pre',
      description: 'Datadog APM tracing client for JavaScript',
      main: 'index.js',
      typings: 'index.d.ts',
      scripts: {
        env: 'bash ./plugin-env',
        preinstall: 'node scripts/preinstall.js',
        bench: 'node benchmark/index.js',
        'bench:e2e:test-optimization': 'node benchmark/e2e-test-optimization/benchmark-run.js',
        'dependencies:dedupe': 'yarn-deduplicate yarn.lock',
        'type:check': 'tsc --noEmit -p tsconfig.dev.json',
        'type:doc:build': 'cd docs && yarn && yarn build',
        'type:doc:test': 'cd docs && yarn && yarn test',
        lint: 'node scripts/check_licenses.js && eslint . --concurrency=auto --max-warnings 0',
        'lint:fix': 'node scripts/check_licenses.js && eslint . --concurrency=auto --max-warnings 0 --fix',
        'lint:inspect': 'npx @eslint/config-inspector@latest',
        'release:proposal': 'node scripts/release/proposal',
        services: 'node ./scripts/install_plugin_modules && node packages/dd-trace/test/setup/services',
        test: "SERVICES=* yarn services && mocha --expose-gc 'packages/dd-trace/test/setup/node.js' 'packages/*/test/**/*.spec.js'",
        'test:aiguard':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/aiguard/**/*.spec.js"',
        'test:aiguard:ci': 'nyc --no-clean --include "packages/dd-trace/src/aiguard/**/*.js" -- npm run test:aiguard',
        'test:appsec':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" --exclude "packages/dd-trace/test/appsec/**/*.plugin.spec.js" "packages/dd-trace/test/appsec/**/*.spec.js"',
        'test:appsec:ci':
          'nyc --no-clean --include "packages/dd-trace/src/appsec/**/*.js" --exclude "packages/dd-trace/test/appsec/**/*.plugin.spec.js" -- npm run test:appsec',
        'test:appsec:plugins':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/appsec/**/*.@($(echo $PLUGINS)).plugin.spec.js"',
        'test:appsec:plugins:ci':
          'yarn services && nyc --no-clean --include "packages/dd-trace/src/appsec/**/*.js" -- npm run test:appsec:plugins',
        'test:debugger':
          "mocha -r 'packages/dd-trace/test/setup/mocha.js' 'packages/dd-trace/test/debugger/**/*.spec.js'",
        'test:debugger:ci':
          "nyc --no-clean --include 'packages/dd-trace/src/debugger/**/*.js' -- npm run test:debugger",
        'test:eslint-rules': 'node eslint-rules/*.test.mjs',
        'test:trace:core':
          'tap packages/dd-trace/test/*.spec.js "packages/dd-trace/test/{ci-visibility,datastreams,encode,exporters,opentelemetry,opentracing,plugins,remote_config,service-naming,standalone,telemetry,external-logger}/**/*.spec.js"',
        'test:trace:core:ci':
          'npm run test:trace:core -- --coverage --nyc-arg=--include="packages/dd-trace/src/**/*.js"',
        'test:trace:guardrails':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/guardrails/**/*.spec.js"',
        'test:trace:guardrails:ci':
          'nyc --no-clean --include "packages/dd-trace/src/guardrails/**/*.js" -- npm run test:trace:guardrails',
        'test:esbuild': 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-esbuild/test/**/*.spec.js"',
        'test:esbuild:ci': 'nyc --no-clean --include "packages/datadog-esbuild/test/**/*.js" -- npm run test:esbuild',
        'test:instrumentations': `mocha -r 'packages/dd-trace/test/setup/mocha.js' "packages/datadog-instrumentations/test/@($(echo $PLUGINS)).spec.js"`,
        'test:instrumentations:ci':
          'yarn services && nyc --no-clean --include "packages/datadog-instrumentations/src/@($(echo $PLUGINS)).js" --include "packages/datadog-instrumentations/src/@($(echo $PLUGINS))/**/*.js" -- npm run test:instrumentations',
        'test:instrumentations:misc':
          "mocha -r 'packages/dd-trace/test/setup/mocha.js' 'packages/datadog-instrumentations/test/*/**/*.spec.js'",
        'test:instrumentations:misc:ci':
          "nyc --no-clean --include 'packages/datadog-instrumentations/src/**/*.js' -- npm run test:instrumentations:misc",
        'test:core': 'tap "packages/datadog-core/test/**/*.spec.js"',
        'test:core:ci': 'npm run test:core -- --coverage --nyc-arg=--include="packages/datadog-core/src/**/*.js"',
        'test:lambda': 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/lambda/**/*.spec.js"',
        'test:lambda:ci': 'nyc --no-clean --include "packages/dd-trace/src/lambda/**/*.js" -- npm run test:lambda',
        'test:llmobs:sdk':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" --exclude "packages/dd-trace/test/llmobs/plugins/**/*.spec.js" "packages/dd-trace/test/llmobs/**/*.spec.js" ',
        'test:llmobs:sdk:ci':
          'nyc --no-clean --include "packages/dd-trace/src/llmobs/**/*.js" -- npm run test:llmobs:sdk',
        'test:llmobs:plugins':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/llmobs/plugins/@($(echo $PLUGINS))/*.spec.js"',
        'test:llmobs:plugins:ci':
          'yarn services && nyc --no-clean --include "packages/dd-trace/src/llmobs/**/*.js" -- npm run test:llmobs:plugins',
        'test:openfeature':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/openfeature/*.spec.js"',
        'test:openfeature:ci':
          'nyc --no-clean --include "packages/dd-trace/src/openfeature/**/*.js" -- npm run test:openfeature',
        'test:plugins': `mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-plugin-@($(echo $PLUGINS))/test/**/@($(echo \${SPEC:-'*'})).spec.js"`,
        'test:plugins:ci':
          'yarn services && nyc --no-clean --include "packages/datadog-plugin-@($(echo $PLUGINS))/src/**/*.js" -- npm run test:plugins',
        'test:plugins:ci:flaky':
          'yarn services && nyc --no-clean --include "packages/datadog-plugin-@($(echo $PLUGINS))/src/**/*.js" -- npm run test:plugins -- --bail --retries 2',
        'test:plugins:upstream': 'node ./packages/dd-trace/test/plugins/suite.js',
        'test:profiler': 'tap "packages/dd-trace/test/profiling/**/*.spec.js"',
        'test:profiler:ci':
          'npm run test:profiler -- --coverage --nyc-arg=--include="packages/dd-trace/src/profiling/**/*.js"',
        'test:integration':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/*.spec.js"',
        'test:integration:aiguard':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/aiguard/*.spec.js"',
        'test:integration:appsec':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/appsec/*.spec.js"',
        'test:integration:cucumber':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/cucumber/*.spec.js"',
        'test:integration:cypress':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/cypress/*.spec.js"',
        'test:integration:debugger':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/debugger/*.spec.js"',
        'test:integration:esbuild':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/esbuild/*.spec.js"',
        'test:integration:openfeature':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/openfeature/*.spec.js"',
        'test:integration:jest':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/jest/*.spec.js"',
        'test:integration:mocha':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/mocha/*.spec.js"',
        'test:integration:playwright':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/playwright/*.spec.js"',
        'test:integration:selenium':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/selenium/*.spec.js"',
        'test:integration:vitest':
          'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/vitest/*.spec.js"',
        'test:integration:testopt':
          'mocha --timeout 120000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/ci-visibility/*.spec.js"',
        'test:integration:profiler':
          'mocha --timeout 180000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/profiler/*.spec.js"',
        'test:integration:plugins':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-plugin-@($(echo $PLUGINS))/test/integration-test/**/*.spec.js"',
        'test:unit:plugins':
          'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-instrumentations/test/@($(echo $PLUGINS)).spec.js" "packages/datadog-plugin-@($(echo $PLUGINS))/test/**/*.spec.js" --exclude "packages/datadog-plugin-@($(echo $PLUGINS))/test/integration-test/**/*.spec.js"',
        'test:shimmer': "mocha 'packages/datadog-shimmer/test/**/*.spec.js'",
        'test:shimmer:ci': "nyc --no-clean --include 'packages/datadog-shimmer/src/**/*.js' -- npm run test:shimmer",
      },
      repository: {
        type: 'git',
        url: 'git+https://github.com/DataDog/dd-trace-js.git',
      },
      keywords: ['datadog', 'trace', 'tracing', 'profile', 'profiler', 'profiling', 'opentracing', 'apm'],
      author: 'Datadog Inc. <info@datadoghq.com>',
      license: '(Apache-2.0 OR BSD-3-Clause)',
      bugs: {
        url: 'https://github.com/DataDog/dd-trace-js/issues',
      },
      homepage: 'https://github.com/DataDog/dd-trace-js#readme',
      engines: {
        node: '>=18',
      },
      files: [
        '/package.json',
        'ci/**/*',
        'cypress/**/*',
        'esbuild.js',
        'ext/**/*',
        'index.d.ts',
        'index.js',
        'init.js',
        'initialize.mjs',
        'LICENSE-3rdparty.csv',
        'LICENSE',
        'LICENSE.Apache',
        'LICENSE.BSD3',
        'loader-hook.mjs',
        'packages/*/index.js',
        'packages/*/lib/**/*',
        'packages/*/src/**/*',
        'packages/datadog-instrumentations/orchestrion.yml',
        'README.md',
        'register.js',
        'scripts/preinstall.js',
        'vendor/dist/**/*.d.ts',
        'vendor/dist/**/*.js',
        'vendor/dist/**/*.wasm',
        'vendor/dist/**/LICENSE',
        'version.js',
      ],
      dependencies: {
        'dc-polyfill': '^0.1.10',
        'import-in-the-middle': '^1.14.2',
      },
      optionalDependencies: {
        '@datadog/libdatadog': '0.7.0',
        '@datadog/native-appsec': '10.3.0',
        '@datadog/native-iast-taint-tracking': '4.1.0',
        '@datadog/native-metrics': '3.1.1',
        '@datadog/openfeature-node-server': '^0.2.0',
        '@datadog/pprof': '5.12.0',
        '@datadog/wasm-js-rewriter': '5.0.1',
        '@opentelemetry/api': '>=1.0.0 <1.10.0',
        '@opentelemetry/api-logs': '<1.0.0',
      },
      devDependencies: {
        '@babel/helpers': '^7.28.4',
        '@eslint/eslintrc': '^3.3.1',
        '@eslint/js': '^9.39.0',
        '@msgpack/msgpack': '^3.1.2',
        '@openfeature/core': '^1.8.1',
        '@openfeature/server-sdk': '~1.20.0',
        '@stylistic/eslint-plugin': '^5.5.0',
        '@types/chai': '^4.3.16',
        '@types/mocha': '^10.0.10',
        '@types/node': '^18.19.106',
        '@types/sinon': '^21.0.0',
        '@types/tap': '^15.0.12',
        axios: '^1.12.2',
        benchmark: '^2.1.4',
        'body-parser': '^2.2.0',
        bun: '1.3.3',
        chai: '^4.5.0',
        eslint: '^9.39.0',
        'eslint-plugin-cypress': '^5.2.0',
        'eslint-plugin-import': '^2.32.0',
        'eslint-plugin-jsdoc': '^61.1.12',
        'eslint-plugin-mocha': '^11.2.0',
        'eslint-plugin-n': '^17.23.1',
        'eslint-plugin-promise': '^7.2.1',
        'eslint-plugin-unicorn': '^62.0.0',
        express: '^5.1.0',
        glob: '^10.4.5',
        globals: '^16.3.0',
        graphql: '*',
        jszip: '^3.10.1',
        mocha: '^11.6.0',
        'mocha-junit-reporter': '^2.2.1',
        'mocha-multi-reporters': '^1.5.1',
        multer: '^2.0.2',
        nock: '^13.5.6',
        nyc: '^15.1.0',
        octokit: '^5.0.3',
        opentracing: '>=0.14.7',
        proxyquire: '^2.1.3',
        retry: '^0.13.1',
        semifies: '^1.0.0',
        semver: '^7.7.2',
        sinon: '^21.0.0',
        'sinon-chai': '^3.7.0',
        tap: '^16.3.10',
        tiktoken: '^1.0.21',
        typescript: '^5.9.2',
        workerpool: '^10.0.0',
        yaml: '^2.8.0',
        'yarn-deduplicate': '^6.0.2',
      },
    }
  },
})

// node_modules/dd-trace/version.js
var require_version = __commonJS({
  'node_modules/dd-trace/version.js'(exports2, module2) {
    'use strict'
    var version = require_package().version
    var ddMatches = version.match(/^(\d+)\.(\d+)\.(\d+)/)
    var nodeMatches = process.versions.node.match(/^(\d+)\.(\d+)\.(\d+)/)
    module2.exports = {
      VERSION: version,
      DD_MAJOR: parseInt(ddMatches[1]),
      DD_MINOR: parseInt(ddMatches[2]),
      DD_PATCH: parseInt(ddMatches[3]),
      NODE_MAJOR: parseInt(nodeMatches[1]),
      NODE_MINOR: parseInt(nodeMatches[2]),
      NODE_PATCH: parseInt(nodeMatches[3]),
      NODE_VERSION: nodeMatches[0],
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/runtime_metrics/runtime_metrics.js
var require_runtime_metrics = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/runtime_metrics/runtime_metrics.js'(exports2, module2) {
    'use strict'
    var v8 = require('v8')
    var os = require('os')
    var process2 = require('process')
    var { DogStatsDClient, MetricsAggregationClient } = require_dogstatsd2()
    var log = require_log2()
    var { performance: performance2, PerformanceObserver, monitorEventLoopDelay } = require('perf_hooks')
    var { getEnvironmentVariable } = require_config_helper()
    var { NODE_MAJOR } = require_version()
    var DD_RUNTIME_METRICS_FLUSH_INTERVAL = getEnvironmentVariable('DD_RUNTIME_METRICS_FLUSH_INTERVAL') ?? '10000'
    var INTERVAL = Number.parseInt(DD_RUNTIME_METRICS_FLUSH_INTERVAL, 10)
    var eventLoopDelayResolution = 4
    var nativeMetrics = null
    var gcObserver = null
    var interval = null
    var client = null
    var lastTime = 0
    var lastCpuUsage = null
    var eventLoopDelayObserver = null
    module2.exports = {
      start(config) {
        this.stop()
        const clientConfig = DogStatsDClient.generateClientConfig(config)
        const trackEventLoop = config.runtimeMetrics.eventLoop !== false
        const trackGc = config.runtimeMetrics.gc !== false
        if (trackGc) {
          startGCObserver()
        }
        const watchers = trackEventLoop ? ['loop'] : ['no-gc']
        try {
          nativeMetrics = require('@datadog/native-metrics')
          nativeMetrics.start(...watchers)
        } catch (error) {
          log.error('Error starting native metrics', error)
          nativeMetrics = null
        }
        client = new MetricsAggregationClient(new DogStatsDClient(clientConfig))
        lastTime = performance2.now()
        if (nativeMetrics) {
          interval = setInterval(() => {
            captureNativeMetrics(trackEventLoop, trackGc)
            captureCommonMetrics(trackEventLoop)
            client.flush()
          }, INTERVAL)
        } else {
          lastCpuUsage = process2.cpuUsage()
          if (trackEventLoop) {
            eventLoopDelayObserver = monitorEventLoopDelay({ resolution: eventLoopDelayResolution })
            eventLoopDelayObserver.enable()
          }
          interval = setInterval(() => {
            captureCpuUsage()
            captureCommonMetrics(trackEventLoop)
            captureHeapSpace()
            if (trackEventLoop) {
              captureEventLoopDelay()
            }
            client.flush()
          }, INTERVAL)
        }
        interval.unref()
      },
      stop() {
        nativeMetrics?.stop()
        nativeMetrics = null
        clearInterval(interval)
        interval = null
        client = null
        lastCpuUsage = null
        gcObserver?.disconnect()
        gcObserver = null
        eventLoopDelayObserver?.disable()
        eventLoopDelayObserver = null
      },
      track(span) {
        if (nativeMetrics) {
          const handle = nativeMetrics.track(span)
          return {
            finish: () => nativeMetrics.finish(handle),
          }
        }
        return { finish: () => {} }
      },
      boolean(name, value, tag) {
        client?.boolean(name, value, tag)
      },
      histogram(name, value, tag) {
        client?.histogram(name, value, tag)
      },
      count(name, count, tag, monotonic = false) {
        client?.count(name, count, tag, monotonic)
      },
      gauge(name, value, tag) {
        client?.gauge(name, value, tag)
      },
      increment(name, tag, monotonic) {
        this.count(name, 1, tag, monotonic)
      },
      decrement(name, tag) {
        this.count(name, -1, tag)
      },
    }
    function captureCpuUsage() {
      const currentCpuUsage = process2.cpuUsage()
      const elapsedUsageUser = currentCpuUsage.user - lastCpuUsage.user
      const elapsedUsageSystem = currentCpuUsage.system - lastCpuUsage.system
      const currentTime = performance2.now()
      const elapsedUsDividedBy100 = (currentTime - lastTime) * 10
      const userPercent = elapsedUsageUser / elapsedUsDividedBy100
      const systemPercent = elapsedUsageSystem / elapsedUsDividedBy100
      const totalPercent = userPercent + systemPercent
      lastTime = currentTime
      lastCpuUsage = currentCpuUsage
      client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))
      client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))
      client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))
    }
    function captureMemoryUsage() {
      const stats = process2.memoryUsage()
      client.gauge('runtime.node.mem.heap_total', stats.heapTotal)
      client.gauge('runtime.node.mem.heap_used', stats.heapUsed)
      client.gauge('runtime.node.mem.rss', stats.rss)
      client.gauge('runtime.node.mem.total', os.totalmem())
      client.gauge('runtime.node.mem.free', os.freemem())
      client.gauge('runtime.node.mem.external', stats.external)
    }
    function captureUptime() {
      client.gauge('runtime.node.process.uptime', Math.round((lastTime + 499) / 1e3))
    }
    function captureEventLoopDelay() {
      eventLoopDelayObserver.disable()
      if (eventLoopDelayObserver.count !== 0) {
        const minimum = eventLoopDelayResolution * 1e6
        const avg = Math.max(eventLoopDelayObserver.mean - minimum, 0)
        const sum = Math.round(avg * eventLoopDelayObserver.count)
        if (sum !== 0) {
          const stats = {
            min: Math.max(eventLoopDelayObserver.min - minimum, 0),
            max: Math.max(eventLoopDelayObserver.max - minimum, 0),
            sum,
            total: sum,
            avg,
            count: eventLoopDelayObserver.count,
            p95: Math.max(eventLoopDelayObserver.percentile(95) - minimum, 0),
          }
          histogram('runtime.node.event_loop.delay', stats)
        }
      }
      eventLoopDelayObserver = monitorEventLoopDelay({ resolution: eventLoopDelayResolution })
      eventLoopDelayObserver.enable()
    }
    function captureHeapStats() {
      const stats = v8.getHeapStatistics()
      client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size)
      client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable)
      client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size)
      client.gauge('runtime.node.heap.total_available_size', stats.total_available_size)
      client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit)
      client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory)
      client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory)
    }
    function captureHeapSpace() {
      const stats = v8.getHeapSpaceStatistics()
      for (let i = 0, l = stats.length; i < l; i++) {
        const tags = [`space:${stats[i].space_name}`]
        client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags)
        client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags)
        client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags)
        client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags)
      }
    }
    var lastElu = { idle: 0, active: 0 }
    function captureELU() {
      const elu = performance2.eventLoopUtilization()
      const idle = elu.idle - lastElu.idle
      const active = elu.active - lastElu.active
      const utilization = active / (idle + active)
      lastElu = elu
      client.gauge('runtime.node.event_loop.utilization', utilization)
    }
    function captureCommonMetrics(trackEventLoop) {
      captureMemoryUsage()
      captureUptime()
      captureHeapStats()
      if (trackEventLoop) {
        captureELU()
      }
    }
    function captureNativeMetrics(trackEventLoop, trackGc) {
      const stats = nativeMetrics.stats()
      const spaces = stats.heap.spaces
      const currentTime = performance2.now()
      const elapsedUsDividedBy100 = (currentTime - lastTime) * 10
      lastTime = currentTime
      const userPercent = stats.cpu.user / elapsedUsDividedBy100
      const systemPercent = stats.cpu.system / elapsedUsDividedBy100
      const totalPercent = userPercent + systemPercent
      client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))
      client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))
      client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))
      if (trackEventLoop) {
        histogram('runtime.node.event_loop.delay', stats.eventLoop)
      }
      if (trackGc) {
        for (const [type, value] of Object.entries(stats.gc)) {
          if (type === 'all') {
            histogram('runtime.node.gc.pause', value)
          } else {
            histogram('runtime.node.gc.pause.by.type', value, `gc_type:${type}`)
          }
        }
      }
      for (let i = 0, l = spaces.length; i < l; i++) {
        const tag = `heap_space:${spaces[i].space_name}`
        client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tag)
        client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tag)
        client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tag)
        client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tag)
      }
    }
    function histogram(name, stats, tag) {
      if (stats.count === 0) {
        return
      }
      client.gauge(`${name}.min`, stats.min, tag)
      client.gauge(`${name}.max`, stats.max, tag)
      client.increment(`${name}.sum`, stats.sum, tag)
      client.increment(`${name}.total`, stats.sum, tag)
      client.gauge(`${name}.avg`, stats.avg, tag)
      client.increment(`${name}.count`, stats.count, tag)
      if (stats.median !== void 0) {
        client.gauge(`${name}.median`, stats.median, tag)
      }
      client.gauge(`${name}.95percentile`, stats.p95, tag)
    }
    function startGCObserver() {
      if (gcObserver) return
      gcObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          const type = gcType(entry.detail?.kind || entry.kind)
          const duration = entry.duration * 1e6
          client.histogram('runtime.node.gc.pause.by.type', duration, `gc_type:${type}`)
          client.histogram('runtime.node.gc.pause', duration)
        }
      })
      gcObserver.observe({ type: 'gc' })
    }
    var minorGCType = NODE_MAJOR >= 22 ? 'minor_mark_sweep' : 'minor_mark_compact'
    function gcType(kind) {
      switch (kind) {
        case 1:
          return 'scavenge'
        case 2:
          return minorGCType
        case 4:
          return 'mark_sweep_compact'
        // Deprecated, might be removed soon.
        case 8:
          return 'incremental_marking'
        case 16:
          return 'process_weak_callbacks'
        case 31:
          return 'all'
        default:
          return 'unknown'
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/runtime_metrics/index.js
var require_runtime_metrics2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/runtime_metrics/index.js'(exports2, module2) {
    'use strict'
    var runtimeMetrics
    var noop = (runtimeMetrics = {
      stop() {},
      track() {},
      boolean() {},
      histogram() {},
      count() {},
      gauge() {},
      increment() {},
      decrement() {},
    })
    module2.exports = {
      start(config) {
        if (!config?.runtimeMetrics.enabled) return
        runtimeMetrics = require_runtime_metrics()
        Object.setPrototypeOf(module2.exports, runtimeMetrics)
        runtimeMetrics.start(config)
      },
      stop() {
        runtimeMetrics.stop()
        Object.setPrototypeOf(module2.exports, (runtimeMetrics = noop))
      },
    }
    Object.setPrototypeOf(module2.exports, noop)
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/send-data.js
var require_send_data = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/send-data.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var log = require_log2()
    var { isTrue } = require_util()
    var { getEnvironmentVariable } = require_config_helper()
    var agentTelemetry = true
    function getHeaders(config, application, reqType) {
      const headers = {
        'content-type': 'application/json',
        'dd-telemetry-api-version': 'v2',
        'dd-telemetry-request-type': reqType,
        'dd-client-library-language': application.language_name,
        'dd-client-library-version': application.tracer_version,
      }
      const debug = config.telemetry && config.telemetry.debug
      if (debug) {
        headers['dd-telemetry-debug-enabled'] = 'true'
      }
      if (config.apiKey) {
        headers['dd-api-key'] = config.apiKey
      }
      return headers
    }
    function getAgentlessTelemetryEndpoint(site) {
      if (site === 'datad0g.com') {
        return 'https://all-http-intake.logs.datad0g.com'
      }
      return `https://instrumentation-telemetry-intake.${site}`
    }
    var seqId = 0
    function getPayload(payload) {
      if (Array.isArray(payload)) {
        return payload
      }
      const { logger, tags, serviceMapping, ...trimmedPayload } = payload
      return trimmedPayload
    }
    function sendData(config, application, host, reqType, payload = {}, cb = () => {}) {
      const { hostname, port, isCiVisibility } = config
      let url = config.url
      const isCiVisibilityAgentlessMode =
        isCiVisibility && isTrue(getEnvironmentVariable('DD_CIVISIBILITY_AGENTLESS_ENABLED'))
      if (isCiVisibilityAgentlessMode) {
        try {
          url = url || new URL(getAgentlessTelemetryEndpoint(config.site))
        } catch (err) {
          log.error('Telemetry endpoint url is invalid', err)
          return cb(err, { payload, reqType })
        }
      }
      const options = {
        url,
        hostname,
        port,
        method: 'POST',
        path: isCiVisibilityAgentlessMode ? '/api/v2/apmtelemetry' : '/telemetry/proxy/api/v2/apmtelemetry',
        headers: getHeaders(config, application, reqType),
      }
      const data = JSON.stringify({
        api_version: 'v2',
        naming_schema_version: config.spanAttributeSchema ?? '',
        request_type: reqType,
        tracer_time: Math.floor(Date.now() / 1e3),
        runtime_id: config.tags['runtime-id'],
        seq_id: ++seqId,
        payload: getPayload(payload),
        application,
        host,
      })
      request(data, options, (error) => {
        if (error && getEnvironmentVariable('DD_API_KEY') && config.site) {
          if (agentTelemetry) {
            log.warn('Agent telemetry failed, started agentless telemetry')
            agentTelemetry = false
          }
          const backendUrl = getAgentlessTelemetryEndpoint(config.site)
          const backendHeader = { ...options.headers, 'DD-API-KEY': getEnvironmentVariable('DD_API_KEY') }
          const backendOptions = {
            ...options,
            url: backendUrl,
            headers: backendHeader,
            path: '/api/v2/apmtelemetry',
          }
          if (backendUrl) {
            request(data, backendOptions, (error2) => {
              if (error2) {
                log.error('Error sending telemetry data', error2)
              }
            })
          } else {
            log.error('Invalid Telemetry URL')
          }
        }
        if (!error && !agentTelemetry) {
          agentTelemetry = true
          log.info('Started agent telemetry')
        }
        cb(error, { payload, reqType })
      })
    }
    module2.exports = { sendData }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/metrics.js
var require_metrics = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/metrics.js'(exports2, module2) {
    'use strict'
    var { sendData } = require_send_data()
    function getId(type, namespace, name, tags) {
      return `${type}:${namespace}.${name}:${tagArray(tags).sort().join(',')}`
    }
    function tagArray(tags = {}) {
      if (Array.isArray(tags)) return tags
      const list = []
      for (const [key, value] of Object.entries(tags)) {
        list.push(`${key}:${value}`.toLowerCase())
      }
      return list
    }
    function now() {
      return Date.now() / 1e3
    }
    function mapToJsonArray(map, filter) {
      const array = []
      for (const value of map.values()) {
        if (!filter || filter(value)) {
          array.push(value.toJSON())
        }
      }
      return array
    }
    function hasPoints(metric) {
      return metric.points.length > 0
    }
    var Metric = class {
      constructor(namespace, metric, common, tags) {
        this.namespace = namespace.toString()
        this.metric = common ? metric : `nodejs.${metric}`
        this.tags = tagArray(tags)
        this.common = common
        this.points = []
      }
      toString() {
        const { namespace, metric } = this
        return `${namespace}.${metric}`
      }
      reset() {
        this.points = []
      }
      track() {
        throw new Error('not implemented')
      }
      toJSON() {
        const { metric, points, interval, type, tags, common } = this
        return {
          metric,
          points,
          interval,
          type,
          tags,
          common,
        }
      }
    }
    var CountMetric = class extends Metric {
      get type() {
        return 'count'
      }
      inc(value) {
        return this.track(value)
      }
      dec(value = 1) {
        return this.track(-value)
      }
      track(value = 1) {
        if (this.points.length) {
          this.points[0][1] += value
        } else {
          this.points.push([now(), value])
        }
      }
    }
    var DistributionMetric = class extends Metric {
      get type() {
        return 'distribution'
      }
      track(value = 1) {
        this.points.push(value)
      }
      toJSON() {
        const { metric, points, tags, common } = this
        return {
          metric,
          points,
          common,
          tags,
        }
      }
    }
    var GaugeMetric = class extends Metric {
      get type() {
        return 'gauge'
      }
      mark(value) {
        return this.track(value)
      }
      track(value = 1) {
        this.points.push([now(), value])
      }
    }
    var RateMetric = class extends Metric {
      constructor(namespace, metric, common, tags, interval) {
        super(namespace, metric, common, tags)
        this.interval = interval
        this.rate = 0
      }
      get type() {
        return 'rate'
      }
      reset() {
        super.reset()
        this.rate = 0
      }
      track(value = 1) {
        this.rate += value
        const rate = this.interval ? this.rate / this.interval : 0
        this.points = [[now(), rate]]
      }
    }
    var metricsTypes = {
      count: CountMetric,
      distribution: DistributionMetric,
      gauge: GaugeMetric,
      rate: RateMetric,
    }
    var MetricsCollection = class extends Map {
      constructor(namespace) {
        super()
        this.namespace = namespace
      }
      reset() {
        for (const metric of this.values()) {
          metric.reset()
        }
      }
      toString() {
        return this.namespace
      }
      toJSON() {
        if (!this.size) return
        const series = mapToJsonArray(this, hasPoints)
        if (!series.length) return
        const { namespace } = this
        return {
          namespace,
          series,
        }
      }
    }
    function getMetric(collection, type, name, tags, interval) {
      const metricId = getId(type, collection, name, tags)
      let metric = collection.get(metricId)
      if (metric) return metric
      const Factory = metricsTypes[type]
      if (!Factory) {
        throw new Error(`Unknown metric type ${type}`)
      }
      metric = new Factory(collection, name, true, tags, interval)
      collection.set(metricId, metric)
      return metric
    }
    var Namespace = class {
      constructor(namespace) {
        this.distributions = new MetricsCollection(namespace)
        this.metrics = new MetricsCollection(namespace)
      }
      reset() {
        this.metrics.reset()
        this.distributions.reset()
      }
      count(name, tags) {
        return getMetric(this.metrics, 'count', name, tags)
      }
      gauge(name, tags) {
        return getMetric(this.metrics, 'gauge', name, tags)
      }
      rate(name, interval, tags) {
        return getMetric(this.metrics, 'rate', name, tags, interval)
      }
      distribution(name, tags) {
        return getMetric(this.distributions, 'distribution', name, tags)
      }
      toJSON() {
        const { distributions, metrics } = this
        return {
          distributions: distributions.toJSON(),
          metrics: metrics.toJSON(),
        }
      }
    }
    var NamespaceManager = class extends Map {
      namespace(name) {
        let ns = this.get(name)
        if (ns) return ns
        ns = new Namespace(name)
        this.set(name, ns)
        return ns
      }
      toJSON() {
        return mapToJsonArray(this)
      }
      send(config, application, host) {
        for (const namespace of this.values()) {
          const { metrics, distributions } = namespace.toJSON()
          if (metrics) {
            sendData(config, application, host, 'generate-metrics', metrics)
          }
          if (distributions) {
            sendData(config, application, host, 'distributions', distributions)
          }
          namespace.reset()
        }
      }
    }
    var manager = new NamespaceManager()
    module2.exports = {
      CountMetric,
      DistributionMetric,
      GaugeMetric,
      RateMetric,
      MetricsCollection,
      Namespace,
      NamespaceManager,
      manager,
    }
  },
})

// node_modules/dd-trace/vendor/dist/tlhunter-sorted-set/index.js
var require_tlhunter_sorted_set = __commonJS({
  'node_modules/dd-trace/vendor/dist/tlhunter-sorted-set/index.js'(exports2, module2) {
    ;(() => {
      var e = {
          './tlhunter-sorted-set/lib/intersect.js': function (e2) {
            e2.exports = function (e3) {
              let t2, n2, r, l, i, s, h
              if (!e3.length) return []
              for (i = e3.length - 1; i >= 0; i--) {
                if (!e3[i].length) return []
                e3[i] = e3[i]._head.next[0].next
              }
              if (1 === e3.length) return e3[0].toArray({ field: 'key' })
              if (2 === e3.length)
                return (function (e4, t3) {
                  let n3 = /* @__PURE__ */ Object.create(null),
                    r2 = []
                  for (; e4; e4 = e4.next[0].next) n3[e4.key] = true
                  for (; t3; t3 = t3.next[0].next) n3[t3.key] && r2.push(t3.key)
                  return r2
                })(e3[0], e3[1])
              if (3 === e3.length)
                return (function (e4, t3, n3) {
                  let r2 = /* @__PURE__ */ Object.create(null),
                    l2 = []
                  for (; e4; e4 = e4.next[0].next) r2[e4.key] = 0
                  for (; t3; t3 = t3.next[0].next) 0 === r2[t3.key] && (r2[t3.key] = 1)
                  for (; n3; n3 = n3.next[0].next) 1 === r2[n3.key] && l2.push(n3.key)
                  return l2
                })(e3[0], e3[1], e3[2])
              for (r = /* @__PURE__ */ Object.create(null), n2 = e3.shift(); n2; n2 = n2.next[0].next) r[n2.key] = 0
              for (i = 0, h = e3.length - 1; i < h; i++) {
                for (l = 0, s = i + 1, n2 = e3[i]; n2; n2 = n2.next[0].next) r[n2.key] === i && ((r[n2.key] = s), l++)
                if (!l) return []
              }
              for (t2 = [], n2 = e3[i]; n2; n2 = n2.next[0].next) r[n2.key] === i && t2.push(n2.key)
              return t2
            }
          },
          './tlhunter-sorted-set/lib/set.js': function (e2, t2, n2) {
            'use strict'
            let r = n2('./tlhunter-sorted-set/lib/intersect.js'),
              l = Array.prototype.slice,
              i = 1 / Math.E
            class s {
              constructor(e3 = {}) {
                ;((this._unique = !!e3.unique), this.empty())
              }
              static intersect() {
                return r.call(s, l.call(arguments))
              }
              add(e3, t3) {
                let n3
                if (null == t3) return this.rem(e3)
                if (void 0 !== (n3 = this._map.get(e3))) {
                  if (t3 === n3) return n3
                  this._remove(e3, n3)
                }
                if (!this._insert(e3, t3))
                  throw (void 0 === n3 || this._insert(e3, n3), Error('unique constraint violated'))
                return (this._map.set(e3, t3), void 0 === n3 ? null : n3)
              }
              card() {
                return this.length ? this.length : 0
              }
              count(e3, t3) {
                let n3
                if (!this.length) return 0
                if (
                  (null == e3 && (e3 = -1 / 0),
                  null == t3 && (t3 = 1 / 0),
                  e3 <= this._head.next[0].next.value && t3 >= this._tail.value)
                )
                  return this.length
                if (t3 < e3 || e3 > this._tail.value || t3 < this._head.next[0].next.value) return 0
                let r2 = this._first(e3),
                  l2 = 0
                if (!r2) return 0
                for (n3 = r2.next.length - 1; n3 >= 0; n3 -= 1)
                  for (; r2.next[n3].next && r2.next[n3].next.value <= t3; )
                    ((l2 += r2.next[n3].span), (r2 = r2.next[n3].next))
                return l2 && l2 + 1
              }
              del(e3) {
                return this.rem(e3)
              }
              empty() {
                ;((this.length = 0),
                  (this._level = 1),
                  (this._map = /* @__PURE__ */ new Map()),
                  (this._head = new u(32, null, 0)),
                  (this._tail = null))
                for (let e3 = 0; e3 < 32; e3 += 1) this._head.next[e3] = new h(null, 0)
              }
              get(e3) {
                return this.score(e3)
              }
              has(e3) {
                return this._map.has(e3)
              }
              incrBy(e3, t3) {
                let n3 = this.score(t3)
                return n3 ? (this.add(t3, n3 + e3), n3 + e3) : (this.add(t3, e3), e3)
              }
              intersect() {
                let e3 = l.call(arguments)
                return (e3.unshift(this), r.call(this, e3))
              }
              intersectKeys() {
                let e3 = l.call(arguments)
                return (e3.unshift(this), intersectKeys.call(this, e3))
              }
              keys() {
                let e3
                if (!this.length) return []
                let t3 = Array(this.length),
                  n3 = this._head.next[0].next
                for (e3 = 0; n3; n3 = n3.next[0].next) ((t3[e3] = n3.key), (e3 += 1))
                return t3
              }
              range(e3, t3, n3) {
                let r2
                if (
                  0 === this.length ||
                  (null == e3 ? (e3 = 0) : e3 < 0 && (e3 = Math.max(this.length + e3, 0)),
                  null == t3 ? (t3 = this.length - 1) : t3 < 0 && (t3 = this.length + t3),
                  e3 > t3 || e3 >= this.length)
                )
                  return []
                ;(t3 >= this.length && (t3 = this.length - 1), 'object' != typeof n3 && (n3 = { withScores: false }))
                let l2 = 0,
                  i2 = t3 - e3 + 1
                try {
                  r2 = Array(i2)
                } catch (n4) {
                  throw (console.log('start', e3), console.log('stop', t3), console.log('Invalid length', i2), n4)
                }
                let s2 = e3 > 0 ? this._get(e3) : this._head.next[0].next
                if (n3.withScores) for (; i2--; s2 = s2.next[0].next) ((r2[l2] = [s2.key, s2.value]), (l2 += 1))
                else for (; i2--; s2 = s2.next[0].next) ((r2[l2] = s2.key), (l2 += 1))
                return r2
              }
              rangeByScore(e3, t3, n3) {
                if (!this.length) return []
                if (
                  ('object' != typeof n3 && (n3 = { withScores: false }),
                  null == e3 && (e3 = -1 / 0),
                  null == t3 && (t3 = 1 / 0),
                  e3 <= this._head.next[0].next.value && t3 >= this._tail.value)
                )
                  return this.toArray({ withScores: n3.withScores })
                if (t3 < e3 || e3 > this._tail.value || t3 < this._head.next[0].next.value) return []
                let r2 = this._first(e3),
                  l2 = []
                if (n3.withScores) for (; r2 && r2.value <= t3; r2 = r2.next[0].next) l2.push([r2.key, r2.value])
                else for (; r2 && r2.value <= t3; r2 = r2.next[0].next) l2.push(r2.key)
                return l2
              }
              rank(e3) {
                let t3,
                  n3 = this._map.get(e3)
                if (void 0 === n3) return null
                let r2 = this._head,
                  l2 = null,
                  i2 = -1
                for (t3 = this._level - 1; t3 >= 0; t3 -= 1) {
                  for (; (l2 = r2.next[t3].next) && (l2.value < n3 || (l2.value === n3 && l2.key <= e3)); )
                    ((i2 += r2.next[t3].span), (r2 = l2))
                  if (r2.key && r2.key === e3) return i2
                }
                return null
              }
              rem(e3) {
                let t3 = this._map.get(e3)
                return void 0 !== t3 ? (this._remove(e3, t3), this._map.delete(e3), t3) : null
              }
              remRangeByRank(e3, t3) {
                let n3,
                  r2,
                  l2 = this.length
                if (
                  !l2 ||
                  (null == e3 ? (e3 = 0) : e3 < 0 && (e3 = Math.max(l2 + e3, 0)),
                  null == t3 ? (t3 = l2) : t3 < 0 && (t3 = l2 + t3),
                  e3 > t3 || e3 >= l2)
                )
                  return 0
                if ((t3 > l2 && (t3 = l2), 0 === e3 && t3 === l2)) return (this.empty(), l2)
                let i2 = this._head,
                  s2 = Array(32),
                  h2 = -1
                for (n3 = this._level - 1; n3 >= 0; n3 -= 1) {
                  for (; (r2 = i2.next[n3].next) && h2 + i2.next[n3].span < e3; ) ((h2 += i2.next[n3].span), (i2 = r2))
                  s2[n3] = i2
                }
                let u2 = 0
                for (h2 += 1, i2 = i2.next[0].next; i2 && h2 < t3; )
                  ((r2 = i2.next[0].next),
                    this._removeNode(i2, s2),
                    this._map.delete(i2.key),
                    (u2 += 1),
                    (h2 += 1),
                    (i2 = r2))
                return ((this.length -= u2), u2)
              }
              remRangeByScore(e3, t3) {
                let n3,
                  r2,
                  l2 = 0
                if (!this.length) return 0
                if (
                  (null == e3 && (e3 = -1 / 0),
                  null == t3 && (t3 = 1 / 0),
                  e3 <= this._head.next[0].next.value && t3 >= this._tail.value)
                )
                  return ((l2 = this.length), this.empty(), l2)
                let i2 = this._head,
                  s2 = Array(32)
                for (r2 = this._level - 1; r2 >= 0; r2 -= 1) {
                  for (; (n3 = i2.next[r2].next) && n3.value < e3; ) i2 = n3
                  s2[r2] = i2
                }
                for (i2 = i2.next[0].next; i2 && i2.value <= t3; )
                  ((n3 = i2.next[0].next), this._removeNode(i2, s2), this._map.delete(i2.key), (l2 += 1), (i2 = n3))
                return ((this.length -= l2), l2)
              }
              score(e3) {
                let t3 = this._map.get(e3)
                return void 0 === t3 ? null : t3
              }
              set(e3, t3) {
                return this.add(e3, t3)
              }
              slice(e3, t3, n3) {
                return ('number' == typeof t3 && 0 !== t3 && (t3 -= 1), this.range(e3, t3, n3))
              }
              toArray(e3) {
                let t3
                if (!this.length) return []
                'object' != typeof e3 && (e3 = { withScores: false })
                let n3 = Array(this.length),
                  r2 = this._head.next[0].next
                if (e3.withScores) for (t3 = 0; r2; r2 = r2.next[0].next) ((n3[t3] = [r2.key, r2.value]), (t3 += 1))
                else for (t3 = 0; r2; r2 = r2.next[0].next) ((n3[t3] = r2.key), (t3 += 1))
                return n3
              }
              values() {
                let e3
                if (!this.length) return []
                let t3 = Array(this.length),
                  n3 = this._head.next[0].next
                for (e3 = 0; n3; n3 = n3.next[0].next) ((t3[e3] = n3.value), (e3 += 1))
                return t3
              }
              _first(e3) {
                let t3 = this._tail
                if (!t3 || t3.value < e3) return null
                t3 = this._head
                for (let n3 = null, r2 = this._level - 1; r2 >= 0; r2 -= 1)
                  for (; (n3 = t3.next[r2].next) && n3.value < e3; ) t3 = n3
                return t3.next[0].next
              }
              _get(e3) {
                let t3,
                  n3 = this._head,
                  r2 = -1
                for (t3 = this._level - 1; t3 >= 0; t3 -= 1) {
                  for (; n3.next[t3].next && r2 + n3.next[t3].span <= e3; )
                    ((r2 += n3.next[t3].span), (n3 = n3.next[t3].next))
                  if (r2 === e3) return n3
                }
                return null
              }
              _insert(e3, t3) {
                let n3,
                  r2 = Array(32),
                  l2 = Array(32),
                  s2 = this._head,
                  a = null
                for (n3 = this._level - 1; n3 >= 0; n3 -= 1) {
                  for (l2[n3] = n3 === this._level - 1 ? 0 : l2[n3 + 1]; (a = s2.next[n3].next) && a.value <= t3; ) {
                    if (a.value === t3) {
                      if (this._unique) return null
                      if (a.key >= e3) break
                    }
                    ;((l2[n3] += s2.next[n3].span), (s2 = a))
                  }
                  if (this._unique && s2.value === t3) return null
                  r2[n3] = s2
                }
                if (this._unique && s2.value === t3) return null
                let x = (function () {
                  let e4 = 1
                  for (; Math.random() < i; ) e4 += 1
                  return e4 < 32 ? e4 : 32
                })()
                if (x > this._level) {
                  for (n3 = this._level; n3 < x; n3 += 1)
                    ((l2[n3] = 0), (r2[n3] = this._head), (r2[n3].next[n3].span = this.length))
                  this._level = x
                }
                for (n3 = 0, s2 = new u(x, e3, t3); n3 < x; n3 += 1)
                  ((s2.next[n3] = new h(r2[n3].next[n3].next, r2[n3].next[n3].span - (l2[0] - l2[n3]))),
                    (r2[n3].next[n3].next = s2),
                    (r2[n3].next[n3].span = l2[0] - l2[n3] + 1))
                for (n3 = x; n3 < this._level; n3 += 1) r2[n3].next[n3].span++
                return (
                  (s2.prev = r2[0] === this._head ? null : r2[0]),
                  s2.next[0].next ? (s2.next[0].next.prev = s2) : (this._tail = s2),
                  (this.length += 1),
                  s2
                )
              }
              _next(e3, t3) {
                let n3, r2
                if (!this._tail || this._tail.value < e3) return null
                for (n3 = null; (n3 = t3.next[t3.next.length - 1].next) && n3.value < e3; ) t3 = n3
                if (t3.value === e3) return t3
                for (r2 = t3.next.length - 1; r2 >= 0; r2 -= 1) {
                  for (; (n3 = t3.next[r2].next) && n3.value < e3; ) t3 = n3
                  if (t3.value === e3) return t3
                }
                return t3.next[0].next
              }
              _remove(e3, t3) {
                let n3,
                  r2,
                  l2 = Array(32),
                  i2 = this._head
                for (n3 = this._level - 1; n3 >= 0; n3 -= 1) {
                  for (; (r2 = i2.next[n3].next) && (r2.value < t3 || (r2.value === t3 && r2.key < e3)); ) i2 = r2
                  l2[n3] = i2
                }
                if (!(i2 = i2.next[0].next) || t3 !== i2.value || i2.key !== e3) return false
                ;(this._removeNode(i2, l2), (this.length -= 1))
              }
              _removeNode(e3, t3) {
                let n3 = null,
                  r2 = 0,
                  l2 = this._level
                for (; r2 < l2; r2 += 1)
                  t3[r2].next[r2].next === e3
                    ? ((t3[r2].next[r2].span += e3.next[r2].span - 1), (t3[r2].next[r2].next = e3.next[r2].next))
                    : (t3[r2].next[r2].span -= 1)
                for (
                  (n3 = e3.next[0].next) ? (n3.prev = e3.prev) : (this._tail = e3.prev);
                  this._level > 1 && !this._head.next[this._level - 1].next;
                )
                  this._level -= 1
              }
            }
            function h(e3, t3) {
              ;((this.next = e3), (this.span = t3))
            }
            function u(e3, t3, n3) {
              ;((this.key = t3), (this.value = n3), (this.next = Array(e3)), (this.prev = null))
            }
            e2.exports = s
          },
        },
        t = {},
        n = (function n2(r) {
          var l = t[r]
          if (void 0 !== l) return l.exports
          var i = (t[r] = { exports: {} })
          return (e[r](i, i.exports, n2), i.exports)
        })('./tlhunter-sorted-set/lib/set.js')
      module2.exports = n
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/spanleak.js
var require_spanleak = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/spanleak.js'(exports2, module2) {
    'use strict'
    var SortedSet = require_tlhunter_sorted_set()
    var INTERVAL = 1e3
    var LIFETIME = 60 * 1e3
    var MODES = {
      DISABLED: 0,
      // METRICS_ONLY
      LOG: 1,
      GC_AND_LOG: 2,
      // GC
    }
    module2.exports.MODES = MODES
    var spans = new SortedSet()
    var interval
    var mode = MODES.DISABLED
    module2.exports.disable = function () {
      mode = MODES.DISABLED
    }
    module2.exports.enableLogging = function () {
      mode = MODES.LOG
    }
    module2.exports.enableGarbageCollection = function () {
      mode = MODES.GC_AND_LOG
    }
    module2.exports.startScrubber = function () {
      if (!isEnabled()) return
      interval = setInterval(() => {
        const now = Date.now()
        const expired = spans.rangeByScore(0, now)
        if (!expired.length) return
        const gc = isGarbageCollecting()
        const expirationsByType = /* @__PURE__ */ Object.create(null)
        for (const wrapped of expired) {
          spans.del(wrapped)
          const span = wrapped.deref()
          if (!span) continue
          if (!expirationsByType[span._name]) expirationsByType[span._name] = 0
          expirationsByType[span._name]++
          if (!gc) continue
          span.context()._tags = /* @__PURE__ */ Object.create(null)
        }
        console.log(
          'expired spans:' + Object.keys(expirationsByType).reduce((a, c) => `${a} ${c}: ${expirationsByType[c]}`, '')
        )
      }, INTERVAL)
    }
    module2.exports.stopScrubber = function () {
      clearInterval(interval)
    }
    module2.exports.addSpan = function (span) {
      if (!isEnabled()) return
      const now = Date.now()
      const expiration = now + LIFETIME
      const wrapped = new WeakRef(span)
      spans.add(wrapped, expiration)
    }
    function isEnabled() {
      return mode > MODES.DISABLED
    }
    function isGarbageCollecting() {
      return mode >= MODES.GC_AND_LOG
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js
var require_span2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js'(exports2, module2) {
    'use strict'
    var { performance: performance2 } = require('perf_hooks')
    var now = performance2.now.bind(performance2)
    var dateNow = Date.now
    var SpanContext = require_span_context()
    var id = require_id()
    var tagger = require_tagger()
    var runtimeMetrics = require_runtime_metrics2()
    var log = require_log2()
    var { storage } = require_datadog_core()
    var telemetryMetrics = require_metrics()
    var { channel } = require_dc_polyfill()
    var util = require('util')
    var { getEnvironmentVariable } = require_config_helper()
    var tracerMetrics = telemetryMetrics.manager.namespace('tracers')
    var DD_TRACE_EXPERIMENTAL_STATE_TRACKING = getEnvironmentVariable('DD_TRACE_EXPERIMENTAL_STATE_TRACKING')
    var DD_TRACE_EXPERIMENTAL_SPAN_COUNTS = getEnvironmentVariable('DD_TRACE_EXPERIMENTAL_SPAN_COUNTS')
    var unfinishedRegistry = createRegistry('unfinished')
    var finishedRegistry = createRegistry('finished')
    var OTEL_ENABLED = !!getEnvironmentVariable('DD_TRACE_OTEL_ENABLED')
    var ALLOWED = /* @__PURE__ */ new Set(['string', 'number', 'boolean'])
    var integrationCounters = {
      spans_created: {},
      spans_finished: {},
    }
    var startCh = channel('dd-trace:span:start')
    var finishCh = channel('dd-trace:span:finish')
    function getIntegrationCounter(event, integration) {
      const counters = integrationCounters[event]
      if (integration in counters) {
        return counters[integration]
      }
      const counter = tracerMetrics.count(event, [
        `integration_name:${integration.toLowerCase()}`,
        `otel_enabled:${OTEL_ENABLED}`,
      ])
      integrationCounters[event][integration] = counter
      return counter
    }
    var DatadogSpan = class {
      constructor(tracer2, processor, prioritySampler, fields, debug) {
        const operationName = fields.operationName
        const parent = fields.parent || null
        const tags = Object.assign({}, fields.tags)
        const hostname = fields.hostname
        this._parentTracer = tracer2
        this._debug = debug
        this._processor = processor
        this._prioritySampler = prioritySampler
        this._store = storage('legacy').getHandle()
        this._duration = void 0
        this._events = []
        this._name = operationName
        this._integrationName = fields.integrationName || 'opentracing'
        getIntegrationCounter('spans_created', this._integrationName).inc()
        this._spanContext = this._createContext(parent, fields)
        this._spanContext._name = operationName
        this._spanContext._tags = tags
        this._spanContext._hostname = hostname
        this._spanContext._trace.started.push(this)
        this._startTime = fields.startTime || this._getTime()
        this._links =
          fields.links?.map((link) => ({
            context: link.context._ddContext ?? link.context,
            attributes: this._sanitizeAttributes(link.attributes),
          })) ?? []
        if (DD_TRACE_EXPERIMENTAL_SPAN_COUNTS && finishedRegistry) {
          runtimeMetrics.increment('runtime.node.spans.unfinished')
          runtimeMetrics.increment('runtime.node.spans.unfinished.by.name', `span_name:${operationName}`)
          runtimeMetrics.increment('runtime.node.spans.open')
          runtimeMetrics.increment('runtime.node.spans.open.by.name', `span_name:${operationName}`)
          unfinishedRegistry.register(this, operationName, this)
        }
        if (tracer2?._config?.spanLeakDebug > 0) {
          require_spanleak().addSpan(this, operationName)
        }
        if (startCh.hasSubscribers) {
          startCh.publish({ span: this, fields })
        }
      }
      [util.inspect.custom]() {
        return {
          ...this,
          _parentTracer: `[${this._parentTracer.constructor.name}]`,
          _prioritySampler: `[${this._prioritySampler.constructor.name}]`,
          _processor: `[${this._processor.constructor.name}]`,
        }
      }
      toString() {
        const spanContext = this.context()
        const resourceName = spanContext._tags['resource.name'] || ''
        const resource = resourceName.length > 100 ? `${resourceName.slice(0, 97)}...` : resourceName
        const json = JSON.stringify({
          traceId: spanContext._traceId,
          spanId: spanContext._spanId,
          parentId: spanContext._parentId,
          service: spanContext._tags['service.name'],
          name: spanContext._name,
          resource,
        })
        return `Span${json}`
      }
      /**
       * @returns {import('../priority_sampler').DatadogSpanContext}
       */
      context() {
        return this._spanContext
      }
      tracer() {
        return this._parentTracer
      }
      setOperationName(name) {
        this._spanContext._name = name
        return this
      }
      setBaggageItem(key, value) {
        this._spanContext._baggageItems[key] = value
        return this
      }
      getBaggageItem(key) {
        return this._spanContext._baggageItems[key]
      }
      getAllBaggageItems() {
        return JSON.stringify(this._spanContext._baggageItems)
      }
      removeBaggageItem(key) {
        delete this._spanContext._baggageItems[key]
      }
      removeAllBaggageItems() {
        this._spanContext._baggageItems = {}
      }
      setTag(key, value) {
        this._addTags({ [key]: value })
        return this
      }
      addTags(keyValueMap) {
        this._addTags(keyValueMap)
        return this
      }
      log() {
        return this
      }
      logEvent() {}
      addLink(link, attrs) {
        if (link instanceof SpanContext) {
          link = { context: link, attributes: attrs ?? {} }
        }
        const { context, attributes } = link
        this._links.push({
          context: context._ddContext ?? context,
          attributes: this._sanitizeAttributes(attributes),
        })
      }
      addLinks(links) {
        links.forEach((link) => this.addLink(link))
        return this
      }
      addSpanPointer(ptrKind, ptrDir, ptrHash) {
        const zeroContext = new SpanContext({
          traceId: id('0'),
          spanId: id('0'),
        })
        const attributes = {
          'ptr.kind': ptrKind,
          'ptr.dir': ptrDir,
          'ptr.hash': ptrHash,
          'link.kind': 'span-pointer',
        }
        this.addLink({ context: zeroContext, attributes })
      }
      addEvent(name, attributesOrStartTime, startTime) {
        const event = { name }
        if (attributesOrStartTime) {
          if (typeof attributesOrStartTime === 'object') {
            event.attributes = this._sanitizeEventAttributes(attributesOrStartTime)
          } else {
            startTime = attributesOrStartTime
          }
        }
        event.startTime = startTime || this._getTime()
        this._events.push(event)
      }
      finish(finishTime) {
        if (this._duration !== void 0) {
          return
        }
        if (DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true' && !this._spanContext._tags['service.name']) {
          log.error('Finishing invalid span: %s', this)
        }
        getIntegrationCounter('spans_finished', this._integrationName).inc()
        this._spanContext._tags['_dd.integration'] = this._integrationName
        if (DD_TRACE_EXPERIMENTAL_SPAN_COUNTS && finishedRegistry) {
          runtimeMetrics.decrement('runtime.node.spans.unfinished')
          runtimeMetrics.decrement('runtime.node.spans.unfinished.by.name', `span_name:${this._name}`)
          runtimeMetrics.increment('runtime.node.spans.finished')
          runtimeMetrics.increment('runtime.node.spans.finished.by.name', `span_name:${this._name}`)
          runtimeMetrics.decrement('runtime.node.spans.open')
          runtimeMetrics.decrement('runtime.node.spans.open.by.name', `span_name:${this._name}`)
          unfinishedRegistry.unregister(this)
          finishedRegistry.register(this, this._name)
        }
        finishTime = Number.parseFloat(finishTime) || this._getTime()
        this._duration = finishTime - this._startTime
        this._spanContext._trace.finished.push(this)
        this._spanContext._isFinished = true
        finishCh.publish(this)
        this._processor.process(this)
      }
      _sanitizeAttributes(attributes = {}) {
        const sanitizedAttributes = {}
        const addArrayOrScalarAttributes = (key, maybeArray) => {
          if (Array.isArray(maybeArray)) {
            for (const subkey in maybeArray) {
              addArrayOrScalarAttributes(`${key}.${subkey}`, maybeArray[subkey])
            }
          } else {
            const maybeScalar = maybeArray
            if (ALLOWED.has(typeof maybeScalar)) {
              sanitizedAttributes[key] = typeof maybeScalar === 'string' ? maybeScalar : String(maybeScalar)
            } else {
              log.warn('Dropping span link attribute. It is not of an allowed type')
            }
          }
        }
        Object.entries(attributes).forEach((entry) => {
          const [key, value] = entry
          addArrayOrScalarAttributes(key, value)
        })
        return sanitizedAttributes
      }
      _sanitizeEventAttributes(attributes = {}) {
        const sanitizedAttributes = {}
        for (const key in attributes) {
          const value = attributes[key]
          if (Array.isArray(value)) {
            const newArray = []
            for (const subkey in value) {
              if (ALLOWED.has(typeof value[subkey])) {
                newArray.push(value[subkey])
              } else {
                log.warn('Dropping span event attribute. It is not of an allowed type')
              }
            }
            sanitizedAttributes[key] = newArray
          } else if (ALLOWED.has(typeof value)) {
            sanitizedAttributes[key] = value
          } else {
            log.warn('Dropping span event attribute. It is not of an allowed type')
          }
        }
        return sanitizedAttributes
      }
      _createContext(parent, fields) {
        let spanContext
        let startTime
        let baggage = {}
        if (parent && parent._isRemote && this._parentTracer?._config?.tracePropagationBehaviorExtract !== 'continue') {
          baggage = parent._baggageItems
          parent = null
        }
        if (fields.context) {
          spanContext = fields.context
          if (!spanContext._trace.startTime) {
            startTime = dateNow()
          }
        } else if (parent) {
          spanContext = new SpanContext({
            traceId: parent._traceId,
            spanId: id(),
            parentId: parent._spanId,
            sampling: parent._sampling,
            baggageItems: { ...parent._baggageItems },
            trace: parent._trace,
            tracestate: parent._tracestate,
          })
          if (!spanContext._trace.startTime) {
            startTime = dateNow()
          }
        } else {
          const spanId = id()
          startTime = dateNow()
          spanContext = new SpanContext({
            traceId: spanId,
            spanId,
          })
          spanContext._trace.startTime = startTime
          if (fields.traceId128BitGenerationEnabled) {
            spanContext._trace.tags['_dd.p.tid'] = Math.floor(startTime / 1e3)
              .toString(16)
              .padStart(8, '0')
              .padEnd(16, '0')
          }
          if (this._parentTracer?._config?.tracePropagationBehaviorExtract === 'restart') {
            spanContext._baggageItems = baggage
          }
        }
        spanContext._trace.ticks = spanContext._trace.ticks || now()
        if (startTime) {
          spanContext._trace.startTime = startTime
        }
        spanContext._isRemote = false
        return spanContext
      }
      _getTime() {
        const { startTime, ticks } = this._spanContext._trace
        return startTime + now() - ticks
      }
      _addTags(keyValuePairs) {
        tagger.add(this._spanContext._tags, keyValuePairs)
        this._prioritySampler.sample(this, false)
      }
    }
    function createRegistry(type) {
      return new global.FinalizationRegistry((name) => {
        runtimeMetrics.decrement(`runtime.node.spans.${type}`)
        runtimeMetrics.decrement(`runtime.node.spans.${type}.by.name`, [`span_name:${name}`])
      })
    }
    module2.exports = DatadogSpan
  },
})

// node_modules/dd-trace/ext/tags.js
var require_tags = __commonJS({
  'node_modules/dd-trace/ext/tags.js'(exports2, module2) {
    'use strict'
    var tags = {
      // Common
      SERVICE_NAME: 'service.name',
      RESOURCE_NAME: 'resource.name',
      SPAN_TYPE: 'span.type',
      SPAN_KIND: 'span.kind',
      SAMPLING_PRIORITY: 'sampling.priority',
      ANALYTICS: '_dd1.sr.eausr',
      ERROR: 'error',
      MANUAL_KEEP: 'manual.keep',
      MANUAL_DROP: 'manual.drop',
      MEASURED: '_dd.measured',
      BASE_SERVICE: '_dd.base_service',
      DD_PARENT_ID: '_dd.parent_id',
      // HTTP
      HTTP_URL: 'http.url',
      HTTP_METHOD: 'http.method',
      HTTP_STATUS_CODE: 'http.status_code',
      HTTP_ROUTE: 'http.route',
      HTTP_ENDPOINT: 'http.endpoint',
      HTTP_REQUEST_HEADERS: 'http.request.headers',
      HTTP_RESPONSE_HEADERS: 'http.response.headers',
      HTTP_USERAGENT: 'http.useragent',
      HTTP_CLIENT_IP: 'http.client_ip',
      // Messaging
      // DSM Specific
      PATHWAY_HASH: 'pathway.hash',
    }
    tags.ANALYTICS_SAMPLE_RATE = tags.ANALYTICS
    module2.exports = tags
  },
})

// node_modules/dd-trace/ext/kinds.js
var require_kinds = __commonJS({
  'node_modules/dd-trace/ext/kinds.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      SERVER: 'server',
      CLIENT: 'client',
      PRODUCER: 'producer',
      CONSUMER: 'consumer',
      INTERNAL: 'internal',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/span.js
var require_span3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/span.js'(exports2, module2) {
    'use strict'
    var api = require('@opentelemetry/api')
    var { performance: performance2 } = require('perf_hooks')
    var { timeOrigin } = performance2
    var { timeInputToHrTime } = require_core()
    var tracer2 = require_dd_trace()
    var DatadogSpan = require_span2()
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK, IGNORE_OTEL_ERROR } = require_constants2()
    var { SERVICE_NAME, RESOURCE_NAME, SPAN_KIND } = require_tags()
    var kinds = require_kinds()
    var SpanContext = require_span_context3()
    var id = require_id()
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6
    }
    function isTimeInput(startTime) {
      if (typeof startTime === 'number') {
        return true
      }
      if (startTime instanceof Date) {
        return true
      }
      if (
        Array.isArray(startTime) &&
        startTime.length === 2 &&
        typeof startTime[0] === 'number' &&
        typeof startTime[1] === 'number'
      ) {
        return true
      }
      return false
    }
    var spanKindNames = {
      [api.SpanKind.INTERNAL]: kinds.INTERNAL,
      [api.SpanKind.SERVER]: kinds.SERVER,
      [api.SpanKind.CLIENT]: kinds.CLIENT,
      [api.SpanKind.PRODUCER]: kinds.PRODUCER,
      [api.SpanKind.CONSUMER]: kinds.CONSUMER,
    }
    function spanNameMapper(spanName, kind, attributes) {
      if (spanName) return spanName
      const opName = attributes['operation.name']
      if (opName) return opName
      const { INTERNAL, SERVER, CLIENT } = api.SpanKind
      for (const key of ['http.method', 'http.request.method']) {
        if (key in attributes) {
          if (kind === SERVER) {
            return 'http.server.request'
          }
          if (kind === CLIENT) {
            return 'http.client.request'
          }
        }
      }
      const dbSystem = attributes['db.system']
      if (dbSystem && kind === CLIENT) {
        return `${dbSystem}.query`
      }
      const msgSys = attributes['messaging.system']
      const msgOp = attributes['messaging.operation']
      if (msgSys && msgOp && kind !== INTERNAL) {
        return `${msgSys}.${msgOp}`
      }
      const rpcSystem = attributes['rpc.system']
      if (rpcSystem) {
        if (kind === CLIENT) {
          return rpcSystem === 'aws-api'
            ? `aws.${attributes['rpc.service'] || 'client'}.request`
            : `${rpcSystem}.client.request`
        }
        if (kind === SERVER) {
          return `${rpcSystem}.server.request`
        }
      }
      const faasProvider = attributes['faas.invoked_provider']
      const faasName = attributes['faas.invoked_name']
      const faasTrigger = attributes['faas.trigger']
      if (kind === CLIENT && faasProvider && faasName) {
        return `${faasProvider}.${faasName}.invoke`
      }
      if (kind === SERVER && faasTrigger) {
        return `${faasTrigger}.invoke`
      }
      const isGraphQL = 'graphql.operation.type' in attributes
      if (isGraphQL) return 'graphql.server.request'
      const protocol = attributes['network.protocol.name']
      const protocolPrefix = protocol ? `${protocol}.` : ''
      if (kind === SERVER) return `${protocolPrefix}server.request`
      if (kind === CLIENT) return `${protocolPrefix}client.request`
      return spanKindNames[kind]
    }
    var Span = class {
      constructor(parentTracer, context, spanName, spanContext, kind, links = [], timeInput, attributes) {
        const { _tracer } = tracer2
        const hrStartTime = timeInputToHrTime(timeInput || performance2.now() + timeOrigin)
        const startTime = hrTimeToMilliseconds(hrStartTime)
        this._ddSpan = new DatadogSpan(
          _tracer,
          _tracer._processor,
          _tracer._prioritySampler,
          {
            operationName: spanNameMapper(spanName, kind, attributes),
            context: spanContext._ddContext,
            startTime,
            hostname: _tracer._hostname,
            integrationName: parentTracer?._isOtelLibrary ? 'otel.library' : 'otel',
            tags: {
              [SERVICE_NAME]: _tracer._service,
              [RESOURCE_NAME]: spanName,
              [SPAN_KIND]: spanKindNames[kind],
            },
            links,
          },
          _tracer._debug
        )
        if (attributes) {
          this.setAttributes(attributes)
        }
        this._parentTracer = parentTracer
        this._context = context
        this._hasStatus = false
        this.startTime = hrStartTime
        this.kind = kind
        this._spanProcessor.onStart(this, context)
      }
      get parentSpanId() {
        const { _parentId } = this._ddSpan.context()
        return _parentId && _parentId.toString(16)
      }
      // Expected by OTel
      get resource() {
        return this._parentTracer.resource
      }
      get instrumentationLibrary() {
        return this._parentTracer.instrumentationLibrary
      }
      get _spanProcessor() {
        return this._parentTracer.getActiveSpanProcessor()
      }
      get name() {
        return this._ddSpan.context()._name
      }
      spanContext() {
        return new SpanContext(this._ddSpan.context())
      }
      setAttribute(key, value) {
        if (key === 'http.response.status_code') {
          this._ddSpan.setTag('http.status_code', value.toString())
        }
        this._ddSpan.setTag(key, value)
        return this
      }
      setAttributes(attributes) {
        if ('http.response.status_code' in attributes) {
          attributes['http.status_code'] = attributes['http.response.status_code'].toString()
        }
        this._ddSpan.addTags(attributes)
        return this
      }
      addLink(link, attrs) {
        if (link instanceof SpanContext) {
          link = { context: link, attributes: attrs ?? {} }
        }
        const { context, attributes } = link
        const ddSpanContext = context._ddContext
        this._ddSpan.addLink({ context: ddSpanContext, attributes })
        return this
      }
      addLinks(links) {
        links.forEach((link) => this.addLink(link))
        return this
      }
      addSpanPointer(ptrKind, ptrDir, ptrHash) {
        const zeroContext = new SpanContext({
          traceId: id('0'),
          spanId: id('0'),
        })
        const attributes = {
          'ptr.kind': ptrKind,
          'ptr.dir': ptrDir,
          'ptr.hash': ptrHash,
          'link.kind': 'span-pointer',
        }
        return this.addLink(zeroContext, attributes)
      }
      setStatus({ code, message }) {
        if (!this.ended && !this._hasStatus && code) {
          this._hasStatus = true
          if (code === 2) {
            this._ddSpan.addTags({
              [ERROR_MESSAGE]: message,
              [IGNORE_OTEL_ERROR]: false,
            })
          }
        }
        return this
      }
      updateName(name) {
        if (!this.ended) {
          this._ddSpan.setOperationName(name)
        }
        return this
      }
      end(timeInput) {
        if (this.ended) {
          api.diag.error('You can only call end() on a span once.')
          return
        }
        const hrEndTime = timeInputToHrTime(timeInput || performance2.now() + timeOrigin)
        const endTime = hrTimeToMilliseconds(hrEndTime)
        this._ddSpan.finish(endTime)
        this._spanProcessor.onEnd(this)
      }
      isRecording() {
        return this.ended === false
      }
      addEvent(name, attributesOrStartTime, startTime) {
        startTime = attributesOrStartTime && isTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime
        const hrStartTime = timeInputToHrTime(startTime || performance2.now() + timeOrigin)
        startTime = hrTimeToMilliseconds(hrStartTime)
        this._ddSpan.addEvent(name, attributesOrStartTime, startTime)
        return this
      }
      recordException(exception, timeInput) {
        this._ddSpan.addTags({
          [ERROR_TYPE]: exception.name,
          [ERROR_MESSAGE]: exception.message,
          [ERROR_STACK]: exception.stack,
          [IGNORE_OTEL_ERROR]: this._ddSpan.context()._tags[IGNORE_OTEL_ERROR] ?? true,
        })
        const attributes = {}
        if (exception.message) attributes['exception.message'] = exception.message
        if (exception.type) attributes['exception.type'] = exception.type
        if (exception.escaped) attributes['exception.escaped'] = exception.escaped
        if (exception.stack) attributes['exception.stacktrace'] = exception.stack
        this.addEvent(exception.name, attributes, timeInput)
      }
      get duration() {
        return this._ddSpan._duration
      }
      get ended() {
        return this.duration !== void 0
      }
    }
    module2.exports = Span
  },
})

// node_modules/dd-trace/packages/datadog-core/src/utils/src/pick.js
var require_pick = __commonJS({
  'node_modules/dd-trace/packages/datadog-core/src/utils/src/pick.js'(exports2, module2) {
    'use strict'
    module2.exports = function pick(object, props) {
      const result = {}
      props.forEach((prop) => {
        if (Object.hasOwn(object, prop)) {
          result[prop] = object[prop]
        }
      })
      return result
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/tracestate.js
var require_tracestate = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/tracestate.js'(exports2, module2) {
    'use strict'
    var traceStateRegex = /[ \t]*([^=]+)=([ \t]*[^, \t]+)[ \t]*(,|$)/gim
    var traceStateDataRegex = /([^:]+):([^;]+)(;|$)/gim
    function fromString(Type, regex, value) {
      if (typeof value !== 'string' || !value.length) {
        return new Type()
      }
      const values = []
      for (const row of value.matchAll(regex)) {
        values.unshift(row.slice(1, 3))
      }
      return new Type(values)
    }
    function toString(map, pairSeparator, fieldSeparator) {
      let result = ''
      for (const [key, value] of map) {
        if (result) {
          result = `${fieldSeparator}${result}`
        }
        result = `${key}${pairSeparator}${value}${result}`
      }
      return result
    }
    var TraceStateData = class _TraceStateData extends Map {
      constructor(...args) {
        super(...args)
        this.changed = false
      }
      set(...args) {
        if (this.has(args[0]) && this.get(args[0]) === args[1]) {
          return
        }
        this.changed = true
        return super.set(...args)
      }
      delete(...args) {
        this.changed = true
        return super.delete(...args)
      }
      clear(...args) {
        this.changed = true
        return super.clear(...args)
      }
      static fromString(value) {
        return fromString(_TraceStateData, traceStateDataRegex, value)
      }
      toString() {
        return toString(this, ':', ';')
      }
    }
    var TraceState = class _TraceState extends Map {
      // Delete entries on update to ensure they're moved to the end of the list
      set(key, value) {
        if (this.has(key)) {
          this.delete(key)
        }
        return super.set(key, value)
      }
      forVendor(vendor, handle) {
        const data = super.get(vendor)
        const state = TraceStateData.fromString(data)
        const result = handle(state)
        if (state.changed) {
          const value = state.toString()
          if (value) {
            this.set(vendor, state.toString())
          } else {
            this.delete(vendor)
          }
        }
        return result
      }
      static fromString(value) {
        return fromString(_TraceState, traceStateRegex, value)
      }
      toString() {
        return toString(this, '=', ',')
      }
    }
    module2.exports = TraceState
  },
})

// node_modules/dd-trace/packages/dd-trace/src/baggage.js
var require_baggage = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/baggage.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var baggageStorage = storage('baggage')
    function setBaggageItem(key, value) {
      storage('baggage').enterWith({ ...baggageStorage.getStore(), [key]: value })
      return storage('baggage').getStore()
    }
    function getBaggageItem(key) {
      return storage('baggage').getStore()?.[key]
    }
    function getAllBaggageItems() {
      return storage('baggage').getStore() ?? {}
    }
    function removeBaggageItem(keyToRemove) {
      const { [keyToRemove]: _, ...newBaggage } = storage('baggage').getStore()
      storage('baggage').enterWith(newBaggage)
      return newBaggage
    }
    function removeAllBaggageItems() {
      storage('baggage').enterWith()
      return storage('baggage').getStore()
    }
    module2.exports = {
      setBaggageItem,
      getBaggageItem,
      getAllBaggageItems,
      removeBaggageItem,
      removeAllBaggageItems,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js
var require_text_map = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js'(exports2, module2) {
    'use strict'
    var pick = require_pick()
    var id = require_id()
    var DatadogSpanContext = require_span_context()
    var log = require_log2()
    var TraceState = require_tracestate()
    var tags = require_tags()
    var { channel } = require_dc_polyfill()
    var { setBaggageItem, getAllBaggageItems, removeAllBaggageItems } = require_baggage()
    var telemetryMetrics = require_metrics()
    var { AUTO_KEEP, AUTO_REJECT, USER_KEEP } = require_priority()
    var tracerMetrics = telemetryMetrics.manager.namespace('tracers')
    var injectCh = channel('dd-trace:span:inject')
    var extractCh = channel('dd-trace:span:extract')
    var traceKey = 'x-datadog-trace-id'
    var spanKey = 'x-datadog-parent-id'
    var originKey = 'x-datadog-origin'
    var samplingKey = 'x-datadog-sampling-priority'
    var tagsKey = 'x-datadog-tags'
    var baggagePrefix = 'ot-baggage-'
    var b3TraceKey = 'x-b3-traceid'
    var b3TraceExpr = /^([0-9a-f]{16}){1,2}$/i
    var b3SpanKey = 'x-b3-spanid'
    var b3SpanExpr = /^[0-9a-f]{16}$/i
    var b3ParentKey = 'x-b3-parentspanid'
    var b3SampledKey = 'x-b3-sampled'
    var b3FlagsKey = 'x-b3-flags'
    var b3HeaderKey = 'b3'
    var sqsdHeaderHey = 'x-aws-sqsd-attr-_datadog'
    var b3HeaderExpr = /^(([0-9a-f]{16}){1,2}-[0-9a-f]{16}(-[01d](-[0-9a-f]{16})?)?|[01d])$/i
    var baggageExpr = new RegExp(`^${baggagePrefix}(.+)$`)
    var tagKeyExpr = /^_dd\.p\.[\x21-\x2B\x2D-\x7E]+$/
    var tagValueExpr = /^[\x20-\x2B\x2D-\x7E]*$/
    var traceparentExpr = /^([a-f0-9]{2})-([a-f0-9]{32})-([a-f0-9]{16})-([a-f0-9]{2})(-.*)?$/i
    var traceparentKey = 'traceparent'
    var tracestateKey = 'tracestate'
    var ddKeys = [traceKey, spanKey, samplingKey, originKey]
    var b3Keys = [b3TraceKey, b3SpanKey, b3ParentKey, b3SampledKey, b3FlagsKey, b3HeaderKey]
    var w3cKeys = [traceparentKey, tracestateKey]
    var logKeys = [...ddKeys, ...b3Keys, ...w3cKeys]
    var tracestateOriginFilter = /[^\x20-\x2B\x2D-\x3A\x3C-\x7D]/g
    var tracestateTagKeyFilter = /[^\x21-\x2B\x2D-\x3C\x3E-\x7E]/g
    var tracestateTagValueFilter = /[^\x20-\x2B\x2D-\x3A\x3C-\x7D]/g
    var invalidSegment = /^0+$/
    var zeroTraceId = '0000000000000000'
    var hex16 = /^[0-9A-Fa-f]{16}$/
    var TextMapPropagator = class {
      constructor(config) {
        this._config = config
      }
      inject(spanContext, carrier) {
        if (!carrier) return
        this._injectBaggageItems(spanContext, carrier)
        if (!spanContext) return
        this._injectDatadog(spanContext, carrier)
        this._injectB3MultipleHeaders(spanContext, carrier)
        this._injectB3SingleHeader(spanContext, carrier)
        this._injectTraceparent(spanContext, carrier)
        if (injectCh.hasSubscribers) {
          injectCh.publish({ spanContext, carrier })
        }
        log.debug(() => `Inject into carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)
      }
      extract(carrier) {
        const spanContext = this._extractSpanContext(carrier)
        if (!spanContext) return spanContext
        if (extractCh.hasSubscribers) {
          extractCh.publish({ spanContext, carrier })
        }
        log.debug(() => {
          const keys = JSON.stringify(pick(carrier, logKeys))
          const styles = this._config.tracePropagationStyle.extract.join(', ')
          return `Extract from carrier (${styles}): ${keys}.`
        })
        return spanContext
      }
      _injectDatadog(spanContext, carrier) {
        if (!this._hasPropagationStyle('inject', 'datadog')) return
        carrier[traceKey] = spanContext.toTraceId()
        carrier[spanKey] = spanContext.toSpanId()
        this._injectOrigin(spanContext, carrier)
        this._injectSamplingPriority(spanContext, carrier)
        this._injectTags(spanContext, carrier)
      }
      _injectOrigin(spanContext, carrier) {
        const origin = spanContext._trace.origin
        if (origin) {
          carrier[originKey] = origin
        }
      }
      _injectSamplingPriority(spanContext, carrier) {
        const priority = spanContext._sampling.priority
        if (Number.isInteger(priority)) {
          carrier[samplingKey] = priority.toString()
        }
      }
      _encodeOtelBaggageKey(key) {
        let encoded = encodeURIComponent(key)
        encoded = encoded.replaceAll('(', '%28')
        encoded = encoded.replaceAll(')', '%29')
        return encoded
      }
      _injectBaggageItems(spanContext, carrier) {
        if (this._config.legacyBaggageEnabled) {
          spanContext?._baggageItems &&
            Object.keys(spanContext._baggageItems).forEach((key) => {
              carrier[baggagePrefix + key] = String(spanContext._baggageItems[key])
            })
        }
        if (this._hasPropagationStyle('inject', 'baggage')) {
          let baggage = ''
          let itemCounter = 0
          let byteCounter = 0
          const baggageItems = getAllBaggageItems()
          if (!baggageItems) return
          for (const [key, value] of Object.entries(baggageItems)) {
            const item = `${this._encodeOtelBaggageKey(String(key).trim())}=${encodeURIComponent(String(value).trim())},`
            itemCounter += 1
            byteCounter += Buffer.byteLength(item)
            if (itemCounter > this._config.baggageMaxItems) {
              tracerMetrics.count('context_header.truncated', ['truncation_reason:baggage_item_count_exceeded']).inc()
              break
            }
            if (byteCounter > this._config.baggageMaxBytes) {
              tracerMetrics.count('context_header.truncated', ['truncation_reason:baggage_byte_count_exceeded']).inc()
              break
            }
            baggage += item
          }
          baggage = baggage.slice(0, -1)
          if (baggage) {
            carrier.baggage = baggage
            tracerMetrics.count('context_header_style.injected', ['header_style:baggage']).inc()
          }
        }
      }
      _injectTags(spanContext, carrier) {
        const trace = spanContext._trace
        if (this._config.tagsHeaderMaxLength === 0) {
          log.debug('Trace tag propagation is disabled, skipping injection.')
          return
        }
        const tags2 = []
        for (const key in trace.tags) {
          if (!trace.tags[key] || !key.startsWith('_dd.p.')) continue
          if (!this._validateTagKey(key) || !this._validateTagValue(trace.tags[key])) {
            log.error('Trace tags from span are invalid, skipping injection.')
            return
          }
          tags2.push(`${key}=${trace.tags[key]}`)
        }
        const header = tags2.join(',')
        if (header.length > this._config.tagsHeaderMaxLength) {
          log.error('Trace tags from span are too large, skipping injection.')
        } else if (header) {
          carrier[tagsKey] = header
        }
      }
      _injectB3MultipleHeaders(spanContext, carrier) {
        const hasB3 = this._hasPropagationStyle('inject', 'b3')
        const hasB3multi = this._hasPropagationStyle('inject', 'b3multi')
        if (!(hasB3 || hasB3multi)) return
        carrier[b3TraceKey] = this._getB3TraceId(spanContext)
        carrier[b3SpanKey] = spanContext._spanId.toString(16)
        carrier[b3SampledKey] = spanContext._sampling.priority >= AUTO_KEEP ? '1' : '0'
        if (spanContext._sampling.priority > AUTO_KEEP) {
          carrier[b3FlagsKey] = '1'
        }
        if (spanContext._parentId) {
          carrier[b3ParentKey] = spanContext._parentId.toString(16)
        }
      }
      _injectB3SingleHeader(spanContext, carrier) {
        const hasB3SingleHeader = this._hasPropagationStyle('inject', 'b3 single header')
        if (!hasB3SingleHeader) return null
        const traceId = this._getB3TraceId(spanContext)
        const spanId = spanContext._spanId.toString(16)
        const sampled = spanContext._sampling.priority >= AUTO_KEEP ? '1' : '0'
        carrier[b3HeaderKey] = `${traceId}-${spanId}-${sampled}`
        if (spanContext._parentId) {
          carrier[b3HeaderKey] += '-' + spanContext._parentId.toString(16)
        }
      }
      _injectTraceparent(spanContext, carrier) {
        if (!this._hasPropagationStyle('inject', 'tracecontext')) return
        const {
          _sampling: { priority, mechanism },
          _tracestate: ts = new TraceState(),
          _trace: { origin, tags: tags2 },
        } = spanContext
        carrier[traceparentKey] = spanContext.toTraceparent()
        ts.forVendor('dd', (state) => {
          if (!spanContext._isRemote) {
            state.set('p', spanContext._spanId)
          } else if (spanContext._trace.tags[tags2.DD_PARENT_ID]) {
            state.set('p', spanContext._trace.tags[tags2.DD_PARENT_ID])
          }
          state.set('s', priority)
          if (mechanism) {
            state.set('t.dm', `-${mechanism}`)
          }
          if (typeof origin === 'string') {
            const originValue = origin.replaceAll(tracestateOriginFilter, '_').replaceAll(/[\x3D]/g, '~')
            state.set('o', originValue)
          }
          for (const key in tags2) {
            if (!tags2[key] || !key.startsWith('_dd.p.')) continue
            const tagKey = 't.' + key.slice(6).replaceAll(tracestateTagKeyFilter, '_')
            const tagValue = tags2[key]
              .toString()
              .replaceAll(tracestateTagValueFilter, '_')
              .replaceAll(/[\x3D]/g, '~')
            state.set(tagKey, tagValue)
          }
        })
        carrier.tracestate = ts.toString()
      }
      _hasPropagationStyle(mode, name) {
        return this._config.tracePropagationStyle[mode].includes(name)
      }
      _hasTraceIdConflict(w3cSpanContext, firstSpanContext) {
        return (
          w3cSpanContext !== null &&
          firstSpanContext.toTraceId(true) === w3cSpanContext.toTraceId(true) &&
          firstSpanContext.toSpanId() !== w3cSpanContext.toSpanId()
        )
      }
      _hasParentIdInTags(spanContext) {
        return tags.DD_PARENT_ID in spanContext._trace.tags
      }
      _updateParentIdFromDdHeaders(carrier, firstSpanContext) {
        const ddCtx = this._extractDatadogContext(carrier)
        if (ddCtx !== null) {
          firstSpanContext._trace.tags[tags.DD_PARENT_ID] = ddCtx._spanId.toString().padStart(16, '0')
        }
      }
      _resolveTraceContextConflicts(w3cSpanContext, firstSpanContext, carrier) {
        if (!this._hasTraceIdConflict(w3cSpanContext, firstSpanContext)) {
          return firstSpanContext
        }
        if (this._hasParentIdInTags(w3cSpanContext)) {
          firstSpanContext._trace.tags[tags.DD_PARENT_ID] = w3cSpanContext._trace.tags[tags.DD_PARENT_ID]
        } else {
          this._updateParentIdFromDdHeaders(carrier, firstSpanContext)
        }
        firstSpanContext._spanId = w3cSpanContext._spanId
        return firstSpanContext
      }
      _extractSpanContext(carrier) {
        let context = null
        let style = ''
        for (const extractor of this._config.tracePropagationStyle.extract) {
          let extractedContext = null
          switch (extractor) {
            case 'datadog':
              extractedContext = this._extractDatadogContext(carrier)
              break
            case 'tracecontext':
              extractedContext = this._extractTraceparentContext(carrier)
              break
            case 'b3 single header':
              extractedContext = this._extractB3SingleContext(carrier)
              break
            case 'b3':
              extractedContext = this._config.tracePropagationStyle.otelPropagators
                ? this._extractB3SingleContext(carrier)
                : this._extractB3MultiContext(carrier)
              break
            case 'b3multi':
              extractedContext = this._extractB3MultiContext(carrier)
              break
            default:
              if (extractor !== 'baggage') log.warn('Unknown propagation style:', extractor)
          }
          if (extractedContext === null) {
            continue
          }
          if (context === null) {
            context = extractedContext
            style = extractor
            if (this._config.tracePropagationExtractFirst) {
              break
            }
          } else {
            if (extractor === 'tracecontext') {
              context = this._resolveTraceContextConflicts(this._extractTraceparentContext(carrier), context, carrier)
            }
            if (
              extractedContext._traceId &&
              extractedContext._spanId &&
              extractedContext.toTraceId(true) !== context.toTraceId(true)
            ) {
              const link = {
                context: extractedContext,
                attributes: { reason: 'terminated_context', context_headers: extractor },
              }
              context._links.push(link)
            }
          }
        }
        if (this._config.tracePropagationBehaviorExtract === 'ignore') {
          context._links = []
        } else {
          if (this._config.tracePropagationBehaviorExtract === 'restart') {
            context._links = []
            context._links.push({
              context,
              attributes: {
                reason: 'propagation_behavior_extract',
                context_headers: style,
              },
            })
          }
          this._extractBaggageItems(carrier, context)
        }
        return context || this._extractSqsdContext(carrier)
      }
      _extractDatadogContext(carrier) {
        const spanContext = this._extractGenericContext(carrier, traceKey, spanKey, 10)
        if (!spanContext) return spanContext
        this._extractOrigin(carrier, spanContext)
        this._extractLegacyBaggageItems(carrier, spanContext)
        this._extractSamplingPriority(carrier, spanContext)
        this._extractTags(carrier, spanContext)
        if (this._config.tracePropagationExtractFirst) return spanContext
        const tc = this._extractTraceparentContext(carrier)
        if (tc && spanContext._traceId.equals(tc._traceId)) {
          spanContext._traceparent = tc._traceparent
          spanContext._tracestate = tc._tracestate
        }
        return spanContext
      }
      _extractB3MultiContext(carrier) {
        const b3 = this._extractB3MultipleHeaders(carrier)
        if (!b3) return null
        return this._extractB3Context(b3)
      }
      _extractB3SingleContext(carrier) {
        if (!b3HeaderExpr.test(carrier[b3HeaderKey])) return null
        const b3 = this._extractB3SingleHeader(carrier)
        if (!b3) return null
        return this._extractB3Context(b3)
      }
      _extractB3Context(b3) {
        const debug = b3[b3FlagsKey] === '1'
        const priority = this._getPriority(b3[b3SampledKey], debug)
        const spanContext = this._extractGenericContext(b3, b3TraceKey, b3SpanKey, 16)
        if (priority !== void 0) {
          if (!spanContext) {
            return new DatadogSpanContext({
              traceId: id(),
              spanId: null,
              sampling: { priority },
              isRemote: true,
            })
          }
          spanContext._sampling.priority = priority
        }
        this._extract128BitTraceId(b3[b3TraceKey], spanContext)
        return spanContext
      }
      _extractSqsdContext(carrier) {
        const headerValue = carrier[sqsdHeaderHey]
        if (!headerValue) {
          return null
        }
        let parsed
        try {
          parsed = JSON.parse(headerValue)
        } catch {
          return null
        }
        return this._extractDatadogContext(parsed)
      }
      _extractTraceparentContext(carrier) {
        const headerValue = carrier[traceparentKey]
        if (!headerValue) {
          return null
        }
        const matches = headerValue.trim().match(traceparentExpr)
        if (matches?.length) {
          const [version, traceId, spanId, flags, tail] = matches.slice(1)
          const traceparent = { version }
          const tracestate = TraceState.fromString(carrier.tracestate)
          if (invalidSegment.test(traceId)) return null
          if (invalidSegment.test(spanId)) return null
          if (version === 'ff') return null
          if (tail && version === '00') return null
          const spanContext = new DatadogSpanContext({
            traceId: id(traceId, 16),
            spanId: id(spanId, 16),
            isRemote: true,
            sampling: { priority: Number.parseInt(flags, 10) & 1 ? 1 : 0 },
            traceparent,
            tracestate,
          })
          this._extract128BitTraceId(traceId, spanContext)
          tracestate.forVendor('dd', (state) => {
            for (const [key, value] of state.entries()) {
              switch (key) {
                case 'p': {
                  spanContext._trace.tags[tags.DD_PARENT_ID] = value
                  break
                }
                case 's': {
                  const priority = Number.parseInt(value, 10)
                  if (!Number.isInteger(priority)) continue
                  if (
                    (spanContext._sampling.priority === 1 && priority > 0) ||
                    (spanContext._sampling.priority === 0 && priority < 0)
                  ) {
                    spanContext._sampling.priority = priority
                  }
                  break
                }
                case 'o':
                  spanContext._trace.origin = value
                  break
                case 't.dm': {
                  const mechanism = Math.abs(Number.parseInt(value, 10))
                  if (Number.isInteger(mechanism)) {
                    spanContext._sampling.mechanism = mechanism
                    spanContext._trace.tags['_dd.p.dm'] = `-${mechanism}`
                  }
                  break
                }
                default: {
                  if (!key.startsWith('t.')) continue
                  const subKey = key.slice(2)
                  const transformedValue = value.replaceAll(/[\x7E]/gm, '=')
                  if (subKey === 'tid') {
                    if (!hex16.test(value) || spanContext._trace.tags['_dd.p.tid'] !== transformedValue) {
                      log.error('Invalid trace id %s in tracestate, skipping', value)
                    }
                    continue
                  }
                  spanContext._trace.tags[`_dd.p.${subKey}`] = transformedValue
                }
              }
            }
          })
          this._extractLegacyBaggageItems(carrier, spanContext)
          return spanContext
        }
        return null
      }
      _extractGenericContext(carrier, traceKey2, spanKey2, radix) {
        if (carrier && carrier[traceKey2] && carrier[spanKey2]) {
          if (invalidSegment.test(carrier[traceKey2])) return null
          return new DatadogSpanContext({
            traceId: id(carrier[traceKey2], radix),
            spanId: id(carrier[spanKey2], radix),
            isRemote: true,
          })
        }
        return null
      }
      _extractB3MultipleHeaders(carrier) {
        let empty = true
        const b3 = {}
        if (b3TraceExpr.test(carrier[b3TraceKey]) && b3SpanExpr.test(carrier[b3SpanKey])) {
          b3[b3TraceKey] = carrier[b3TraceKey]
          b3[b3SpanKey] = carrier[b3SpanKey]
          empty = false
        }
        if (carrier[b3SampledKey]) {
          b3[b3SampledKey] = carrier[b3SampledKey]
          empty = false
        }
        if (carrier[b3FlagsKey]) {
          b3[b3FlagsKey] = carrier[b3FlagsKey]
          empty = false
        }
        return empty ? null : b3
      }
      _extractB3SingleHeader(carrier) {
        const header = carrier[b3HeaderKey]
        if (!header) return null
        const parts = header.split('-')
        if (parts[0] === 'd') {
          return {
            [b3SampledKey]: '1',
            [b3FlagsKey]: '1',
          }
        } else if (parts.length === 1) {
          return {
            [b3SampledKey]: parts[0],
          }
        }
        const b3 = {
          [b3TraceKey]: parts[0],
          [b3SpanKey]: parts[1],
        }
        if (parts[2]) {
          b3[b3SampledKey] = parts[2] === '0' ? '0' : '1'
          if (parts[2] === 'd') {
            b3[b3FlagsKey] = '1'
          }
        }
        return b3
      }
      _extractOrigin(carrier, spanContext) {
        const origin = carrier[originKey]
        if (typeof carrier[originKey] === 'string') {
          spanContext._trace.origin = origin
        }
      }
      _decodeOtelBaggageKey(key) {
        let decoded = decodeURIComponent(key)
        decoded = decoded.replaceAll('%28', '(')
        decoded = decoded.replaceAll('%29', ')')
        return decoded
      }
      _extractLegacyBaggageItems(carrier, spanContext) {
        if (this._config.legacyBaggageEnabled) {
          Object.keys(carrier).forEach((key) => {
            const match = key.match(baggageExpr)
            if (match) {
              spanContext._baggageItems[match[1]] = carrier[key]
            }
          })
        }
      }
      _extractBaggageItems(carrier, spanContext) {
        if (!this._hasPropagationStyle('extract', 'baggage')) return
        if (!carrier || !carrier.baggage) return
        const baggages = carrier.baggage.split(',')
        const keysToSpanTag =
          this._config.baggageTagKeys === '*' ? void 0 : new Set(this._config.baggageTagKeys.split(','))
        for (const keyValue of baggages) {
          if (!keyValue.includes('=')) {
            tracerMetrics.count('context_header_style.malformed', ['header_style:baggage']).inc()
            removeAllBaggageItems()
            return
          }
          let [key, value] = keyValue.split('=')
          key = this._decodeOtelBaggageKey(key.trim())
          value = decodeURIComponent(value.trim())
          if (!key || !value) {
            tracerMetrics.count('context_header_style.malformed', ['header_style:baggage']).inc()
            removeAllBaggageItems()
            return
          }
          if (spanContext && (this._config.baggageTagKeys === '*' || keysToSpanTag.has(key))) {
            spanContext._trace.tags['baggage.' + key] = value
          }
          setBaggageItem(key, value)
        }
        tracerMetrics.count('context_header_style.extracted', ['header_style:baggage']).inc()
      }
      _extractSamplingPriority(carrier, spanContext) {
        const priority = Number.parseInt(carrier[samplingKey], 10)
        if (Number.isInteger(priority)) {
          spanContext._sampling.priority = priority
        }
      }
      _extractTags(carrier, spanContext) {
        if (!carrier[tagsKey]) return
        const trace = spanContext._trace
        if (this._config.tagsHeaderMaxLength === 0) {
          log.debug('Trace tag propagation is disabled, skipping extraction.')
        } else if (carrier[tagsKey].length > this._config.tagsHeaderMaxLength) {
          log.error('Trace tags from carrier are too large, skipping extraction.')
        } else {
          const pairs = carrier[tagsKey].split(',')
          const tags2 = {}
          for (const pair of pairs) {
            const [key, ...rest] = pair.split('=')
            const value = rest.join('=')
            if (!this._validateTagKey(key) || !this._validateTagValue(value)) {
              log.error('Trace tags from carrier are invalid, skipping extraction.')
              return
            }
            if (key === '_dd.p.tid' && !hex16.test(value)) {
              log.error('Invalid _dd.p.tid tag %s, skipping', value)
              continue
            }
            tags2[key] = value
          }
          Object.assign(trace.tags, tags2)
        }
      }
      _extract128BitTraceId(traceId, spanContext) {
        if (!spanContext) return
        const buffer = spanContext._traceId.toBuffer()
        if (buffer.length !== 16) return
        const tid = traceId.slice(0, 16)
        if (tid === zeroTraceId) return
        spanContext._trace.tags['_dd.p.tid'] = tid
      }
      _validateTagKey(key) {
        return tagKeyExpr.test(key)
      }
      _validateTagValue(value) {
        return tagValueExpr.test(value)
      }
      _getPriority(sampled, debug) {
        if (debug) {
          return USER_KEEP
        } else if (sampled === '1') {
          return AUTO_KEEP
        } else if (sampled === '0') {
          return AUTO_REJECT
        }
      }
      _getB3TraceId(spanContext) {
        if (spanContext._traceId.toBuffer().length <= 8 && spanContext._trace.tags['_dd.p.tid']) {
          return spanContext._trace.tags['_dd.p.tid'] + spanContext._traceId.toString(16)
        }
        return spanContext._traceId.toString(16)
      }
      static _getSamplingPriority(traceparentSampled, tracestateSamplingPriority, origin = null) {
        const fromRumWithoutPriority = !tracestateSamplingPriority && origin === 'rum'
        let samplingPriority
        if (
          !fromRumWithoutPriority &&
          traceparentSampled === 0 &&
          (!tracestateSamplingPriority || tracestateSamplingPriority >= 0)
        ) {
          samplingPriority = 0
        } else if (
          !fromRumWithoutPriority &&
          traceparentSampled === 1 &&
          (!tracestateSamplingPriority || tracestateSamplingPriority < 0)
        ) {
          samplingPriority = 1
        } else {
          samplingPriority = tracestateSamplingPriority
        }
        return samplingPriority
      }
    }
    module2.exports = TextMapPropagator
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/tracer.js
var require_tracer2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/tracer.js'(exports2, module2) {
    'use strict'
    var api = require('@opentelemetry/api')
    var { sanitizeAttributes } = require_core()
    var Sampler = require_sampler()
    var Span = require_span3()
    var id = require_id()
    var log = require_log2()
    var SpanContext = require_span_context3()
    var TextMapPropagator = require_text_map()
    var TraceState = require_tracestate()
    var Tracer = class {
      constructor(library, config, tracerProvider) {
        this._sampler = new Sampler()
        this._config = config
        this._tracerProvider = tracerProvider
        this.instrumentationLibrary = library
        this._isOtelLibrary = library?.name?.startsWith('@opentelemetry/instrumentation-')
        this._spanLimits = {}
      }
      get resource() {
        return this._tracerProvider.resource
      }
      _createSpanContextFromParent(parentSpanContext) {
        return new SpanContext({
          traceId: parentSpanContext._traceId,
          spanId: id(),
          parentId: parentSpanContext._spanId,
          sampling: parentSpanContext._sampling,
          baggageItems: { ...parentSpanContext._baggageItems },
          trace: parentSpanContext._trace,
          tracestate: parentSpanContext._tracestate,
        })
      }
      // Extracted method to create span context for a new span
      _createSpanContextForNewSpan(context) {
        const { traceId, spanId, traceFlags, traceState } = context
        return this._convertOtelContextToDatadog(traceId, spanId, traceFlags, traceState)
      }
      _convertOtelContextToDatadog(traceId, spanId, traceFlag, ts, meta = {}) {
        const origin = null
        let samplingPriority = traceFlag
        ts = ts?.traceparent || null
        if (ts) {
          const traceState = TraceState.fromString(ts)
          let ddTraceStateData = null
          traceState.forVendor('dd', (state) => {
            ddTraceStateData = state
            return state
          })
          if (ddTraceStateData) {
            const samplingPriorityTs = ddTraceStateData.get('s')
            const origin2 = ddTraceStateData.get('o')
            const otherPropagatedTags = Object.fromEntries(ddTraceStateData.entries())
            Object.assign(meta, otherPropagatedTags)
            samplingPriority = TextMapPropagator._getSamplingPriority(
              traceFlag,
              Number.parseInt(samplingPriorityTs, 10),
              origin2
            )
          } else {
            log.debug('no dd list member in tracestate from incoming request:', ts)
          }
        }
        const spanContext = new SpanContext({
          traceId: id(traceId, 16),
          spanId: id(),
          tags: meta,
          parentId: id(spanId, 16),
        })
        spanContext._sampling = { priority: samplingPriority }
        spanContext._trace = { origin }
        return spanContext
      }
      startSpan(name, options = {}, context = api.context.active()) {
        if (options.root) {
          context = api.trace.deleteSpan(context)
        }
        const parentSpan = api.trace.getSpan(context)
        const parentSpanContext = parentSpan && parentSpan.spanContext()
        let spanContext
        if (parentSpanContext && api.trace.isSpanContextValid(parentSpanContext)) {
          spanContext = parentSpanContext._ddContext
            ? this._createSpanContextFromParent(parentSpanContext._ddContext)
            : this._createSpanContextForNewSpan(parentSpanContext)
        } else {
          spanContext = new SpanContext()
        }
        const spanKind = options.kind || api.SpanKind.INTERNAL
        const links = (options.links || []).map((link) => {
          return {
            context: link.context,
            attributes: sanitizeAttributes(link.attributes),
          }
        })
        const attributes = sanitizeAttributes(options.attributes)
        return new Span(
          this,
          context,
          name,
          spanContext,
          spanKind,
          links,
          options.startTime,
          // Set initial span attributes. The attributes object may have been mutated
          // by the sampler, so we sanitize the merged attributes before setting them.
          sanitizeAttributes(attributes)
        )
      }
      startActiveSpan(name, options, context, fn) {
        if (arguments.length === 2) {
          fn = options
          context = void 0
          options = void 0
        } else if (arguments.length === 3) {
          fn = context
          context = void 0
        } else if (arguments.length !== 4) {
          return
        }
        const parentContext = context || api.context.active()
        const span = this.startSpan(name, options, parentContext)
        const contextWithSpanSet = api.trace.setSpan(parentContext, span)
        return api.context.with(contextWithSpanSet, fn, void 0, span)
      }
      getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor()
      }
      // not used in our codebase but needed for compatibility. See issue #1244
      getSpanLimits() {
        return this._spanLimits
      }
    }
    module2.exports = Tracer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/tracer_provider.js
var require_tracer_provider = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/tracer_provider.js'(exports2, module2) {
    'use strict'
    var { trace, context, propagation } = require('@opentelemetry/api')
    var { W3CTraceContextPropagator } = require_core()
    var tracer2 = require_dd_trace()
    var ContextManager = require_context_manager()
    var { MultiSpanProcessor, NoopSpanProcessor } = require_span_processor()
    var Tracer = require_tracer2()
    var TracerProvider = class {
      constructor(config = {}) {
        this.config = config
        this.resource = config.resource
        this._processors = []
        this._tracers = /* @__PURE__ */ new Map()
        this._activeProcessor = new NoopSpanProcessor()
        this._contextManager = new ContextManager()
      }
      getTracer(name = 'opentelemetry', version = '0.0.0', options) {
        const key = `${name}@${version}`
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer({ ...options, name, version }, this.config, this))
        }
        return this._tracers.get(key)
      }
      addSpanProcessor(spanProcessor) {
        if (!this._processors.length) {
          this._activeProcessor.shutdown()
        }
        this._processors.push(spanProcessor)
        this._activeProcessor = new MultiSpanProcessor(this._processors)
      }
      getActiveSpanProcessor() {
        return this._activeProcessor
      }
      // Not actually required by the SDK spec, but the official Node.js SDK does
      // this and the docs reflect that so we should do this too for familiarity.
      register(config = {}) {
        context.setGlobalContextManager(this._contextManager)
        if (!trace.setGlobalTracerProvider(this)) {
          trace.getTracerProvider().setDelegate(this)
        }
        if (config.propagator) {
          propagation.setGlobalPropagator(config.propagator)
        } else {
          propagation.setGlobalPropagator(new W3CTraceContextPropagator())
        }
      }
      forceFlush() {
        const exporter = tracer2._tracer._exporter
        if (!exporter) {
          return Promise.reject(new Error('Not started'))
        }
        exporter._writer.flush()
        return this._activeProcessor.forceFlush()
      }
      shutdown() {
        return this._activeProcessor.shutdown()
      }
    }
    module2.exports = TracerProvider
  },
})

// node_modules/dd-trace/packages/dd-trace/src/noop/proxy.js
var require_proxy = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/noop/proxy.js'(exports2, module2) {
    'use strict'
    var NoopTracer = require_tracer()
    var NoopAppsecSdk = require_noop()
    var NoopDogStatsDClient = require_dogstatsd()
    var NoopLLMObsSDK = require_noop2()
    var NoopFlaggingProvider = require_noop3()
    var NoopAIGuardSDK = require_noop4()
    var noop = new NoopTracer()
    var noopAppsec = new NoopAppsecSdk()
    var noopDogStatsDClient = new NoopDogStatsDClient()
    var noopLLMObs = new NoopLLMObsSDK(noop)
    var noopOpenFeatureProvider = new NoopFlaggingProvider()
    var noopAIGuard = new NoopAIGuardSDK()
    var NoopProxy = class {
      constructor() {
        this._tracer = noop
        this.appsec = noopAppsec
        this.dogstatsd = noopDogStatsDClient
        this.llmobs = noopLLMObs
        this.openfeature = noopOpenFeatureProvider
        this.aiguard = noopAIGuard
        this.setBaggageItem = () => {}
        this.getBaggageItem = () => {}
        this.getAllBaggageItems = () => {}
        this.removeBaggageItem = () => {}
        this.removeAllBaggageItems = () => {}
      }
      init() {
        return this
      }
      use() {
        return this
      }
      profilerStarted() {
        return Promise.resolve(false)
      }
      trace(name, options, fn) {
        if (!fn) {
          fn = options
          options = {}
        }
        if (typeof fn !== 'function') return
        options = options || {}
        return this._tracer.trace(name, options, fn)
      }
      wrap(name, options, fn) {
        if (!fn) {
          fn = options
          options = {}
        }
        if (typeof fn !== 'function') return fn
        options = options || {}
        return this._tracer.wrap(name, options, fn)
      }
      setUrl() {
        this._tracer.setUrl.apply(this._tracer, arguments)
        return this
      }
      startSpan() {
        return this._tracer.startSpan.apply(this._tracer, arguments)
      }
      inject() {
        return this._tracer.inject.apply(this._tracer, arguments)
      }
      extract() {
        return this._tracer.extract.apply(this._tracer, arguments)
      }
      scope() {
        return this._tracer.scope.apply(this._tracer, arguments)
      }
      getRumData() {
        return this._tracer.getRumData.apply(this._tracer, arguments)
      }
      setUser(user) {
        this.appsec.setUser(user)
        return this
      }
      get TracerProvider() {
        return require_tracer_provider()
      }
    }
    module2.exports = NoopProxy
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/extra-services.js
var require_extra_services = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/extra-services.js'(exports2, module2) {
    'use strict'
    var maxExtraServices = 64
    var extraServices = /* @__PURE__ */ new Set()
    function getExtraServices() {
      return [...extraServices]
    }
    function registerExtraService(serviceName) {
      if (serviceName && extraServices.size < maxExtraServices) {
        extraServices.add(serviceName)
      }
    }
    function clear() {
      extraServices.clear()
    }
    module2.exports = {
      registerExtraService,
      getExtraServices,
      clear,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/process-tags/index.js
var require_process_tags = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/process-tags/index.js'(exports2, module2) {
    'use strict'
    var path = require('node:path')
    var pkg = require_pkg()
    var CURRENT_WORKING_DIRECTORY = process.cwd()
    var ENTRYPOINT_PATH = require.main?.filename || ''
    var TRACING_FIELD_NAME = '_dd.tags.process'
    var DSM_FIELD_NAME = 'ProcessTags'
    var PROFILING_FIELD_NAME = 'process_tags'
    module2.exports.TRACING_FIELD_NAME = TRACING_FIELD_NAME
    module2.exports.DSM_FIELD_NAME = DSM_FIELD_NAME
    module2.exports.PROFILING_FIELD_NAME = PROFILING_FIELD_NAME
    module2.exports = function getProcessTags() {
      const tags = [
        // the parent directory name of the entrypoint script, e.g. /foo/bar/baz/banana.js -> baz
        ['entrypoint.basedir', ENTRYPOINT_PATH === '' ? void 0 : path.basename(path.dirname(ENTRYPOINT_PATH))],
        // the entrypoint script filename without the extension, e.g. /foo/bar/baz/banana.js -> banana
        ['entrypoint.name', path.basename(ENTRYPOINT_PATH, path.extname(ENTRYPOINT_PATH)) || void 0],
        // always script for JavaScript applications
        ['entrypoint.type', 'script'],
        // last segment of the current working directory, e.g. /foo/bar/baz/ -> baz
        ['entrypoint.workdir', path.basename(CURRENT_WORKING_DIRECTORY) || void 0],
        // the .name field from the application's package.json
        ['package.json.name', pkg.name || void 0],
      ]
      const serialized = serialize(tags)
      return {
        tags,
        serialized,
      }
    }
    function serialize(tags) {
      const intermediary = []
      for (const [name, value] of tags) {
        if (value === void 0) continue
        intermediary.push(`${name}:${sanitize(value)}`)
      }
      return intermediary.join(',')
    }
    module2.exports.serialize = serialize
    function sanitize(value) {
      return String(value)
        .toLowerCase()
        .replaceAll(/[^a-zA-Z0-9/_.-]+/g, '_')
    }
    module2.exports.sanitize = sanitize
  },
})

// node_modules/dd-trace/packages/dd-trace/src/span_format.js
var require_span_format = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/span_format.js'(exports2, module2) {
    'use strict'
    var constants = require_constants2()
    var tags = require_tags()
    var id = require_id()
    var { isError } = require_util()
    var { registerExtraService } = require_extra_services()
    var { TRACING_FIELD_NAME } = require_process_tags()
    var SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY
    var SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION
    var SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION
    var SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION
    var SPAN_SAMPLING_MECHANISM = constants.SPAN_SAMPLING_MECHANISM
    var SPAN_SAMPLING_RULE_RATE = constants.SPAN_SAMPLING_RULE_RATE
    var SPAN_SAMPLING_MAX_PER_SECOND = constants.SPAN_SAMPLING_MAX_PER_SECOND
    var SAMPLING_MECHANISM_SPAN = constants.SAMPLING_MECHANISM_SPAN
    var { MEASURED, BASE_SERVICE, ANALYTICS } = tags
    var ORIGIN_KEY = constants.ORIGIN_KEY
    var HOSTNAME_KEY = constants.HOSTNAME_KEY
    var TOP_LEVEL_KEY = constants.TOP_LEVEL_KEY
    var PROCESS_ID = constants.PROCESS_ID
    var ERROR_MESSAGE = constants.ERROR_MESSAGE
    var ERROR_STACK = constants.ERROR_STACK
    var ERROR_TYPE = constants.ERROR_TYPE
    var { IGNORE_OTEL_ERROR } = constants
    var map = {
      'operation.name': 'name',
      'service.name': 'service',
      'span.type': 'type',
      'resource.name': 'resource',
    }
    function format(span, isFirstSpanInChunk = false, tagForFirstSpanInChunk = false) {
      const formatted = formatSpan(span)
      extractSpanLinks(formatted, span)
      extractSpanEvents(formatted, span)
      extractRootTags(formatted, span)
      extractChunkTags(formatted, span, isFirstSpanInChunk, tagForFirstSpanInChunk)
      extractTags(formatted, span)
      return formatted
    }
    function formatSpan(span) {
      const spanContext = span.context()
      return {
        trace_id: spanContext._traceId,
        span_id: spanContext._spanId,
        parent_id: spanContext._parentId || id('0'),
        name: String(spanContext._name),
        resource: String(spanContext._name),
        error: 0,
        meta: {},
        meta_struct: span.meta_struct,
        metrics: {},
        start: Math.round(span._startTime * 1e6),
        duration: Math.round(span._duration * 1e6),
        links: [],
      }
    }
    function setSingleSpanIngestionTags(span, options) {
      if (!options) return
      addTag({}, span.metrics, SPAN_SAMPLING_MECHANISM, SAMPLING_MECHANISM_SPAN)
      addTag({}, span.metrics, SPAN_SAMPLING_RULE_RATE, options.sampleRate)
      addTag({}, span.metrics, SPAN_SAMPLING_MAX_PER_SECOND, options.maxPerSecond)
    }
    function extractSpanLinks(formattedSpan, span) {
      if (!span._links?.length) {
        return
      }
      const links = span._links.map((link) => {
        const { context, attributes } = link
        const formattedLink = {
          trace_id: context.toTraceId(true),
          span_id: context.toSpanId(true),
        }
        if (attributes && Object.keys(attributes).length > 0) {
          formattedLink.attributes = attributes
        }
        if (context?._sampling?.priority >= 0) formattedLink.flags = context._sampling.priority > 0 ? 1 : 0
        if (context?._tracestate) formattedLink.tracestate = context._tracestate.toString()
        return formattedLink
      })
      formattedSpan.meta['_dd.span_links'] = JSON.stringify(links)
    }
    function extractSpanEvents(formattedSpan, span) {
      if (!span._events?.length) {
        return
      }
      const events = span._events.map((event) => {
        return {
          name: event.name,
          time_unix_nano: Math.round(event.startTime * 1e6),
          attributes: event.attributes && Object.keys(event.attributes).length > 0 ? event.attributes : void 0,
        }
      })
      formattedSpan.span_events = events
    }
    function extractTags(formattedSpan, span) {
      const context = span.context()
      const origin = context._trace.origin
      const tags2 = context._tags
      const hostname = context._hostname
      const priority = context._sampling.priority
      if (tags2['span.kind'] && tags2['span.kind'] !== 'internal') {
        addTag({}, formattedSpan.metrics, MEASURED, 1)
      }
      const tracerService = span.tracer()._service.toLowerCase()
      if (tags2['service.name']?.toLowerCase() !== tracerService) {
        span.setTag(BASE_SERVICE, tracerService)
        registerExtraService(tags2['service.name'])
      }
      for (const [tag, value] of Object.entries(tags2)) {
        switch (tag) {
          case 'service.name':
          case 'span.type':
          case 'resource.name':
            addTag(formattedSpan, {}, map[tag], value)
            break
          // HACK: remove when Datadog supports numeric status code
          case 'http.status_code':
            addTag(formattedSpan.meta, {}, tag, value && String(value))
            break
          case 'analytics.event':
            addTag({}, formattedSpan.metrics, ANALYTICS, value === void 0 || value ? 1 : 0)
            break
          case HOSTNAME_KEY:
          case MEASURED:
            addTag({}, formattedSpan.metrics, tag, value === void 0 || value ? 1 : 0)
            break
          // TODO(BridgeAR)[31.03.2025]: How come we use two different ways to pass
          // through errors? Can we just unify the behavior to always use one way?
          case 'error':
            if (context._name !== 'fs.operation') {
              extractError(formattedSpan, value)
            }
            break
          case ERROR_TYPE:
          case ERROR_MESSAGE:
          case ERROR_STACK:
            if (context._name === 'fs.operation') {
              break
            }
            if (!tags2[IGNORE_OTEL_ERROR]) {
              formattedSpan.error = 1
            }
          default:
            addTag(formattedSpan.meta, formattedSpan.metrics, tag, value)
        }
      }
      setSingleSpanIngestionTags(formattedSpan, context._spanSampling)
      addTag(formattedSpan.meta, formattedSpan.metrics, 'language', 'javascript')
      addTag(formattedSpan.meta, formattedSpan.metrics, PROCESS_ID, process.pid)
      addTag(formattedSpan.meta, formattedSpan.metrics, SAMPLING_PRIORITY_KEY, priority)
      addTag(formattedSpan.meta, formattedSpan.metrics, ORIGIN_KEY, origin)
      addTag(formattedSpan.meta, formattedSpan.metrics, HOSTNAME_KEY, hostname)
    }
    function extractRootTags(formattedSpan, span) {
      const context = span.context()
      const isLocalRoot = span === context._trace.started[0]
      const parentId = context._parentId
      if (!isLocalRoot || (parentId && parentId.toString(10) !== '0')) return
      addTag({}, formattedSpan.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION])
      addTag({}, formattedSpan.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION])
      addTag({}, formattedSpan.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION])
      addTag({}, formattedSpan.metrics, TOP_LEVEL_KEY, 1)
    }
    function extractChunkTags(formattedSpan, span, isFirstSpanInChunk, tagForFirstSpanInChunk) {
      const context = span.context()
      if (!isFirstSpanInChunk) return
      if (tagForFirstSpanInChunk) {
        addTag(formattedSpan.meta, formattedSpan.metrics, TRACING_FIELD_NAME, tagForFirstSpanInChunk)
      }
      for (const [key, value] of Object.entries(context._trace.tags)) {
        addTag(formattedSpan.meta, formattedSpan.metrics, key, value)
      }
    }
    function extractError(formattedSpan, error) {
      if (!error) return
      formattedSpan.error = 1
      if (isError(error)) {
        addTag(formattedSpan.meta, formattedSpan.metrics, ERROR_MESSAGE, error.message || error.code)
        addTag(formattedSpan.meta, formattedSpan.metrics, ERROR_TYPE, error.name)
        addTag(formattedSpan.meta, formattedSpan.metrics, ERROR_STACK, error.stack)
      }
    }
    function addTag(meta, metrics, key, value, nested) {
      switch (typeof value) {
        case 'string':
          meta[key] = value
          break
        case 'number':
          if (Number.isNaN(value)) break
          metrics[key] = value
          break
        case 'boolean':
          metrics[key] = value ? 1 : 0
          break
        default:
          if (value == null) break
          if (isNodeBuffer(value) || isUrl(value)) {
            metrics[key] = value.toString()
          } else if (!Array.isArray(value) && !nested) {
            for (const [prop, val] of Object.entries(value)) {
              addTag(meta, metrics, `${key}.${prop}`, val, true)
            }
          }
      }
    }
    function isNodeBuffer(obj) {
      return (
        obj.constructor &&
        obj.constructor.name === 'Buffer' &&
        typeof obj.readInt8 === 'function' &&
        typeof obj.toString === 'function'
      )
    }
    function isUrl(obj) {
      return (
        obj.constructor &&
        obj.constructor.name === 'URL' &&
        typeof obj.href === 'string' &&
        typeof obj.toString === 'function'
      )
    }
    module2.exports = format
  },
})

// node_modules/dd-trace/ext/formats.js
var require_formats = __commonJS({
  'node_modules/dd-trace/ext/formats.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      TEXT_MAP: 'text_map',
      HTTP_HEADERS: 'http_headers',
      BINARY: 'binary',
      LOG: 'log',
      TEXT_MAP_DSM: 'text_map_dsm',
    }
  },
})

// node_modules/dd-trace/ext/types.js
var require_types = __commonJS({
  'node_modules/dd-trace/ext/types.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      HTTP: 'http',
      SERVERLESS: 'serverless',
      WEB: 'web',
    }
  },
})

// node_modules/dd-trace/ext/exporters.js
var require_exporters = __commonJS({
  'node_modules/dd-trace/ext/exporters.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      LOG: 'log',
      AGENT: 'agent',
      DATADOG: 'datadog',
      AGENT_PROXY: 'agent_proxy',
      JEST_WORKER: 'jest_worker',
      CUCUMBER_WORKER: 'cucumber_worker',
      MOCHA_WORKER: 'mocha_worker',
      PLAYWRIGHT_WORKER: 'playwright_worker',
      VITEST_WORKER: 'vitest_worker',
    }
  },
})

// node_modules/dd-trace/ext/index.js
var require_ext = __commonJS({
  'node_modules/dd-trace/ext/index.js'(exports2, module2) {
    'use strict'
    var formats = require_formats()
    var kinds = require_kinds()
    var priority = require_priority()
    var tags = require_tags()
    var types = require_types()
    var exporters = require_exporters()
    module2.exports = {
      formats,
      kinds,
      priority,
      tags,
      types,
      exporters,
    }
  },
})

// node_modules/dd-trace/vendor/dist/limiter/index.js
var require_limiter = __commonJS({
  'node_modules/dd-trace/vendor/dist/limiter/index.js'(exports2, module2) {
    ;(() => {
      var t = {
          './limiter/lib/clock.js': function (t2) {
            t2.exports = function () {
              if ('undefined' != typeof process && process.hrtime) {
                var t3 = process.hrtime()
                return 1e3 * t3[0] + Math.floor(t3[1] / 1e6)
              }
              return /* @__PURE__ */ new Date().getTime()
            }
          },
          './limiter/lib/rateLimiter.js': function (t2, e2, n2) {
            var i2 = n2('./limiter/lib/tokenBucket.js'),
              r = n2('./limiter/lib/clock.js'),
              s = function (t3, e3, n3) {
                ;((this.tokenBucket = new i2(t3, t3, e3, null)),
                  (this.tokenBucket.content = t3),
                  (this.curIntervalStart = r()),
                  (this.tokensThisInterval = 0),
                  (this.fireImmediately = n3))
              }
            ;((s.prototype = {
              tokenBucket: null,
              curIntervalStart: 0,
              tokensThisInterval: 0,
              fireImmediately: false,
              removeTokens: function (t3, e3) {
                if (t3 > this.tokenBucket.bucketSize)
                  return (
                    process.nextTick(
                      e3.bind(
                        null,
                        'Requested tokens ' +
                          t3 +
                          ' exceeds maximum tokens per interval ' +
                          this.tokenBucket.bucketSize,
                        null
                      )
                    ),
                    false
                  )
                var n3 = this,
                  i3 = r()
                if (
                  ((i3 < this.curIntervalStart || i3 - this.curIntervalStart >= this.tokenBucket.interval) &&
                    ((this.curIntervalStart = i3), (this.tokensThisInterval = 0)),
                  t3 > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
                )
                  return (
                    this.fireImmediately
                      ? process.nextTick(e3.bind(null, null, -1))
                      : setTimeout(
                          function () {
                            n3.tokenBucket.removeTokens(t3, s2)
                          },
                          Math.ceil(this.curIntervalStart + this.tokenBucket.interval - i3)
                        ),
                    false
                  )
                return this.tokenBucket.removeTokens(t3, s2)
                function s2(i4, r2) {
                  if (i4) return e3(i4, null)
                  ;((n3.tokensThisInterval += t3), e3(null, r2))
                }
              },
              tryRemoveTokens: function (t3) {
                if (t3 > this.tokenBucket.bucketSize) return false
                var e3 = r()
                if (
                  ((e3 < this.curIntervalStart || e3 - this.curIntervalStart >= this.tokenBucket.interval) &&
                    ((this.curIntervalStart = e3), (this.tokensThisInterval = 0)),
                  t3 > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
                )
                  return false
                var n3 = this.tokenBucket.tryRemoveTokens(t3)
                return (n3 && (this.tokensThisInterval += t3), n3)
              },
              getTokensRemaining: function () {
                return (this.tokenBucket.drip(), this.tokenBucket.content)
              },
            }),
              (t2.exports = s))
          },
          './limiter/lib/tokenBucket.js': function (t2) {
            var e2 = function (t3, e3, n2, i2) {
              if (((this.bucketSize = t3), (this.tokensPerInterval = e3), 'string' == typeof n2))
                switch (n2) {
                  case 'sec':
                  case 'second':
                    this.interval = 1e3
                    break
                  case 'min':
                  case 'minute':
                    this.interval = 6e4
                    break
                  case 'hr':
                  case 'hour':
                    this.interval = 36e5
                    break
                  case 'day':
                    this.interval = 864e5
                    break
                  default:
                    throw Error('Invaid interval ' + n2)
                }
              else this.interval = n2
              ;((this.parentBucket = i2), (this.content = 0), (this.lastDrip = +(/* @__PURE__ */ new Date())))
            }
            ;((e2.prototype = {
              bucketSize: 1,
              tokensPerInterval: 1,
              interval: 1e3,
              parentBucket: null,
              content: 0,
              lastDrip: 0,
              removeTokens: function (t3, e3) {
                var n2 = this
                if (!this.bucketSize) return (process.nextTick(e3.bind(null, null, t3, 1 / 0)), true)
                if (t3 > this.bucketSize)
                  return (
                    process.nextTick(
                      e3.bind(null, 'Requested tokens ' + t3 + ' exceeds bucket size ' + this.bucketSize, null)
                    ),
                    false
                  )
                if ((this.drip(), t3 > this.content)) return i2()
                if (this.parentBucket)
                  return this.parentBucket.removeTokens(t3, function (r, s) {
                    return r
                      ? e3(r, null)
                      : t3 > n2.content
                        ? i2()
                        : void ((n2.content -= t3), e3(null, Math.min(s, n2.content)))
                  })
                return ((this.content -= t3), process.nextTick(e3.bind(null, null, this.content)), true)
                function i2() {
                  return (
                    setTimeout(
                      function () {
                        n2.removeTokens(t3, e3)
                      },
                      Math.ceil((t3 - n2.content) * (n2.interval / n2.tokensPerInterval))
                    ),
                    false
                  )
                }
              },
              tryRemoveTokens: function (t3) {
                return (
                  !this.bucketSize ||
                  (!(t3 > this.bucketSize) &&
                    (this.drip(),
                    !(t3 > this.content) &&
                      (!this.parentBucket || !!this.parentBucket.tryRemoveTokens(t3)) &&
                      ((this.content -= t3), true)))
                )
              },
              drip: function () {
                if (!this.tokensPerInterval) {
                  this.content = this.bucketSize
                  return
                }
                var t3 = +(/* @__PURE__ */ new Date()),
                  e3 = Math.max(t3 - this.lastDrip, 0)
                this.lastDrip = t3
                var n2 = e3 * (this.tokensPerInterval / this.interval)
                this.content = Math.min(this.content + n2, this.bucketSize)
              },
            }),
              (t2.exports = e2))
          },
        },
        e = {}
      function n(i2) {
        var r = e[i2]
        if (void 0 !== r) return r.exports
        var s = (e[i2] = { exports: {} })
        return (t[i2](s, s.exports, n), s.exports)
      }
      var i = {}
      ;((i.RateLimiter = n('./limiter/lib/rateLimiter.js')),
        (i.TokenBucket = n('./limiter/lib/tokenBucket.js')),
        (module2.exports = i))
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js
var require_rate_limiter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js'(exports2, module2) {
    'use strict'
    var limiter = require_limiter()
    var RateLimiter = class {
      /**
       * @param {number} rateLimit - Allowed units per interval. Negative means unlimited, 0 disables.
       * @param {'second'|'minute'|'hour'|'day'} [interval='second'] - Time window for the limiter.
       */
      constructor(rateLimit, interval = 'second') {
        this._rateLimit = Number.parseInt(String(rateLimit))
        this._limiter = new limiter.RateLimiter(this._rateLimit, interval)
        this._tokensRequested = 0
        this._prevIntervalTokens = 0
        this._prevTokensRequested = 0
      }
      /**
       * Attempts to consume a token and reports whether it was allowed.
       * Updates internal counters used for effective rate computation.
       *
       * @returns {boolean}
       */
      isAllowed() {
        const curIntervalStart = this._limiter.curIntervalStart
        const curIntervalTokens = this._limiter.tokensThisInterval
        const allowed = this._isAllowed()
        if (curIntervalStart === this._limiter.curIntervalStart) {
          this._tokensRequested++
        } else {
          this._prevIntervalTokens = curIntervalTokens
          this._prevTokensRequested = this._tokensRequested
          this._tokensRequested = 1
        }
        return allowed
      }
      /**
       * Returns the fraction of allowed requests over requested ones in the
       * current and previous intervals combined.
       *
       * @returns {number}
       */
      effectiveRate() {
        if (this._rateLimit < 0) return 1
        if (this._rateLimit === 0) return 0
        if (this._tokensRequested === 0) return 1
        const allowed = this._prevIntervalTokens + this._limiter.tokensThisInterval
        const requested = this._prevTokensRequested + this._tokensRequested
        return allowed / requested
      }
      /**
       * Internal token consumption without counter side-effects.
       * @returns {boolean}
       */
      _isAllowed() {
        if (this._rateLimit < 0) return true
        if (this._rateLimit === 0) return false
        return this._limiter.tryRemoveTokens(1)
      }
      /**
       * Effective rate within the current interval only.
       * @returns {number}
       */
      _currentWindowRate() {
        if (this._rateLimit < 0) return 1
        if (this._rateLimit === 0) return 0
        if (this._tokensRequested === 0) return 1
        return this._limiter.tokensThisInterval / this._tokensRequested
      }
    }
    module2.exports = RateLimiter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/sampler.js
var require_sampler2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/sampler.js'(exports2, module2) {
    'use strict'
    var MAX_TRACE_ID = 2 ** 64 - 1
    var UINT64_MODULO = 2n ** 64n
    var SAMPLING_KNUTH_FACTOR = 1111111111111111111n
    var Sampler = class {
      #threshold = 0n
      /**
       * @param {number} rate
       */
      constructor(rate) {
        rate = Math.min(Math.max(rate, 0), 1)
        this._rate = rate
        this.#threshold = BigInt(Math.floor(rate * MAX_TRACE_ID))
      }
      /**
       * @returns {number}
       */
      rate() {
        return this._rate
      }
      get threshold() {
        return this.#threshold
      }
      /**
       * Determines whether a trace/span should be sampled based on the configured sampling rate.
       *
       * @param {Span|SpanContext} span - The span or span context to evaluate.
       * @returns {boolean} `true` if the trace/span should be sampled, otherwise `false`.
       */
      isSampled(span) {
        if (this._rate === 1) {
          return true
        }
        if (this._rate === 0) {
          return false
        }
        span = typeof span.context === 'function' ? span.context() : span
        return (span._traceId.toBigInt() * SAMPLING_KNUTH_FACTOR) % UINT64_MODULO <= this.#threshold
      }
    }
    module2.exports = Sampler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/sampling_rule.js
var require_sampling_rule = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/sampling_rule.js'(exports2, module2) {
    'use strict'
    var { globMatch } = require_util()
    var RateLimiter = require_rate_limiter()
    var Sampler = require_sampler2()
    var AlwaysMatcher = class {
      /**
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        return true
      }
    }
    var GlobMatcher = class {
      /**
       * @param {string} pattern - Glob pattern used to match the subject.
       * @param {Locator} locator - Function extracting the subject to match.
       */
      constructor(pattern, locator) {
        this.pattern = pattern
        this.locator = locator
      }
      /**
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        const subject = this.locator(span)
        if (!subject) return false
        return globMatch(this.pattern, subject)
      }
    }
    var RegExpMatcher = class {
      /**
       * @param {RegExp} pattern - Regular expression used to test the subject.
       * @param {Locator} locator - Function extracting the subject to test.
       */
      constructor(pattern, locator) {
        this.pattern = pattern
        this.locator = locator
      }
      /**
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        const subject = this.locator(span)
        if (!subject) return false
        return this.pattern.test(subject)
      }
    }
    function matcher(pattern, locator) {
      if (pattern instanceof RegExp) {
        return new RegExpMatcher(pattern, locator)
      }
      if (typeof pattern === 'string' && pattern !== '*' && pattern !== '**' && pattern !== '***') {
        return new GlobMatcher(pattern, locator)
      }
      return new AlwaysMatcher()
    }
    function makeTagLocator(tag) {
      return (span) => span.context()._tags[tag]
    }
    function nameLocator(span) {
      return span.context()._name
    }
    function serviceLocator(span) {
      const { _tags: tags } = span.context()
      return tags.service || tags['service.name'] || span.tracer()._service
    }
    function resourceLocator(span) {
      const { _tags: tags } = span.context()
      return tags.resource || tags['resource.name']
    }
    var SamplingRule = class _SamplingRule {
      /**
       * @param {SamplingRuleConfig} [config]
       */
      constructor({ name, service, resource, tags, sampleRate = 1, provenance, maxPerSecond } = {}) {
        this.matchers = []
        if (name) {
          this.matchers.push(matcher(name, nameLocator))
        }
        if (service) {
          this.matchers.push(matcher(service, serviceLocator))
        }
        if (resource) {
          this.matchers.push(matcher(resource, resourceLocator))
        }
        for (const [key, value] of Object.entries(tags || {})) {
          this.matchers.push(matcher(value, makeTagLocator(key)))
        }
        this._sampler = new Sampler(sampleRate)
        this._limiter = void 0
        this.provenance = provenance
        if (Number.isFinite(maxPerSecond)) {
          this._limiter = new RateLimiter(maxPerSecond)
        }
      }
      /**
       * Constructs a SamplingRule from the given configuration.
       * @param {SamplingRuleConfig} config
       * @returns {SamplingRule}
       */
      static from(config) {
        return new _SamplingRule(config)
      }
      /**
       * Deterministic sampling rate in [0, 1].
       * @returns {number}
       */
      get sampleRate() {
        return this._sampler.rate()
      }
      /**
       * Effective rate applied by the rate limiter, if configured.
       * @returns {number|undefined}
       */
      get effectiveRate() {
        return this._limiter && this._limiter.effectiveRate()
      }
      /**
       * Maximum samples per second if a limiter is present.
       * @returns {number|undefined}
       */
      get maxPerSecond() {
        return this._limiter && this._limiter._rateLimit
      }
      /**
       * Checks whether the provided span matches all configured criteria.
       *
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        for (const matcher2 of this.matchers) {
          if (!matcher2.match(span)) {
            return false
          }
        }
        return true
      }
      /**
       * Determines whether a span should be sampled based on the configured sampling rule.
       *
       * @param {DatadogSpan|DatadogSpanContext} span - The span or span context to evaluate.
       * @returns {boolean} `true` if the span should be sampled, otherwise `false`.
       */
      sample(span) {
        if (!this._sampler.isSampled(span)) {
          return false
        }
        if (this._limiter) {
          return this._limiter.isAllowed()
        }
        return true
      }
    }
    module2.exports = SamplingRule
  },
})

// node_modules/dd-trace/packages/dd-trace/src/span_sampler.js
var require_span_sampler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/span_sampler.js'(exports2, module2) {
    'use strict'
    var { USER_KEEP, AUTO_KEEP } = require_ext().priority
    var SamplingRule = require_sampling_rule()
    var SpanSampler = class {
      /**
       * @param {{ spanSamplingRules?: Array<import('./sampling_rule')>|Array<Record<string, unknown>> }} [config]
       */
      constructor({ spanSamplingRules = [] } = {}) {
        this._rules = spanSamplingRules.map(SamplingRule.from)
      }
      /**
       * Finds the first matching span sampling rule for the given span.
       *
       * @param {import('./opentracing/span')} context
       * @returns {import('./sampling_rule')|undefined}
       */
      findRule(context) {
        for (const rule of this._rules) {
          if (rule.match(context)) {
            return rule
          }
        }
      }
      /**
       * Applies span sampling to spans in the trace, tagging matching spans with
       * span sampling metadata when appropriate.
       *
       * @param {import('./opentracing/span_context')} spanContext
       * @returns {void}
       */
      sample(spanContext) {
        const decision = spanContext._sampling.priority
        if (decision === USER_KEEP || decision === AUTO_KEEP) return
        const { started } = spanContext._trace
        for (const span of started) {
          const rule = this.findRule(span)
          if (rule && rule.sample(spanContext)) {
            span.context()._spanSampling = {
              sampleRate: rule.sampleRate,
              maxPerSecond: rule.maxPerSecond,
            }
          }
        }
      }
    }
    module2.exports = SpanSampler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/git_metadata_tagger.js
var require_git_metadata_tagger = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/git_metadata_tagger.js'(exports2, module2) {
    'use strict'
    var { SCI_COMMIT_SHA, SCI_REPOSITORY_URL } = require_constants2()
    var GitMetadataTagger = class {
      constructor(config) {
        this._config = config
      }
      tagGitMetadata(spanContext) {
        if (this._config.gitMetadataEnabled) {
          spanContext._trace.tags[SCI_COMMIT_SHA] = this._config.commitSHA
          spanContext._trace.tags[SCI_REPOSITORY_URL] = this._config.repositoryUrl
        }
      }
    }
    module2.exports = GitMetadataTagger
  },
})

// node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js
var require_tags_processors = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js'(exports2, module2) {
    'use strict'
    var MAX_RESOURCE_NAME_LENGTH = 5e3
    var MAX_META_KEY_LENGTH = 200
    var MAX_META_VALUE_LENGTH = 25e3
    var MAX_METRIC_KEY_LENGTH = MAX_META_KEY_LENGTH
    var DEFAULT_SPAN_NAME = 'unnamed_operation'
    var DEFAULT_SERVICE_NAME = 'unnamed-service'
    var MAX_NAME_LENGTH = 100
    var MAX_SERVICE_LENGTH = 100
    var MAX_TYPE_LENGTH = 100
    function truncateSpan(span, shouldTruncateResourceName = true) {
      if (shouldTruncateResourceName && span.resource && span.resource.length > MAX_RESOURCE_NAME_LENGTH) {
        span.resource = `${span.resource.slice(0, MAX_RESOURCE_NAME_LENGTH)}...`
      }
      for (let metaKey in span.meta) {
        const val = span.meta[metaKey]
        if (metaKey.length > MAX_META_KEY_LENGTH) {
          delete span.meta[metaKey]
          metaKey = `${metaKey.slice(0, MAX_META_KEY_LENGTH)}...`
          span.metrics[metaKey] = val
        }
        if (val && val.length > MAX_META_VALUE_LENGTH) {
          span.meta[metaKey] = `${val.slice(0, MAX_META_VALUE_LENGTH)}...`
        }
      }
      for (let metricsKey in span.metrics) {
        const val = span.metrics[metricsKey]
        if (metricsKey.length > MAX_METRIC_KEY_LENGTH) {
          delete span.metrics[metricsKey]
          metricsKey = `${metricsKey.slice(0, MAX_METRIC_KEY_LENGTH)}...`
          span.metrics[metricsKey] = val
        }
      }
      return span
    }
    function normalizeSpan(span) {
      span.service = span.service || DEFAULT_SERVICE_NAME
      if (span.service.length > MAX_SERVICE_LENGTH) {
        span.service = span.service.slice(0, MAX_SERVICE_LENGTH)
      }
      span.name = span.name || DEFAULT_SPAN_NAME
      if (span.name.length > MAX_NAME_LENGTH) {
        span.name = span.name.slice(0, MAX_NAME_LENGTH)
      }
      if (!span.resource) {
        span.resource = span.name
      }
      if (span.type && span.type.length > MAX_TYPE_LENGTH) {
        span.type = span.type.slice(0, MAX_TYPE_LENGTH)
      }
      return span
    }
    module2.exports = {
      truncateSpan,
      normalizeSpan,
      MAX_META_KEY_LENGTH,
      MAX_META_VALUE_LENGTH,
      MAX_METRIC_KEY_LENGTH,
      MAX_NAME_LENGTH,
      MAX_SERVICE_LENGTH,
      MAX_TYPE_LENGTH,
      MAX_RESOURCE_NAME_LENGTH,
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/msgpack/chunk.js
var require_chunk = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/msgpack/chunk.js'(exports2, module2) {
    'use strict'
    var DEFAULT_MIN_SIZE = 2 * 1024 * 1024
    var MsgpackChunk = class {
      constructor(minSize = DEFAULT_MIN_SIZE) {
        this.buffer = Buffer.allocUnsafe(minSize)
        this.view = new DataView(this.buffer.buffer)
        this.length = 0
        this._minSize = minSize
      }
      write(value) {
        const length = Buffer.byteLength(value)
        const offset = this.length
        if (length < 32) {
          this.reserve(length + 1)
          this.buffer[offset] = length | 160
        } else if (length < 4294967296) {
          this.reserve(length + 5)
          this.buffer[offset] = 219
          this.buffer[offset + 1] = length >> 24
          this.buffer[offset + 2] = length >> 16
          this.buffer[offset + 3] = length >> 8
          this.buffer[offset + 4] = length
        }
        this.buffer.utf8Write(value, this.length - length, length)
        return this.length - offset
      }
      copy(target, sourceStart, sourceEnd) {
        target.set(new Uint8Array(this.buffer.buffer, sourceStart, sourceEnd - sourceStart))
      }
      set(array) {
        const length = this.length
        this.reserve(array.length)
        this.buffer.set(array, length)
      }
      reserve(size) {
        if (this.length + size > this.buffer.length) {
          this._resize(this._minSize * Math.ceil((this.length + size) / this._minSize))
        }
        this.length += size
      }
      _resize(size) {
        const oldBuffer = this.buffer
        this.buffer = Buffer.allocUnsafe(size)
        this.view = new DataView(this.buffer.buffer)
        oldBuffer.copy(this.buffer, 0, 0, this.length)
      }
    }
    module2.exports = MsgpackChunk
  },
})

// node_modules/dd-trace/packages/dd-trace/src/msgpack/encoder.js
var require_encoder = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/msgpack/encoder.js'(exports2, module2) {
    'use strict'
    var MsgpackChunk = require_chunk()
    var MsgpackEncoder = class {
      encode(value) {
        const bytes = new MsgpackChunk()
        this.encodeValue(bytes, value)
        return bytes.buffer.subarray(0, bytes.length)
      }
      encodeValue(bytes, value) {
        switch (typeof value) {
          case 'bigint':
            this.encodeBigInt(bytes, value)
            break
          case 'boolean':
            this.encodeBoolean(bytes, value)
            break
          case 'number':
            this.encodeNumber(bytes, value)
            break
          case 'object':
            if (value === null) {
              this.encodeNull(bytes, value)
            } else if (Array.isArray(value)) {
              this.encodeArray(bytes, value)
            } else if (Buffer.isBuffer(value) || ArrayBuffer.isView(value)) {
              this.encodeBin(bytes, value)
            } else {
              this.encodeMap(bytes, value)
            }
            break
          case 'string':
            this.encodeString(bytes, value)
            break
          case 'symbol':
            this.encodeString(bytes, value.toString())
            break
          default:
            this.encodeNull(bytes, value)
            break
        }
      }
      encodeNull(bytes) {
        const offset = bytes.length
        bytes.reserve(1)
        bytes.buffer[offset] = 192
      }
      encodeBoolean(bytes, value) {
        const offset = bytes.length
        bytes.reserve(1)
        bytes.buffer[offset] = value ? 195 : 194
      }
      encodeString(bytes, value) {
        bytes.write(value)
      }
      encodeFixArray(bytes, size = 0) {
        const offset = bytes.length
        bytes.reserve(1)
        bytes.buffer[offset] = 144 + size
      }
      encodeArrayPrefix(bytes, value) {
        const length = value.length
        const offset = bytes.length
        bytes.reserve(5)
        bytes.buffer[offset] = 221
        bytes.buffer[offset + 1] = length >> 24
        bytes.buffer[offset + 2] = length >> 16
        bytes.buffer[offset + 3] = length >> 8
        bytes.buffer[offset + 4] = length
      }
      encodeArray(bytes, value) {
        if (value.length < 16) {
          this.encodeFixArray(bytes, value.length)
        } else {
          this.encodeArrayPrefix(bytes, value)
        }
        for (const item of value) {
          this.encodeValue(bytes, item)
        }
      }
      encodeFixMap(bytes, size = 0) {
        const offset = bytes.length
        bytes.reserve(1)
        bytes.buffer[offset] = 128 + size
      }
      encodeMapPrefix(bytes, keysLength) {
        const offset = bytes.length
        bytes.reserve(5)
        bytes.buffer[offset] = 223
        bytes.buffer[offset + 1] = keysLength >> 24
        bytes.buffer[offset + 2] = keysLength >> 16
        bytes.buffer[offset + 3] = keysLength >> 8
        bytes.buffer[offset + 4] = keysLength
      }
      encodeByte(bytes, value) {
        bytes.reserve(1)
        bytes.buffer[bytes.length - 1] = value
      }
      encodeBin(bytes, value) {
        const offset = bytes.length
        if (value.byteLength < 256) {
          bytes.reserve(2)
          bytes.buffer[offset] = 196
          bytes.buffer[offset + 1] = value.byteLength
        } else if (value.byteLength < 65536) {
          bytes.reserve(3)
          bytes.buffer[offset] = 197
          bytes.buffer[offset + 1] = value.byteLength >> 8
          bytes.buffer[offset + 2] = value.byteLength
        } else {
          bytes.reserve(5)
          bytes.buffer[offset] = 198
          bytes.buffer[offset + 1] = value.byteLength >> 24
          bytes.buffer[offset + 2] = value.byteLength >> 16
          bytes.buffer[offset + 3] = value.byteLength >> 8
          bytes.buffer[offset + 4] = value.byteLength
        }
        bytes.set(value)
      }
      encodeInteger(bytes, value) {
        const offset = bytes.length
        bytes.reserve(5)
        bytes.buffer[offset] = 206
        bytes.buffer[offset + 1] = value >> 24
        bytes.buffer[offset + 2] = value >> 16
        bytes.buffer[offset + 3] = value >> 8
        bytes.buffer[offset + 4] = value
      }
      encodeShort(bytes, value) {
        const offset = bytes.length
        bytes.reserve(3)
        bytes.buffer[offset] = 205
        bytes.buffer[offset + 1] = value >> 8
        bytes.buffer[offset + 2] = value
      }
      encodeLong(bytes, value) {
        const offset = bytes.length
        const hi = (value / 2 ** 32) >> 0
        const lo = value >>> 0
        bytes.reserve(9)
        bytes.buffer[offset] = 207
        bytes.buffer[offset + 1] = hi >> 24
        bytes.buffer[offset + 2] = hi >> 16
        bytes.buffer[offset + 3] = hi >> 8
        bytes.buffer[offset + 4] = hi
        bytes.buffer[offset + 5] = lo >> 24
        bytes.buffer[offset + 6] = lo >> 16
        bytes.buffer[offset + 7] = lo >> 8
        bytes.buffer[offset + 8] = lo
      }
      encodeNumber(bytes, value) {
        if (Number.isNaN(value)) {
          value = 0
        }
        if (Number.isInteger(value)) {
          if (value >= 0) {
            this.encodeUnsigned(bytes, value)
          } else {
            this.encodeSigned(bytes, value)
          }
        } else {
          this.encodeFloat(bytes, value)
        }
      }
      encodeSigned(bytes, value) {
        const offset = bytes.length
        if (value >= -32) {
          bytes.reserve(1)
          bytes.buffer[offset] = value
        } else if (value >= -128) {
          bytes.reserve(2)
          bytes.buffer[offset] = 208
          bytes.buffer[offset + 1] = value
        } else if (value >= -32768) {
          bytes.reserve(3)
          bytes.buffer[offset] = 209
          bytes.buffer[offset + 1] = value >> 8
          bytes.buffer[offset + 2] = value
        } else if (value >= -2147483648) {
          bytes.reserve(5)
          bytes.buffer[offset] = 210
          bytes.buffer[offset + 1] = value >> 24
          bytes.buffer[offset + 2] = value >> 16
          bytes.buffer[offset + 3] = value >> 8
          bytes.buffer[offset + 4] = value
        } else {
          const hi = Math.floor(value / 2 ** 32)
          const lo = value >>> 0
          bytes.reserve(9)
          bytes.buffer[offset] = 211
          bytes.buffer[offset + 1] = hi >> 24
          bytes.buffer[offset + 2] = hi >> 16
          bytes.buffer[offset + 3] = hi >> 8
          bytes.buffer[offset + 4] = hi
          bytes.buffer[offset + 5] = lo >> 24
          bytes.buffer[offset + 6] = lo >> 16
          bytes.buffer[offset + 7] = lo >> 8
          bytes.buffer[offset + 8] = lo
        }
      }
      encodeUnsigned(bytes, value) {
        const offset = bytes.length
        if (value <= 127) {
          bytes.reserve(1)
          bytes.buffer[offset] = value
        } else if (value <= 255) {
          bytes.reserve(2)
          bytes.buffer[offset] = 204
          bytes.buffer[offset + 1] = value
        } else if (value <= 65535) {
          bytes.reserve(3)
          bytes.buffer[offset] = 205
          bytes.buffer[offset + 1] = value >> 8
          bytes.buffer[offset + 2] = value
        } else if (value <= 4294967295) {
          bytes.reserve(5)
          bytes.buffer[offset] = 206
          bytes.buffer[offset + 1] = value >> 24
          bytes.buffer[offset + 2] = value >> 16
          bytes.buffer[offset + 3] = value >> 8
          bytes.buffer[offset + 4] = value
        } else {
          const hi = (value / 2 ** 32) >> 0
          const lo = value >>> 0
          bytes.reserve(9)
          bytes.buffer[offset] = 207
          bytes.buffer[offset + 1] = hi >> 24
          bytes.buffer[offset + 2] = hi >> 16
          bytes.buffer[offset + 3] = hi >> 8
          bytes.buffer[offset + 4] = hi
          bytes.buffer[offset + 5] = lo >> 24
          bytes.buffer[offset + 6] = lo >> 16
          bytes.buffer[offset + 7] = lo >> 8
          bytes.buffer[offset + 8] = lo
        }
      }
      // TODO: Support BigInt larger than 64bit.
      encodeBigInt(bytes, value) {
        const offset = bytes.length
        bytes.reserve(9)
        if (value >= 0n) {
          bytes.buffer[offset] = 207
          bytes.view.setBigUint64(offset + 1, value)
        } else {
          bytes.buffer[offset] = 211
          bytes.view.setBigInt64(offset + 1, value)
        }
      }
      encodeMap(bytes, value) {
        const keys = Object.keys(value)
        this.encodeMapPrefix(bytes, keys.length)
        for (const key of keys) {
          this.encodeValue(bytes, key)
          this.encodeValue(bytes, value[key])
        }
      }
      encodeFloat(bytes, value) {
        const offset = bytes.length
        bytes.reserve(9)
        bytes.buffer[offset] = 203
        bytes.view.setFloat64(offset + 1, value)
      }
    }
    module2.exports = { MsgpackEncoder }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/msgpack/index.js
var require_msgpack = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/msgpack/index.js'(exports2, module2) {
    'use strict'
    var MsgpackChunk = require_chunk()
    var { MsgpackEncoder } = require_encoder()
    module2.exports = { MsgpackChunk, MsgpackEncoder }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js
var require__ = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js'(exports2, module2) {
    'use strict'
    var { truncateSpan, normalizeSpan } = require_tags_processors()
    var { MsgpackChunk, MsgpackEncoder } = require_msgpack()
    var log = require_log2()
    var { isTrue } = require_util()
    var { memoize } = require_utils()
    var { getEnvironmentVariable } = require_config_helper()
    var SOFT_LIMIT = 8 * 1024 * 1024
    function formatSpan(span, config) {
      span = normalizeSpan(truncateSpan(span, false))
      if (span.span_events) {
        if (config?.trace?.nativeSpanEvents) {
          formatSpanEvents(span)
        } else {
          span.meta.events = JSON.stringify(span.span_events)
          delete span.span_events
        }
      }
      return span
    }
    var AgentEncoder = class {
      constructor(writer, limit = SOFT_LIMIT) {
        this._msgpack = new MsgpackEncoder()
        this._limit = limit
        this._traceBytes = new MsgpackChunk()
        this._stringBytes = new MsgpackChunk()
        this._writer = writer
        this._reset()
        this._debugEncoding = isTrue(getEnvironmentVariable('DD_TRACE_ENCODING_DEBUG'))
        this._config = this._writer?._config
      }
      count() {
        return this._traceCount
      }
      encode(trace) {
        const bytes = this._traceBytes
        const start = bytes.length
        this._traceCount++
        this._encode(bytes, trace)
        const end = bytes.length
        if (this._debugEncoding) {
          log.debug(() => {
            const hex = bytes.buffer.subarray(start, end).toString('hex').match(/../g).join(' ')
            return `Adding encoded trace to buffer: ${hex}`
          })
        }
        if (this._traceBytes.length > this._limit || this._stringBytes.length > this._limit) {
          log.debug('Buffer went over soft limit, flushing')
          this._writer.flush()
        }
      }
      makePayload() {
        const traceSize = this._traceBytes.length + 5
        const buffer = Buffer.allocUnsafe(traceSize)
        this._writeTraces(buffer)
        this._reset()
        return buffer
      }
      reset() {
        this._reset()
      }
      _encode(bytes, trace) {
        this._encodeArrayPrefix(bytes, trace)
        for (let span of trace) {
          span = formatSpan(span, this._config)
          bytes.reserve(1)
          let mapSize = 11
          if (span.type) mapSize += 1
          if (span.meta_struct) mapSize += 1
          if (span.span_events) mapSize += 1
          bytes.buffer[bytes.length - 1] = 128 + mapSize
          if (span.type) {
            this._encodeString(bytes, 'type')
            this._encodeString(bytes, span.type)
          }
          this._encodeString(bytes, 'trace_id')
          this._encodeId(bytes, span.trace_id)
          this._encodeString(bytes, 'span_id')
          this._encodeId(bytes, span.span_id)
          this._encodeString(bytes, 'parent_id')
          this._encodeId(bytes, span.parent_id)
          this._encodeString(bytes, 'name')
          this._encodeString(bytes, span.name)
          this._encodeString(bytes, 'resource')
          this._encodeString(bytes, span.resource)
          this._encodeString(bytes, 'service')
          this._encodeString(bytes, span.service)
          this._encodeString(bytes, 'error')
          this._encodeInteger(bytes, span.error)
          this._encodeString(bytes, 'start')
          this._encodeLong(bytes, span.start)
          this._encodeString(bytes, 'duration')
          this._encodeLong(bytes, span.duration)
          this._encodeString(bytes, 'meta')
          this._encodeMap(bytes, span.meta)
          this._encodeString(bytes, 'metrics')
          this._encodeMap(bytes, span.metrics)
          if (span.span_events) {
            this._encodeString(bytes, 'span_events')
            this._encodeObjectAsArray(bytes, span.span_events, /* @__PURE__ */ new Set())
          }
          if (span.meta_struct) {
            this._encodeString(bytes, 'meta_struct')
            this._encodeMetaStruct(bytes, span.meta_struct)
          }
        }
      }
      _reset() {
        this._traceCount = 0
        this._traceBytes.length = 0
        this._stringCount = 0
        this._stringBytes.length = 0
        this._stringMap = {}
        this._cacheString('')
      }
      _encodeBuffer(bytes, buffer) {
        this._msgpack.encodeBin(bytes, buffer)
      }
      _encodeBool(bytes, value) {
        this._msgpack.encodeBoolean(bytes, value)
      }
      _encodeArrayPrefix(bytes, value) {
        this._msgpack.encodeArrayPrefix(bytes, value)
      }
      _encodeMapPrefix(bytes, keysLength) {
        this._msgpack.encodeMapPrefix(bytes, keysLength)
      }
      _encodeByte(bytes, value) {
        this._msgpack.encodeByte(bytes, value)
      }
      // TODO: Use BigInt instead.
      _encodeId(bytes, id) {
        const offset = bytes.length
        bytes.reserve(9)
        id = id.toArray()
        bytes.buffer[offset] = 207
        bytes.buffer[offset + 1] = id[0]
        bytes.buffer[offset + 2] = id[1]
        bytes.buffer[offset + 3] = id[2]
        bytes.buffer[offset + 4] = id[3]
        bytes.buffer[offset + 5] = id[4]
        bytes.buffer[offset + 6] = id[5]
        bytes.buffer[offset + 7] = id[6]
        bytes.buffer[offset + 8] = id[7]
      }
      _encodeNumber(bytes, value) {
        this._msgpack.encodeNumber(bytes, value)
      }
      _encodeInteger(bytes, value) {
        this._msgpack.encodeInteger(bytes, value)
      }
      _encodeLong(bytes, value) {
        this._msgpack.encodeLong(bytes, value)
      }
      _encodeMap(bytes, value) {
        const keys = Object.keys(value)
        const validKeys = keys.filter((key) => typeof value[key] === 'string' || typeof value[key] === 'number')
        this._encodeMapPrefix(bytes, validKeys.length)
        for (const key of validKeys) {
          this._encodeString(bytes, key)
          this._encodeValue(bytes, value[key])
        }
      }
      _encodeValue(bytes, value) {
        switch (typeof value) {
          case 'string':
            this._encodeString(bytes, value)
            break
          case 'number':
            this._encodeFloat(bytes, value)
            break
          case 'boolean':
            this._encodeBool(bytes, value)
            break
          default:
        }
      }
      _encodeString(bytes, value = '') {
        this._cacheString(value)
        const { start, end } = this._stringMap[value]
        this._stringBytes.copy(bytes, start, end)
      }
      _encodeFloat(bytes, value) {
        this._msgpack.encodeFloat(bytes, value)
      }
      _encodeMetaStruct(bytes, value) {
        const keys = Array.isArray(value) ? [] : Object.keys(value)
        const validKeys = keys.filter((key) => {
          const v = value[key]
          return typeof v === 'string' || typeof v === 'number' || (v !== null && typeof v === 'object')
        })
        this._encodeMapPrefix(bytes, validKeys.length)
        for (const key of validKeys) {
          const v = value[key]
          this._encodeString(bytes, key)
          this._encodeObjectAsByteArray(bytes, v)
        }
      }
      _encodeObjectAsByteArray(bytes, value) {
        const prefixLength = 5
        const offset = bytes.length
        bytes.reserve(prefixLength)
        this._encodeObject(bytes, value)
        const length = bytes.length - offset - prefixLength
        bytes.buffer[offset] = 198
        bytes.buffer[offset + 1] = length >> 24
        bytes.buffer[offset + 2] = length >> 16
        bytes.buffer[offset + 3] = length >> 8
        bytes.buffer[offset + 4] = length
      }
      _encodeObject(bytes, value, circularReferencesDetector = /* @__PURE__ */ new Set()) {
        circularReferencesDetector.add(value)
        if (Array.isArray(value)) {
          this._encodeObjectAsArray(bytes, value, circularReferencesDetector)
        } else if (value !== null && typeof value === 'object') {
          this._encodeObjectAsMap(bytes, value, circularReferencesDetector)
        } else if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          this._encodeValue(bytes, value)
        }
      }
      _encodeObjectAsMap(bytes, value, circularReferencesDetector) {
        const keys = Object.keys(value)
        const validKeys = keys.filter((key) => {
          const v = value[key]
          return (
            typeof v === 'string' ||
            typeof v === 'number' ||
            typeof v === 'boolean' ||
            (v !== null && typeof v === 'object' && !circularReferencesDetector.has(v))
          )
        })
        this._encodeMapPrefix(bytes, validKeys.length)
        for (const key of validKeys) {
          const v = value[key]
          this._encodeString(bytes, key)
          this._encodeObject(bytes, v, circularReferencesDetector)
        }
      }
      _encodeObjectAsArray(bytes, value, circularReferencesDetector) {
        const validValue = value.filter(
          (item) =>
            typeof item === 'string' ||
            typeof item === 'number' ||
            (item !== null && typeof item === 'object' && !circularReferencesDetector.has(item))
        )
        this._encodeArrayPrefix(bytes, validValue)
        for (const item of validValue) {
          this._encodeObject(bytes, item, circularReferencesDetector)
        }
      }
      _cacheString(value) {
        if (!(value in this._stringMap)) {
          this._stringCount++
          this._stringMap[value] = {
            start: this._stringBytes.length,
            end: this._stringBytes.length + this._stringBytes.write(value),
          }
        }
      }
      _writeArrayPrefix(buffer, offset, count) {
        buffer[offset++] = 221
        buffer.writeUInt32BE(count, offset)
        return offset + 4
      }
      _writeTraces(buffer, offset = 0) {
        offset = this._writeArrayPrefix(buffer, offset, this._traceCount)
        offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length)
        return offset
      }
    }
    var memoizedLogDebug = memoize((key, message) => {
      log.debug(message)
      return true
    })
    function formatSpanEvents(span) {
      for (const spanEvent of span.span_events) {
        if (spanEvent.attributes) {
          let hasAttributes = false
          for (const [key, value] of Object.entries(spanEvent.attributes)) {
            const newValue = convertSpanEventAttributeValues(key, value)
            if (newValue === void 0) {
              delete spanEvent.attributes[key]
            } else {
              hasAttributes = true
              spanEvent.attributes[key] = newValue
            }
          }
          if (!hasAttributes) {
            delete spanEvent.attributes
          }
        }
      }
    }
    function convertSpanEventAttributeValues(key, value, depth = 0) {
      if (typeof value === 'string') {
        return {
          type: 0,
          string_value: value,
        }
      }
      if (typeof value === 'boolean') {
        return {
          type: 1,
          bool_value: value,
        }
      }
      if (typeof value === 'number') {
        if (Number.isInteger(value)) {
          return {
            type: 2,
            int_value: value,
          }
        }
        return {
          type: 3,
          double_value: value,
        }
      }
      if (Array.isArray(value)) {
        if (depth === 0) {
          const convertedArray = []
          for (const val of value) {
            const convertedVal = convertSpanEventAttributeValues(key, val, 1)
            if (convertedVal !== void 0) {
              convertedArray.push(convertedVal)
            }
          }
          if (convertedArray.length > 0) {
            return {
              type: 4,
              array_value: { values: convertedArray },
            }
          }
        } else {
          memoizedLogDebug(
            key,
            `Encountered nested array data type for span event v0.4 encoding. Skipping encoding key: ${key}: with value: ${typeof value}.`
          )
        }
      } else {
        memoizedLogDebug(
          key,
          `Encountered unsupported data type for span event v0.4 encoding, key: ${key}: with value: ${typeof value}. Skipping encoding of pair.`
        )
      }
    }
    module2.exports = { AgentEncoder }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/encode/span-stats.js
var require_span_stats = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/encode/span-stats.js'(exports2, module2) {
    'use strict'
    var { AgentEncoder } = require__()
    var {
      MAX_NAME_LENGTH,
      MAX_SERVICE_LENGTH,
      MAX_RESOURCE_NAME_LENGTH,
      MAX_TYPE_LENGTH,
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME,
    } = require_tags_processors()
    function truncate(value, maxLength, suffix = '') {
      if (!value) {
        return value
      }
      if (value.length > maxLength) {
        return `${value.slice(0, maxLength)}${suffix}`
      }
      return value
    }
    var SpanStatsEncoder = class extends AgentEncoder {
      makePayload() {
        const traceSize = this._traceBytes.length
        const buffer = Buffer.allocUnsafe(traceSize)
        this._traceBytes.copy(buffer, 0, traceSize)
        this._reset()
        return buffer
      }
      _encodeStat(bytes, stat) {
        this._encodeMapPrefix(bytes, 14)
        this._encodeString(bytes, 'Service')
        const service = stat.Service || DEFAULT_SERVICE_NAME
        this._encodeString(bytes, truncate(service, MAX_SERVICE_LENGTH))
        this._encodeString(bytes, 'Name')
        const name = stat.Name || DEFAULT_SPAN_NAME
        this._encodeString(bytes, truncate(name, MAX_NAME_LENGTH))
        this._encodeString(bytes, 'Resource')
        this._encodeString(bytes, truncate(stat.Resource, MAX_RESOURCE_NAME_LENGTH, '...'))
        this._encodeString(bytes, 'HTTPStatusCode')
        this._encodeInteger(bytes, stat.HTTPStatusCode)
        this._encodeString(bytes, 'Type')
        this._encodeString(bytes, truncate(stat.Type, MAX_TYPE_LENGTH))
        this._encodeString(bytes, 'Hits')
        this._encodeLong(bytes, stat.Hits)
        this._encodeString(bytes, 'Errors')
        this._encodeLong(bytes, stat.Errors)
        this._encodeString(bytes, 'Duration')
        this._encodeLong(bytes, stat.Duration)
        this._encodeString(bytes, 'OkSummary')
        this._encodeBuffer(bytes, stat.OkSummary)
        this._encodeString(bytes, 'ErrorSummary')
        this._encodeBuffer(bytes, stat.ErrorSummary)
        this._encodeString(bytes, 'Synthetics')
        this._encodeBool(bytes, stat.Synthetics)
        this._encodeString(bytes, 'TopLevelHits')
        this._encodeLong(bytes, stat.TopLevelHits)
        this._encodeString(bytes, 'HTTPMethod')
        this._encodeString(bytes, stat.HTTPMethod)
        this._encodeString(bytes, 'HTTPEndpoint')
        this._encodeString(bytes, stat.HTTPEndpoint)
      }
      _encodeBucket(bytes, bucket) {
        this._encodeMapPrefix(bytes, 3)
        this._encodeString(bytes, 'Start')
        this._encodeLong(bytes, bucket.Start)
        this._encodeString(bytes, 'Duration')
        this._encodeLong(bytes, bucket.Duration)
        this._encodeString(bytes, 'Stats')
        this._encodeArrayPrefix(bytes, bucket.Stats)
        for (const stat of bucket.Stats) {
          this._encodeStat(bytes, stat)
        }
      }
      _encode(bytes, stats) {
        this._encodeMapPrefix(bytes, 8)
        this._encodeString(bytes, 'Hostname')
        this._encodeString(bytes, stats.Hostname)
        this._encodeString(bytes, 'Env')
        this._encodeString(bytes, stats.Env)
        this._encodeString(bytes, 'Version')
        this._encodeString(bytes, stats.Version)
        this._encodeString(bytes, 'Stats')
        this._encodeArrayPrefix(bytes, stats.Stats)
        for (const bucket of stats.Stats) {
          this._encodeBucket(bytes, bucket)
        }
        this._encodeString(bytes, 'Lang')
        this._encodeString(bytes, stats.Lang)
        this._encodeString(bytes, 'TracerVersion')
        this._encodeString(bytes, stats.TracerVersion)
        this._encodeString(bytes, 'RuntimeID')
        this._encodeString(bytes, stats.RuntimeID)
        this._encodeString(bytes, 'Sequence')
        this._encodeLong(bytes, stats.Sequence)
      }
    }
    module2.exports = {
      SpanStatsEncoder,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/util.js
var require_util2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/util.js'(exports2, module2) {
    'use strict'
    var { getEnvironmentVariable } = require_config_helper()
    function safeJSONStringify(value) {
      return JSON.stringify(
        value,
        (key, value2) => (key === 'dd-api-key' ? void 0 : value2),
        getEnvironmentVariable('DD_TRACE_BEAUTIFUL_LOGS') ? 2 : void 0
      )
    }
    module2.exports = { safeJSONStringify }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js
var require_writer2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var log = require_log2()
    var { safeJSONStringify } = require_util2()
    var Writer = class {
      constructor({ url }) {
        this._url = url
      }
      flush(done = () => {}) {
        const count = this._encoder.count()
        if (!request.writable) {
          this._encoder.reset()
          done()
        } else if (count > 0) {
          const payload = this._encoder.makePayload()
          this._sendPayload(payload, count, done)
        } else {
          done()
        }
      }
      append(payload) {
        if (!request.writable) {
          log.debug(() => `Maximum number of active requests reached. Payload discarded: ${safeJSONStringify(payload)}`)
          return
        }
        log.debug(() => `Encoding payload: ${safeJSONStringify(payload)}`)
        this._encode(payload)
      }
      _encode(payload) {
        this._encoder.encode(payload)
      }
      setUrl(url) {
        this._url = url
      }
    }
    module2.exports = Writer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/writer.js
var require_writer3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/writer.js'(exports2, module2) {
    'use strict'
    var { SpanStatsEncoder } = require_span_stats()
    var pkg = require_package()
    var BaseWriter = require_writer2()
    var request = require_request()
    var log = require_log2()
    var Writer = class extends BaseWriter {
      constructor({ url }) {
        super(...arguments)
        this._url = url
        this._encoder = new SpanStatsEncoder(this)
      }
      _sendPayload(data, _, done) {
        makeRequest(data, this._url, (err, res) => {
          if (err) {
            log.error('Error sending span stats', err)
            done()
            return
          }
          log.debug('Response from the intake:', res)
          done()
        })
      }
    }
    function makeRequest(data, url, cb) {
      const options = {
        path: '/v0.6/stats',
        method: 'PUT',
        headers: {
          'Datadog-Meta-Lang': 'javascript',
          'Datadog-Meta-Tracer-Version': pkg.version,
          'Content-Type': 'application/msgpack',
        },
        protocol: url.protocol,
        hostname: url.hostname,
        port: url.port,
      }
      log.debug('Request to the intake: %j', options)
      request(data, options, (err, res) => {
        cb(err, res)
      })
    }
    module2.exports = {
      Writer,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/index.js
var require_span_stats2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/index.js'(exports2, module2) {
    'use strict'
    var { URL: URL2, format } = require('url')
    var { Writer } = require_writer3()
    var defaults = require_config_defaults()
    var SpanStatsExporter = class {
      constructor(config) {
        const { hostname = defaults.hostname, port = defaults.port, tags, url } = config
        this._url =
          url ||
          new URL2(
            format({
              protocol: 'http:',
              hostname,
              port,
            })
          )
        this._writer = new Writer({ url: this._url, tags })
      }
      export(payload) {
        this._writer.append(payload)
        this._writer.flush()
      }
    }
    module2.exports = {
      SpanStatsExporter,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/span_stats.js
var require_span_stats3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/span_stats.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var { version } = require_pkg()
    var pkg = require_package()
    var { LogCollapsingLowestDenseDDSketch } = require_sketches_js()
    var { ORIGIN_KEY, TOP_LEVEL_KEY } = require_constants2()
    var { MEASURED, HTTP_STATUS_CODE, HTTP_ENDPOINT, HTTP_ROUTE, HTTP_METHOD } = require_tags()
    var { SpanStatsExporter } = require_span_stats2()
    var { DEFAULT_SPAN_NAME, DEFAULT_SERVICE_NAME } = require_tags_processors()
    var SpanAggStats = class {
      constructor(aggKey) {
        this.aggKey = aggKey
        this.hits = 0
        this.topLevelHits = 0
        this.errors = 0
        this.duration = 0
        this.okDistribution = new LogCollapsingLowestDenseDDSketch()
        this.errorDistribution = new LogCollapsingLowestDenseDDSketch()
      }
      record(span) {
        const durationNs = span.duration
        this.hits++
        this.duration += durationNs
        if (span.metrics[TOP_LEVEL_KEY]) {
          this.topLevelHits++
        }
        if (span.error) {
          this.errors++
          this.errorDistribution.accept(durationNs)
        } else {
          this.okDistribution.accept(durationNs)
        }
      }
      toJSON() {
        const { name, service, resource, type, statusCode, synthetics, method, endpoint } = this.aggKey
        return {
          Name: name,
          Service: service,
          Resource: resource,
          Type: type,
          HTTPStatusCode: statusCode,
          Synthetics: synthetics,
          HTTPMethod: method,
          HTTPEndpoint: endpoint,
          Hits: this.hits,
          TopLevelHits: this.topLevelHits,
          Errors: this.errors,
          Duration: this.duration,
          OkSummary: this.okDistribution.toProto(),
          // TODO: custom proto encoding
          ErrorSummary: this.errorDistribution.toProto(),
          // TODO: custom proto encoding
        }
      }
    }
    var SpanAggKey = class {
      constructor(span) {
        this.name = span.name || DEFAULT_SPAN_NAME
        this.service = span.service || DEFAULT_SERVICE_NAME
        this.resource = span.resource || ''
        this.type = span.type || ''
        this.statusCode = span.meta[HTTP_STATUS_CODE] || 0
        this.synthetics = span.meta[ORIGIN_KEY] === 'synthetics'
        this.endpoint = span.meta[HTTP_ROUTE] || span.meta[HTTP_ENDPOINT] || ''
        this.method = span.meta[HTTP_METHOD] || ''
      }
      toString() {
        return [
          this.name,
          this.service,
          this.resource,
          this.type,
          this.statusCode,
          this.synthetics,
          this.method,
          this.endpoint,
        ].join(',')
      }
    }
    var SpanBuckets = class extends Map {
      forSpan(span) {
        const aggKey = new SpanAggKey(span)
        const key = aggKey.toString()
        if (!this.has(key)) {
          this.set(key, new SpanAggStats(aggKey))
        }
        return this.get(key)
      }
    }
    var TimeBuckets = class extends Map {
      forTime(time) {
        if (!this.has(time)) {
          this.set(time, new SpanBuckets())
        }
        return this.get(time)
      }
    }
    var SpanStatsProcessor = class {
      constructor({
        stats: { enabled = false, interval = 10 },
        hostname,
        port,
        url,
        env,
        tags,
        version: version2,
      } = {}) {
        this.exporter = new SpanStatsExporter({
          hostname,
          port,
          tags,
          url,
        })
        this.interval = interval
        this.bucketSizeNs = interval * 1e9
        this.buckets = new TimeBuckets()
        this.hostname = os.hostname()
        this.enabled = enabled
        this.env = env
        this.tags = tags || {}
        this.sequence = 0
        this.version = version2
        if (this.enabled) {
          this.timer = setInterval(this.onInterval.bind(this), interval * 1e3)
          this.timer.unref()
        }
      }
      onInterval() {
        const serialized = this._serializeBuckets()
        if (!serialized) return
        this.exporter.export({
          Hostname: this.hostname,
          Env: this.env,
          Version: this.version || version,
          Stats: serialized,
          Lang: 'javascript',
          TracerVersion: pkg.version,
          RuntimeID: this.tags['runtime-id'],
          Sequence: ++this.sequence,
        })
      }
      onSpanFinished(span) {
        if (!this.enabled) return
        if (!span.metrics[TOP_LEVEL_KEY] && !span.metrics[MEASURED]) return
        const spanEndNs = span.startTime + span.duration
        const bucketTime = spanEndNs - (spanEndNs % this.bucketSizeNs)
        this.buckets.forTime(bucketTime).forSpan(span).record(span)
      }
      _serializeBuckets() {
        const { bucketSizeNs } = this
        const serializedBuckets = []
        for (const [timeNs, bucket] of this.buckets.entries()) {
          const bucketAggStats = []
          for (const stats of bucket.values()) {
            bucketAggStats.push(stats.toJSON())
          }
          serializedBuckets.push({
            Start: timeNs,
            Duration: bucketSizeNs,
            Stats: bucketAggStats,
          })
        }
        this.buckets.clear()
        return serializedBuckets
      }
    }
    module2.exports = {
      SpanAggStats,
      SpanAggKey,
      SpanBuckets,
      TimeBuckets,
      SpanStatsProcessor,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/span_processor.js
var require_span_processor2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/span_processor.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var spanFormat = require_span_format()
    var SpanSampler = require_span_sampler()
    var GitMetadataTagger = require_git_metadata_tagger()
    var { getEnvironmentVariable } = require_config_helper()
    var getProcessTags = require_process_tags()
    var startedSpans = /* @__PURE__ */ new WeakSet()
    var finishedSpans = /* @__PURE__ */ new WeakSet()
    var SpanProcessor = class {
      constructor(exporter, prioritySampler, config) {
        this._exporter = exporter
        this._prioritySampler = prioritySampler
        this._config = config
        this._killAll = false
        if (config.stats?.enabled && !config.appsec?.standalone?.enabled) {
          const { SpanStatsProcessor } = require_span_stats3()
          this._stats = new SpanStatsProcessor(config)
        }
        this._spanSampler = new SpanSampler(config.sampler)
        this._gitMetadataTagger = new GitMetadataTagger(config)
        this._processTags = config.propagateProcessTags?.enabled ? getProcessTags().serialized : false
      }
      sample(span) {
        const spanContext = span.context()
        this._prioritySampler.sample(spanContext)
        this._spanSampler.sample(spanContext)
      }
      process(span) {
        const spanContext = span.context()
        const active = []
        const formatted = []
        const trace = spanContext._trace
        const { flushMinSpans, tracing } = this._config
        const { started, finished } = trace
        if (trace.record === false) return
        if (tracing === false) {
          this._erase(trace, active)
          return
        }
        if (started.length === finished.length || finished.length >= flushMinSpans) {
          this.sample(span)
          this._gitMetadataTagger.tagGitMetadata(spanContext)
          let isFirstSpanInChunk = true
          for (const span2 of started) {
            if (span2._duration === void 0) {
              active.push(span2)
            } else {
              const formattedSpan = spanFormat(span2, isFirstSpanInChunk, this._processTags)
              isFirstSpanInChunk = false
              this._stats?.onSpanFinished(formattedSpan)
              formatted.push(formattedSpan)
            }
          }
          if (formatted.length !== 0 && trace.isRecording !== false) {
            this._exporter.export(formatted)
          }
          this._erase(trace, active)
        }
        if (this._killAll) {
          for (const startedSpan of started) {
            if (!startedSpan._finished) {
              startedSpan.finish()
            }
          }
        }
      }
      killAll() {
        this._killAll = true
      }
      _erase(trace, active) {
        if (getEnvironmentVariable('DD_TRACE_EXPERIMENTAL_STATE_TRACKING') === 'true') {
          const started = /* @__PURE__ */ new Set()
          const startedIds = /* @__PURE__ */ new Set()
          const finished = /* @__PURE__ */ new Set()
          const finishedIds = /* @__PURE__ */ new Set()
          for (const span of trace.finished) {
            const context = span.context()
            const id = context.toSpanId()
            if (finished.has(span)) {
              log.error('Span was already finished in the same trace: %s', span)
            } else {
              finished.add(span)
              if (finishedIds.has(id)) {
                log.error('Another span with the same ID was already finished in the same trace: %s', span)
              } else {
                finishedIds.add(id)
              }
              if (context._trace !== trace) {
                log.error('A span was finished in the wrong trace: %s', span)
              }
              if (finishedSpans.has(span)) {
                log.error('Span was already finished in a different trace: %s', span)
              } else {
                finishedSpans.add(span)
              }
            }
          }
          for (const span of trace.started) {
            const context = span.context()
            const id = context.toSpanId()
            if (started.has(span)) {
              log.error('Span was already started in the same trace: %s', span)
            } else {
              started.add(span)
              if (startedIds.has(id)) {
                log.error('Another span with the same ID was already started in the same trace: %s', span)
              } else {
                startedIds.add(id)
              }
              if (context._trace !== trace) {
                log.error('A span was started in the wrong trace: %s', span)
              }
              if (startedSpans.has(span)) {
                log.error('Span was already started in a different trace: %s', span)
              } else {
                startedSpans.add(span)
              }
            }
            if (!finished.has(span)) {
              log.error('Span started in one trace but was finished in another trace: %s', span)
            }
          }
          for (const span of trace.finished) {
            if (!started.has(span)) {
              log.error('Span finished in one trace but was started in another trace: %s', span)
            }
          }
        }
        for (const span of trace.finished) {
          span.context()._tags = {}
        }
        trace.started = active
        trace.finished = []
      }
    }
    module2.exports = SpanProcessor
  },
})

// node_modules/dd-trace/packages/dd-trace/src/startup-log.js
var require_startup_log = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/startup-log.js'(exports2, module2) {
    'use strict'
    var { info, warn } = require_writer()
    var os = require('os')
    var { inspect } = require('util')
    var defaults = require_config_defaults()
    var tracerVersion = require_package().version
    var errors = {}
    var config
    var pluginManager
    var samplingRules = []
    var alreadyRan = false
    function startupLog({ agentError } = {}) {
      if (!config || !pluginManager) {
        return
      }
      if (alreadyRan) {
        return
      }
      alreadyRan = true
      if (!config.startupLogs) {
        return
      }
      const out = tracerInfo()
      if (agentError) {
        out.agent_error = agentError.message
      }
      info('DATADOG TRACER CONFIGURATION - ' + out)
      if (agentError) {
        warn('DATADOG TRACER DIAGNOSTIC - Agent Error: ' + agentError.message)
        errors.agentError = {
          code: agentError.code ?? '',
          message: `Agent Error:${agentError.message}`,
        }
      }
    }
    function tracerInfo() {
      const url = config.url || `http://${config.hostname || defaults.hostname}:${config.port}`
      const out = {
        [inspect.custom]() {
          return String(this)
        },
        toString() {
          return JSON.stringify(this, (_key_, value) => {
            return typeof value === 'bigint' || typeof value === 'symbol' ? String(value) : value
          })
        },
        date: /* @__PURE__ */ new Date().toISOString(),
        os_name: os.type(),
        os_version: os.release(),
        architecture: os.arch(),
        version: tracerVersion,
        lang: 'nodejs',
        lang_version: process.versions.node,
        env: config.env,
        enabled: config.enabled,
        service: config.service,
        agent_url: url,
        debug: !!config.debug,
        sample_rate: config.sampler.sampleRate,
        sampling_rules: samplingRules,
        tags: config.tags,
        ...(config.tags && config.tags.version && { dd_version: config.tags.version }),
        log_injection_enabled: !!config.logInjection,
        runtime_metrics_enabled: !!config.runtimeMetrics,
        profiling_enabled: config.profiling?.enabled === 'true' || config.profiling?.enabled === 'auto',
        integrations_loaded: Object.keys(pluginManager._pluginsByName),
        appsec_enabled: !!config.appsec.enabled,
      }
      return out
    }
    function setStartupLogConfig(aConfig) {
      config = aConfig
    }
    function setStartupLogPluginManager(thePluginManager) {
      pluginManager = thePluginManager
    }
    function setSamplingRules(theRules) {
      samplingRules = theRules
    }
    module2.exports = {
      startupLog,
      setStartupLogConfig,
      setStartupLogPluginManager,
      setSamplingRules,
      tracerInfo,
      errors,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js
var require_priority_sampler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var RateLimiter = require_rate_limiter()
    var Sampler = require_sampler2()
    var { setSamplingRules } = require_startup_log()
    var SamplingRule = require_sampling_rule()
    var {
      SAMPLING_MECHANISM_DEFAULT,
      SAMPLING_MECHANISM_AGENT,
      SAMPLING_MECHANISM_RULE,
      SAMPLING_MECHANISM_MANUAL,
      SAMPLING_MECHANISM_REMOTE_USER,
      SAMPLING_MECHANISM_REMOTE_DYNAMIC,
      SAMPLING_RULE_DECISION,
      SAMPLING_LIMIT_DECISION,
      SAMPLING_AGENT_DECISION,
      DECISION_MAKER_KEY,
    } = require_constants2()
    var {
      tags: { MANUAL_KEEP, MANUAL_DROP, SAMPLING_PRIORITY, SERVICE_NAME },
      priority: { AUTO_REJECT, AUTO_KEEP, USER_REJECT, USER_KEEP },
    } = require_ext()
    var DEFAULT_KEY = 'service:,env:'
    var defaultSampler = new Sampler(AUTO_KEEP)
    var PrioritySampler = class {
      /**
       * Creates an instance of PrioritySampler.
       *
       * @typedef {Object} SamplingConfig
       * @property {number} [sampleRate] - The default sample rate for traces.
       * @property {string} [provenance] - Optional rule provenance ("customer" or "dynamic").
       * @property {number} [rateLimit=100] - The maximum number of traces to sample per second.
       * @property {Array<import('./sampling_rule')>|Array<Record<string, unknown>>} [rules=[]] - Sampling rules or configs.
       *
       * @param {string} env - The environment name (e.g., "production", "staging").
       * @param {SamplingConfig} [config] - The configuration object for sampling.
       */
      constructor(env, config) {
        this.configure(env, config)
        this.update({})
      }
      /**
       *
       * @param {string} env
       * @param {SamplingConfig} config
       */
      configure(env, config = {}) {
        const { sampleRate, provenance, rateLimit = 100, rules } = config
        this._env = env
        this._rules = this.#normalizeRules(rules || [], sampleRate, rateLimit, provenance)
        this._limiter = new RateLimiter(rateLimit)
        log.trace(env, config)
        setSamplingRules(this._rules)
      }
      /**
       * @param {DatadogSpan} span
       * @returns {boolean} True if the trace should be sampled based on priority.
       */
      isSampled(span) {
        const priority = this._getPriorityFromAuto(span)
        log.trace(span)
        return priority === USER_KEEP || priority === AUTO_KEEP
      }
      /**
       * Assigns a sampling priority to a span if not already set.
       *
       * @param {DatadogSpan} span
       * @param {boolean} [auto=true] - Whether to use automatic sampling if no manual tags are present.
       * @returns {void}
       */
      sample(span, auto = true) {
        if (!span) return
        const context = this._getContext(span)
        const root = context._trace.started[0]
        if (context._sampling.priority !== void 0) return
        if (!root) return
        log.trace(span, auto)
        const tag = this._getPriorityFromTags(context._tags, context)
        if (this.validate(tag)) {
          context._sampling.priority = tag
          context._sampling.mechanism = SAMPLING_MECHANISM_MANUAL
        } else if (auto) {
          context._sampling.priority = this._getPriorityFromAuto(root)
        } else {
          return
        }
        this.#addDecisionMaker(root)
      }
      /**
       * Updates agent-provided sampling rates keyed by `service:,env:`.
       *
       * @param {Record<string, number>} rates
       * @returns {void}
       */
      update(rates) {
        const samplers = {}
        for (const key in rates) {
          const rate = rates[key]
          samplers[key] = new Sampler(rate)
        }
        samplers[DEFAULT_KEY] = samplers[DEFAULT_KEY] || defaultSampler
        this._samplers = samplers
        log.trace(rates)
      }
      /**
       * Validates that a sampling priority value is one of the allowed constants.
       *
       * @param {SamplingPriority|undefined} samplingPriority
       * @returns {boolean}
       */
      validate(samplingPriority) {
        switch (samplingPriority) {
          case USER_REJECT:
          case USER_KEEP:
          case AUTO_REJECT:
          case AUTO_KEEP:
            return true
          default:
            return false
        }
      }
      /**
       * Explicitly sets the priority and mechanism for the span's trace.
       *
       * @param {DatadogSpan} span
       * @param {SamplingPriority} samplingPriority
       * @param {Product} [product]
       */
      setPriority(span, samplingPriority, product) {
        if (!span || !this.validate(samplingPriority)) return
        const context = this._getContext(span)
        const root = context._trace.started[0]
        if (!root) {
          log.error('Skipping the setPriority on noop span')
          return
        }
        context._sampling.priority = samplingPriority
        const mechanism = product?.mechanism ?? SAMPLING_MECHANISM_MANUAL
        context._sampling.mechanism = mechanism
        log.trace(span, samplingPriority, mechanism)
        this.#addDecisionMaker(root)
      }
      /**
       * Returns the span context, accepting either a span or a span context.
       *
       * @param {DatadogSpan|DatadogSpanContext} span
       * @returns {DatadogSpanContext}
       */
      _getContext(span) {
        return (
          typeof (/** @type {DatadogSpan} */ span.context) === 'function'
            ? /** @type {DatadogSpan} */
              span.context()
            : /** @type {DatadogSpanContext} */
              span
        )
      }
      /**
       * Computes priority using rules and agent rates when no manual tag is present.
       *
       * @param {DatadogSpan} span
       * @returns {SamplingPriority}
       */
      _getPriorityFromAuto(span) {
        const context = this._getContext(span)
        const rule = this.#findRule(span)
        return rule ? this.#getPriorityByRule(context, rule) : this.#getPriorityByAgent(context)
      }
      /**
       * Computes priority from manual sampling tags if present.
       * Included for compatibility with {@link import('./standalone/tracesource_priority_sampler')._getPriorityFromTags}
       *
       * @param {Record<string, unknown>} tags
       * @param {DatadogSpanContext} _context
       * @returns {SamplingPriority|undefined}
       */
      _getPriorityFromTags(tags, _context) {
        if (Object.hasOwn(tags, MANUAL_KEEP) && tags[MANUAL_KEEP] !== false) {
          return USER_KEEP
        } else if (Object.hasOwn(tags, MANUAL_DROP) && tags[MANUAL_DROP] !== false) {
          return USER_REJECT
        }
        const rawPriority = tags[SAMPLING_PRIORITY]
        if (rawPriority !== void 0) {
          const priority = Number.parseInt(String(rawPriority), 10)
          if (priority === 1 || priority === 2) {
            return USER_KEEP
          } else if (priority === 0 || priority === -1) {
            return USER_REJECT
          }
        }
      }
      /**
       * Applies a matching rule and rate limit to compute the sampling priority.
       *
       * @param {DatadogSpanContext} context
       * @param {import('./sampling_rule')} rule
       * @returns {SamplingPriority}
       */
      #getPriorityByRule(context, rule) {
        context._trace[SAMPLING_RULE_DECISION] = rule.sampleRate
        context._sampling.mechanism = SAMPLING_MECHANISM_RULE
        if (rule.provenance === 'customer') context._sampling.mechanism = SAMPLING_MECHANISM_REMOTE_USER
        if (rule.provenance === 'dynamic') context._sampling.mechanism = SAMPLING_MECHANISM_REMOTE_DYNAMIC
        return rule.sample(context) && this._isSampledByRateLimit(context) ? USER_KEEP : USER_REJECT
      }
      /**
       * Checks if the rate limiter allows sampling for the current window and
       * records the effective rate on the trace.
       *
       * @param {DatadogSpanContext} context
       * @returns {boolean}
       */
      _isSampledByRateLimit(context) {
        const allowed = this._limiter.isAllowed()
        context._trace[SAMPLING_LIMIT_DECISION] = this._limiter.effectiveRate()
        return allowed
      }
      /**
       * Computes priority using agent-provided sampling rates.
       *
       * @param {DatadogSpanContext} context
       * @returns {SamplingPriority}
       */
      #getPriorityByAgent(context) {
        const key = `service:${context._tags[SERVICE_NAME]},env:${this._env}`
        const sampler = this._samplers[key] || this._samplers[DEFAULT_KEY]
        context._trace[SAMPLING_AGENT_DECISION] = sampler.rate()
        context._sampling.mechanism = sampler === defaultSampler ? SAMPLING_MECHANISM_DEFAULT : SAMPLING_MECHANISM_AGENT
        return sampler.isSampled(context) ? AUTO_KEEP : AUTO_REJECT
      }
      /**
       * Tags the trace with a decision maker when priority is keep, or removes it otherwise.
       *
       * @param {DatadogSpan} span
       * @returns {void}
       */
      #addDecisionMaker(span) {
        const context = span.context()
        const trace = context._trace
        const priority = context._sampling.priority
        const mechanism = context._sampling.mechanism
        if (priority >= AUTO_KEEP) {
          if (!trace.tags[DECISION_MAKER_KEY]) {
            trace.tags[DECISION_MAKER_KEY] = `-${mechanism}`
          }
        } else {
          delete trace.tags[DECISION_MAKER_KEY]
        }
      }
      /**
       * Normalizes rule inputs to SamplingRule instances, applying defaults.
       *
       * @param {Array<SamplingRuleLike>|SamplingRuleLike} rules - Rules to normalize.
       * @param {number|undefined} sampleRate
       * @param {number} rateLimit
       * @param {string|undefined} provenance
       * @returns {Array<import('./sampling_rule')>}
       */
      #normalizeRules(rules, sampleRate, rateLimit, provenance) {
        rules = Array.isArray(rules) ? rules.flat() : [rules]
        rules.push({ sampleRate, maxPerSecond: rateLimit, provenance })
        const result = []
        for (const rule of rules) {
          const sampleRate2 = Number.parseFloat(String(rule.sampleRate))
          if (!Number.isNaN(sampleRate2)) {
            result.push(SamplingRule.from({ ...rule, sampleRate: sampleRate2 }))
          }
        }
        return result
      }
      /**
       * Finds the first matching rule for the given span.
       *
       * @param {DatadogSpan} span
       * @returns {import('./sampling_rule')|undefined}
       */
      #findRule(span) {
        for (const rule of this._rules) {
          if (rule.match(span)) return rule
        }
      }
      /**
       * Convenience helper to keep a trace with an optional product mechanism.
       *
       * @param {DatadogSpan} span
       * @param {Product} [product]
       */
      static keepTrace(span, product) {
        span?._prioritySampler?.setPriority(span, USER_KEEP, product)
      }
    }
    module2.exports = PrioritySampler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/size.js
var require_size = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/size.js'(exports2, module2) {
    'use strict'
    var { types } = require('util')
    function getSizeOrZero(obj) {
      if (typeof obj === 'string') {
        return Buffer.from(obj, 'utf8').length
      }
      if (types.isArrayBuffer(obj)) {
        return obj.byteLength
      }
      if (Buffer.isBuffer(obj)) {
        return obj.length
      }
      if (Array.isArray(obj) && obj.length > 0) {
        if (typeof obj[0] === 'number') return Buffer.from(obj).length
        let payloadSize = 0
        obj.forEach((item) => {
          payloadSize += getSizeOrZero(item)
        })
        return payloadSize
      }
      if (obj !== null && typeof obj === 'object') {
        try {
          return getHeadersSize(obj)
        } catch {}
      }
      return 0
    }
    function getHeadersSize(headers) {
      if (headers === void 0) return 0
      return Object.entries(headers).reduce((prev, [key, val]) => getSizeOrZero(key) + getSizeOrZero(val) + prev, 0)
    }
    function getMessageSize(message) {
      const { key, value, headers } = message
      return getSizeOrZero(key) + getSizeOrZero(value) + getHeadersSize(headers)
    }
    function getAmqpMessageSize(message) {
      const { headers, content } = message
      return getSizeOrZero(content) + getHeadersSize(headers)
    }
    module2.exports = {
      getMessageSize,
      getHeadersSize,
      getSizeOrZero,
      getAmqpMessageSize,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/encoding.js
var require_encoding = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/encoding.js'(exports2, module2) {
    'use strict'
    function encodeVarint(v) {
      const sign = v >= 0 ? 0 : 1
      const double = Math.abs(v) * 2
      if (double > Number.MAX_SAFE_INTEGER) {
        return
      }
      const high = Math.floor(double / 4294967296)
      const low = (double & 4294967295) | sign
      return encodeUvarint64(low, high)
    }
    function decodeVarint(b) {
      const [low, high, bytes] = decodeUvarint64(b)
      if (low === void 0 || high === void 0) {
        return [void 0, bytes]
      }
      const positive = (low & 1) === 0
      const abs = (low >>> 1) + high * 2147483648
      return [positive ? abs : -abs, bytes]
    }
    var maxVarLen64 = 9
    function encodeUvarint64(low, high) {
      const result = new Uint8Array(maxVarLen64)
      let i = 0
      while ((high !== 0 || low < 0 || low > 128) && i < maxVarLen64 - 1) {
        result[i] = (low & 127) | 128
        low >>>= 7
        low |= (high & 127) << 25
        high >>>= 7
        i++
      }
      result[i] = low & 127
      return result.slice(0, i + 1)
    }
    function decodeUvarint64(bytes) {
      let low = 0
      let high = 0
      let s = 0
      for (let i = 0; ; i++) {
        if (bytes.length <= i) {
          return [void 0, void 0, bytes.slice(bytes.length)]
        }
        const n = bytes[i]
        if (n < 128 || i === maxVarLen64 - 1) {
          bytes = bytes.slice(i + 1)
          if (s < 32) {
            low |= n << s
          }
          if (s > 0) {
            high |= s - 32 > 0 ? n << (s - 32) : n >> (32 - s)
          }
          return [low, high, bytes]
        }
        if (s < 32) {
          low |= (n & 127) << s
        }
        if (s > 0) {
          high |= s - 32 > 0 ? (n & 127) << (s - 32) : (n & 127) >> (32 - s)
        }
        s += 7
      }
    }
    module2.exports = {
      encodeVarint,
      decodeVarint,
    }
  },
})

// node_modules/dd-trace/vendor/dist/lru-cache/index.js
var require_lru_cache = __commonJS({
  'node_modules/dd-trace/vendor/dist/lru-cache/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var t = {}
      ;((t.d = (e2, i2) => {
        for (var s2 in i2)
          t.o(i2, s2) && !t.o(e2, s2) && Object.defineProperty(e2, s2, { enumerable: true, get: i2[s2] })
      }),
        (t.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2)),
        (t.r = (t2) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(t2, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(t2, '__esModule', { value: true }))
        }))
      var e = {}
      ;(t.r(e), t.d(e, { LRUCache: () => u }))
      let i =
          'object' == typeof performance && performance && 'function' == typeof performance.now ? performance : Date,
        s = /* @__PURE__ */ new Set(),
        h = 'object' == typeof process && process ? process : {},
        r = (t2, e2, i2, s2) => {
          'function' == typeof h.emitWarning ? h.emitWarning(t2, e2, i2, s2) : console.error(`[${i2}] ${e2}: ${t2}`)
        },
        o = globalThis.AbortController,
        a = globalThis.AbortSignal
      if (void 0 === o) {
        ;((a = class {
          onabort
          _onabort = []
          reason
          aborted = false
          addEventListener(t3, e3) {
            this._onabort.push(e3)
          }
        }),
          (o = class {
            constructor() {
              e2()
            }
            signal = new a()
            abort(t3) {
              if (!this.signal.aborted) {
                for (let e3 of ((this.signal.reason = t3), (this.signal.aborted = true), this.signal._onabort)) e3(t3)
                this.signal.onabort?.(t3)
              }
            }
          }))
        let t2 = h.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1',
          e2 = () => {
            t2 &&
              ((t2 = false),
              r(
                'AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',
                'NO_ABORT_CONTROLLER',
                'ENOTSUP',
                e2
              ))
          }
      }
      /* @__PURE__ */ Symbol('type')
      let l = (t2) => t2 && t2 === Math.floor(t2) && t2 > 0 && isFinite(t2),
        n = (t2) =>
          l(t2)
            ? t2 <= 256
              ? Uint8Array
              : t2 <= 65536
                ? Uint16Array
                : t2 <= 4294967296
                  ? Uint32Array
                  : t2 <= Number.MAX_SAFE_INTEGER
                    ? d
                    : null
            : null
      class d extends Array {
        constructor(t2) {
          ;(super(t2), this.fill(0))
        }
      }
      class c {
        heap
        length
        static #t = false
        static create(t2) {
          let e2 = n(t2)
          if (!e2) return []
          c.#t = true
          let i2 = new c(t2, e2)
          return ((c.#t = false), i2)
        }
        constructor(t2, e2) {
          if (!c.#t) throw TypeError('instantiate Stack using Stack.create(n)')
          ;((this.heap = new e2(t2)), (this.length = 0))
        }
        push(t2) {
          this.heap[this.length++] = t2
        }
        pop() {
          return this.heap[--this.length]
        }
      }
      class u {
        #e
        #i
        #s
        #h
        #r
        #o
        ttl
        ttlResolution
        ttlAutopurge
        updateAgeOnGet
        updateAgeOnHas
        allowStale
        noDisposeOnSet
        noUpdateTTL
        maxEntrySize
        sizeCalculation
        noDeleteOnFetchRejection
        noDeleteOnStaleGet
        allowStaleOnFetchAbort
        allowStaleOnFetchRejection
        ignoreFetchAbort
        #a
        #l
        #n
        #d
        #c
        #u
        #f
        #p
        #g
        #v
        #m
        #y
        #S
        #z
        #L
        #_
        #x
        static unsafeExposeInternals(t2) {
          return {
            starts: t2.#S,
            ttls: t2.#z,
            sizes: t2.#y,
            keyMap: t2.#n,
            keyList: t2.#d,
            valList: t2.#c,
            next: t2.#u,
            prev: t2.#f,
            get head() {
              return t2.#p
            },
            get tail() {
              return t2.#g
            },
            free: t2.#v,
            isBackgroundFetch: (e2) => t2.#k(e2),
            backgroundFetch: (e2, i2, s2, h2) => t2.#F(e2, i2, s2, h2),
            moveToTail: (e2) => t2.#T(e2),
            indexes: (e2) => t2.#b(e2),
            rindexes: (e2) => t2.#A(e2),
            isStale: (e2) => t2.#w(e2),
          }
        }
        get max() {
          return this.#e
        }
        get maxSize() {
          return this.#i
        }
        get calculatedSize() {
          return this.#l
        }
        get size() {
          return this.#a
        }
        get fetchMethod() {
          return this.#r
        }
        get memoMethod() {
          return this.#o
        }
        get dispose() {
          return this.#s
        }
        get disposeAfter() {
          return this.#h
        }
        constructor(t2) {
          const {
            max: e2 = 0,
            ttl: i2,
            ttlResolution: h2 = 1,
            ttlAutopurge: o2,
            updateAgeOnGet: a2,
            updateAgeOnHas: d2,
            allowStale: f,
            dispose: p,
            disposeAfter: g,
            noDisposeOnSet: v,
            noUpdateTTL: m,
            maxSize: y = 0,
            maxEntrySize: S = 0,
            sizeCalculation: z,
            fetchMethod: L,
            memoMethod: _,
            noDeleteOnFetchRejection: x,
            noDeleteOnStaleGet: k,
            allowStaleOnFetchRejection: F,
            allowStaleOnFetchAbort: T,
            ignoreFetchAbort: b,
          } = t2
          if (0 !== e2 && !l(e2)) throw TypeError('max option must be a nonnegative integer')
          const A = e2 ? n(e2) : Array
          if (!A) throw Error('invalid max value: ' + e2)
          if (
            ((this.#e = e2),
            (this.#i = y),
            (this.maxEntrySize = S || this.#i),
            (this.sizeCalculation = z),
            this.sizeCalculation)
          ) {
            if (!this.#i && !this.maxEntrySize)
              throw TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize')
            if ('function' != typeof this.sizeCalculation) throw TypeError('sizeCalculation set to non-function')
          }
          if (void 0 !== _ && 'function' != typeof _) throw TypeError('memoMethod must be a function if defined')
          if (((this.#o = _), void 0 !== L && 'function' != typeof L))
            throw TypeError('fetchMethod must be a function if specified')
          if (
            ((this.#r = L),
            (this.#_ = !!L),
            (this.#n = /* @__PURE__ */ new Map()),
            (this.#d = Array(e2).fill(void 0)),
            (this.#c = Array(e2).fill(void 0)),
            (this.#u = new A(e2)),
            (this.#f = new A(e2)),
            (this.#p = 0),
            (this.#g = 0),
            (this.#v = c.create(e2)),
            (this.#a = 0),
            (this.#l = 0),
            'function' == typeof p && (this.#s = p),
            'function' == typeof g ? ((this.#h = g), (this.#m = [])) : ((this.#h = void 0), (this.#m = void 0)),
            (this.#L = !!this.#s),
            (this.#x = !!this.#h),
            (this.noDisposeOnSet = !!v),
            (this.noUpdateTTL = !!m),
            (this.noDeleteOnFetchRejection = !!x),
            (this.allowStaleOnFetchRejection = !!F),
            (this.allowStaleOnFetchAbort = !!T),
            (this.ignoreFetchAbort = !!b),
            0 !== this.maxEntrySize)
          ) {
            if (0 !== this.#i && !l(this.#i)) throw TypeError('maxSize must be a positive integer if specified')
            if (!l(this.maxEntrySize)) throw TypeError('maxEntrySize must be a positive integer if specified')
            this.#E()
          }
          if (
            ((this.allowStale = !!f),
            (this.noDeleteOnStaleGet = !!k),
            (this.updateAgeOnGet = !!a2),
            (this.updateAgeOnHas = !!d2),
            (this.ttlResolution = l(h2) || 0 === h2 ? h2 : 1),
            (this.ttlAutopurge = !!o2),
            (this.ttl = i2 || 0),
            this.ttl)
          ) {
            if (!l(this.ttl)) throw TypeError('ttl must be a positive integer if specified')
            this.#M()
          }
          if (0 === this.#e && 0 === this.ttl && 0 === this.#i)
            throw TypeError('At least one of max, maxSize, or ttl is required')
          if (!this.ttlAutopurge && !this.#e && !this.#i) {
            const t3 = 'LRU_CACHE_UNBOUNDED'
            s.has(t3) ||
              (s.add(t3),
              r(
                'TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.',
                'UnboundedCacheWarning',
                t3,
                u
              ))
          }
        }
        getRemainingTTL(t2) {
          return this.#n.has(t2) ? 1 / 0 : 0
        }
        #M() {
          let t2 = new d(this.#e),
            e2 = new d(this.#e)
          ;((this.#z = t2),
            (this.#S = e2),
            (this.#O = (s3, h3, r2 = i.now()) => {
              if (((e2[s3] = 0 !== h3 ? r2 : 0), (t2[s3] = h3), 0 !== h3 && this.ttlAutopurge)) {
                let t3 = setTimeout(() => {
                  this.#w(s3) && this.#D(this.#d[s3], 'expire')
                }, h3 + 1)
                t3.unref && t3.unref()
              }
            }),
            (this.#C = (s3) => {
              e2[s3] = 0 !== t2[s3] ? i.now() : 0
            }),
            (this.#W = (i2, r2) => {
              if (t2[r2]) {
                let o2 = t2[r2],
                  a2 = e2[r2]
                if (!o2 || !a2) return
                ;((i2.ttl = o2), (i2.start = a2), (i2.now = s2 || h2()))
                let l2 = i2.now - a2
                i2.remainingTTL = o2 - l2
              }
            }))
          let s2 = 0,
            h2 = () => {
              let t3 = i.now()
              if (this.ttlResolution > 0) {
                s2 = t3
                let e3 = setTimeout(() => (s2 = 0), this.ttlResolution)
                e3.unref && e3.unref()
              }
              return t3
            }
          ;((this.getRemainingTTL = (i2) => {
            let r2 = this.#n.get(i2)
            if (void 0 === r2) return 0
            let o2 = t2[r2],
              a2 = e2[r2]
            return o2 && a2 ? o2 - ((s2 || h2()) - a2) : 1 / 0
          }),
            (this.#w = (i2) => {
              let r2 = e2[i2],
                o2 = t2[i2]
              return !!o2 && !!r2 && (s2 || h2()) - r2 > o2
            }))
        }
        #C = () => {}
        #W = () => {}
        #O = () => {}
        #w = () => false
        #E() {
          let t2 = new d(this.#e)
          ;((this.#l = 0),
            (this.#y = t2),
            (this.#R = (e2) => {
              ;((this.#l -= t2[e2]), (t2[e2] = 0))
            }),
            (this.#I = (t3, e2, i2, s2) => {
              if (this.#k(e2)) return 0
              if (!l(i2))
                if (s2) {
                  if ('function' != typeof s2) throw TypeError('sizeCalculation must be a function')
                  if (!l((i2 = s2(e2, t3)))) throw TypeError('sizeCalculation return invalid (expect positive integer)')
                } else
                  throw TypeError(
                    'invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.'
                  )
              return i2
            }),
            (this.#B = (e2, i2, s2) => {
              if (((t2[e2] = i2), this.#i)) {
                let i3 = this.#i - t2[e2]
                for (; this.#l > i3; ) this.#U(true)
              }
              ;((this.#l += t2[e2]), s2 && ((s2.entrySize = i2), (s2.totalCalculatedSize = this.#l)))
            }))
        }
        #R = (t2) => {}
        #B = (t2, e2, i2) => {}
        #I = (t2, e2, i2, s2) => {
          if (i2 || s2) throw TypeError('cannot set size without setting maxSize or maxEntrySize on cache')
          return 0
        };
        *#b({ allowStale: t2 = this.allowStale } = {}) {
          if (this.#a)
            for (let e2 = this.#g; this.#j(e2) && ((t2 || !this.#w(e2)) && (yield e2), e2 !== this.#p); )
              e2 = this.#f[e2]
        }
        *#A({ allowStale: t2 = this.allowStale } = {}) {
          if (this.#a)
            for (let e2 = this.#p; this.#j(e2) && ((t2 || !this.#w(e2)) && (yield e2), e2 !== this.#g); )
              e2 = this.#u[e2]
        }
        #j(t2) {
          return void 0 !== t2 && this.#n.get(this.#d[t2]) === t2
        }
        *entries() {
          for (let t2 of this.#b())
            void 0 === this.#c[t2] ||
              void 0 === this.#d[t2] ||
              this.#k(this.#c[t2]) ||
              (yield [this.#d[t2], this.#c[t2]])
        }
        *rentries() {
          for (let t2 of this.#A())
            void 0 === this.#c[t2] ||
              void 0 === this.#d[t2] ||
              this.#k(this.#c[t2]) ||
              (yield [this.#d[t2], this.#c[t2]])
        }
        *keys() {
          for (let t2 of this.#b()) {
            let e2 = this.#d[t2]
            void 0 === e2 || this.#k(this.#c[t2]) || (yield e2)
          }
        }
        *rkeys() {
          for (let t2 of this.#A()) {
            let e2 = this.#d[t2]
            void 0 === e2 || this.#k(this.#c[t2]) || (yield e2)
          }
        }
        *values() {
          for (let t2 of this.#b()) void 0 === this.#c[t2] || this.#k(this.#c[t2]) || (yield this.#c[t2])
        }
        *rvalues() {
          for (let t2 of this.#A()) void 0 === this.#c[t2] || this.#k(this.#c[t2]) || (yield this.#c[t2])
        }
        [Symbol.iterator]() {
          return this.entries()
        }
        [Symbol.toStringTag] = 'LRUCache'
        find(t2, e2 = {}) {
          for (let i2 of this.#b()) {
            let s2 = this.#c[i2],
              h2 = this.#k(s2) ? s2.__staleWhileFetching : s2
            if (void 0 !== h2 && t2(h2, this.#d[i2], this)) return this.get(this.#d[i2], e2)
          }
        }
        forEach(t2, e2 = this) {
          for (let i2 of this.#b()) {
            let s2 = this.#c[i2],
              h2 = this.#k(s2) ? s2.__staleWhileFetching : s2
            void 0 !== h2 && t2.call(e2, h2, this.#d[i2], this)
          }
        }
        rforEach(t2, e2 = this) {
          for (let i2 of this.#A()) {
            let s2 = this.#c[i2],
              h2 = this.#k(s2) ? s2.__staleWhileFetching : s2
            void 0 !== h2 && t2.call(e2, h2, this.#d[i2], this)
          }
        }
        purgeStale() {
          let t2 = false
          for (let e2 of this.#A({ allowStale: true })) this.#w(e2) && (this.#D(this.#d[e2], 'expire'), (t2 = true))
          return t2
        }
        info(t2) {
          let e2 = this.#n.get(t2)
          if (void 0 === e2) return
          let s2 = this.#c[e2],
            h2 = this.#k(s2) ? s2.__staleWhileFetching : s2
          if (void 0 === h2) return
          let r2 = { value: h2 }
          if (this.#z && this.#S) {
            let t3 = this.#z[e2],
              s3 = this.#S[e2]
            t3 && s3 && ((r2.ttl = t3 - (i.now() - s3)), (r2.start = Date.now()))
          }
          return (this.#y && (r2.size = this.#y[e2]), r2)
        }
        dump() {
          let t2 = []
          for (let e2 of this.#b({ allowStale: true })) {
            let s2 = this.#d[e2],
              h2 = this.#c[e2],
              r2 = this.#k(h2) ? h2.__staleWhileFetching : h2
            if (void 0 === r2 || void 0 === s2) continue
            let o2 = { value: r2 }
            if (this.#z && this.#S) {
              o2.ttl = this.#z[e2]
              let t3 = i.now() - this.#S[e2]
              o2.start = Math.floor(Date.now() - t3)
            }
            ;(this.#y && (o2.size = this.#y[e2]), t2.unshift([s2, o2]))
          }
          return t2
        }
        load(t2) {
          for (let [e2, s2] of (this.clear(), t2)) {
            if (s2.start) {
              let t3 = Date.now() - s2.start
              s2.start = i.now() - t3
            }
            this.set(e2, s2.value, s2)
          }
        }
        set(t2, e2, i2 = {}) {
          if (void 0 === e2) return (this.delete(t2), this)
          let {
              ttl: s2 = this.ttl,
              start: h2,
              noDisposeOnSet: r2 = this.noDisposeOnSet,
              sizeCalculation: o2 = this.sizeCalculation,
              status: a2,
            } = i2,
            { noUpdateTTL: l2 = this.noUpdateTTL } = i2,
            n2 = this.#I(t2, e2, i2.size || 0, o2)
          if (this.maxEntrySize && n2 > this.maxEntrySize)
            return (a2 && ((a2.set = 'miss'), (a2.maxEntrySizeExceeded = true)), this.#D(t2, 'set'), this)
          let d2 = 0 === this.#a ? void 0 : this.#n.get(t2)
          if (void 0 === d2)
            ((d2 =
              0 === this.#a
                ? this.#g
                : 0 !== this.#v.length
                  ? this.#v.pop()
                  : this.#a === this.#e
                    ? this.#U(false)
                    : this.#a),
              (this.#d[d2] = t2),
              (this.#c[d2] = e2),
              this.#n.set(t2, d2),
              (this.#u[this.#g] = d2),
              (this.#f[d2] = this.#g),
              (this.#g = d2),
              this.#a++,
              this.#B(d2, n2, a2),
              a2 && (a2.set = 'add'),
              (l2 = false))
          else {
            this.#T(d2)
            let i3 = this.#c[d2]
            if (e2 !== i3) {
              if (this.#_ && this.#k(i3)) {
                i3.__abortController.abort(Error('replaced'))
                let { __staleWhileFetching: e3 } = i3
                void 0 !== e3 && !r2 && (this.#L && this.#s?.(e3, t2, 'set'), this.#x && this.#m?.push([e3, t2, 'set']))
              } else !r2 && (this.#L && this.#s?.(i3, t2, 'set'), this.#x && this.#m?.push([i3, t2, 'set']))
              if ((this.#R(d2), this.#B(d2, n2, a2), (this.#c[d2] = e2), a2)) {
                a2.set = 'replace'
                let t3 = i3 && this.#k(i3) ? i3.__staleWhileFetching : i3
                void 0 !== t3 && (a2.oldValue = t3)
              }
            } else a2 && (a2.set = 'update')
          }
          if (
            (0 === s2 || this.#z || this.#M(),
            this.#z && (l2 || this.#O(d2, s2, h2), a2 && this.#W(a2, d2)),
            !r2 && this.#x && this.#m)
          ) {
            let t3,
              e3 = this.#m
            for (; (t3 = e3?.shift()); ) this.#h?.(...t3)
          }
          return this
        }
        pop() {
          try {
            for (; this.#a; ) {
              let t2 = this.#c[this.#p]
              if ((this.#U(true), this.#k(t2))) {
                if (t2.__staleWhileFetching) return t2.__staleWhileFetching
              } else if (void 0 !== t2) return t2
            }
          } finally {
            if (this.#x && this.#m) {
              let t2,
                e2 = this.#m
              for (; (t2 = e2?.shift()); ) this.#h?.(...t2)
            }
          }
        }
        #U(t2) {
          let e2 = this.#p,
            i2 = this.#d[e2],
            s2 = this.#c[e2]
          return (
            this.#_ && this.#k(s2)
              ? s2.__abortController.abort(Error('evicted'))
              : (this.#L || this.#x) &&
                (this.#L && this.#s?.(s2, i2, 'evict'), this.#x && this.#m?.push([s2, i2, 'evict'])),
            this.#R(e2),
            t2 && ((this.#d[e2] = void 0), (this.#c[e2] = void 0), this.#v.push(e2)),
            1 === this.#a ? ((this.#p = this.#g = 0), (this.#v.length = 0)) : (this.#p = this.#u[e2]),
            this.#n.delete(i2),
            this.#a--,
            e2
          )
        }
        has(t2, e2 = {}) {
          let { updateAgeOnHas: i2 = this.updateAgeOnHas, status: s2 } = e2,
            h2 = this.#n.get(t2)
          if (void 0 !== h2) {
            let t3 = this.#c[h2]
            if (this.#k(t3) && void 0 === t3.__staleWhileFetching) return false
            if (!this.#w(h2)) return (i2 && this.#C(h2), s2 && ((s2.has = 'hit'), this.#W(s2, h2)), true)
            s2 && ((s2.has = 'stale'), this.#W(s2, h2))
          } else s2 && (s2.has = 'miss')
          return false
        }
        peek(t2, e2 = {}) {
          let { allowStale: i2 = this.allowStale } = e2,
            s2 = this.#n.get(t2)
          if (void 0 === s2 || (!i2 && this.#w(s2))) return
          let h2 = this.#c[s2]
          return this.#k(h2) ? h2.__staleWhileFetching : h2
        }
        #F(t2, e2, i2, s2) {
          let h2 = void 0 === e2 ? void 0 : this.#c[e2]
          if (this.#k(h2)) return h2
          let r2 = new o(),
            { signal: a2 } = i2
          a2?.addEventListener('abort', () => r2.abort(a2.reason), { signal: r2.signal })
          let l2 = { signal: r2.signal, options: i2, context: s2 },
            n2 = (s3, h3 = false) => {
              let { aborted: o2 } = r2.signal,
                a3 = i2.ignoreFetchAbort && void 0 !== s3
              return (i2.status &&
                (o2 && !h3
                  ? ((i2.status.fetchAborted = true),
                    (i2.status.fetchError = r2.signal.reason),
                    a3 && (i2.status.fetchAbortIgnored = true))
                  : (i2.status.fetchResolved = true)),
              !o2 || a3 || h3)
                ? (this.#c[e2] === u2 &&
                    (void 0 === s3
                      ? u2.__staleWhileFetching
                        ? (this.#c[e2] = u2.__staleWhileFetching)
                        : this.#D(t2, 'fetch')
                      : (i2.status && (i2.status.fetchUpdated = true), this.set(t2, s3, l2.options))),
                  s3)
                : d2(r2.signal.reason)
            },
            d2 = (s3) => {
              let { aborted: h3 } = r2.signal,
                o2 = h3 && i2.allowStaleOnFetchAbort,
                a3 = o2 || i2.allowStaleOnFetchRejection,
                l3 = a3 || i2.noDeleteOnFetchRejection
              if (
                (this.#c[e2] === u2 &&
                  (l3 && void 0 !== u2.__staleWhileFetching
                    ? o2 || (this.#c[e2] = u2.__staleWhileFetching)
                    : this.#D(t2, 'fetch')),
                a3)
              )
                return (
                  i2.status && void 0 !== u2.__staleWhileFetching && (i2.status.returnedStale = true),
                  u2.__staleWhileFetching
                )
              if (u2.__returned === u2) throw s3
            },
            c2 = (e3, s3) => {
              let o2 = this.#r?.(t2, h2, l2)
              ;(o2 && o2 instanceof Promise && o2.then((t3) => e3(void 0 === t3 ? void 0 : t3), s3),
                r2.signal.addEventListener('abort', () => {
                  ;(!i2.ignoreFetchAbort || i2.allowStaleOnFetchAbort) &&
                    (e3(void 0), i2.allowStaleOnFetchAbort && (e3 = (t3) => n2(t3, true)))
                }))
            }
          i2.status && (i2.status.fetchDispatched = true)
          let u2 = new Promise(c2).then(
              n2,
              (t3) => (i2.status && ((i2.status.fetchRejected = true), (i2.status.fetchError = t3)), d2(t3))
            ),
            f = Object.assign(u2, { __abortController: r2, __staleWhileFetching: h2, __returned: void 0 })
          return (
            void 0 === e2
              ? (this.set(t2, f, { ...l2.options, status: void 0 }), (e2 = this.#n.get(t2)))
              : (this.#c[e2] = f),
            f
          )
        }
        #k(t2) {
          return (
            !!this.#_ &&
            !!t2 &&
            t2 instanceof Promise &&
            t2.hasOwnProperty('__staleWhileFetching') &&
            t2.__abortController instanceof o
          )
        }
        async fetch(t2, e2 = {}) {
          let {
            allowStale: i2 = this.allowStale,
            updateAgeOnGet: s2 = this.updateAgeOnGet,
            noDeleteOnStaleGet: h2 = this.noDeleteOnStaleGet,
            ttl: r2 = this.ttl,
            noDisposeOnSet: o2 = this.noDisposeOnSet,
            size: a2 = 0,
            sizeCalculation: l2 = this.sizeCalculation,
            noUpdateTTL: n2 = this.noUpdateTTL,
            noDeleteOnFetchRejection: d2 = this.noDeleteOnFetchRejection,
            allowStaleOnFetchRejection: c2 = this.allowStaleOnFetchRejection,
            ignoreFetchAbort: u2 = this.ignoreFetchAbort,
            allowStaleOnFetchAbort: f = this.allowStaleOnFetchAbort,
            context: p,
            forceRefresh: g = false,
            status: v,
            signal: m,
          } = e2
          if (!this.#_)
            return (
              v && (v.fetch = 'get'),
              this.get(t2, { allowStale: i2, updateAgeOnGet: s2, noDeleteOnStaleGet: h2, status: v })
            )
          let y = {
              allowStale: i2,
              updateAgeOnGet: s2,
              noDeleteOnStaleGet: h2,
              ttl: r2,
              noDisposeOnSet: o2,
              size: a2,
              sizeCalculation: l2,
              noUpdateTTL: n2,
              noDeleteOnFetchRejection: d2,
              allowStaleOnFetchRejection: c2,
              allowStaleOnFetchAbort: f,
              ignoreFetchAbort: u2,
              status: v,
              signal: m,
            },
            S = this.#n.get(t2)
          if (void 0 === S) {
            v && (v.fetch = 'miss')
            let e3 = this.#F(t2, S, y, p)
            return (e3.__returned = e3)
          }
          {
            let e3 = this.#c[S]
            if (this.#k(e3)) {
              let t3 = i2 && void 0 !== e3.__staleWhileFetching
              return (
                v && ((v.fetch = 'inflight'), t3 && (v.returnedStale = true)),
                t3 ? e3.__staleWhileFetching : (e3.__returned = e3)
              )
            }
            let h3 = this.#w(S)
            if (!g && !h3) return (v && (v.fetch = 'hit'), this.#T(S), s2 && this.#C(S), v && this.#W(v, S), e3)
            let r3 = this.#F(t2, S, y, p),
              o3 = void 0 !== r3.__staleWhileFetching && i2
            return (
              v && ((v.fetch = h3 ? 'stale' : 'refresh'), o3 && h3 && (v.returnedStale = true)),
              o3 ? r3.__staleWhileFetching : (r3.__returned = r3)
            )
          }
        }
        async forceFetch(t2, e2 = {}) {
          let i2 = await this.fetch(t2, e2)
          if (void 0 === i2) throw Error('fetch() returned undefined')
          return i2
        }
        memo(t2, e2 = {}) {
          let i2 = this.#o
          if (!i2) throw Error('no memoMethod provided to constructor')
          let { context: s2, forceRefresh: h2, ...r2 } = e2,
            o2 = this.get(t2, r2)
          if (!h2 && void 0 !== o2) return o2
          let a2 = i2(t2, o2, { options: r2, context: s2 })
          return (this.set(t2, a2, r2), a2)
        }
        get(t2, e2 = {}) {
          let {
              allowStale: i2 = this.allowStale,
              updateAgeOnGet: s2 = this.updateAgeOnGet,
              noDeleteOnStaleGet: h2 = this.noDeleteOnStaleGet,
              status: r2,
            } = e2,
            o2 = this.#n.get(t2)
          if (void 0 !== o2) {
            let e3 = this.#c[o2],
              a2 = this.#k(e3)
            return (r2 && this.#W(r2, o2), this.#w(o2))
              ? (r2 && (r2.get = 'stale'), a2)
                ? (r2 && i2 && void 0 !== e3.__staleWhileFetching && (r2.returnedStale = true),
                  i2 ? e3.__staleWhileFetching : void 0)
                : (h2 || this.#D(t2, 'expire'), r2 && i2 && (r2.returnedStale = true), i2 ? e3 : void 0)
              : (r2 && (r2.get = 'hit'), a2)
                ? e3.__staleWhileFetching
                : (this.#T(o2), s2 && this.#C(o2), e3)
          }
          r2 && (r2.get = 'miss')
        }
        #G(t2, e2) {
          ;((this.#f[e2] = t2), (this.#u[t2] = e2))
        }
        #T(t2) {
          t2 !== this.#g &&
            (t2 === this.#p ? (this.#p = this.#u[t2]) : this.#G(this.#f[t2], this.#u[t2]),
            this.#G(this.#g, t2),
            (this.#g = t2))
        }
        delete(t2) {
          return this.#D(t2, 'delete')
        }
        #D(t2, e2) {
          let i2 = false
          if (0 !== this.#a) {
            let s2 = this.#n.get(t2)
            if (void 0 !== s2)
              if (((i2 = true), 1 === this.#a)) this.#N(e2)
              else {
                this.#R(s2)
                let i3 = this.#c[s2]
                if (
                  (this.#k(i3)
                    ? i3.__abortController.abort(Error('deleted'))
                    : (this.#L || this.#x) &&
                      (this.#L && this.#s?.(i3, t2, e2), this.#x && this.#m?.push([i3, t2, e2])),
                  this.#n.delete(t2),
                  (this.#d[s2] = void 0),
                  (this.#c[s2] = void 0),
                  s2 === this.#g)
                )
                  this.#g = this.#f[s2]
                else if (s2 === this.#p) this.#p = this.#u[s2]
                else {
                  let t3 = this.#f[s2]
                  this.#u[t3] = this.#u[s2]
                  let e3 = this.#u[s2]
                  this.#f[e3] = this.#f[s2]
                }
                ;(this.#a--, this.#v.push(s2))
              }
          }
          if (this.#x && this.#m?.length) {
            let t3,
              e3 = this.#m
            for (; (t3 = e3?.shift()); ) this.#h?.(...t3)
          }
          return i2
        }
        clear() {
          return this.#N('delete')
        }
        #N(t2) {
          for (let e2 of this.#A({ allowStale: true })) {
            let i2 = this.#c[e2]
            if (this.#k(i2)) i2.__abortController.abort(Error('deleted'))
            else {
              let s2 = this.#d[e2]
              ;(this.#L && this.#s?.(i2, s2, t2), this.#x && this.#m?.push([i2, s2, t2]))
            }
          }
          if (
            (this.#n.clear(),
            this.#c.fill(void 0),
            this.#d.fill(void 0),
            this.#z && this.#S && (this.#z.fill(0), this.#S.fill(0)),
            this.#y && this.#y.fill(0),
            (this.#p = 0),
            (this.#g = 0),
            (this.#v.length = 0),
            (this.#l = 0),
            (this.#a = 0),
            this.#x && this.#m)
          ) {
            let t3,
              e2 = this.#m
            for (; (t3 = e2?.shift()); ) this.#h?.(...t3)
          }
        }
      }
      module2.exports = e
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/pathway.js
var require_pathway = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/pathway.js'(exports2, module2) {
    'use strict'
    var crypto = require('crypto')
    var { encodeVarint, decodeVarint } = require_encoding()
    var { LRUCache } = require_lru_cache()
    var log = require_log2()
    var pick = require_pick()
    var cache = new LRUCache({ max: 500 })
    var CONTEXT_PROPAGATION_KEY = 'dd-pathway-ctx'
    var CONTEXT_PROPAGATION_KEY_BASE64 = 'dd-pathway-ctx-base64'
    var logKeys = [CONTEXT_PROPAGATION_KEY, CONTEXT_PROPAGATION_KEY_BASE64]
    function shaHash(checkpointString) {
      const hash = crypto.createHash('sha256').update(checkpointString).digest('hex').slice(0, 16)
      return Buffer.from(hash, 'hex')
    }
    function computeHash(service, env, edgeTags, parentHash) {
      edgeTags.sort()
      const hashableEdgeTags = edgeTags.filter((item) => item !== 'manual_checkpoint:true')
      const key = `${service}${env}${hashableEdgeTags.join('')}${parentHash}`
      let value = cache.get(key)
      if (value) {
        return value
      }
      const currentHash = shaHash(`${service}${env}` + hashableEdgeTags.join(''))
      const buf = Buffer.concat([currentHash, parentHash], 16)
      value = shaHash(buf.toString())
      cache.set(key, value)
      return value
    }
    function encodePathwayContext(dataStreamsContext) {
      return Buffer.concat(
        [
          dataStreamsContext.hash,
          Buffer.from(encodeVarint(Math.round(dataStreamsContext.pathwayStartNs / 1e6))),
          Buffer.from(encodeVarint(Math.round(dataStreamsContext.edgeStartNs / 1e6))),
        ],
        20
      )
    }
    function encodePathwayContextBase64(dataStreamsContext) {
      const encodedPathway = encodePathwayContext(dataStreamsContext)
      return encodedPathway.toString('base64')
    }
    function decodePathwayContext(pathwayContext) {
      if (pathwayContext == null || pathwayContext.length < 8) {
        return null
      }
      const pathwayHash = pathwayContext.subarray(0, 8)
      const encodedTimestamps = pathwayContext.subarray(8)
      const [pathwayStartMs, encodedTimeSincePrev] = decodeVarint(encodedTimestamps)
      if (pathwayStartMs === void 0) {
        return null
      }
      const [edgeStartMs] = decodeVarint(encodedTimeSincePrev)
      if (edgeStartMs === void 0) {
        return null
      }
      return { hash: pathwayHash, pathwayStartNs: pathwayStartMs * 1e6, edgeStartNs: edgeStartMs * 1e6 }
    }
    function decodePathwayContextBase64(pathwayContext) {
      if (pathwayContext == null || pathwayContext.length < 8) {
        return
      }
      if (Buffer.isBuffer(pathwayContext)) {
        pathwayContext = pathwayContext.toString()
      }
      const encodedPathway = Buffer.from(pathwayContext, 'base64')
      return decodePathwayContext(encodedPathway)
    }
    var DsmPathwayCodec = {
      // we use a class for encoding / decoding in case we update our encoding/decoding. A class will make updates easier
      // instead of using individual functions.
      /**
       * @param {Object} dataStreamsContext
       * @param {Buffer} dataStreamsContext.hash
       * @param {number} dataStreamsContext.pathwayStartNs
       * @param {number} dataStreamsContext.edgeStartNs
       * @param {Object} carrier
       */
      encode(dataStreamsContext, carrier) {
        if (!dataStreamsContext || !dataStreamsContext.hash) {
          return
        }
        carrier[CONTEXT_PROPAGATION_KEY_BASE64] = encodePathwayContextBase64(dataStreamsContext)
        log.debug(() => `Injected into DSM carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)
      },
      /**
       * @param {Object} carrier
       * @returns {ReturnType<typeof decodePathwayContext>|undefined}
       */
      decode(carrier) {
        log.debug(() => `Attempting extract from DSM carrier: ${JSON.stringify(pick(carrier, logKeys))}.`)
        if (carrier == null) return
        let ctx
        if (CONTEXT_PROPAGATION_KEY_BASE64 in carrier) {
          ctx = decodePathwayContextBase64(carrier[CONTEXT_PROPAGATION_KEY_BASE64])
        } else if (CONTEXT_PROPAGATION_KEY in carrier) {
          try {
            ctx = decodePathwayContext(carrier[CONTEXT_PROPAGATION_KEY])
          } catch {}
          if (!ctx && CONTEXT_PROPAGATION_KEY in carrier) {
            ctx = decodePathwayContextBase64(carrier[CONTEXT_PROPAGATION_KEY])
          }
        }
        return ctx
      },
    }
    module2.exports = {
      computePathwayHash: computeHash,
      encodePathwayContext,
      decodePathwayContext,
      encodePathwayContextBase64,
      decodePathwayContextBase64,
      DsmPathwayCodec,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/context.js
var require_context = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/context.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var log = require_log2()
    function getDataStreamsContext() {
      const store = storage('legacy').getStore()
      return (store && store.dataStreamsContext) || null
    }
    function setDataStreamsContext(dataStreamsContext) {
      log.debug('Setting new DSM Context: %j.', dataStreamsContext)
      if (dataStreamsContext) storage('legacy').enterWith({ ...storage('legacy').getStore(), dataStreamsContext })
    }
    module2.exports = {
      getDataStreamsContext,
      setDataStreamsContext,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/checkpointer.js
var require_checkpointer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/checkpointer.js'(exports2, module2) {
    'use strict'
    var DataStreamsContext = require_context()
    var DataStreamsCheckpointer = class {
      constructor(tracer2) {
        this.tracer = tracer2
        this.config = tracer2._config
        this.dsmProcessor = tracer2._dataStreamsProcessor
      }
      /**
       * @param {string} type - The type of the checkpoint, usually the streaming technology being used.
       *                       Examples include kafka, kinesis, sns etc.
       * @param {string} target - The target of data. This can be a topic, exchange or stream name.
       * @param {Object} carrier - The carrier object to inject context into.
       */
      setProduceCheckpoint(type, target, carrier) {
        if (!this.config.dsmEnabled) return
        const ctx = this.dsmProcessor.setCheckpoint(
          ['type:' + type, 'topic:' + target, 'direction:out', 'manual_checkpoint:true'],
          null,
          DataStreamsContext.getDataStreamsContext(),
          null
        )
        DataStreamsContext.setDataStreamsContext(ctx)
        this.tracer.inject(ctx, 'text_map_dsm', carrier)
      }
      /**
       * @param {string} type - The type of the checkpoint, usually the streaming technology being used.
       *                       Examples include kafka, kinesis, sns etc.
       * @param {string} source - The source of data. This can be a topic, exchange or stream name.
       * @param {Object} carrier - The carrier object to extract context from.
       * @param {boolean} [manualCheckpoint=true] - Whether this checkpoint was manually set. Keep true if manually
       *                                           instrumenting. Manual instrumentation always overrides automatic
       *                                           instrumentation in the case a call is both manually and automatically
       *                                           instrumented.
       */
      setConsumeCheckpoint(type, source, carrier, manualCheckpoint = true) {
        if (!this.config.dsmEnabled) return
        const parentCtx = this.tracer.extract('text_map_dsm', carrier)
        DataStreamsContext.setDataStreamsContext(parentCtx)
        const tags = ['type:' + type, 'topic:' + source, 'direction:in']
        if (manualCheckpoint) {
          tags.push('manual_checkpoint:true')
        }
        const ctx = this.dsmProcessor.setCheckpoint(tags, null, parentCtx, null)
        DataStreamsContext.setDataStreamsContext(ctx)
        return ctx
      }
    }
    module2.exports = {
      DataStreamsCheckpointer,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/manager.js
var require_manager = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/manager.js'(exports2, module2) {
    'use strict'
    var { DsmPathwayCodec } = require_pathway()
    var DataStreamsContext = require_context()
    var DataStreamsManager = class {
      constructor(processor) {
        this._dataStreamsProcessor = processor
      }
      setCheckpoint(edgeTags, span, payloadSize = 0) {
        const ctx = this._dataStreamsProcessor.setCheckpoint(
          edgeTags,
          span,
          DataStreamsContext.getDataStreamsContext(),
          payloadSize
        )
        DataStreamsContext.setDataStreamsContext(ctx)
        return ctx
      }
      decodeDataStreamsContext(carrier) {
        const ctx = DsmPathwayCodec.decode(carrier)
        DataStreamsContext.setDataStreamsContext(ctx)
        return ctx
      }
    }
    module2.exports = { DataStreamsManager }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/writer.js
var require_writer4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/writer.js'(exports2, module2) {
    'use strict'
    var pkg = require_package()
    var log = require_log2()
    var request = require_request()
    var { URL: URL2, format } = require('url')
    var { MsgpackEncoder } = require_msgpack()
    var defaults = require_config_defaults()
    var zlib = require('zlib')
    var msgpack = new MsgpackEncoder()
    function makeRequest(data, url, cb) {
      const options = {
        path: '/v0.1/pipeline_stats',
        method: 'POST',
        headers: {
          'Datadog-Meta-Lang': 'javascript',
          'Datadog-Meta-Tracer-Version': pkg.version,
          'Content-Type': 'application/msgpack',
          'Content-Encoding': 'gzip',
        },
        url,
      }
      log.debug('Request to the intake: %j', options)
      request(data, options, (err, res) => {
        cb(err, res)
      })
    }
    var DataStreamsWriter = class {
      constructor(config) {
        const { hostname = defaults.hostname, port = defaults.port, url } = config
        this._url =
          url ||
          new URL2(
            format({
              protocol: 'http:',
              hostname,
              port,
            })
          )
      }
      flush(payload) {
        if (!request.writable) {
          log.debug('Maximum number of active requests reached. Payload discarded: %j', payload)
          return
        }
        const encodedPayload = msgpack.encode(payload)
        zlib.gzip(encodedPayload, { level: 1 }, (err, compressedData) => {
          if (err) {
            log.error('Error zipping datastream', err)
            return
          }
          makeRequest(compressedData, this._url, (err2, res) => {
            log.debug('Response from the agent:', res)
            if (err2) {
              log.error('Error sending datastream', err2)
            }
          })
        })
      }
      setUrl(url) {
        try {
          url = new URL2(url)
          this._url = url
        } catch (e) {
          log.warn(e.stack)
        }
      }
    }
    module2.exports = {
      DataStreamsWriter,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/fnv.js
var require_fnv = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/fnv.js'(exports2, module2) {
    'use strict'
    var FNV_64_PRIME = 0x100000001b3n
    var FNV1_64_INIT = 0xcbf29ce484222325n
    function fnv(data, hvalInit, fnvPrime, fnvSize) {
      let hval = hvalInit
      for (const byte of data) {
        hval = (hval * fnvPrime) % fnvSize
        hval ^= BigInt(byte)
      }
      return hval
    }
    function fnv64(data) {
      if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data, 'utf8')
      }
      const byteArray = new Uint8Array(data)
      return fnv(byteArray, FNV1_64_INIT, FNV_64_PRIME, 2n ** 64n)
    }
    module2.exports = {
      fnv64,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/schemas/schema.js
var require_schema = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/schemas/schema.js'(exports2, module2) {
    'use strict'
    var Schema = class {
      constructor(definition, id) {
        this.definition = definition
        this.id = id
      }
    }
    module2.exports = { Schema }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/schemas/schema_builder.js
var require_schema_builder = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/schemas/schema_builder.js'(exports2, module2) {
    'use strict'
    var { LRUCache } = require_lru_cache()
    var { fnv64 } = require_fnv()
    var { Schema } = require_schema()
    var maxDepth = 10
    var maxProperties = 1e3
    var CACHE = new LRUCache({ max: 256 })
    var SchemaBuilder = class _SchemaBuilder {
      constructor(iterator) {
        this.schema = new OpenApiSchema()
        this.iterator = iterator
        this.properties = 0
      }
      // TODO: This is only used in tests. Let's refactor the code and stop exposing the cache.
      static getCache() {
        return CACHE
      }
      static getSchemaDefinition(schema) {
        const definition = toJSON(schema)
        const id = fnv64(Buffer.from(definition, 'utf8')).toString()
        return new Schema(definition, id)
      }
      static getSchema(schemaName, iterator, builder) {
        let entry = CACHE.get(schemaName)
        if (!entry) {
          entry = (builder ?? new _SchemaBuilder(iterator)).build()
          CACHE.set(schemaName, entry)
        }
        return entry
      }
      build() {
        this.iterator.iterateOverSchema(this)
        return this.schema
      }
      addProperty(schemaName, fieldName, isArray, type, description, ref, format, enumValues) {
        if (this.properties >= maxProperties) {
          return false
        }
        this.properties += 1
        let property = new OpenApiSchema.PROPERTY(type, description, ref, format, enumValues, null)
        if (isArray) {
          property = new OpenApiSchema.PROPERTY('array', null, null, null, null, property)
        }
        this.schema.components.schemas[schemaName].properties[fieldName] = property
        return true
      }
      shouldExtractSchema(schemaName, depth) {
        if (depth > maxDepth) {
          return false
        }
        if (schemaName in this.schema.components.schemas) {
          return false
        }
        this.schema.components.schemas[schemaName] = new OpenApiSchema.SCHEMA()
        return true
      }
    }
    var OpenApiSchema = class {
      openapi = '3.0.0'
      components = new OpenApiComponents()
    }
    OpenApiSchema.SCHEMA = class {
      type = 'object'
      properties = {}
    }
    OpenApiSchema.PROPERTY = class {
      constructor(type, description = null, ref = null, format = null, enumValues = null, items = null) {
        this.type = type
        this.description = description
        this.$ref = ref
        this.format = format
        this.enum = enumValues
        this.items = items
      }
    }
    var OpenApiComponents = class {
      constructor() {
        this.schemas = {}
      }
    }
    function toJSON(value) {
      if (typeof value === 'object') {
        if (value === null) {
          return 'null'
        }
        if (Array.isArray(value)) {
          let result2 = '['
          for (let i = 0; i < value.length; i++) {
            if (value[i] !== null) {
              if (i !== 0) {
                result2 += ', '
              }
              result2 += value[i] === void 0 ? 'null' : toJSON(value[i])
            }
          }
          return `${result2}]`
        }
        let result = '{'
        for (const [key, objectValue] of Object.entries(value)) {
          if (objectValue != null && typeof key === 'string') {
            const converted = toJSON(objectValue)
            if (converted !== void 0) {
              if (result !== '{') {
                result += ', '
              }
              result += `"${key}": ${converted}`
            }
          }
        }
        return `${result}}`
      }
      return JSON.stringify(value)
    }
    module2.exports = {
      SchemaBuilder,
      OpenApiSchema,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/schemas/schema_sampler.js
var require_schema_sampler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/schemas/schema_sampler.js'(exports2, module2) {
    'use strict'
    var SAMPLE_INTERVAL_MILLIS = 30 * 1e3
    var SchemaSampler = class {
      weight = 0
      lastSampleMs = 0
      trySample(currentTimeMs) {
        if (currentTimeMs >= this.lastSampleMs + SAMPLE_INTERVAL_MILLIS) {
          this.lastSampleMs = currentTimeMs
          const weight = this.weight
          this.weight = 0
          return weight
        }
        return 0
      }
      canSample(currentTimeMs) {
        this.weight += 1
        return currentTimeMs >= this.lastSampleMs + SAMPLE_INTERVAL_MILLIS
      }
    }
    module2.exports = {
      SchemaSampler,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/processor.js
var require_processor = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/processor.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var pkg = require_package()
    var { LogCollapsingLowestDenseDDSketch } = require_sketches_js()
    var { DsmPathwayCodec } = require_pathway()
    var { DataStreamsWriter } = require_writer4()
    var { computePathwayHash } = require_pathway()
    var { getAmqpMessageSize, getHeadersSize, getMessageSize, getSizeOrZero } = require_size()
    var { PATHWAY_HASH } = require_tags()
    var { SchemaBuilder } = require_schema_builder()
    var { SchemaSampler } = require_schema_sampler()
    var log = require_log2()
    var ENTRY_PARENT_HASH = Buffer.from('0000000000000000', 'hex')
    var StatsPoint = class {
      constructor(hash, parentHash, edgeTags) {
        this.hash = hash.readBigUInt64LE()
        this.parentHash = parentHash.readBigUInt64LE()
        this.edgeTags = edgeTags
        this.edgeLatency = new LogCollapsingLowestDenseDDSketch()
        this.pathwayLatency = new LogCollapsingLowestDenseDDSketch()
        this.payloadSize = new LogCollapsingLowestDenseDDSketch()
      }
      addLatencies(checkpoint) {
        const edgeLatencySec = checkpoint.edgeLatencyNs / 1e9
        const pathwayLatencySec = checkpoint.pathwayLatencyNs / 1e9
        this.edgeLatency.accept(edgeLatencySec)
        this.pathwayLatency.accept(pathwayLatencySec)
        this.payloadSize.accept(checkpoint.payloadSize)
      }
      encode() {
        return {
          Hash: this.hash,
          ParentHash: this.parentHash,
          EdgeTags: this.edgeTags,
          EdgeLatency: this.edgeLatency.toProto(),
          PathwayLatency: this.pathwayLatency.toProto(),
          PayloadSize: this.payloadSize.toProto(),
        }
      }
    }
    var Backlog = class {
      constructor({ offset, ...tags }) {
        this._tags = Object.keys(tags)
          .sort()
          .map((key) => `${key}:${tags[key]}`)
        this._hash = this._tags.join(',')
        this._offset = offset
      }
      get hash() {
        return this._hash
      }
      get offset() {
        return this._offset
      }
      get tags() {
        return this._tags
      }
      encode() {
        return {
          Tags: this.tags,
          Value: this.offset,
        }
      }
    }
    var StatsBucket = class {
      constructor() {
        this._checkpoints = /* @__PURE__ */ new Map()
        this._backlogs = /* @__PURE__ */ new Map()
      }
      get checkpoints() {
        return this._checkpoints
      }
      get backlogs() {
        return this._backlogs
      }
      forCheckpoint({ hash, parentHash, edgeTags }) {
        let checkpoint = this._checkpoints.get(hash)
        if (!checkpoint) {
          checkpoint = new StatsPoint(hash, parentHash, edgeTags)
          this._checkpoints.set(hash, checkpoint)
        }
        return checkpoint
      }
      /**
       * Conditionally add a backlog to the bucket. If there is currently an offset
       * matching the backlog's tags, overwrite the offset IFF the backlog's offset
       * is greater than the recorded offset.
       *
       * @typedef {{[key: string]: string}} BacklogData
       * @property {number} offset
       *
       * @param {BacklogData} backlogData
       * @returns {Backlog}
       */
      forBacklog(backlogData) {
        const backlog = new Backlog(backlogData)
        const existingBacklog = this._backlogs.get(backlog.hash)
        if (existingBacklog !== void 0 && existingBacklog.offset > backlog.offset) {
          return existingBacklog
        }
        this._backlogs.set(backlog.hash, backlog)
        return backlog
      }
    }
    var TimeBuckets = class extends Map {
      forTime(time) {
        if (!this.has(time)) {
          this.set(time, new StatsBucket())
        }
        return this.get(time)
      }
    }
    var DataStreamsProcessor = class {
      constructor({ dsmEnabled, hostname, port, url, env, tags, version, service, flushInterval } = {}) {
        this.writer = new DataStreamsWriter({
          hostname,
          port,
          url,
        })
        this.bucketSizeNs = 1e10
        this.buckets = new TimeBuckets()
        this.hostname = os.hostname()
        this.enabled = dsmEnabled
        this.env = env
        this.tags = tags || {}
        this.service = service || 'unnamed-nodejs-service'
        this.version = version || ''
        this.sequence = 0
        this.flushInterval = flushInterval
        this._schemaSamplers = {}
        if (this.enabled) {
          this.timer = setInterval(this.onInterval.bind(this), flushInterval)
          this.timer.unref()
        }
        process.once('beforeExit', () => this.onInterval())
      }
      onInterval() {
        const { Stats } = this._serializeBuckets()
        if (Stats.length === 0) return
        const payload = {
          Env: this.env,
          Service: this.service,
          Stats,
          TracerVersion: pkg.version,
          Version: this.version,
          Lang: 'javascript',
          Tags: Object.entries(this.tags).map(([key, value]) => `${key}:${value}`),
        }
        this.writer.flush(payload)
      }
      /**
       * Given a timestamp in nanoseconds, compute and return the closest TimeBucket
       * @param {number} timestamp
       * @returns {StatsBucket}
       */
      bucketFromTimestamp(timestamp) {
        const bucketTime = Math.round(timestamp - (timestamp % this.bucketSizeNs))
        const bucket = this.buckets.forTime(bucketTime)
        return bucket
      }
      recordCheckpoint(checkpoint, span = null) {
        if (!this.enabled) return
        this.bucketFromTimestamp(checkpoint.currentTimestamp).forCheckpoint(checkpoint).addLatencies(checkpoint)
        if (span) {
          span.setTag(PATHWAY_HASH, checkpoint.hash.readBigUInt64LE(0).toString())
        }
      }
      setCheckpoint(edgeTags, span, ctx = null, payloadSize = 0) {
        if (!this.enabled) return null
        const nowNs = Date.now() * 1e6
        const direction = edgeTags.find((t) => t.startsWith('direction:'))
        let pathwayStartNs = nowNs
        let edgeStartNs = nowNs
        let parentHash = ENTRY_PARENT_HASH
        let closestOppositeDirectionHash = ENTRY_PARENT_HASH
        let closestOppositeDirectionEdgeStart = nowNs
        if (ctx == null) {
          log.debug('Setting DSM Checkpoint with empty parent context.')
        } else {
          pathwayStartNs = ctx.pathwayStartNs
          edgeStartNs = ctx.edgeStartNs
          parentHash = ctx.hash
          closestOppositeDirectionHash = ctx.closestOppositeDirectionHash || ENTRY_PARENT_HASH
          closestOppositeDirectionEdgeStart = ctx.closestOppositeDirectionEdgeStart || nowNs
          if (direction === ctx.previousDirection) {
            parentHash = ctx.closestOppositeDirectionHash
            if (parentHash === ENTRY_PARENT_HASH) {
              edgeStartNs = nowNs
              pathwayStartNs = nowNs
            } else {
              edgeStartNs = ctx.closestOppositeDirectionEdgeStart
            }
          } else {
            closestOppositeDirectionHash = parentHash
            closestOppositeDirectionEdgeStart = edgeStartNs
          }
          log.debug(
            () =>
              `Setting DSM Checkpoint from extracted parent context with hash: ${parentHash} and edge tags: ${edgeTags}`
          )
        }
        const hash = computePathwayHash(this.service, this.env, edgeTags, parentHash)
        const edgeLatencyNs = nowNs - edgeStartNs
        const pathwayLatencyNs = nowNs - pathwayStartNs
        const dataStreamsContext = {
          hash,
          edgeStartNs,
          pathwayStartNs,
          previousDirection: direction,
          closestOppositeDirectionHash,
          closestOppositeDirectionEdgeStart,
        }
        if (direction === 'direction:out') {
          const ddInfoContinued = {}
          DsmPathwayCodec.encode(dataStreamsContext, ddInfoContinued)
          payloadSize += getSizeOrZero(JSON.stringify(ddInfoContinued)) - 1
        }
        const checkpoint = {
          currentTimestamp: nowNs,
          parentHash,
          hash,
          edgeTags,
          edgeLatencyNs,
          pathwayLatencyNs,
          payloadSize,
        }
        this.recordCheckpoint(checkpoint, span)
        return dataStreamsContext
      }
      recordOffset({ timestamp, ...backlogData }) {
        if (!this.enabled) return
        return this.bucketFromTimestamp(timestamp).forBacklog(backlogData)
      }
      setOffset(offsetObj) {
        if (!this.enabled) return
        const nowNs = Date.now() * 1e6
        const backlogData = {
          ...offsetObj,
          timestamp: nowNs,
        }
        this.recordOffset(backlogData)
      }
      _serializeBuckets() {
        const serializedBuckets = []
        for (const [timeNs, bucket] of this.buckets.entries()) {
          const points = []
          for (const stats of bucket._checkpoints.values()) {
            points.push(stats.encode())
          }
          const backlogs = []
          for (const backlog of bucket._backlogs.values()) {
            backlogs.push(backlog.encode())
          }
          serializedBuckets.push({
            Start: BigInt(timeNs),
            Duration: BigInt(this.bucketSizeNs),
            Stats: points,
            Backlogs: backlogs,
          })
        }
        this.buckets.clear()
        return {
          Stats: serializedBuckets,
        }
      }
      setUrl(url) {
        this.writer.setUrl(url)
      }
      trySampleSchema(topic) {
        const nowMs = Date.now()
        if (!this._schemaSamplers[topic]) {
          this._schemaSamplers[topic] = new SchemaSampler()
        }
        const sampler = this._schemaSamplers[topic]
        return sampler.trySample(nowMs)
      }
      canSampleSchema(topic) {
        const nowMs = Date.now()
        if (!this._schemaSamplers[topic]) {
          this._schemaSamplers[topic] = new SchemaSampler()
        }
        const sampler = this._schemaSamplers[topic]
        return sampler.canSample(nowMs)
      }
      getSchema(schemaName, iterator) {
        return SchemaBuilder.getSchema(schemaName, iterator)
      }
    }
    module2.exports = {
      DataStreamsProcessor,
      StatsPoint,
      StatsBucket,
      Backlog,
      TimeBuckets,
      getMessageSize,
      getHeadersSize,
      getSizeOrZero,
      getAmqpMessageSize,
      ENTRY_PARENT_HASH,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/datastreams/index.js
var require_datastreams = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/datastreams/index.js'(exports2, module2) {
    'use strict'
    var { getAmqpMessageSize, getHeadersSize, getMessageSize, getSizeOrZero } = require_size()
    function lazyClass(classGetter, methods = [], staticMethods = []) {
      let constructorArgs
      let ActiveClass
      const LazyClass = function (...args) {
        constructorArgs = args
      }
      const activate = () => {
        return (ActiveClass = ActiveClass || classGetter())
      }
      for (const method of methods) {
        LazyClass.prototype[method] = function (...args) {
          const instance = activate() && new ActiveClass(...constructorArgs)
          Object.setPrototypeOf(this, instance)
          return this[method](...args)
        }
      }
      for (const method of staticMethods) {
        LazyClass[method] = function (...args) {
          LazyClass[method] = activate() && ActiveClass[method]
          return LazyClass[method](...args)
        }
      }
      return LazyClass
    }
    var DsmPathwayCodec = lazyClass(() => require_pathway().DsmPathwayCodec, [], ['encode', 'decode'])
    var DataStreamsCheckpointer = lazyClass(
      () => require_checkpointer().DataStreamsCheckpointer,
      ['setProduceCheckpoint', 'setConsumeCheckpoint']
    )
    var DataStreamsManager = lazyClass(
      () => require_manager().DataStreamsManager,
      ['setCheckpoint', 'decodeDataStreamsContext']
    )
    var DataStreamsProcessor = lazyClass(
      () => require_processor().DataStreamsProcessor,
      [
        'onInterval',
        'bucketFromTimestamp',
        'recordCheckpoint',
        'setCheckpoint',
        'recordOffset',
        'setOffset',
        'setUrl',
        'trySampleSchema',
        'canSampleSchema',
        'getSchema',
      ]
    )
    var SchemaBuilder = lazyClass(
      () => require_schema_builder().SchemaBuilder,
      ['build', 'addProperty', 'shouldExtractSchema'],
      ['getCache', 'getSchemaDefinition', 'getSchema']
    )
    module2.exports = {
      DsmPathwayCodec,
      DataStreamsCheckpointer,
      DataStreamsManager,
      DataStreamsProcessor,
      SchemaBuilder,
      // These are small functions so they are exposed directly and not lazy loaded.
      getAmqpMessageSize,
      getHeadersSize,
      getMessageSize,
      getSizeOrZero,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map_dsm.js
var require_text_map_dsm = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map_dsm.js'(exports2, module2) {
    'use strict'
    var pick = require_pick()
    var log = require_log2()
    var { DsmPathwayCodec } = require_datastreams()
    var base64Key = 'dd-pathway-ctx-base64'
    var logKeys = [base64Key]
    var DSMTextMapPropagator = class {
      constructor(config) {
        this.config = config
      }
      inject(ctx, carrier) {
        if (!this.config.dsmEnabled) return
        this._injectDatadogDSMContext(ctx, carrier)
        log.debug(() => `Inject into carrier (DSM): ${JSON.stringify(pick(carrier, logKeys))}.`)
      }
      extract(carrier) {
        if (!this.config.dsmEnabled) return
        const dsmContext = this._extractDatadogDSMContext(carrier)
        if (!dsmContext) return dsmContext
        log.debug(() => `Extract from carrier (DSM): ${JSON.stringify(pick(carrier, logKeys))}.`)
        return dsmContext
      }
      _injectDatadogDSMContext(ctx, carrier) {
        DsmPathwayCodec.encode(ctx, carrier)
      }
      _extractDatadogDSMContext(carrier) {
        const ctx = DsmPathwayCodec.decode(carrier)
        return ctx
      }
    }
    module2.exports = DSMTextMapPropagator
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js
var require_http = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js'(exports2, module2) {
    'use strict'
    var TextMapPropagator = require_text_map()
    var HttpPropagator = class extends TextMapPropagator {}
    module2.exports = HttpPropagator
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js
var require_binary = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js'(exports2, module2) {
    'use strict'
    var BinaryPropagator = class {
      inject(spanContext, carrier) {}
      extract(carrier) {
        return null
      }
    }
    module2.exports = BinaryPropagator
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js
var require_log3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js'(exports2, module2) {
    'use strict'
    var id = require_id()
    var DatadogSpanContext = require_span_context()
    var LogPropagator = class {
      constructor(config) {
        this._config = config
      }
      inject(spanContext, carrier) {
        if (!carrier) return
        carrier.dd = {}
        if (spanContext) {
          carrier.dd.trace_id =
            this._config.traceId128BitGenerationEnabled &&
            this._config.traceId128BitLoggingEnabled &&
            spanContext._trace.tags['_dd.p.tid']
              ? spanContext.toTraceId(true)
              : spanContext.toTraceId()
          carrier.dd.span_id = spanContext.toSpanId()
        }
        if (this._config.service) carrier.dd.service = this._config.service
        if (this._config.version) carrier.dd.version = this._config.version
        if (this._config.env) carrier.dd.env = this._config.env
      }
      extract(carrier) {
        if (!carrier || !carrier.dd || !carrier.dd.trace_id || !carrier.dd.span_id) {
          return null
        }
        if (carrier.dd.trace_id.length === 32) {
          const hi = carrier.dd.trace_id.slice(0, 16)
          const lo = carrier.dd.trace_id.slice(16, 32)
          const spanContext = new DatadogSpanContext({
            traceId: id(lo, 16),
            spanId: id(carrier.dd.span_id, 10),
          })
          spanContext._trace.tags['_dd.p.tid'] = hi
          return spanContext
        }
        return new DatadogSpanContext({
          traceId: id(carrier.dd.trace_id, 10),
          spanId: id(carrier.dd.span_id, 10),
        })
      }
    }
    module2.exports = LogPropagator
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js
var require_log4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var TRACE_PREFIX = '{"traces":[['
    var TRACE_SUFFIX = ']]}\n'
    var TRACE_FORMAT_OVERHEAD = TRACE_PREFIX.length + TRACE_SUFFIX.length
    var MAX_SIZE = 64 * 1024
    var LogExporter = class {
      export(spans) {
        log.debug('Adding trace to queue: %j', spans)
        let size = TRACE_FORMAT_OVERHEAD
        let queue = []
        for (const span of spans) {
          const spanStr = JSON.stringify(span)
          if (spanStr.length + TRACE_FORMAT_OVERHEAD > MAX_SIZE) {
            log.debug('Span too large to send to logs, dropping')
            continue
          }
          if (spanStr.length + size > MAX_SIZE) {
            this._printSpans(queue)
            queue = []
            size = TRACE_FORMAT_OVERHEAD
          }
          size += spanStr.length + 1
          queue.push(spanStr)
        }
        if (queue.length > 0) {
          this._printSpans(queue)
        }
      }
      _printSpans(queue) {
        let logLine = TRACE_PREFIX
        let firstTrace = true
        for (const spanStr of queue) {
          if (firstTrace) {
            firstTrace = false
            logLine += spanStr
          } else {
            logLine += ',' + spanStr
          }
        }
        logLine += TRACE_SUFFIX
        process.stdout.write(logLine)
      }
    }
    module2.exports = LogExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js
var require__2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js'(exports2, module2) {
    'use strict'
    var { truncateSpan, normalizeSpan } = require_tags_processors()
    var { AgentEncoder: BaseEncoder } = require__()
    var ARRAY_OF_TWO = 146
    var ARRAY_OF_TWELVE = 156
    function formatSpan(span) {
      span = normalizeSpan(truncateSpan(span, false))
      if (span.span_events) {
        span.meta.events = JSON.stringify(span.span_events)
        delete span.span_events
      }
      return span
    }
    var AgentEncoder = class extends BaseEncoder {
      makePayload() {
        const prefixSize = 1
        const stringSize = this._stringBytes.length + 5
        const traceSize = this._traceBytes.length + 5
        const buffer = Buffer.allocUnsafe(prefixSize + stringSize + traceSize)
        buffer[0] = ARRAY_OF_TWO
        const offset = this._writeStrings(buffer, 1)
        this._writeTraces(buffer, offset)
        this._reset()
        return buffer
      }
      _encode(bytes, trace) {
        this._encodeArrayPrefix(bytes, trace)
        for (let span of trace) {
          span = formatSpan(span)
          this._encodeByte(bytes, ARRAY_OF_TWELVE)
          this._encodeString(bytes, span.service)
          this._encodeString(bytes, span.name)
          this._encodeString(bytes, span.resource)
          this._encodeId(bytes, span.trace_id)
          this._encodeId(bytes, span.span_id)
          this._encodeId(bytes, span.parent_id)
          this._encodeLong(bytes, span.start || 0)
          this._encodeLong(bytes, span.duration || 0)
          this._encodeInteger(bytes, span.error)
          this._encodeMap(bytes, span.meta || {})
          this._encodeMap(bytes, span.metrics || {})
          this._encodeString(bytes, span.type)
        }
      }
      _encodeString(bytes, value = '') {
        this._cacheString(value)
        this._encodeInteger(bytes, this._stringMap[value])
      }
      _cacheString(value) {
        if (!(value in this._stringMap)) {
          this._stringMap[value] = this._stringCount++
          this._stringBytes.write(value)
        }
      }
      _writeStrings(buffer, offset) {
        offset = this._writeArrayPrefix(buffer, offset, this._stringCount)
        offset += this._stringBytes.buffer.copy(buffer, offset, 0, this._stringBytes.length)
        return offset
      }
    }
    module2.exports = { AgentEncoder }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js
var require_writer5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var { startupLog } = require_startup_log()
    var runtimeMetrics = require_runtime_metrics2()
    var log = require_log2()
    var tracerVersion = require_package().version
    var BaseWriter = require_writer2()
    var METRIC_PREFIX = 'datadog.tracer.node.exporter.agent'
    var AgentWriter = class extends BaseWriter {
      constructor({ prioritySampler, lookup, protocolVersion, headers, config = {} }) {
        super(...arguments)
        const AgentEncoder = getEncoder(protocolVersion)
        this._prioritySampler = prioritySampler
        this._lookup = lookup
        this._protocolVersion = protocolVersion
        this._headers = headers
        this._config = config
        this._encoder = new AgentEncoder(this)
      }
      _sendPayload(data, count, done) {
        runtimeMetrics.increment(`${METRIC_PREFIX}.requests`, true)
        const { _headers, _lookup, _protocolVersion, _url } = this
        makeRequest(_protocolVersion, data, count, _url, _headers, _lookup, true, (err, res, status) => {
          if (status) {
            runtimeMetrics.increment(`${METRIC_PREFIX}.responses`, true)
            runtimeMetrics.increment(`${METRIC_PREFIX}.responses.by.status`, `status:${status}`, true)
          } else if (err) {
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors`, true)
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${err.name}`, true)
            if (err.code) {
              runtimeMetrics.increment(`${METRIC_PREFIX}.errors.by.code`, `code:${err.code}`, true)
            }
          }
          startupLog({ agentError: err })
          if (err) {
            log.errorWithoutTelemetry('Error sending payload to the agent (status code: %s)', err.status, err)
            done()
            return
          }
          log.debug('Response from the agent: %s', res)
          try {
            this._prioritySampler.update(JSON.parse(res).rate_by_service)
          } catch (e) {
            log.error('Error updating prioritySampler rates', e)
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors`, true)
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${e.name}`, true)
          }
          done()
        })
      }
    }
    function getEncoder(protocolVersion) {
      return protocolVersion === '0.5' ? require__2().AgentEncoder : require__().AgentEncoder
    }
    function makeRequest(version, data, count, url, headers, lookup, needsStartupLog, cb) {
      const options = {
        path: `/v${version}/traces`,
        method: 'PUT',
        headers: {
          ...headers,
          'Content-Type': 'application/msgpack',
          'Datadog-Meta-Tracer-Version': tracerVersion,
          'X-Datadog-Trace-Count': String(count),
          'Datadog-Meta-Lang': 'nodejs',
          'Datadog-Meta-Lang-Version': process.version,
          'Datadog-Meta-Lang-Interpreter': process.jsEngine || 'v8',
        },
        lookup,
        url,
      }
      log.debug('Request to the agent: %j', options)
      request(data, options, (err, res, status) => {
        if (needsStartupLog) {
          startupLog({
            agentError: status !== 404 && status !== 200 ? err : void 0,
          })
        }
        cb(err, res, status)
      })
    }
    module2.exports = AgentWriter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js
var require_agent = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js'(exports2, module2) {
    'use strict'
    var { URL: URL2, format } = require('url')
    var log = require_log2()
    var Writer = require_writer5()
    var defaults = require_config_defaults()
    var AgentExporter = class {
      #timer
      constructor(config, prioritySampler) {
        this._config = config
        const {
          url,
          hostname = defaults.hostname,
          port,
          lookup,
          protocolVersion,
          stats = {},
          apmTracingEnabled,
        } = config
        this._url =
          url ||
          new URL2(
            format({
              protocol: 'http:',
              hostname,
              port,
            })
          )
        const headers = {}
        if (stats.enabled || apmTracingEnabled === false) {
          headers['Datadog-Client-Computed-Stats'] = 'yes'
        }
        this._writer = new Writer({
          url: this._url,
          prioritySampler,
          lookup,
          protocolVersion,
          headers,
          config,
        })
        process.once('beforeExit', () => {
          this.flush()
        })
      }
      setUrl(url) {
        try {
          url = new URL2(url)
          this._url = url
          this._writer.setUrl(url)
        } catch (e) {
          log.warn(e.stack)
        }
      }
      export(spans) {
        this._writer.append(spans)
        const { flushInterval } = this._config
        if (flushInterval === 0) {
          this._writer.flush()
        } else if (this.#timer === void 0) {
          this.#timer = setTimeout(() => {
            this._writer.flush()
            this.#timer = void 0
          }, flushInterval).unref()
        }
      }
      flush(done = () => {}) {
        clearTimeout(this.#timer)
        this.#timer = void 0
        this._writer.flush(done)
      }
    }
    module2.exports = AgentExporter
  },
})

// node_modules/dd-trace/vendor/dist/semifies/index.js
var require_semifies = __commonJS({
  'node_modules/dd-trace/vendor/dist/semifies/index.js'(exports2, module2) {
    ;(() => {
      var t = {
          './semifies/index.js': function (t2) {
            function e2(t3) {
              return ('latest' === t3 && (t3 = '>=0'), t3.match(/^([^\d+]*)(\d.*)$/) || [null, '', '*.*.*'])
            }
            function n2(t3, e3) {
              let n3 = t3.slice(0)
              if (-1 === t3[e3]) return n3
              for (n3[e3++]++; e3 < 3; e3++) n3[e3] = 0
              return n3
            }
            function r(t3) {
              return 'x' === t3 || 'X' === t3 || '*' === t3 || 'latest' === t3 ? -1 : Number(t3)
            }
            function i(t3) {
              return /^\d+$/.test(t3) ? Number(t3) : t3
            }
            function u(t3, e3, n3) {
              return -1 === n3
                ? '<' !== t3
                : '=' === t3
                  ? e3 === n3
                  : '>' === t3
                    ? e3 > n3
                    : '>=' === t3
                      ? e3 >= n3
                      : '<' === t3
                        ? e3 < n3
                        : '<=' === t3 && e3 <= n3
            }
            function l(t3, e3) {
              let [n3, u2] = (t3 = t3.split('+')[0]).split('-'),
                l2 = n3.split('.').map(r).slice(0, 3),
                s = Math.max(l2.length - 1, 0)
              return ('>' === e3
                ? ((e3 = '>='), l2.push(0, 0, 0), l2[s]++)
                : '' === e3
                  ? l2.push(0, 0, 0)
                  : l2.push(-1, -1, -1),
              u2)
                ? [l2.slice(0, 3).concat(u2.split('.').map(i)), e3]
                : [l2.slice(0, 3), e3]
            }
            t2.exports = function (t3, r2) {
              let [i2] = l(t3, '')
              for (let t4 of (function (t5) {
                let r3 = [],
                  i3 = [],
                  u2 = t5.trim().split(/\s+/)
                for (let t6 = 0; t6 < u2.length; t6++) {
                  let s = u2[t6]
                  if ('-' === s) continue
                  if ('||' === s) {
                    ;(r3.push(i3), (i3 = []))
                    continue
                  }
                  if (/^[<>=~v^]+$/.test(s) && t6 + 1 < u2.length) {
                    u2[t6 + 1] = s + u2[t6 + 1]
                    continue
                  }
                  let f = e2(s),
                    o = f[1] || '='
                  o.endsWith('v') && (o = o.slice(0, -1))
                  let [h, p] = l(f[2], o)
                  if (t6 + 2 < u2.length && '-' === u2[t6 + 1]) {
                    let n3 = e2(u2[t6 + 2])
                    ;((u2[t6 + 2] = '<=' + (-1 === n3[2].indexOf('-') ? n3[2] + '.*.*' : n3[2])), (p = '>='))
                  }
                  if ('~' === p[0]) {
                    let t7 = f[2].split('-')[0].split('.').length
                    ;(i3.push(['>=', h]), i3.push(['<', 1 === t7 ? n2(h, 0) : n2(h, 1)]))
                  } else if ('^' === p[0]) {
                    let t7 = 0 !== h[0] ? 0 : 0 !== h[1] ? 1 : 2
                    ;(i3.push(['>=', h]), i3.push(['<', 0 === t7 ? n2(h, 0) : 1 === t7 ? n2(h, 1) : n2(h, 2)]))
                  } else i3.push([p.replace('~', '').replace('^', ''), h])
                }
                return (i3.length && r3.push(i3), r3)
              })(r2))
                if (
                  (function (t5, e3) {
                    for (let [n3, r3] of t5)
                      if (
                        !(function (t6, e4, n4) {
                          if (!u('=', t6[0], e4[0])) return u(n4, t6[0], e4[0])
                          if (!u('=', t6[1], e4[1])) return u(n4, t6[1], e4[1])
                          if (!u('=', t6[2], e4[2]) || (3 === t6.length && 3 === e4.length)) return u(n4, t6[2], e4[2])
                          if ('<' === n4[0] && (3 === e4.length || 3 === t6.length)) return false
                          if ('>' === n4[0]) {
                            if (3 === t6.length) return true
                            if (3 === e4.length) return false
                          }
                          for (let r4 = 3; r4 < Math.max(t6.length, e4.length); r4++)
                            if (u(n4, t6[r4] || '', e4[r4] || '')) return true
                          return false
                        })(e3, r3, n3)
                      )
                        return false
                    return true
                  })(t4, i2)
                )
                  return true
              return false
            }
          },
        },
        e = {},
        n = (function n2(r) {
          var i = e[r]
          if (void 0 !== i) return i.exports
          var u = (e[r] = { exports: {} })
          return (t[r](u, u.exports, n2), u.exports)
        })('./semifies/index.js')
      module2.exports = n
    })()
  },
})

// node_modules/dd-trace/vendor/dist/istanbul-lib-coverage/index.js
var require_istanbul_lib_coverage = __commonJS({
  'node_modules/dd-trace/vendor/dist/istanbul-lib-coverage/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e = {
          './istanbul-lib-coverage/index.js': function (e2, t2, a2) {
            let { FileCoverage: r } = a2('./istanbul-lib-coverage/lib/file-coverage.js'),
              { CoverageMap: s } = a2('./istanbul-lib-coverage/lib/coverage-map.js'),
              { CoverageSummary: n } = a2('./istanbul-lib-coverage/lib/coverage-summary.js')
            ;((e2.exports = {
              createCoverageSummary: (e3) => (e3 && e3 instanceof n ? e3 : new n(e3)),
              createCoverageMap: (e3) => (e3 && e3 instanceof s ? e3 : new s(e3)),
              createFileCoverage: (e3) => (e3 && e3 instanceof r ? e3 : new r(e3)),
            }),
              (e2.exports.classes = { FileCoverage: r }))
          },
          './istanbul-lib-coverage/lib/coverage-map.js': function (e2, t2, a2) {
            let { FileCoverage: r } = a2('./istanbul-lib-coverage/lib/file-coverage.js'),
              { CoverageSummary: s } = a2('./istanbul-lib-coverage/lib/coverage-summary.js')
            function n(e3, t3) {
              return e3 instanceof t3 ? e3 : new t3(e3)
            }
            class i {
              constructor(e3) {
                e3 instanceof i
                  ? (this.data = e3.data)
                  : (this.data = (function (e4) {
                      let t3 = /* @__PURE__ */ Object.create(null)
                      return (
                        e4 &&
                          Object.entries(e4).forEach(([e5, a3]) => {
                            t3[e5] = n(a3, r)
                          }),
                        t3
                      )
                    })(e3))
              }
              merge(e3) {
                Object.values(n(e3, i).data).forEach((e4) => {
                  this.addFileCoverage(e4)
                })
              }
              filter(e3) {
                Object.keys(this.data).forEach((t3) => {
                  e3(t3) || delete this.data[t3]
                })
              }
              toJSON() {
                return this.data
              }
              files() {
                return Object.keys(this.data)
              }
              fileCoverageFor(e3) {
                let t3 = this.data[e3]
                if (!t3) throw Error(`No file coverage available for: ${e3}`)
                return t3
              }
              addFileCoverage(e3) {
                let t3 = new r(e3),
                  { path: a3 } = t3
                this.data[a3] ? this.data[a3].merge(t3) : (this.data[a3] = t3)
              }
              getCoverageSummary() {
                let e3 = new s()
                return (
                  Object.values(this.data).forEach((t3) => {
                    e3.merge(t3.toSummary())
                  }),
                  e3
                )
              }
            }
            e2.exports = { CoverageMap: i }
          },
          './istanbul-lib-coverage/lib/coverage-summary.js': function (e2, t2, a2) {
            let r = a2('./istanbul-lib-coverage/lib/percent.js'),
              s = a2('./istanbul-lib-coverage/lib/data-properties.js')
            class n {
              constructor(e3) {
                ;(e3
                  ? e3 instanceof n
                    ? (this.data = e3.data)
                    : (this.data = e3)
                  : (this.data = (function () {
                      let e4 = () => ({ total: 0, covered: 0, skipped: 0, pct: 'Unknown' })
                      return { lines: e4(), statements: e4(), functions: e4(), branches: e4(), branchesTrue: e4() }
                    })()),
                  (function (e4) {
                    if (!(e4 && e4.lines && e4.statements && e4.functions && e4.branches))
                      throw Error('Invalid summary coverage object, missing keys, found:' + Object.keys(e4).join(','))
                  })(this.data))
              }
              merge(e3) {
                return (
                  ['lines', 'statements', 'branches', 'functions', 'branchesTrue'].forEach((t3) => {
                    e3[t3] &&
                      ((this[t3].total += e3[t3].total),
                      (this[t3].covered += e3[t3].covered),
                      (this[t3].skipped += e3[t3].skipped),
                      (this[t3].pct = r(this[t3].covered, this[t3].total)))
                  }),
                  this
                )
              }
              toJSON() {
                return this.data
              }
              isEmpty() {
                return 0 === this.lines.total
              }
            }
            ;(s(n, ['lines', 'statements', 'functions', 'branches', 'branchesTrue']),
              (e2.exports = { CoverageSummary: n }))
          },
          './istanbul-lib-coverage/lib/data-properties.js': function (e2) {
            e2.exports = function (e3, t2) {
              t2.forEach((t3) => {
                Object.defineProperty(e3.prototype, t3, {
                  enumerable: true,
                  get() {
                    return this.data[t3]
                  },
                })
              })
            }
          },
          './istanbul-lib-coverage/lib/file-coverage.js': function (e2, t2, a2) {
            let r = a2('./istanbul-lib-coverage/lib/percent.js'),
              s = a2('./istanbul-lib-coverage/lib/data-properties.js'),
              { CoverageSummary: n } = a2('./istanbul-lib-coverage/lib/coverage-summary.js'),
              i = ({ start: e3, end: t3 }) => `${e3.line}|${e3.column}|${t3.line}|${t3.column}`,
              o = (e3) => !!e3 && 'object' == typeof e3,
              l = (e3) => o(e3) && 'number' == typeof e3.line && 'number' == typeof e3.column,
              c = (e3) => o(e3) && l(e3.start) && l(e3.end),
              u = (e3) => (c(e3) ? e3 : c(e3.loc) ? e3.loc : null),
              h = (e3, t3) => {
                let a3 = u(e3)
                if (!a3) return null
                let r2 = null,
                  s2 = null,
                  n2 = null
                for (let [e4, i2] of Object.entries(t3)) {
                  let t4 = u(i2)
                  if (!t4) continue
                  let o2 = [
                    a3.start.line - t4.start.line,
                    a3.start.column - t4.start.column,
                    t4.end.line - a3.end.line,
                    t4.end.column - a3.end.column,
                  ]
                  if (o2[0] < 0 || o2[2] < 0 || (0 === o2[0] && o2[1] < 0) || (0 === o2[2] && o2[3] < 0)) continue
                  if (null === r2) {
                    ;((s2 = o2), (r2 = i2), (n2 = e4))
                    continue
                  }
                  let l2 = o2[0] < s2[0] || (0 === o2[0] && o2[1] < s2[1]),
                    c2 = o2[2] < s2[2] || (0 === o2[2] && o2[3] < s2[3])
                  ;(l2 || c2) && ((s2 = o2), (r2 = i2), (n2 = e4))
                }
                return n2
              },
              b = (e3, t3) =>
                'number' == typeof e3 && 'number' == typeof t3
                  ? e3 + t3
                  : Array.isArray(e3) && Array.isArray(t3)
                    ? e3.map((e4, a3) => (e4 || 0) + (t3[a3] || 0))
                    : null,
              f = (e3, t3, a3, r2) => {
                let s2 = h(e3, a3)
                return s2 ? b(t3, r2[s2]) : t3
              },
              p = (e3, t3, a3, r2, s2 = i) => {
                let n2 = {}
                for (let [a4, r3] of Object.entries(e3)) {
                  let e4 = t3[a4]
                  n2[s2(e4)] = [r3, e4]
                }
                let o2 = {}
                for (let [e4, t4] of Object.entries(a3)) {
                  let a4 = r2[e4]
                  o2[s2(a4)] = [t4, a4]
                }
                let l2 = {}
                for (let [e4, t4] of Object.entries(n2)) {
                  let s3 = t4[0],
                    n3 = t4[1],
                    i2 = o2[e4]
                  ;((s3 = i2 ? b(s3, i2[0]) : f(n3, s3, r2, a3)), (l2[e4] = [s3, n3]))
                }
                for (let [a4, r3] of Object.entries(o2)) {
                  let s3 = r3[0],
                    n3 = r3[1]
                  l2[a4] || ((s3 = f(n3, s3, t3, e3)), (l2[a4] = [s3, n3]))
                }
                let c2 = {},
                  u2 = {}
                return (
                  Object.values(l2).forEach(([e4, t4], a4) => {
                    ;((c2[a4] = e4), (u2[a4] = t4))
                  }),
                  [c2, u2]
                )
              }
            class d {
              constructor(e3, t3 = false) {
                if (!e3) throw Error('Coverage must be initialized with a path or an object')
                if ('string' == typeof e3)
                  this.data = (function (e4, t4) {
                    let a3 = { path: e4, statementMap: {}, fnMap: {}, branchMap: {}, s: {}, f: {}, b: {} }
                    return (t4 && (a3.bT = {}), a3)
                  })(e3, t3)
                else if (e3 instanceof d) this.data = e3.data
                else if ('object' == typeof e3) this.data = e3
                else throw Error('Invalid argument to coverage constructor')
                !(function (e4) {
                  if (!(e4 && e4.path && e4.statementMap && e4.fnMap && e4.branchMap && e4.s && e4.f && e4.b))
                    throw Error('Invalid file coverage object, missing keys, found:' + Object.keys(e4).join(','))
                })(this.data)
              }
              getLineCoverage() {
                let e3 = this.data.statementMap,
                  t3 = this.data.s,
                  a3 = /* @__PURE__ */ Object.create(null)
                return (
                  Object.entries(t3).forEach(([t4, r2]) => {
                    if (!e3[t4]) return
                    let { line: s2 } = e3[t4].start,
                      n2 = a3[s2]
                    ;(void 0 === n2 || n2 < r2) && (a3[s2] = r2)
                  }),
                  a3
                )
              }
              getUncoveredLines() {
                let e3 = this.getLineCoverage(),
                  t3 = []
                return (
                  Object.entries(e3).forEach(([e4, a3]) => {
                    0 === a3 && t3.push(e4)
                  }),
                  t3
                )
              }
              getBranchCoverageByLine() {
                let e3 = this.branchMap,
                  t3 = this.b,
                  a3 = {}
                return (
                  Object.entries(e3).forEach(([e4, r2]) => {
                    let s2 = r2.line || r2.loc.start.line,
                      n2 = t3[e4]
                    ;((a3[s2] = a3[s2] || []), a3[s2].push(...n2))
                  }),
                  Object.entries(a3).forEach(([e4, t4]) => {
                    let r2 = t4.filter((e5) => e5 > 0),
                      s2 = (r2.length / t4.length) * 100
                    a3[e4] = { covered: r2.length, total: t4.length, coverage: s2 }
                  }),
                  a3
                )
              }
              toJSON() {
                return this.data
              }
              merge(e3) {
                if (true === e3.all) return
                if (true === this.all) {
                  this.data = e3.data
                  return
                }
                let [t3, a3] = p(this.s, this.statementMap, e3.s, e3.statementMap)
                ;((this.data.s = t3), (this.data.statementMap = a3))
                let r2 = (e4) => i(e4.locations[0])
                ;(([t3, a3] = p(this.f, this.fnMap, e3.f, e3.fnMap, (e4) => i(e4.loc))),
                  (this.data.f = t3),
                  (this.data.fnMap = a3),
                  ([t3, a3] = p(this.b, this.branchMap, e3.b, e3.branchMap, r2)),
                  (this.data.b = t3),
                  (this.data.branchMap = a3),
                  this.bT &&
                    e3.bT &&
                    (([t3, a3] = p(this.bT, this.branchMap, e3.bT, e3.branchMap, r2)), (this.data.bT = t3)))
              }
              computeSimpleTotals(e3) {
                let t3 = this[e3]
                'function' == typeof t3 && (t3 = t3.call(this))
                let a3 = {
                  total: Object.keys(t3).length,
                  covered: Object.values(t3).filter((e4) => !!e4).length,
                  skipped: 0,
                }
                return ((a3.pct = r(a3.covered, a3.total)), a3)
              }
              computeBranchTotals(e3) {
                let t3 = this[e3],
                  a3 = { total: 0, covered: 0, skipped: 0 }
                return (
                  Object.values(t3).forEach((e4) => {
                    ;((a3.covered += e4.filter((e5) => e5 > 0).length), (a3.total += e4.length))
                  }),
                  (a3.pct = r(a3.covered, a3.total)),
                  a3
                )
              }
              resetHits() {
                let e3 = this.s,
                  t3 = this.f,
                  a3 = this.b,
                  r2 = this.bT
                ;(Object.keys(e3).forEach((t4) => {
                  e3[t4] = 0
                }),
                  Object.keys(t3).forEach((e4) => {
                    t3[e4] = 0
                  }),
                  Object.keys(a3).forEach((e4) => {
                    a3[e4].fill(0)
                  }),
                  r2 &&
                    Object.keys(r2).forEach((e4) => {
                      r2[e4].fill(0)
                    }))
              }
              toSummary() {
                let e3 = {}
                return (
                  (e3.lines = this.computeSimpleTotals('getLineCoverage')),
                  (e3.functions = this.computeSimpleTotals('f', 'fnMap')),
                  (e3.statements = this.computeSimpleTotals('s', 'statementMap')),
                  (e3.branches = this.computeBranchTotals('b')),
                  this.bT && (e3.branchesTrue = this.computeBranchTotals('bT')),
                  new n(e3)
                )
              }
            }
            ;(s(d, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'bT', 'all']),
              (e2.exports = { FileCoverage: d, findNearestContainer: h, addHits: b, addNearestContainerHits: f }))
          },
          './istanbul-lib-coverage/lib/percent.js': function (e2) {
            e2.exports = function (e3, t2) {
              return t2 > 0 ? Math.floor((1e5 * e3) / t2 / 10) / 100 : 100
            }
          },
        },
        t = {},
        a = (function a2(r) {
          var s = t[r]
          if (void 0 !== s) return s.exports
          var n = (t[r] = { exports: {} })
          return (e[r](n, n.exports, a2), n.exports)
        })('./istanbul-lib-coverage/index.js')
      module2.exports = a
    })()
  },
})

// node_modules/dd-trace/vendor/dist/ignore/index.js
var require_ignore = __commonJS({
  'node_modules/dd-trace/vendor/dist/ignore/index.js'(exports2, module2) {
    ;(() => {
      var t = {
          './ignore/index.js': function (t2) {
            function e2(t3) {
              return Array.isArray(t3) ? t3 : [t3]
            }
            let r2,
              s = /^\s+$/,
              i = /(?:[^\\]|^)\\$/,
              n = /^\\!/,
              h = /^\\#/,
              o = /\r?\n/g,
              l = /^\.{0,2}\/|^\.{1,2}$/,
              a = /\/$/,
              u = 'node-ignore'
            'undefined' != typeof Symbol && (u = /* @__PURE__ */ Symbol.for('node-ignore'))
            let c = u,
              d = (t3, e3, r3) => (Object.defineProperty(t3, e3, { value: r3 }), r3),
              g = /([0-z])-([0-z])/g,
              p = () => false,
              _ = [
                [/^\uFEFF/, () => ''],
                [/((?:\\\\)*?)(\\?\s+)$/, (t3, e3, r3) => e3 + (0 === r3.indexOf('\\') ? ' ' : '')],
                [
                  /(\\+?)\s/g,
                  (t3, e3) => {
                    let { length: r3 } = e3
                    return e3.slice(0, r3 - (r3 % 2)) + ' '
                  },
                ],
                [/[\\$.|*+(){^]/g, (t3) => `\\${t3}`],
                [/(?!\\)\?/g, () => '[^/]'],
                [/^\//, () => '^'],
                [/\//g, () => '\\/'],
                [/^\^*\\\*\\\*\\\//, () => '^(?:.*\\/)?'],
                [
                  /^(?=[^^])/,
                  function () {
                    return /\/(?!$)/.test(this) ? '^' : '(?:^|\\/)'
                  },
                ],
                [/\\\/\\\*\\\*(?=\\\/|$)/g, (t3, e3, r3) => (e3 + 6 < r3.length ? '(?:\\/[^\\/]+)*' : '\\/.+')],
                [/(^|[^\\]+)(\\\*)+(?=.+)/g, (t3, e3, r3) => e3 + r3.replace(/\\\*/g, '[^\\/]*')],
                [/\\\\\\(?=[$.|*+(){^])/g, () => '\\'],
                [/\\\\/g, () => '\\'],
                [
                  /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
                  (t3, e3, r3, s2, i2) =>
                    '\\' === e3
                      ? `\\[${r3}${((t4) => {
                          let { length: e4 } = t4
                          return t4.slice(0, e4 - (e4 % 2))
                        })(s2)}${i2}`
                      : ']' === i2 && s2.length % 2 == 0
                        ? `[${r3.replace(g, (t4, e4, r4) => (e4.charCodeAt(0) <= r4.charCodeAt(0) ? t4 : ''))}${s2}]`
                        : '[]',
                ],
                [/(?:[^*])$/, (t3) => (/\/$/.test(t3) ? `${t3}$` : `${t3}(?=$|\\/$)`)],
              ],
              f = /(^|\\\/)?\\\*$/,
              $ = 'regex',
              x = 'checkRegex',
              y = {
                [$](t3, e3) {
                  let r3 = e3 ? `${e3}[^/]+` : '[^/]*'
                  return `${r3}(?=$|\\/$)`
                },
                [x](t3, e3) {
                  let r3 = e3 ? `${e3}[^/]*` : '[^/]*'
                  return `${r3}(?=$|\\/$)`
                },
              }
            class C {
              constructor(t3, e3, r3, s2, i2, n2) {
                ;((this.pattern = t3),
                  (this.mark = e3),
                  (this.negative = i2),
                  d(this, 'body', r3),
                  d(this, 'ignoreCase', s2),
                  d(this, 'regexPrefix', n2))
              }
              get regex() {
                let t3 = '_' + $
                return this[t3] ? this[t3] : this._make($, t3)
              }
              get checkRegex() {
                let t3 = '_' + x
                return this[t3] ? this[t3] : this._make(x, t3)
              }
              _make(t3, e3) {
                let r3 = this.regexPrefix.replace(f, y[t3])
                return d(this, e3, this.ignoreCase ? RegExp(r3, 'i') : new RegExp(r3))
              }
            }
            class b {
              constructor(t3) {
                ;((this._ignoreCase = t3), (this._rules = []))
              }
              _add(t3) {
                let e3
                if (t3 && t3[c]) {
                  ;((this._rules = this._rules.concat(t3._rules._rules)), (this._added = true))
                  return
                }
                if (
                  ('string' == typeof t3 && (t3 = { pattern: t3 }),
                  (e3 = t3.pattern) && 'string' == typeof e3 && !s.test(e3) && !i.test(e3) && 0 !== e3.indexOf('#'))
                ) {
                  let e4 = (({ pattern: t4, mark: e5 }, r3) => {
                    let s2,
                      i2 = false,
                      o2 = t4
                    0 === o2.indexOf('!') && ((i2 = true), (o2 = o2.substr(1)))
                    let l2 =
                      ((s2 = o2 = o2.replace(n, '!').replace(h, '#')),
                      _.reduce((t5, [e6, r4]) => t5.replace(e6, r4.bind(s2)), s2))
                    return new C(t4, e5, o2, r3, i2, l2)
                  })(t3, this._ignoreCase)
                  ;((this._added = true), this._rules.push(e4))
                }
              }
              add(t3) {
                return (
                  (this._added = false),
                  e2('string' == typeof t3 ? t3.split(o).filter(Boolean) : t3).forEach(this._add, this),
                  this._added
                )
              }
              test(t3, e3, s2) {
                let i2,
                  n2 = false,
                  h2 = false
                this._rules.forEach((o3) => {
                  let { negative: l2 } = o3
                  ;(h2 !== l2 || n2 === h2) &&
                    (!l2 || n2 || h2 || e3) &&
                    o3[s2].test(t3) &&
                    ((n2 = !l2), (h2 = l2), (i2 = l2 ? r2 : o3))
                })
                let o2 = { ignored: n2, unignored: h2 }
                return (i2 && (o2.rule = i2), o2)
              }
            }
            let v = (t3, e3) => {
                throw new e3(t3)
              },
              m = (t3, e3, r3) =>
                'string' != typeof t3
                  ? r3(`path must be a string, but got \`${e3}\``, TypeError)
                  : t3
                    ? !m.isNotRelative(t3) ||
                      r3(`path should be a \`path.relative()\`d string, but got "${e3}"`, RangeError)
                    : r3('path must not be empty', TypeError),
              k = (t3) => l.test(t3)
            ;((m.isNotRelative = k), (m.convert = (t3) => t3))
            class w {
              constructor({ ignorecase: t3 = true, ignoreCase: e3 = t3, allowRelativePaths: r3 = false } = {}) {
                ;(d(this, c, true), (this._rules = new b(e3)), (this._strictPathCheck = !r3), this._initCache())
              }
              _initCache() {
                ;((this._ignoreCache = /* @__PURE__ */ Object.create(null)),
                  (this._testCache = /* @__PURE__ */ Object.create(null)))
              }
              add(t3) {
                return (this._rules.add(t3) && this._initCache(), this)
              }
              addPattern(t3) {
                return this.add(t3)
              }
              _test(t3, e3, r3, s2) {
                let i2 = t3 && m.convert(t3)
                return (m(i2, t3, this._strictPathCheck ? v : p), this._t(i2, e3, r3, s2))
              }
              checkIgnore(t3) {
                if (!a.test(t3)) return this.test(t3)
                let e3 = t3.split('/').filter(Boolean)
                if ((e3.pop(), e3.length)) {
                  let t4 = this._t(e3.join('/') + '/', this._testCache, true, e3)
                  if (t4.ignored) return t4
                }
                return this._rules.test(t3, false, x)
              }
              _t(t3, e3, r3, s2) {
                if (t3 in e3) return e3[t3]
                if ((s2 || (s2 = t3.split('/').filter(Boolean)), s2.pop(), !s2.length))
                  return (e3[t3] = this._rules.test(t3, r3, $))
                let i2 = this._t(s2.join('/') + '/', e3, r3, s2)
                return (e3[t3] = i2.ignored ? i2 : this._rules.test(t3, r3, $))
              }
              ignores(t3) {
                return this._test(t3, this._ignoreCache, false).ignored
              }
              createFilter() {
                return (t3) => !this.ignores(t3)
              }
              filter(t3) {
                return e2(t3).filter(this.createFilter())
              }
              test(t3) {
                return this._test(t3, this._testCache, true)
              }
            }
            let E = (t3) => new w(t3),
              R = () => {
                m.convert = (t4) =>
                  /^\\\\\?\\/.test(t4) || /["<>|\u0000-\u001F]+/u.test(t4) ? t4 : t4.replace(/\\/g, '/')
                let t3 = /^[a-z]:\//i
                m.isNotRelative = (e3) => t3.test(e3) || k(e3)
              }
            ;('undefined' != typeof process && 'win32' === process.platform && R(),
              (t2.exports = E),
              (E.default = E),
              (t2.exports.isPathValid = (t3) => m(t3 && m.convert(t3), t3, p)),
              d(t2.exports, /* @__PURE__ */ Symbol.for('setupWindows'), R))
          },
        },
        e = {},
        r = (function r2(s) {
          var i = e[s]
          if (void 0 !== i) return i.exports
          var n = (e[s] = { exports: {} })
          return (t[s](n, n.exports, r2), n.exports)
        })('./ignore/index.js')
      module2.exports = r
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js
var require_tags2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js'(exports2, module2) {
    'use strict'
    var GIT_COMMIT_SHA = 'git.commit.sha'
    var GIT_BRANCH = 'git.branch'
    var GIT_REPOSITORY_URL = 'git.repository_url'
    var GIT_TAG = 'git.tag'
    var GIT_COMMIT_MESSAGE = 'git.commit.message'
    var GIT_COMMIT_COMMITTER_DATE = 'git.commit.committer.date'
    var GIT_COMMIT_COMMITTER_EMAIL = 'git.commit.committer.email'
    var GIT_COMMIT_COMMITTER_NAME = 'git.commit.committer.name'
    var GIT_COMMIT_AUTHOR_DATE = 'git.commit.author.date'
    var GIT_COMMIT_AUTHOR_EMAIL = 'git.commit.author.email'
    var GIT_COMMIT_AUTHOR_NAME = 'git.commit.author.name'
    var GIT_COMMIT_HEAD_SHA = 'git.commit.head.sha'
    var GIT_COMMIT_HEAD_MESSAGE = 'git.commit.head.message'
    var GIT_COMMIT_HEAD_AUTHOR_DATE = 'git.commit.head.author.date'
    var GIT_COMMIT_HEAD_AUTHOR_EMAIL = 'git.commit.head.author.email'
    var GIT_COMMIT_HEAD_AUTHOR_NAME = 'git.commit.head.author.name'
    var GIT_COMMIT_HEAD_COMMITTER_DATE = 'git.commit.head.committer.date'
    var GIT_COMMIT_HEAD_COMMITTER_EMAIL = 'git.commit.head.committer.email'
    var GIT_COMMIT_HEAD_COMMITTER_NAME = 'git.commit.head.committer.name'
    var GIT_PULL_REQUEST_BASE_BRANCH_SHA = 'git.pull_request.base_branch_sha'
    var GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA = 'git.pull_request.base_branch_head_sha'
    var GIT_PULL_REQUEST_BASE_BRANCH = 'git.pull_request.base_branch'
    var CI_PIPELINE_ID = 'ci.pipeline.id'
    var CI_PIPELINE_NAME = 'ci.pipeline.name'
    var CI_PIPELINE_NUMBER = 'ci.pipeline.number'
    var CI_PIPELINE_URL = 'ci.pipeline.url'
    var CI_PROVIDER_NAME = 'ci.provider.name'
    var CI_WORKSPACE_PATH = 'ci.workspace_path'
    var CI_JOB_URL = 'ci.job.url'
    var CI_JOB_NAME = 'ci.job.name'
    var CI_JOB_ID = 'ci.job.id'
    var CI_STAGE_NAME = 'ci.stage.name'
    var CI_NODE_NAME = 'ci.node.name'
    var CI_NODE_LABELS = 'ci.node.labels'
    var CI_ENV_VARS = '_dd.ci.env_vars'
    var PR_NUMBER = 'pr.number'
    module2.exports = {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_HEAD_SHA,
      GIT_COMMIT_HEAD_MESSAGE,
      GIT_COMMIT_HEAD_AUTHOR_DATE,
      GIT_COMMIT_HEAD_AUTHOR_EMAIL,
      GIT_COMMIT_HEAD_AUTHOR_NAME,
      GIT_COMMIT_HEAD_COMMITTER_DATE,
      GIT_COMMIT_HEAD_COMMITTER_EMAIL,
      GIT_COMMIT_HEAD_COMMITTER_NAME,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH,
      CI_PIPELINE_ID,
      CI_PIPELINE_NAME,
      CI_PIPELINE_NUMBER,
      CI_PIPELINE_URL,
      CI_PROVIDER_NAME,
      CI_WORKSPACE_PATH,
      CI_JOB_URL,
      CI_JOB_NAME,
      CI_JOB_ID,
      CI_STAGE_NAME,
      CI_ENV_VARS,
      CI_NODE_NAME,
      CI_NODE_LABELS,
      PR_NUMBER,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/telemetry.js
var require_telemetry = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/telemetry.js'(exports2, module2) {
    'use strict'
    var telemetryMetrics = require_metrics()
    var ciVisibilityMetrics = telemetryMetrics.manager.namespace('civisibility')
    var formattedTags = {
      testLevel: 'event_type',
      testFramework: 'test_framework',
      errorType: 'error_type',
      exitCode: 'exit_code',
      isCodeCoverageEnabled: 'coverage_enabled',
      isSuitesSkippingEnabled: 'itrskip_enabled',
      hasCodeOwners: 'has_code_owners',
      isUnsupportedCIProvider: 'is_unsupported_ci',
      isNew: 'is_new',
      isRum: 'is_rum',
      browserDriver: 'browser_driver',
      autoInjected: 'auto_injected',
    }
    function formatMetricTags(tagsDictionary) {
      return Object.keys(tagsDictionary).reduce((acc, tagKey) => {
        if (tagKey === 'statusCode') {
          const statusCode = tagsDictionary[tagKey]
          if (isStatusCode400(statusCode)) {
            acc.push(`status_code:${statusCode}`)
          }
          acc.push(`error_type:${getErrorTypeFromStatusCode(statusCode)}`)
          return acc
        }
        const formattedTagKey = formattedTags[tagKey] || tagKey
        if (tagsDictionary[tagKey] === true) {
          acc.push(formattedTagKey)
        } else if (tagsDictionary[tagKey] !== void 0 && tagsDictionary[tagKey] !== null) {
          acc.push(`${formattedTagKey}:${tagsDictionary[tagKey]}`)
        }
        return acc
      }, [])
    }
    function incrementCountMetric(name, tags = {}, value = 1) {
      ciVisibilityMetrics.count(name, formatMetricTags(tags)).inc(value)
    }
    function distributionMetric(name, tags, measure) {
      ciVisibilityMetrics.distribution(name, formatMetricTags(tags)).track(measure)
    }
    var TELEMETRY_TEST_SESSION = 'test_session'
    var TELEMETRY_EVENT_CREATED = 'event_created'
    var TELEMETRY_EVENT_FINISHED = 'event_finished'
    var TELEMETRY_CODE_COVERAGE_STARTED = 'code_coverage_started'
    var TELEMETRY_CODE_COVERAGE_FINISHED = 'code_coverage_finished'
    var TELEMETRY_ITR_SKIPPED = 'itr_skipped'
    var TELEMETRY_ITR_UNSKIPPABLE = 'itr_unskippable'
    var TELEMETRY_ITR_FORCED_TO_RUN = 'itr_forced_run'
    var TELEMETRY_CODE_COVERAGE_EMPTY = 'code_coverage.is_empty'
    var TELEMETRY_CODE_COVERAGE_NUM_FILES = 'code_coverage.files'
    var TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION = 'events_enqueued_for_serialization'
    var TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS = 'endpoint_payload.events_serialization_ms'
    var TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS = 'endpoint_payload.requests'
    var TELEMETRY_ENDPOINT_PAYLOAD_BYTES = 'endpoint_payload.bytes'
    var TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT = 'endpoint_payload.events_count'
    var TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS = 'endpoint_payload.requests_ms'
    var TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS = 'endpoint_payload.requests_errors'
    var TELEMETRY_ENDPOINT_PAYLOAD_DROPPED = 'endpoint_payload.dropped'
    var TELEMETRY_GIT_COMMAND = 'git.command'
    var TELEMETRY_GIT_COMMAND_MS = 'git.command_ms'
    var TELEMETRY_GIT_COMMAND_ERRORS = 'git.command_errors'
    var TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS = 'git_requests.search_commits'
    var TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS = 'git_requests.search_commits_ms'
    var TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS = 'git_requests.search_commits_errors'
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES = 'git_requests.objects_pack'
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS = 'git_requests.objects_pack_ms'
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS = 'git_requests.objects_pack_errors'
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM = 'git_requests.objects_pack_files'
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES = 'git_requests.objects_pack_bytes'
    var TELEMETRY_GIT_REQUESTS_SETTINGS = 'git_requests.settings'
    var TELEMETRY_GIT_REQUESTS_SETTINGS_MS = 'git_requests.settings_ms'
    var TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS = 'git_requests.settings_errors'
    var TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE = 'git_requests.settings_response'
    var TELEMETRY_GIT_SHA_MATCH = 'git.commit_sha_match'
    var TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY = 'git.commit_sha_discrepancy'
    var TELEMETRY_ITR_SKIPPABLE_TESTS = 'itr_skippable_tests.request'
    var TELEMETRY_ITR_SKIPPABLE_TESTS_MS = 'itr_skippable_tests.request_ms'
    var TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS = 'itr_skippable_tests.request_errors'
    var TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES = 'itr_skippable_tests.response_suites'
    var TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS = 'itr_skippable_tests.response_tests'
    var TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES = 'itr_skippable_tests.response_bytes'
    var TELEMETRY_KNOWN_TESTS = 'early_flake_detection.request'
    var TELEMETRY_KNOWN_TESTS_MS = 'early_flake_detection.request_ms'
    var TELEMETRY_KNOWN_TESTS_ERRORS = 'early_flake_detection.request_errors'
    var TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS = 'early_flake_detection.response_tests'
    var TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES = 'early_flake_detection.response_bytes'
    function isStatusCode400(statusCode) {
      return statusCode >= 400 && statusCode < 500
    }
    function getErrorTypeFromStatusCode(statusCode) {
      if (statusCode >= 400 && statusCode < 500) {
        return 'status_code_4xx_response'
      }
      if (statusCode >= 500) {
        return 'status_code_5xx_response'
      }
      return 'network'
    }
    module2.exports = {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_TEST_SESSION,
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_SKIPPED,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION,
      TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS,
      TELEMETRY_ENDPOINT_PAYLOAD_BYTES,
      TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
      TELEMETRY_ENDPOINT_PAYLOAD_DROPPED,
      TELEMETRY_GIT_COMMAND,
      TELEMETRY_GIT_COMMAND_MS,
      TELEMETRY_GIT_COMMAND_ERRORS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS,
      TELEMETRY_GIT_REQUESTS_SETTINGS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_MS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE,
      TELEMETRY_GIT_SHA_MATCH,
      TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY,
      TELEMETRY_ITR_SKIPPABLE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_MS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES,
      TELEMETRY_KNOWN_TESTS,
      TELEMETRY_KNOWN_TESTS_MS,
      TELEMETRY_KNOWN_TESTS_ERRORS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/url.js
var require_url = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/url.js'(exports2, module2) {
    'use strict'
    var { URL: URL2 } = require('url')
    var HTTP2_HEADER_AUTHORITY = ':authority'
    var HTTP2_HEADER_SCHEME = ':scheme'
    var HTTP2_HEADER_PATH = ':path'
    var PATH_REGEX = /^(?:[a-z]+:\/\/(?:[^?/]+))?(?<path>\/[^?]*)(?:(\?).*)?$/
    var INT_SEGMENT = /^[1-9][0-9]+$/
    var INT_ID_SEGMENT = /^(?=.*[0-9].*)[0-9._-]{3,}$/
    var HEX_SEGMENT = /^(?=.*[0-9].*)[A-Fa-f0-9]{6,}$/
    var HEX_ID_SEGMENT = /^(?=.*[0-9].*)[A-Fa-f0-9._-]{6,}$/
    var STRING_SEGMENT = /^.{20,}|.*[%&'()*+,:=@].*$/
    function extractURL(req) {
      const headers = req.headers
      if (req.stream) {
        return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`
      }
      const protocol = getProtocol(req)
      return `${protocol}://${req.headers.host}${req.originalUrl || req.url}`
    }
    function getProtocol(req) {
      return req.socket?.encrypted || req.connection?.encrypted ? 'https' : 'http'
    }
    function obfuscateQs(config, url) {
      const { queryStringObfuscation } = config
      if (queryStringObfuscation === false) return url
      const i = url.indexOf('?')
      if (i === -1) return url
      const path = url.slice(0, i)
      if (queryStringObfuscation === true) return path
      let qs = url.slice(i + 1)
      qs = qs.replace(queryStringObfuscation, '<redacted>')
      return `${path}?${qs}`
    }
    function extractPathFromUrl(url) {
      if (!url) return '/'
      const match = url.match(PATH_REGEX)
      return match?.groups?.path || '/'
    }
    function calculateHttpEndpoint(url) {
      const path = extractPathFromUrl(url)
      const elements = path.split('/').filter(Boolean)
      const limitedElements = elements.slice(0, 8)
      const normalizedElements = limitedElements.map((element) => {
        if (INT_SEGMENT.test(element)) return '{param:int}'
        if (INT_ID_SEGMENT.test(element)) return '{param:int_id}'
        if (HEX_SEGMENT.test(element)) return '{param:hex}'
        if (HEX_ID_SEGMENT.test(element)) return '{param:hex_id}'
        if (STRING_SEGMENT.test(element)) return '{param:str}'
        return element
      })
      const endpoint = normalizedElements.length > 0 ? '/' + normalizedElements.join('/') : '/'
      return endpoint
    }
    function filterSensitiveInfoFromRepository(repositoryUrl) {
      if (!repositoryUrl) {
        return ''
      }
      if (repositoryUrl.startsWith('git@')) {
        return repositoryUrl
      }
      if (repositoryUrl.startsWith('ssh://')) {
        const sshRegex = /^(ssh:\/\/)[^@/]*@/
        return repositoryUrl.replace(sshRegex, '$1')
      }
      try {
        const { protocol, host, pathname } = new URL2(repositoryUrl)
        return `${protocol}//${host}${pathname === '/' ? '' : pathname}`
      } catch {
        return ''
      }
    }
    module2.exports = {
      extractURL,
      obfuscateQs,
      calculateHttpEndpoint,
      filterSensitiveInfoFromRepository,
      extractPathFromUrl,
      // test only
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/git-cache.js
var require_git_cache = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/git-cache.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var path = require('path')
    var fs = require('fs')
    var crypto = require('crypto')
    var cp = require('child_process')
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var { isTrue } = require_util()
    var isGitEnabled = isTrue(getEnvironmentVariable('DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_ENABLED'))
    var GIT_CACHE_DIR =
      getEnvironmentVariable('DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_DIR') || path.join(os.tmpdir(), 'dd-trace-git-cache')
    function ensureCacheDir() {
      if (!isGitEnabled) return false
      try {
        if (fs.existsSync(GIT_CACHE_DIR)) {
          const stats = fs.statSync(GIT_CACHE_DIR)
          if (!stats.isDirectory()) {
            throw new Error(`Cache directory path exists but is not a directory: ${GIT_CACHE_DIR}`)
          }
        } else {
          fs.mkdirSync(GIT_CACHE_DIR, { recursive: true })
        }
        return true
      } catch (err) {
        log.error('Failed to create git cache directory, disabling cache', err)
        isGitEnabled = false
        return false
      }
    }
    ensureCacheDir()
    function getCacheKey(cmd, flags) {
      const commandString = `${cmd} ${flags.join(' ')}`
      return crypto.createHash('sha256').update(commandString).digest('hex')
    }
    function getCacheFilePath(cacheKey) {
      return path.join(GIT_CACHE_DIR, `${cacheKey}.cache`)
    }
    function getCache(cacheKey) {
      if (!isGitEnabled) return null
      try {
        const cacheFilePath = getCacheFilePath(cacheKey)
        if (!fs.existsSync(cacheFilePath)) {
          return null
        }
        const content = fs.readFileSync(cacheFilePath, 'utf8')
        return content
      } catch (err) {
        log.error('Failed to read git cache', err)
        return null
      }
    }
    function setCache(cacheKey, result) {
      if (!isGitEnabled) return
      if (!ensureCacheDir()) return
      try {
        const cacheFilePath = getCacheFilePath(cacheKey)
        fs.writeFileSync(cacheFilePath, result, 'utf8')
      } catch (err) {
        log.error('Failed to write git cache', err)
      }
    }
    function cachedExec(cmd, flags, options) {
      if (options === void 0) {
        options = { stdio: 'pipe' }
      }
      if (!isGitEnabled) {
        return cp.execFileSync(cmd, flags, options)
      }
      const cacheKey = getCacheKey(cmd, flags)
      const cachedResult = getCache(cacheKey)
      if (cachedResult !== null) {
        if (cachedResult.startsWith('__GIT_COMMAND_FAILED__')) {
          let error
          try {
            const errorData = cachedResult.replace('__GIT_COMMAND_FAILED__', '')
            const { message, code, status, errno } = JSON.parse(errorData)
            error = new Error(message)
            error.code = code
            error.status = status
            error.errno = errno
          } catch {
            throw new Error('Git command failed')
          }
          throw error
        }
        return cachedResult
      }
      try {
        const result = cp.execFileSync(cmd, flags, options)
        setCache(cacheKey, result)
        return result
      } catch (err) {
        const cacheValue =
          '__GIT_COMMAND_FAILED__' +
          JSON.stringify({
            code: err.code,
            status: err.status,
            errno: err.errno,
            message: err.message,
          })
        setCache(cacheKey, cacheValue)
        throw err
      }
    }
    module2.exports = {
      getCacheKey,
      getCacheFilePath,
      cachedExec,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js
var require_git = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var path = require('path')
    var fs = require('fs')
    var log = require_log2()
    var {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      CI_WORKSPACE_PATH,
      GIT_COMMIT_HEAD_AUTHOR_DATE,
      GIT_COMMIT_HEAD_AUTHOR_EMAIL,
      GIT_COMMIT_HEAD_AUTHOR_NAME,
      GIT_COMMIT_HEAD_COMMITTER_DATE,
      GIT_COMMIT_HEAD_COMMITTER_EMAIL,
      GIT_COMMIT_HEAD_COMMITTER_NAME,
      GIT_COMMIT_HEAD_MESSAGE,
    } = require_tags2()
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_GIT_COMMAND,
      TELEMETRY_GIT_COMMAND_MS,
      TELEMETRY_GIT_COMMAND_ERRORS,
    } = require_telemetry()
    var { filterSensitiveInfoFromRepository } = require_url()
    var { storage } = require_datadog_core()
    var { cachedExec } = require_git_cache()
    var GIT_REV_LIST_MAX_BUFFER = 12 * 1024 * 1024
    function sanitizedExec(cmd, flags, operationMetric, durationMetric, errorMetric, shouldTrim = true) {
      const store = storage('legacy').getStore()
      storage('legacy').enterWith({ noop: true })
      let startTime
      if (operationMetric) {
        incrementCountMetric(operationMetric.name, operationMetric.tags)
      }
      if (durationMetric) {
        startTime = Date.now()
      }
      try {
        let result = cachedExec(cmd, flags, { stdio: 'pipe' }).toString()
        if (shouldTrim) {
          result = result.replaceAll(/(\r\n|\n|\r)/gm, '')
        }
        if (durationMetric) {
          distributionMetric(durationMetric.name, durationMetric.tags, Date.now() - startTime)
        }
        return result
      } catch (err) {
        if (errorMetric) {
          incrementCountMetric(errorMetric.name, {
            ...errorMetric.tags,
            errorType: err.code,
            exitCode: err.status || err.errno,
          })
        }
        log.error('Git plugin error executing command', err)
        return ''
      } finally {
        storage('legacy').enterWith(store)
      }
    }
    function isDirectory(path2) {
      try {
        const stats = fs.statSync(path2)
        return stats.isDirectory()
      } catch {
        return false
      }
    }
    function isGitAvailable() {
      const isWindows = os.platform() === 'win32'
      const command = isWindows ? 'where' : 'which'
      try {
        cachedExec(command, ['git'])
        return true
      } catch {
        incrementCountMetric(TELEMETRY_GIT_COMMAND_ERRORS, { command: 'check_git', exitCode: 'missing' })
        return false
      }
    }
    function isShallowRepository() {
      return (
        sanitizedExec(
          'git',
          ['rev-parse', '--is-shallow-repository'],
          { name: TELEMETRY_GIT_COMMAND, tags: { command: 'check_shallow' } },
          { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'check_shallow' } },
          { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'check_shallow' } }
        ) === 'true'
      )
    }
    function getGitVersion() {
      const gitVersionString = sanitizedExec('git', ['version'])
      const gitVersionMatches =
        /** @type {RegExpMatchArray} */
        gitVersionString.match(/git version (\d+)\.(\d+)\.(\d+)/)
      try {
        return {
          major: Number.parseInt(gitVersionMatches[1]),
          minor: Number.parseInt(gitVersionMatches[2]),
          patch: Number.parseInt(gitVersionMatches[3]),
        }
      } catch {
        return null
      }
    }
    function unshallowRepository(parentOnly = false) {
      const gitVersion = getGitVersion()
      if (!gitVersion) {
        log.warn('Git version could not be extracted, so git unshallow will not proceed')
        return
      }
      if (gitVersion.major < 2 || (gitVersion.major === 2 && gitVersion.minor < 27)) {
        log.warn('Git version is <2.27, so git unshallow will not proceed')
        return
      }
      const defaultRemoteName = sanitizedExec('git', [
        'config',
        '--default',
        'origin',
        '--get',
        'clone.defaultRemoteName',
      ])
      const revParseHead = sanitizedExec('git', ['rev-parse', 'HEAD'])
      const baseGitOptions = [
        'fetch',
        parentOnly ? '--deepen=1' : '--shallow-since="1 month ago"',
        '--update-shallow',
        '--filter=blob:none',
        '--recurse-submodules=no',
        defaultRemoteName,
      ]
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: 'unshallow' })
      const start = Date.now()
      let flags = [...baseGitOptions, revParseHead]
      try {
        cachedExec('git', flags)
      } catch (err) {
        log.warn(`Git unshallow failed: ${flags.join(' ')}`)
        incrementCountMetric(TELEMETRY_GIT_COMMAND_ERRORS, {
          command: 'unshallow',
          errorType: err.code,
          exitCode: err.status || err.errno,
        })
        const upstreamRemote = sanitizedExec('git', [
          'rev-parse',
          '--abbrev-ref',
          '--symbolic-full-name',
          '@{upstream}',
        ])
        flags = [...baseGitOptions, upstreamRemote]
        try {
          cachedExec('git', flags)
        } catch (err2) {
          log.warn(`Git unshallow failed again: ${flags.join(' ')}`)
          incrementCountMetric(TELEMETRY_GIT_COMMAND_ERRORS, {
            command: 'unshallow',
            errorType: err2.code,
            exitCode: err2.status || err2.errno,
          })
          sanitizedExec(
            'git',
            baseGitOptions,
            null,
            null,
            { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'unshallow' } }
            // we log the error in sanitizedExec
          )
        }
      }
      distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: 'unshallow' }, Date.now() - start)
    }
    function getRepositoryUrl() {
      return sanitizedExec(
        'git',
        ['config', '--get', 'remote.origin.url'],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_repository' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_repository' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_repository' } }
      )
    }
    function getLatestCommits() {
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: 'get_local_commits' })
      const startTime = Date.now()
      try {
        const result = cachedExec('git', ['log', '--format=%H', '-n 1000', '--since="1 month ago"'])
          .toString()
          .split('\n')
          .filter(Boolean)
        distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: 'get_local_commits' }, Date.now() - startTime)
        return result
      } catch (err) {
        log.error('Get latest commits failed: %s', err.message)
        incrementCountMetric(TELEMETRY_GIT_COMMAND_ERRORS, { command: 'get_local_commits', errorType: err.status })
        return []
      }
    }
    function getGitDiff(baseCommit, targetCommit) {
      const flags = ['diff', '-U0', '--word-diff=porcelain', baseCommit]
      if (targetCommit) {
        flags.push(targetCommit)
      }
      return sanitizedExec(
        'git',
        flags,
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'diff' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'diff' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'diff' } },
        false
        // important not to trim or we'll lose the line breaks which we need to detect impacted tests
      )
    }
    function getGitRemoteName() {
      const upstreamRemote = sanitizedExec(
        'git',
        ['rev-parse', '--abbrev-ref', '--symbolic-full-name', '@{upstream}'],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_remote_name' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_remote_name' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_remote_name' } }
      )
      if (upstreamRemote) {
        return upstreamRemote.split('/')[0]
      }
      const remotes = sanitizedExec(
        'git',
        ['remote'],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_remote_name' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_remote_name' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_remote_name' } },
        false
      )
      return remotes.split('\n')[0] || 'origin'
    }
    function getSourceBranch() {
      return sanitizedExec(
        'git',
        ['rev-parse', '--abbrev-ref', 'HEAD'],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_source_branch' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_source_branch' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_source_branch' } }
      )
    }
    function checkAndFetchBranch(branch, remoteName) {
      try {
        cachedExec('git', ['show-ref', '--verify', '--quiet', `refs/remotes/${remoteName}/${branch}`])
      } catch {
        try {
          const remoteHeads = cachedExec('git', ['ls-remote', '--heads', remoteName, branch], {
            stdio: 'pipe',
            timeout: 2e3,
          })
          if (remoteHeads) {
            cachedExec('git', ['fetch', '--depth', '1', remoteName, branch], { stdio: 'pipe', timeout: 5e3 })
          }
        } catch (err) {
          log.debug('Git plugin error checking and fetching branch', err)
        }
      }
    }
    function getLocalBranches(remoteName) {
      const localBranches = sanitizedExec(
        'git',
        ['for-each-ref', '--format=%(refname:short)', `refs/remotes/${remoteName}`],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_local_branches' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_local_branches' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_local_branches' } },
        false
      )
      try {
        return localBranches.split('\n').filter(Boolean)
      } catch {
        return []
      }
    }
    function getMergeBase(baseBranch, sourceBranch) {
      return sanitizedExec(
        'git',
        ['merge-base', baseBranch, sourceBranch],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_merge_base' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_merge_base' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_merge_base' } }
      )
    }
    function getCounts(sourceBranch, candidateBranch) {
      const counts = sanitizedExec(
        'git',
        ['rev-list', '--left-right', '--count', `${candidateBranch}...${sourceBranch}`],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_counts' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_counts' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_counts' } }
      )
      try {
        if (!counts) {
          return { behind: null, ahead: null }
        }
        const [behind, ahead] = counts.split(/\s+/).map(Number)
        return { behind, ahead }
      } catch {
        return { behind: null, ahead: null }
      }
    }
    function getCommitsRevList(commitsToExclude, commitsToInclude) {
      let result = null
      const commitsToExcludeString = commitsToExclude.map((commit) => `^${commit}`)
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: 'get_objects' })
      const startTime = Date.now()
      try {
        result = cachedExec(
          'git',
          [
            'rev-list',
            '--objects',
            '--no-object-names',
            '--filter=blob:none',
            '--since="1 month ago"',
            ...commitsToExcludeString,
            ...commitsToInclude,
          ],
          { stdio: 'pipe', maxBuffer: GIT_REV_LIST_MAX_BUFFER }
        )
          .toString()
          .split('\n')
          .filter(Boolean)
      } catch (err) {
        log.error('Get commits to upload failed: %s', err.message)
        incrementCountMetric(
          TELEMETRY_GIT_COMMAND_ERRORS,
          { command: 'get_objects', errorType: err.code, exitCode: err.status || err.errno }
          // err.status might be null
        )
      }
      distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: 'get_objects' }, Date.now() - startTime)
      return result
    }
    function generatePackFilesForCommits(commitsToUpload) {
      let result = []
      const tmpFolder = os.tmpdir()
      if (!isDirectory(tmpFolder)) {
        log.error(new Error('Provided path to generate packfiles is not a directory'))
        return []
      }
      const randomPrefix = String(Math.floor(Math.random() * 1e4))
      const temporaryPath = path.join(tmpFolder, randomPrefix)
      const cwdPath = path.join(process.cwd(), randomPrefix)
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: 'pack_objects' })
      const startTime = Date.now()
      function execGitPackObjects(targetPath) {
        return cachedExec('git', ['pack-objects', '--compression=9', '--max-pack-size=3m', targetPath], {
          stdio: 'pipe',
          input: commitsToUpload.join('\n'),
        })
          .toString()
          .split('\n')
          .filter(Boolean)
          .map((commit) => `${targetPath}-${commit}.pack`)
      }
      try {
        result = execGitPackObjects(temporaryPath)
      } catch (err) {
        log.error('Git plugin error executing git pack-objects command', err)
        incrementCountMetric(TELEMETRY_GIT_COMMAND_ERRORS, {
          command: 'pack_objects',
          exitCode: err.status || err.errno,
          errorType: err.code,
        })
        try {
          result = execGitPackObjects(cwdPath)
        } catch (err2) {
          log.error('Git plugin error executing fallback git pack-objects command', err2)
          incrementCountMetric(TELEMETRY_GIT_COMMAND_ERRORS, {
            command: 'pack_objects',
            exitCode: err2.status || err2.errno,
            errorType: err2.code,
          })
        }
      }
      distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: 'pack_objects' }, Date.now() - startTime)
      return result
    }
    function getRepositoryRoot() {
      return sanitizedExec('git', ['rev-parse', '--show-toplevel'])
    }
    function getGitMetadata(ciMetadata) {
      const {
        commitSHA,
        branch,
        repositoryUrl,
        tag,
        commitMessage,
        authorName: ciAuthorName,
        authorEmail: ciAuthorEmail,
        ciWorkspacePath,
        headCommitSha,
      } = ciMetadata
      const [authorName, authorEmail, authorDate, committerName, committerEmail, committerDate] = sanitizedExec('git', [
        'show',
        '-s',
        '--format=%an,%ae,%aI,%cn,%ce,%cI',
      ]).split(',')
      const tags = {
        [GIT_COMMIT_MESSAGE]:
          commitMessage || sanitizedExec('git', ['show', '-s', '--format=%B'], null, null, null, false),
        [GIT_BRANCH]: branch || sanitizedExec('git', ['rev-parse', '--abbrev-ref', 'HEAD']),
        [GIT_COMMIT_SHA]: commitSHA || sanitizedExec('git', ['rev-parse', 'HEAD']),
        [CI_WORKSPACE_PATH]: ciWorkspacePath || getRepositoryRoot(),
      }
      if (headCommitSha) {
        if (isShallowRepository()) {
          fetchHeadCommitSha(headCommitSha)
        }
        const [
          gitHeadCommitSha,
          headAuthorDate,
          headAuthorName,
          headAuthorEmail,
          headCommitterDate,
          headCommitterName,
          headCommitterEmail,
          headCommitMessage,
        ] = sanitizedExec(
          'git',
          ['show', '-s', `--format='%H","%aI","%an","%ae","%cI","%cn","%ce","%B'`, headCommitSha],
          null,
          null,
          null,
          false
        ).split('","')
        if (gitHeadCommitSha) {
          tags[GIT_COMMIT_HEAD_AUTHOR_DATE] = headAuthorDate
          tags[GIT_COMMIT_HEAD_AUTHOR_EMAIL] = headAuthorEmail
          tags[GIT_COMMIT_HEAD_AUTHOR_NAME] = headAuthorName
          tags[GIT_COMMIT_HEAD_COMMITTER_DATE] = headCommitterDate
          tags[GIT_COMMIT_HEAD_COMMITTER_EMAIL] = headCommitterEmail
          tags[GIT_COMMIT_HEAD_COMMITTER_NAME] = headCommitterName
          tags[GIT_COMMIT_HEAD_MESSAGE] = headCommitMessage
        }
      }
      const entries = [
        GIT_REPOSITORY_URL,
        filterSensitiveInfoFromRepository(repositoryUrl || sanitizedExec('git', ['ls-remote', '--get-url'])),
        GIT_COMMIT_AUTHOR_DATE,
        authorDate,
        GIT_COMMIT_AUTHOR_NAME,
        ciAuthorName || authorName,
        GIT_COMMIT_AUTHOR_EMAIL,
        ciAuthorEmail || authorEmail,
        GIT_COMMIT_COMMITTER_DATE,
        committerDate,
        GIT_COMMIT_COMMITTER_NAME,
        committerName,
        GIT_COMMIT_COMMITTER_EMAIL,
        committerEmail,
        GIT_TAG,
        tag,
      ]
      for (let i = 0; i < entries.length; i += 2) {
        const value = entries[i + 1]
        if (value) {
          tags[entries[i]] = value
        }
      }
      return tags
    }
    function getGitInformationDiscrepancy() {
      const gitRepositoryUrl = getRepositoryUrl()
      const gitCommitSHA = sanitizedExec(
        'git',
        ['rev-parse', 'HEAD'],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'get_commit_sha' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'get_commit_sha' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'get_commit_sha' } }
      )
      return { gitRepositoryUrl, gitCommitSHA }
    }
    function fetchHeadCommitSha(headSha) {
      const remoteName = getGitRemoteName()
      sanitizedExec(
        'git',
        [
          'fetch',
          '--update-shallow',
          '--filter=blob:none',
          '--recurse-submodules=no',
          '--no-write-fetch-head',
          remoteName,
          headSha,
        ],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: 'fetch_head_commit_sha' } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: 'fetch_head_commit_sha' } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: 'fetch_head_commit_sha' } }
      )
    }
    module2.exports = {
      getGitMetadata,
      getLatestCommits,
      getRepositoryUrl,
      generatePackFilesForCommits,
      getCommitsRevList,
      GIT_REV_LIST_MAX_BUFFER,
      isShallowRepository,
      unshallowRepository,
      isGitAvailable,
      getGitInformationDiscrepancy,
      getGitDiff,
      getGitRemoteName,
      getSourceBranch,
      checkAndFetchBranch,
      getLocalBranches,
      getMergeBase,
      getCounts,
      fetchHeadCommitSha,
      getRepositoryRoot,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js
var require_ci = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js'(exports2, module2) {
    'use strict'
    var { readFileSync } = require('fs')
    var {
      GIT_BRANCH,
      GIT_COMMIT_SHA,
      GIT_TAG,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_HEAD_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH,
      GIT_REPOSITORY_URL,
      CI_PIPELINE_ID,
      CI_PIPELINE_NAME,
      CI_PIPELINE_NUMBER,
      CI_PIPELINE_URL,
      CI_PROVIDER_NAME,
      CI_WORKSPACE_PATH,
      CI_JOB_URL,
      CI_JOB_NAME,
      CI_STAGE_NAME,
      CI_ENV_VARS,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_COMMITTER_EMAIL,
      CI_NODE_LABELS,
      CI_NODE_NAME,
      PR_NUMBER,
      CI_JOB_ID,
      GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA,
    } = require_tags2()
    var { filterSensitiveInfoFromRepository } = require_url()
    var { getEnvironmentVariable, getEnvironmentVariables } = require_config_helper()
    function parseEmailAndName(emailAndName) {
      if (!emailAndName) {
        return { name: '', email: '' }
      }
      let name = ''
      let email = ''
      const matchNameAndEmail = emailAndName.match(/(?:"?([^"]*)"?\s)?(?:<?(.+@[^>]+)>?)/)
      if (matchNameAndEmail) {
        name = matchNameAndEmail[1]
        email = matchNameAndEmail[2]
      }
      return { name, email }
    }
    function removeEmptyValues(tags) {
      return Object.keys(tags).reduce((filteredTags, tag) => {
        if (!tags[tag]) {
          return filteredTags
        }
        return {
          ...filteredTags,
          [tag]: tags[tag],
        }
      }, {})
    }
    function normalizeTag(targetTags, tagKey, normalize) {
      if (targetTags[tagKey]) {
        targetTags[tagKey] = normalize(targetTags[tagKey])
      }
    }
    function normalizeRef(ref) {
      if (!ref) {
        return ref
      }
      return ref.replaceAll(/origin\/|refs\/heads\/|tags\//gm, '')
    }
    function resolveTilde(filePath) {
      if (!filePath || typeof filePath !== 'string') {
        return ''
      }
      if (filePath[0] === '~' && (filePath[1] === '/' || filePath.length === 1)) {
        return filePath.replace('~', getEnvironmentVariable('HOME'))
      }
      return filePath
    }
    function normalizeNumber(number) {
      if (typeof number !== 'number') {
        return number
      }
      return number.toString()
    }
    function getGitHubEventPayload() {
      const path = getEnvironmentVariable('GITHUB_EVENT_PATH')
      if (!path) {
        return
      }
      return JSON.parse(readFileSync(path, 'utf8'))
    }
    module2.exports = {
      normalizeRef,
      getCIMetadata() {
        const env = getEnvironmentVariables()
        let tags = {}
        if (env.JENKINS_URL) {
          const {
            WORKSPACE,
            BUILD_TAG,
            JOB_NAME,
            BUILD_NUMBER,
            BUILD_URL,
            GIT_BRANCH: JENKINS_GIT_BRANCH,
            GIT_COMMIT: JENKINS_GIT_COMMIT,
            GIT_URL: JENKINS_GIT_REPOSITORY_URL,
            GIT_URL_1: JENKINS_GIT_REPOSITORY_URL_1,
            DD_CUSTOM_TRACE_ID,
            NODE_NAME,
            NODE_LABELS,
            CHANGE_ID,
            CHANGE_TARGET,
          } = env
          tags = {
            [CI_PIPELINE_ID]: BUILD_TAG,
            [CI_PIPELINE_NUMBER]: BUILD_NUMBER,
            [CI_PIPELINE_URL]: BUILD_URL,
            [CI_PROVIDER_NAME]: 'jenkins',
            [GIT_COMMIT_SHA]: JENKINS_GIT_COMMIT,
            [GIT_REPOSITORY_URL]: JENKINS_GIT_REPOSITORY_URL || JENKINS_GIT_REPOSITORY_URL_1,
            [CI_WORKSPACE_PATH]: WORKSPACE,
            [CI_ENV_VARS]: JSON.stringify({ DD_CUSTOM_TRACE_ID }),
            [CI_NODE_NAME]: NODE_NAME,
            [PR_NUMBER]: CHANGE_ID,
            [GIT_PULL_REQUEST_BASE_BRANCH]: CHANGE_TARGET,
          }
          if (NODE_LABELS) {
            let nodeLabels
            try {
              nodeLabels = JSON.stringify(NODE_LABELS.split(' '))
              tags[CI_NODE_LABELS] = nodeLabels
            } catch {}
          }
          const isTag = JENKINS_GIT_BRANCH && JENKINS_GIT_BRANCH.includes('tags/')
          const refKey = isTag ? GIT_TAG : GIT_BRANCH
          const ref = normalizeRef(JENKINS_GIT_BRANCH)
          tags[refKey] = ref
          if (JOB_NAME) {
            const jobNameAndParams = JOB_NAME.split('/')
            const finalPipelineName =
              jobNameAndParams.length > 1 && jobNameAndParams[1].includes('=')
                ? jobNameAndParams[0]
                : JOB_NAME.replace(`/${ref}`, '')
            tags[CI_PIPELINE_NAME] = finalPipelineName
          }
        }
        if (env.GITLAB_CI) {
          const {
            CI_PIPELINE_ID: GITLAB_PIPELINE_ID,
            CI_PROJECT_PATH,
            CI_PIPELINE_IID,
            CI_PIPELINE_URL: GITLAB_PIPELINE_URL,
            CI_PROJECT_DIR,
            CI_COMMIT_REF_NAME,
            CI_COMMIT_TAG,
            CI_COMMIT_SHA,
            CI_REPOSITORY_URL,
            CI_JOB_URL: GITLAB_CI_JOB_URL,
            CI_JOB_STAGE,
            CI_JOB_NAME: GITLAB_CI_JOB_NAME,
            CI_COMMIT_MESSAGE,
            CI_COMMIT_TIMESTAMP,
            CI_COMMIT_AUTHOR,
            CI_PROJECT_URL: GITLAB_PROJECT_URL,
            CI_JOB_ID: GITLAB_CI_JOB_ID,
            CI_RUNNER_ID,
            CI_RUNNER_TAGS,
            CI_MERGE_REQUEST_TARGET_BRANCH_NAME,
            CI_MERGE_REQUEST_IID,
            CI_MERGE_REQUEST_TARGET_BRANCH_SHA,
            CI_MERGE_REQUEST_DIFF_BASE_SHA,
          } = env
          const { name, email } = parseEmailAndName(CI_COMMIT_AUTHOR)
          tags = {
            [CI_PIPELINE_ID]: GITLAB_PIPELINE_ID,
            [CI_PIPELINE_NAME]: CI_PROJECT_PATH,
            [CI_PIPELINE_NUMBER]: CI_PIPELINE_IID,
            [CI_PROVIDER_NAME]: 'gitlab',
            [GIT_COMMIT_SHA]: CI_COMMIT_SHA,
            [GIT_REPOSITORY_URL]: CI_REPOSITORY_URL,
            [CI_JOB_URL]: GITLAB_CI_JOB_URL,
            [GIT_TAG]: CI_COMMIT_TAG,
            [GIT_BRANCH]: CI_COMMIT_REF_NAME,
            [CI_WORKSPACE_PATH]: CI_PROJECT_DIR,
            [CI_PIPELINE_URL]: GITLAB_PIPELINE_URL,
            [CI_STAGE_NAME]: CI_JOB_STAGE,
            [CI_JOB_NAME]: GITLAB_CI_JOB_NAME,
            [GIT_COMMIT_MESSAGE]: CI_COMMIT_MESSAGE,
            [GIT_COMMIT_AUTHOR_NAME]: name,
            [GIT_COMMIT_AUTHOR_EMAIL]: email,
            [GIT_COMMIT_AUTHOR_DATE]: CI_COMMIT_TIMESTAMP,
            [CI_ENV_VARS]: JSON.stringify({
              CI_PROJECT_URL: GITLAB_PROJECT_URL,
              CI_PIPELINE_ID: GITLAB_PIPELINE_ID,
              CI_JOB_ID: GITLAB_CI_JOB_ID,
            }),
            [CI_NODE_LABELS]: CI_RUNNER_TAGS,
            [CI_NODE_NAME]: CI_RUNNER_ID,
            [GIT_PULL_REQUEST_BASE_BRANCH]: CI_MERGE_REQUEST_TARGET_BRANCH_NAME,
            [PR_NUMBER]: CI_MERGE_REQUEST_IID,
            [CI_JOB_ID]: GITLAB_CI_JOB_ID,
            [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: CI_MERGE_REQUEST_DIFF_BASE_SHA,
            [GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA]: CI_MERGE_REQUEST_TARGET_BRANCH_SHA,
          }
        }
        if (env.CIRCLECI) {
          const {
            CIRCLE_WORKFLOW_ID,
            CIRCLE_PROJECT_REPONAME,
            CIRCLE_BUILD_URL,
            CIRCLE_WORKING_DIRECTORY,
            CIRCLE_BRANCH,
            CIRCLE_TAG,
            CIRCLE_SHA1,
            CIRCLE_REPOSITORY_URL,
            CIRCLE_JOB,
            CIRCLE_BUILD_NUM,
            CIRCLE_PR_NUMBER,
          } = env
          const pipelineUrl = `https://app.circleci.com/pipelines/workflows/${CIRCLE_WORKFLOW_ID}`
          tags = {
            [CI_PIPELINE_ID]: CIRCLE_WORKFLOW_ID,
            [CI_PIPELINE_NAME]: CIRCLE_PROJECT_REPONAME,
            [CI_PIPELINE_URL]: pipelineUrl,
            [CI_JOB_NAME]: CIRCLE_JOB,
            [CI_PROVIDER_NAME]: 'circleci',
            [GIT_COMMIT_SHA]: CIRCLE_SHA1,
            [GIT_REPOSITORY_URL]: CIRCLE_REPOSITORY_URL,
            [CI_JOB_URL]: CIRCLE_BUILD_URL,
            [CI_WORKSPACE_PATH]: CIRCLE_WORKING_DIRECTORY,
            [GIT_TAG]: CIRCLE_TAG,
            [GIT_BRANCH]: CIRCLE_BRANCH,
            [CI_ENV_VARS]: JSON.stringify({
              CIRCLE_WORKFLOW_ID,
              CIRCLE_BUILD_NUM,
            }),
            [PR_NUMBER]: CIRCLE_PR_NUMBER,
            [CI_JOB_ID]: CIRCLE_BUILD_NUM,
          }
        }
        if (env.GITHUB_ACTIONS || env.GITHUB_ACTION) {
          const {
            GITHUB_RUN_ID,
            GITHUB_WORKFLOW,
            GITHUB_RUN_NUMBER,
            GITHUB_WORKSPACE,
            GITHUB_HEAD_REF,
            GITHUB_REF,
            GITHUB_SHA,
            GITHUB_REPOSITORY,
            GITHUB_SERVER_URL,
            GITHUB_RUN_ATTEMPT,
            GITHUB_JOB,
            GITHUB_BASE_REF,
          } = env
          const repositoryURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git`
          let pipelineURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`
          if (GITHUB_RUN_ATTEMPT) {
            pipelineURL = `${pipelineURL}/attempts/${GITHUB_RUN_ATTEMPT}`
          }
          const jobUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks`
          const ref = GITHUB_HEAD_REF || GITHUB_REF || ''
          const refKey = ref.includes('tags/') ? GIT_TAG : GIT_BRANCH
          tags = {
            [CI_PIPELINE_ID]: GITHUB_RUN_ID,
            [CI_PIPELINE_NAME]: GITHUB_WORKFLOW,
            [CI_PIPELINE_NUMBER]: GITHUB_RUN_NUMBER,
            [CI_PIPELINE_URL]: filterSensitiveInfoFromRepository(pipelineURL),
            [CI_PROVIDER_NAME]: 'github',
            [GIT_COMMIT_SHA]: GITHUB_SHA,
            [GIT_REPOSITORY_URL]: repositoryURL,
            [CI_JOB_URL]: filterSensitiveInfoFromRepository(jobUrl),
            [CI_JOB_NAME]: GITHUB_JOB,
            [CI_WORKSPACE_PATH]: GITHUB_WORKSPACE,
            [refKey]: ref,
            [CI_ENV_VARS]: JSON.stringify({
              GITHUB_SERVER_URL: filterSensitiveInfoFromRepository(GITHUB_SERVER_URL),
              GITHUB_REPOSITORY,
              GITHUB_RUN_ID,
              GITHUB_RUN_ATTEMPT,
            }),
            [CI_JOB_ID]: GITHUB_JOB,
          }
          if (GITHUB_BASE_REF) {
            tags[GIT_PULL_REQUEST_BASE_BRANCH] = GITHUB_BASE_REF
            try {
              const eventContent = getGitHubEventPayload()
              tags[GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA] = eventContent.pull_request.base.sha
              tags[GIT_COMMIT_HEAD_SHA] = eventContent.pull_request.head.sha
            } catch {}
          }
        }
        if (env.APPVEYOR) {
          const {
            APPVEYOR_REPO_NAME,
            APPVEYOR_REPO_PROVIDER,
            APPVEYOR_BUILD_FOLDER,
            APPVEYOR_BUILD_ID,
            APPVEYOR_BUILD_NUMBER,
            APPVEYOR_REPO_COMMIT,
            APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH,
            APPVEYOR_REPO_BRANCH,
            APPVEYOR_REPO_TAG_NAME,
            APPVEYOR_REPO_COMMIT_AUTHOR,
            APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            APPVEYOR_REPO_COMMIT_MESSAGE,
            APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED,
            APPVEYOR_PULL_REQUEST_HEAD_COMMIT,
            APPVEYOR_PULL_REQUEST_NUMBER,
          } = env
          const pipelineUrl = `https://ci.appveyor.com/project/${APPVEYOR_REPO_NAME}/builds/${APPVEYOR_BUILD_ID}`
          tags = {
            [CI_PROVIDER_NAME]: 'appveyor',
            [CI_PIPELINE_URL]: pipelineUrl,
            [CI_PIPELINE_ID]: APPVEYOR_BUILD_ID,
            [CI_PIPELINE_NAME]: APPVEYOR_REPO_NAME,
            [CI_PIPELINE_NUMBER]: APPVEYOR_BUILD_NUMBER,
            [CI_JOB_URL]: pipelineUrl,
            [CI_WORKSPACE_PATH]: APPVEYOR_BUILD_FOLDER,
            [GIT_COMMIT_AUTHOR_NAME]: APPVEYOR_REPO_COMMIT_AUTHOR,
            [GIT_COMMIT_AUTHOR_EMAIL]: APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: APPVEYOR_REPO_COMMIT_MESSAGE + '\n' + APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED,
            [GIT_COMMIT_HEAD_SHA]: APPVEYOR_PULL_REQUEST_HEAD_COMMIT,
            [PR_NUMBER]: APPVEYOR_PULL_REQUEST_NUMBER,
          }
          if (APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH) {
            tags[GIT_PULL_REQUEST_BASE_BRANCH] = APPVEYOR_REPO_BRANCH
          }
          if (APPVEYOR_REPO_PROVIDER === 'github') {
            tags = {
              ...tags,
              [GIT_REPOSITORY_URL]: `https://github.com/${APPVEYOR_REPO_NAME}.git`,
              [GIT_COMMIT_SHA]: APPVEYOR_REPO_COMMIT,
              [GIT_TAG]: APPVEYOR_REPO_TAG_NAME,
              [GIT_BRANCH]: APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || APPVEYOR_REPO_BRANCH,
            }
          }
        }
        if (env.TF_BUILD) {
          const {
            BUILD_SOURCESDIRECTORY,
            BUILD_BUILDID,
            BUILD_DEFINITIONNAME,
            SYSTEM_TEAMFOUNDATIONSERVERURI,
            SYSTEM_TEAMPROJECTID,
            SYSTEM_JOBID,
            SYSTEM_TASKINSTANCEID,
            SYSTEM_PULLREQUEST_SOURCEBRANCH,
            BUILD_SOURCEBRANCH,
            BUILD_SOURCEBRANCHNAME,
            SYSTEM_PULLREQUEST_SOURCECOMMITID,
            SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI,
            BUILD_REPOSITORY_URI,
            BUILD_SOURCEVERSION,
            BUILD_REQUESTEDFORID,
            BUILD_REQUESTEDFOREMAIL,
            BUILD_SOURCEVERSIONMESSAGE,
            SYSTEM_STAGEDISPLAYNAME,
            SYSTEM_JOBDISPLAYNAME,
            SYSTEM_PULLREQUEST_PULLREQUESTNUMBER,
            SYSTEM_PULLREQUEST_TARGETBRANCH,
          } = env
          const ref = SYSTEM_PULLREQUEST_SOURCEBRANCH || BUILD_SOURCEBRANCH || BUILD_SOURCEBRANCHNAME
          const refKey = (ref || '').includes('tags/') ? GIT_TAG : GIT_BRANCH
          tags = {
            [CI_PROVIDER_NAME]: 'azurepipelines',
            [CI_PIPELINE_ID]: BUILD_BUILDID,
            [CI_PIPELINE_NAME]: BUILD_DEFINITIONNAME,
            [CI_PIPELINE_NUMBER]: BUILD_BUILDID,
            [GIT_COMMIT_SHA]: SYSTEM_PULLREQUEST_SOURCECOMMITID || BUILD_SOURCEVERSION,
            [CI_WORKSPACE_PATH]: BUILD_SOURCESDIRECTORY,
            [GIT_REPOSITORY_URL]: SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI || BUILD_REPOSITORY_URI,
            [refKey]: ref,
            [GIT_COMMIT_AUTHOR_NAME]: BUILD_REQUESTEDFORID,
            [GIT_COMMIT_AUTHOR_EMAIL]: BUILD_REQUESTEDFOREMAIL,
            [GIT_COMMIT_MESSAGE]: BUILD_SOURCEVERSIONMESSAGE,
            [CI_STAGE_NAME]: SYSTEM_STAGEDISPLAYNAME,
            [CI_JOB_NAME]: SYSTEM_JOBDISPLAYNAME,
            [CI_ENV_VARS]: JSON.stringify({ SYSTEM_TEAMPROJECTID, BUILD_BUILDID, SYSTEM_JOBID }),
            [PR_NUMBER]: SYSTEM_PULLREQUEST_PULLREQUESTNUMBER,
            [GIT_PULL_REQUEST_BASE_BRANCH]: SYSTEM_PULLREQUEST_TARGETBRANCH,
            [CI_JOB_ID]: SYSTEM_JOBID,
          }
          if (SYSTEM_TEAMFOUNDATIONSERVERURI && SYSTEM_TEAMPROJECTID && BUILD_BUILDID) {
            const baseUrl = `${SYSTEM_TEAMFOUNDATIONSERVERURI}${SYSTEM_TEAMPROJECTID}/_build/results?buildId=${BUILD_BUILDID}`
            const pipelineUrl = baseUrl
            const jobUrl = `${baseUrl}&view=logs&j=${SYSTEM_JOBID}&t=${SYSTEM_TASKINSTANCEID}`
            tags = {
              ...tags,
              [CI_PIPELINE_URL]: pipelineUrl,
              [CI_JOB_URL]: jobUrl,
            }
          }
        }
        if (env.BITBUCKET_COMMIT) {
          const {
            BITBUCKET_REPO_FULL_NAME,
            BITBUCKET_BUILD_NUMBER,
            BITBUCKET_BRANCH,
            BITBUCKET_COMMIT,
            BITBUCKET_GIT_SSH_ORIGIN,
            BITBUCKET_GIT_HTTP_ORIGIN,
            BITBUCKET_TAG,
            BITBUCKET_PIPELINE_UUID,
            BITBUCKET_CLONE_DIR,
            BITBUCKET_PR_DESTINATION_BRANCH,
            BITBUCKET_PR_ID,
          } = env
          const url = `https://bitbucket.org/${BITBUCKET_REPO_FULL_NAME}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER}`
          tags = {
            [CI_PROVIDER_NAME]: 'bitbucket',
            [GIT_COMMIT_SHA]: BITBUCKET_COMMIT,
            [CI_PIPELINE_NUMBER]: BITBUCKET_BUILD_NUMBER,
            [CI_PIPELINE_NAME]: BITBUCKET_REPO_FULL_NAME,
            [CI_JOB_URL]: url,
            [CI_PIPELINE_URL]: url,
            [GIT_BRANCH]: BITBUCKET_BRANCH,
            [GIT_TAG]: BITBUCKET_TAG,
            [GIT_REPOSITORY_URL]: BITBUCKET_GIT_SSH_ORIGIN || BITBUCKET_GIT_HTTP_ORIGIN,
            [CI_WORKSPACE_PATH]: BITBUCKET_CLONE_DIR,
            [CI_PIPELINE_ID]: BITBUCKET_PIPELINE_UUID && BITBUCKET_PIPELINE_UUID.replaceAll(/{|}/gm, ''),
            [GIT_PULL_REQUEST_BASE_BRANCH]: BITBUCKET_PR_DESTINATION_BRANCH,
            [PR_NUMBER]: BITBUCKET_PR_ID,
          }
        }
        if (env.BITRISE_BUILD_SLUG) {
          const {
            BITRISE_GIT_COMMIT,
            GIT_CLONE_COMMIT_HASH,
            BITRISEIO_GIT_BRANCH_DEST,
            BITRISE_GIT_BRANCH,
            BITRISE_BUILD_SLUG,
            BITRISE_TRIGGERED_WORKFLOW_ID,
            BITRISE_BUILD_NUMBER,
            BITRISE_BUILD_URL,
            BITRISE_SOURCE_DIR,
            GIT_REPOSITORY_URL: BITRISE_GIT_REPOSITORY_URL,
            BITRISE_GIT_TAG,
            BITRISE_GIT_MESSAGE,
            BITRISE_PULL_REQUEST,
          } = env
          tags = {
            [CI_PROVIDER_NAME]: 'bitrise',
            [CI_PIPELINE_ID]: BITRISE_BUILD_SLUG,
            [CI_PIPELINE_NAME]: BITRISE_TRIGGERED_WORKFLOW_ID,
            [CI_PIPELINE_NUMBER]: BITRISE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: BITRISE_BUILD_URL,
            [GIT_COMMIT_SHA]: BITRISE_GIT_COMMIT || GIT_CLONE_COMMIT_HASH,
            [GIT_REPOSITORY_URL]: BITRISE_GIT_REPOSITORY_URL,
            [CI_WORKSPACE_PATH]: BITRISE_SOURCE_DIR,
            [GIT_TAG]: BITRISE_GIT_TAG,
            [GIT_BRANCH]: BITRISEIO_GIT_BRANCH_DEST || BITRISE_GIT_BRANCH,
            [GIT_COMMIT_MESSAGE]: BITRISE_GIT_MESSAGE,
            [GIT_PULL_REQUEST_BASE_BRANCH]: BITRISEIO_GIT_BRANCH_DEST,
            [PR_NUMBER]: BITRISE_PULL_REQUEST,
          }
        }
        if (env.BUILDKITE) {
          const {
            BUILDKITE_BRANCH,
            BUILDKITE_COMMIT,
            BUILDKITE_REPO,
            BUILDKITE_TAG,
            BUILDKITE_BUILD_ID,
            BUILDKITE_PIPELINE_SLUG,
            BUILDKITE_BUILD_NUMBER,
            BUILDKITE_BUILD_URL,
            BUILDKITE_JOB_ID,
            BUILDKITE_BUILD_CHECKOUT_PATH,
            BUILDKITE_BUILD_AUTHOR,
            BUILDKITE_BUILD_AUTHOR_EMAIL,
            BUILDKITE_MESSAGE,
            BUILDKITE_AGENT_ID,
            BUILDKITE_PULL_REQUEST,
            BUILDKITE_PULL_REQUEST_BASE_BRANCH,
          } = env
          const extraTags = Object.keys(env)
            .filter((envVar) => envVar.startsWith('BUILDKITE_AGENT_META_DATA_'))
            .map((metadataKey) => {
              const key = metadataKey.replace('BUILDKITE_AGENT_META_DATA_', '').toLowerCase()
              return `${key}:${env[metadataKey]}`
            })
          tags = {
            [CI_PROVIDER_NAME]: 'buildkite',
            [CI_PIPELINE_ID]: BUILDKITE_BUILD_ID,
            [CI_PIPELINE_NAME]: BUILDKITE_PIPELINE_SLUG,
            [CI_PIPELINE_NUMBER]: BUILDKITE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: BUILDKITE_BUILD_URL,
            [CI_JOB_URL]: `${BUILDKITE_BUILD_URL}#${BUILDKITE_JOB_ID}`,
            [GIT_COMMIT_SHA]: BUILDKITE_COMMIT,
            [CI_WORKSPACE_PATH]: BUILDKITE_BUILD_CHECKOUT_PATH,
            [GIT_REPOSITORY_URL]: BUILDKITE_REPO,
            [GIT_TAG]: BUILDKITE_TAG,
            [GIT_BRANCH]: BUILDKITE_BRANCH,
            [GIT_COMMIT_AUTHOR_NAME]: BUILDKITE_BUILD_AUTHOR,
            [GIT_COMMIT_AUTHOR_EMAIL]: BUILDKITE_BUILD_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: BUILDKITE_MESSAGE,
            [CI_ENV_VARS]: JSON.stringify({
              BUILDKITE_BUILD_ID,
              BUILDKITE_JOB_ID,
            }),
            [CI_NODE_NAME]: BUILDKITE_AGENT_ID,
            [CI_NODE_LABELS]: JSON.stringify(extraTags),
            [PR_NUMBER]: BUILDKITE_PULL_REQUEST,
            [CI_JOB_ID]: BUILDKITE_JOB_ID,
          }
          if (BUILDKITE_PULL_REQUEST) {
            tags[GIT_PULL_REQUEST_BASE_BRANCH] = BUILDKITE_PULL_REQUEST_BASE_BRANCH
          }
        }
        if (env.TRAVIS) {
          const {
            TRAVIS_PULL_REQUEST_BRANCH,
            TRAVIS_BRANCH,
            TRAVIS_COMMIT,
            TRAVIS_REPO_SLUG,
            TRAVIS_TAG,
            TRAVIS_JOB_WEB_URL,
            TRAVIS_BUILD_ID,
            TRAVIS_BUILD_NUMBER,
            TRAVIS_BUILD_WEB_URL,
            TRAVIS_BUILD_DIR,
            TRAVIS_COMMIT_MESSAGE,
            TRAVIS_PULL_REQUEST,
            TRAVIS_PULL_REQUEST_SHA,
          } = env
          tags = {
            [CI_PROVIDER_NAME]: 'travisci',
            [CI_JOB_URL]: TRAVIS_JOB_WEB_URL,
            [CI_PIPELINE_ID]: TRAVIS_BUILD_ID,
            [CI_PIPELINE_NAME]: TRAVIS_REPO_SLUG,
            [CI_PIPELINE_NUMBER]: TRAVIS_BUILD_NUMBER,
            [CI_PIPELINE_URL]: TRAVIS_BUILD_WEB_URL,
            [GIT_COMMIT_SHA]: TRAVIS_COMMIT,
            [GIT_REPOSITORY_URL]: `https://github.com/${TRAVIS_REPO_SLUG}.git`,
            [CI_WORKSPACE_PATH]: TRAVIS_BUILD_DIR,
            [GIT_TAG]: TRAVIS_TAG,
            [GIT_BRANCH]: TRAVIS_PULL_REQUEST_BRANCH || TRAVIS_BRANCH,
            [GIT_COMMIT_MESSAGE]: TRAVIS_COMMIT_MESSAGE,
            [GIT_COMMIT_HEAD_SHA]: TRAVIS_PULL_REQUEST_SHA,
            [GIT_PULL_REQUEST_BASE_BRANCH]: TRAVIS_BRANCH,
            [PR_NUMBER]: TRAVIS_PULL_REQUEST,
          }
        }
        if (env.BUDDY) {
          const {
            BUDDY_EXECUTION_BRANCH,
            BUDDY_EXECUTION_ID,
            BUDDY_EXECUTION_REVISION,
            BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL,
            BUDDY_EXECUTION_REVISION_COMMITTER_NAME,
            BUDDY_EXECUTION_REVISION_MESSAGE,
            BUDDY_EXECUTION_TAG,
            BUDDY_EXECUTION_URL,
            BUDDY_PIPELINE_ID,
            BUDDY_PIPELINE_NAME,
            BUDDY_SCM_URL,
            BUDDY_RUN_PR_BASE_BRANCH,
            BUDDY_RUN_PR_NO,
          } = env
          tags = {
            [CI_PROVIDER_NAME]: 'buddy',
            [CI_PIPELINE_ID]: `${BUDDY_PIPELINE_ID}/${BUDDY_EXECUTION_ID}`,
            [CI_PIPELINE_NAME]: BUDDY_PIPELINE_NAME,
            [CI_PIPELINE_NUMBER]: BUDDY_EXECUTION_ID,
            [CI_PIPELINE_URL]: BUDDY_EXECUTION_URL,
            [GIT_COMMIT_SHA]: BUDDY_EXECUTION_REVISION,
            [GIT_REPOSITORY_URL]: BUDDY_SCM_URL,
            [GIT_BRANCH]: BUDDY_EXECUTION_BRANCH,
            [GIT_TAG]: BUDDY_EXECUTION_TAG,
            [GIT_COMMIT_MESSAGE]: BUDDY_EXECUTION_REVISION_MESSAGE,
            [GIT_COMMIT_COMMITTER_NAME]: BUDDY_EXECUTION_REVISION_COMMITTER_NAME,
            [GIT_COMMIT_COMMITTER_EMAIL]: BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL,
            [GIT_PULL_REQUEST_BASE_BRANCH]: BUDDY_RUN_PR_BASE_BRANCH,
            [PR_NUMBER]: BUDDY_RUN_PR_NO,
          }
        }
        if (env.TEAMCITY_VERSION) {
          const {
            BUILD_URL,
            TEAMCITY_BUILDCONF_NAME,
            DATADOG_BUILD_ID,
            TEAMCITY_PULLREQUEST_NUMBER,
            TEAMCITY_PULLREQUEST_TARGET_BRANCH,
          } = env
          tags = {
            [CI_PROVIDER_NAME]: 'teamcity',
            [CI_JOB_URL]: BUILD_URL,
            [CI_JOB_NAME]: TEAMCITY_BUILDCONF_NAME,
            [CI_ENV_VARS]: JSON.stringify({
              DATADOG_BUILD_ID,
            }),
            [PR_NUMBER]: TEAMCITY_PULLREQUEST_NUMBER,
            [GIT_PULL_REQUEST_BASE_BRANCH]: TEAMCITY_PULLREQUEST_TARGET_BRANCH,
          }
        }
        if (env.CF_BUILD_ID) {
          const {
            CF_BUILD_ID,
            CF_PIPELINE_NAME,
            CF_BUILD_URL,
            CF_STEP_NAME,
            CF_BRANCH,
            CF_PULL_REQUEST_NUMBER,
            CF_PULL_REQUEST_TARGET,
          } = env
          tags = {
            [CI_PROVIDER_NAME]: 'codefresh',
            [CI_PIPELINE_ID]: CF_BUILD_ID,
            [CI_PIPELINE_NAME]: CF_PIPELINE_NAME,
            [CI_PIPELINE_URL]: CF_BUILD_URL,
            [CI_JOB_NAME]: CF_STEP_NAME,
            [CI_ENV_VARS]: JSON.stringify({
              CF_BUILD_ID,
            }),
            [PR_NUMBER]: CF_PULL_REQUEST_NUMBER,
            [GIT_PULL_REQUEST_BASE_BRANCH]: CF_PULL_REQUEST_TARGET,
          }
          const isTag = CF_BRANCH && CF_BRANCH.includes('tags/')
          const refKey = isTag ? GIT_TAG : GIT_BRANCH
          const ref = normalizeRef(CF_BRANCH)
          tags[refKey] = ref
        }
        if (env.CODEBUILD_INITIATOR?.startsWith('codepipeline/')) {
          const { CODEBUILD_BUILD_ARN, DD_ACTION_EXECUTION_ID, DD_PIPELINE_EXECUTION_ID } = env
          tags = {
            [CI_PROVIDER_NAME]: 'awscodepipeline',
            [CI_PIPELINE_ID]: DD_PIPELINE_EXECUTION_ID,
            [CI_ENV_VARS]: JSON.stringify({
              CODEBUILD_BUILD_ARN,
              DD_PIPELINE_EXECUTION_ID,
              DD_ACTION_EXECUTION_ID,
            }),
            [CI_JOB_ID]: DD_ACTION_EXECUTION_ID,
          }
        }
        if (env.DRONE && env.CI) {
          const {
            DRONE_BUILD_NUMBER,
            DRONE_BUILD_LINK,
            DRONE_STEP_NAME,
            DRONE_STAGE_NAME,
            DRONE_WORKSPACE,
            DRONE_GIT_HTTP_URL,
            DRONE_COMMIT_SHA,
            DRONE_BRANCH,
            DRONE_TAG,
            DRONE_COMMIT_AUTHOR_NAME,
            DRONE_COMMIT_AUTHOR_EMAIL,
            DRONE_COMMIT_MESSAGE,
            DRONE_PULL_REQUEST,
            DRONE_TARGET_BRANCH,
          } = env
          tags = {
            [CI_PROVIDER_NAME]: 'drone',
            [CI_PIPELINE_NUMBER]: DRONE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: DRONE_BUILD_LINK,
            [CI_JOB_NAME]: DRONE_STEP_NAME,
            [CI_STAGE_NAME]: DRONE_STAGE_NAME,
            [CI_WORKSPACE_PATH]: DRONE_WORKSPACE,
            [GIT_REPOSITORY_URL]: DRONE_GIT_HTTP_URL,
            [GIT_COMMIT_SHA]: DRONE_COMMIT_SHA,
            [GIT_BRANCH]: DRONE_BRANCH,
            [GIT_TAG]: DRONE_TAG,
            [GIT_COMMIT_AUTHOR_NAME]: DRONE_COMMIT_AUTHOR_NAME,
            [GIT_COMMIT_AUTHOR_EMAIL]: DRONE_COMMIT_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: DRONE_COMMIT_MESSAGE,
            [PR_NUMBER]: DRONE_PULL_REQUEST,
            [GIT_PULL_REQUEST_BASE_BRANCH]: DRONE_TARGET_BRANCH,
          }
        }
        normalizeTag(tags, CI_WORKSPACE_PATH, resolveTilde)
        normalizeTag(tags, GIT_REPOSITORY_URL, filterSensitiveInfoFromRepository)
        normalizeTag(tags, GIT_BRANCH, normalizeRef)
        normalizeTag(tags, GIT_TAG, normalizeRef)
        normalizeTag(tags, GIT_PULL_REQUEST_BASE_BRANCH, normalizeRef)
        normalizeTag(tags, PR_NUMBER, normalizeNumber)
        return removeEmptyValues(tags)
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js
var require_user_provided_git = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js'(exports2, module2) {
    'use strict'
    var {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_PULL_REQUEST_BASE_BRANCH,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_COMMIT_HEAD_SHA,
    } = require_tags2()
    var { normalizeRef } = require_ci()
    var { filterSensitiveInfoFromRepository } = require_url()
    var { getEnvironmentVariables } = require_config_helper()
    function removeEmptyValues(tags) {
      return Object.keys(tags).reduce((filteredTags, tag) => {
        if (!tags[tag]) {
          return filteredTags
        }
        return {
          ...filteredTags,
          [tag]: tags[tag],
        }
      }, {})
    }
    function validateGitRepositoryUrl(repoUrl) {
      return /(?:git|ssh|https?|git@[-\w.]+):(\/\/)?(.*?)(\/?|#[-\d\w._]+?)$/.test(repoUrl)
    }
    function validateGitCommitSha(gitCommitSha) {
      const isValidSha1 = /^[0-9a-f]{40}$/.test(gitCommitSha)
      const isValidSha256 = /^[0-9a-f]{64}$/.test(gitCommitSha)
      return isValidSha1 || isValidSha256
    }
    function getUserProviderGitMetadata() {
      const {
        DD_GIT_COMMIT_SHA,
        DD_GIT_BRANCH,
        DD_GIT_REPOSITORY_URL,
        DD_GIT_TAG,
        DD_GIT_COMMIT_MESSAGE,
        DD_GIT_COMMIT_COMMITTER_NAME,
        DD_GIT_COMMIT_COMMITTER_EMAIL,
        DD_GIT_COMMIT_COMMITTER_DATE,
        DD_GIT_COMMIT_AUTHOR_NAME,
        DD_GIT_COMMIT_AUTHOR_EMAIL,
        DD_GIT_COMMIT_AUTHOR_DATE,
        DD_GIT_PULL_REQUEST_BASE_BRANCH,
        DD_GIT_PULL_REQUEST_BASE_BRANCH_SHA,
        DD_GIT_COMMIT_HEAD_SHA,
      } = getEnvironmentVariables()
      const branch = normalizeRef(DD_GIT_BRANCH)
      let tag = normalizeRef(DD_GIT_TAG)
      if ((DD_GIT_BRANCH || '').includes('origin/tags') || (DD_GIT_BRANCH || '').includes('refs/heads/tags')) {
        tag = normalizeRef(DD_GIT_BRANCH)
      }
      return removeEmptyValues({
        [GIT_COMMIT_SHA]: DD_GIT_COMMIT_SHA,
        [GIT_BRANCH]: branch,
        [GIT_REPOSITORY_URL]: filterSensitiveInfoFromRepository(DD_GIT_REPOSITORY_URL),
        [GIT_TAG]: tag,
        [GIT_COMMIT_MESSAGE]: DD_GIT_COMMIT_MESSAGE,
        [GIT_COMMIT_COMMITTER_NAME]: DD_GIT_COMMIT_COMMITTER_NAME,
        [GIT_COMMIT_COMMITTER_DATE]: DD_GIT_COMMIT_COMMITTER_DATE,
        [GIT_COMMIT_COMMITTER_EMAIL]: DD_GIT_COMMIT_COMMITTER_EMAIL,
        [GIT_COMMIT_AUTHOR_NAME]: DD_GIT_COMMIT_AUTHOR_NAME,
        [GIT_COMMIT_AUTHOR_EMAIL]: DD_GIT_COMMIT_AUTHOR_EMAIL,
        [GIT_COMMIT_AUTHOR_DATE]: DD_GIT_COMMIT_AUTHOR_DATE,
        [GIT_PULL_REQUEST_BASE_BRANCH]: DD_GIT_PULL_REQUEST_BASE_BRANCH,
        [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: DD_GIT_PULL_REQUEST_BASE_BRANCH_SHA,
        [GIT_COMMIT_HEAD_SHA]: DD_GIT_COMMIT_HEAD_SHA,
      })
    }
    module2.exports = { getUserProviderGitMetadata, validateGitRepositoryUrl, validateGitCommitSha }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js
var require_env = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var OS_PLATFORM = 'os.platform'
    var OS_VERSION = 'os.version'
    var OS_ARCHITECTURE = 'os.architecture'
    var RUNTIME_NAME = 'runtime.name'
    var RUNTIME_VERSION = 'runtime.version'
    var DD_HOST_CPU_COUNT = '_dd.host.vcpu_count'
    function getRuntimeAndOSMetadata() {
      return {
        [RUNTIME_VERSION]: process.version,
        [OS_ARCHITECTURE]: process.arch,
        [OS_PLATFORM]: process.platform,
        [RUNTIME_NAME]: 'node',
        [OS_VERSION]: os.release(),
        [DD_HOST_CPU_COUNT]: os.cpus().length,
      }
    }
    module2.exports = {
      getRuntimeAndOSMetadata,
      OS_PLATFORM,
      OS_VERSION,
      OS_ARCHITECTURE,
      RUNTIME_NAME,
      RUNTIME_VERSION,
      DD_HOST_CPU_COUNT,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js
var require_test = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var fs = require('fs')
    var { URL: URL2 } = require('url')
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var satisfies = require_semifies()
    var istanbul = require_istanbul_lib_coverage()
    var ignore = require_ignore()
    var {
      getGitMetadata,
      getGitInformationDiscrepancy,
      getGitDiff,
      getGitRemoteName,
      getSourceBranch,
      checkAndFetchBranch,
      getLocalBranches,
      getMergeBase,
      getCounts,
    } = require_git()
    var { getUserProviderGitMetadata, validateGitRepositoryUrl, validateGitCommitSha } = require_user_provided_git()
    var { getCIMetadata } = require_ci()
    var { getRuntimeAndOSMetadata } = require_env()
    var {
      GIT_BRANCH,
      GIT_COMMIT_SHA,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_MESSAGE,
      CI_WORKSPACE_PATH,
      CI_PIPELINE_URL,
      CI_JOB_NAME,
      GIT_COMMIT_HEAD_SHA,
    } = require_tags2()
    var id = require_id()
    var { incrementCountMetric, TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY, TELEMETRY_GIT_SHA_MATCH } = require_telemetry()
    var { SPAN_TYPE, RESOURCE_NAME, SAMPLING_PRIORITY } = require_tags()
    var { SAMPLING_RULE_DECISION } = require_constants2()
    var { AUTO_KEEP } = require_priority()
    var { version: ddTraceVersion } = require_package()
    var TEST_SESSION_NAME = 'test_session.name'
    var TEST_FRAMEWORK = 'test.framework'
    var TEST_FRAMEWORK_VERSION = 'test.framework_version'
    var TEST_TYPE = 'test.type'
    var TEST_NAME = 'test.name'
    var TEST_SUITE = 'test.suite'
    var TEST_STATUS = 'test.status'
    var TEST_PARAMETERS = 'test.parameters'
    var TEST_SKIP_REASON = 'test.skip_reason'
    var TEST_IS_RUM_ACTIVE = 'test.is_rum_active'
    var TEST_CODE_OWNERS = 'test.codeowners'
    var TEST_SOURCE_FILE = 'test.source.file'
    var TEST_SOURCE_START = 'test.source.start'
    var LIBRARY_VERSION = 'library_version'
    var TEST_COMMAND = 'test.command'
    var TEST_MODULE = 'test.module'
    var TEST_SESSION_ID = 'test_session_id'
    var TEST_MODULE_ID = 'test_module_id'
    var TEST_SUITE_ID = 'test_suite_id'
    var TEST_TOOLCHAIN = 'test.toolchain'
    var TEST_SKIPPED_BY_ITR = 'test.skipped_by_itr'
    var TEST_IS_NEW = 'test.is_new'
    var TEST_IS_RETRY = 'test.is_retry'
    var TEST_EARLY_FLAKE_ENABLED = 'test.early_flake.enabled'
    var TEST_EARLY_FLAKE_ABORT_REASON = 'test.early_flake.abort_reason'
    var TEST_RETRY_REASON = 'test.retry_reason'
    var TEST_HAS_FAILED_ALL_RETRIES = 'test.has_failed_all_retries'
    var TEST_IS_MODIFIED = 'test.is_modified'
    var CI_APP_ORIGIN = 'ciapp-test'
    var JEST_TEST_RUNNER = 'test.jest.test_runner'
    var JEST_DISPLAY_NAME = 'test.jest.display_name'
    var VITEST_POOL = 'test.vitest.pool'
    var CUCUMBER_IS_PARALLEL = 'test.cucumber.is_parallel'
    var MOCHA_IS_PARALLEL = 'test.mocha.is_parallel'
    var TEST_ITR_TESTS_SKIPPED = '_dd.ci.itr.tests_skipped'
    var TEST_ITR_SKIPPING_ENABLED = 'test.itr.tests_skipping.enabled'
    var TEST_ITR_SKIPPING_TYPE = 'test.itr.tests_skipping.type'
    var TEST_ITR_SKIPPING_COUNT = 'test.itr.tests_skipping.count'
    var TEST_CODE_COVERAGE_ENABLED = 'test.code_coverage.enabled'
    var TEST_ITR_UNSKIPPABLE = 'test.itr.unskippable'
    var TEST_ITR_FORCED_RUN = 'test.itr.forced_run'
    var ITR_CORRELATION_ID = 'itr_correlation_id'
    var TEST_CODE_COVERAGE_LINES_PCT = 'test.code_coverage.lines_pct'
    var TEST_BROWSER_DRIVER = 'test.browser.driver'
    var TEST_BROWSER_DRIVER_VERSION = 'test.browser.driver_version'
    var TEST_BROWSER_NAME = 'test.browser.name'
    var TEST_BROWSER_VERSION = 'test.browser.version'
    var JEST_WORKER_TRACE_PAYLOAD_CODE = 60
    var JEST_WORKER_COVERAGE_PAYLOAD_CODE = 61
    var JEST_WORKER_LOGS_PAYLOAD_CODE = 62
    var CUCUMBER_WORKER_TRACE_PAYLOAD_CODE = 70
    var MOCHA_WORKER_TRACE_PAYLOAD_CODE = 80
    var PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE = 90
    var VITEST_WORKER_TRACE_PAYLOAD_CODE = 100
    var VITEST_WORKER_LOGS_PAYLOAD_CODE = 102
    var TEST_IS_TEST_FRAMEWORK_WORKER = 'test.is_test_framework_worker'
    var DD_CAPABILITIES_TEST_IMPACT_ANALYSIS = '_dd.library_capabilities.test_impact_analysis'
    var DD_CAPABILITIES_EARLY_FLAKE_DETECTION = '_dd.library_capabilities.early_flake_detection'
    var DD_CAPABILITIES_AUTO_TEST_RETRIES = '_dd.library_capabilities.auto_test_retries'
    var DD_CAPABILITIES_IMPACTED_TESTS = '_dd.library_capabilities.impacted_tests'
    var DD_CAPABILITIES_TEST_MANAGEMENT_QUARANTINE = '_dd.library_capabilities.test_management.quarantine'
    var DD_CAPABILITIES_TEST_MANAGEMENT_DISABLE = '_dd.library_capabilities.test_management.disable'
    var DD_CAPABILITIES_TEST_MANAGEMENT_ATTEMPT_TO_FIX = '_dd.library_capabilities.test_management.attempt_to_fix'
    var DD_CAPABILITIES_FAILED_TEST_REPLAY = '_dd.library_capabilities.failed_test_replay'
    var UNSUPPORTED_TIA_FRAMEWORKS = /* @__PURE__ */ new Set(['playwright', 'vitest'])
    var UNSUPPORTED_TIA_FRAMEWORKS_PARALLEL_MODE = /* @__PURE__ */ new Set(['cucumber', 'mocha'])
    var MINIMUM_FRAMEWORK_VERSION_FOR_EFD = {
      playwright: '>=1.38.0',
    }
    var MINIMUM_FRAMEWORK_VERSION_FOR_IMPACTED_TESTS = {
      playwright: '>=1.38.0',
    }
    var MINIMUM_FRAMEWORK_VERSION_FOR_QUARANTINE = {
      playwright: '>=1.38.0',
    }
    var MINIMUM_FRAMEWORK_VERSION_FOR_DISABLE = {
      playwright: '>=1.38.0',
    }
    var MINIMUM_FRAMEWORK_VERSION_FOR_ATTEMPT_TO_FIX = {
      playwright: '>=1.38.0',
    }
    var MINIMUM_FRAMEWORK_VERSION_FOR_FAILED_TEST_REPLAY = {
      playwright: '>=1.38.0',
    }
    var UNSUPPORTED_ATTEMPT_TO_FIX_FRAMEWORKS_PARALLEL_MODE = /* @__PURE__ */ new Set(['mocha'])
    var NOT_SUPPORTED_GRANULARITY_IMPACTED_TESTS_FRAMEWORKS = /* @__PURE__ */ new Set(['mocha', 'playwright', 'vitest'])
    var TEST_LEVEL_EVENT_TYPES = ['test', 'test_suite_end', 'test_module_end', 'test_session_end']
    var TEST_RETRY_REASON_TYPES = {
      efd: 'early_flake_detection',
      atr: 'auto_test_retry',
      atf: 'attempt_to_fix',
      ext: 'external',
    }
    var DD_TEST_IS_USER_PROVIDED_SERVICE = '_dd.test.is_user_provided_service'
    var DI_ERROR_DEBUG_INFO_CAPTURED = 'error.debug_info_captured'
    var DI_DEBUG_ERROR_PREFIX = '_dd.debug.error'
    var DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX = 'snapshot_id'
    var DI_DEBUG_ERROR_FILE_SUFFIX = 'file'
    var DI_DEBUG_ERROR_LINE_SUFFIX = 'line'
    var TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX = 'test.test_management.is_attempt_to_fix'
    var TEST_MANAGEMENT_IS_DISABLED = 'test.test_management.is_test_disabled'
    var TEST_MANAGEMENT_IS_QUARANTINED = 'test.test_management.is_quarantined'
    var TEST_MANAGEMENT_ENABLED = 'test.test_management.enabled'
    var TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED = 'test.test_management.attempt_to_fix_passed'
    var POSSIBLE_BASE_BRANCHES = ['main', 'master', 'preprod', 'prod', 'dev', 'development', 'trunk']
    var BASE_LIKE_BRANCH_FILTER = /^(main|master|preprod|prod|dev|development|trunk|release\/.*|hotfix\/.*)$/
    module2.exports = {
      TEST_CODE_OWNERS,
      TEST_SESSION_NAME,
      TEST_FRAMEWORK,
      TEST_FRAMEWORK_VERSION,
      JEST_TEST_RUNNER,
      JEST_DISPLAY_NAME,
      VITEST_POOL,
      CUCUMBER_IS_PARALLEL,
      MOCHA_IS_PARALLEL,
      TEST_TYPE,
      TEST_NAME,
      TEST_SUITE,
      TEST_STATUS,
      TEST_PARAMETERS,
      TEST_SKIP_REASON,
      TEST_IS_RUM_ACTIVE,
      TEST_SOURCE_FILE,
      CI_APP_ORIGIN,
      LIBRARY_VERSION,
      JEST_WORKER_TRACE_PAYLOAD_CODE,
      JEST_WORKER_COVERAGE_PAYLOAD_CODE,
      JEST_WORKER_LOGS_PAYLOAD_CODE,
      CUCUMBER_WORKER_TRACE_PAYLOAD_CODE,
      MOCHA_WORKER_TRACE_PAYLOAD_CODE,
      PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_LOGS_PAYLOAD_CODE,
      TEST_IS_TEST_FRAMEWORK_WORKER,
      TEST_SOURCE_START,
      TEST_SKIPPED_BY_ITR,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TEST_RETRY_REASON,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_IS_MODIFIED,
      getTestEnvironmentMetadata,
      getTestParametersString,
      finishAllTraceSpans,
      getTestParentSpan,
      getTestSuitePath,
      getCodeOwnersFileEntries,
      getCodeOwnersForFilename,
      getTestCommonTags,
      getTestSessionCommonTags,
      getTestModuleCommonTags,
      getTestSuiteCommonTags,
      TEST_COMMAND,
      TEST_TOOLCHAIN,
      TEST_SESSION_ID,
      TEST_MODULE_ID,
      TEST_SUITE_ID,
      TEST_ITR_TESTS_SKIPPED,
      TEST_MODULE,
      TEST_ITR_SKIPPING_ENABLED,
      TEST_ITR_SKIPPING_TYPE,
      TEST_ITR_SKIPPING_COUNT,
      TEST_CODE_COVERAGE_ENABLED,
      TEST_CODE_COVERAGE_LINES_PCT,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      ITR_CORRELATION_ID,
      addIntelligentTestRunnerSpanTags,
      getCoveredFilenamesFromCoverage,
      resetCoverage,
      mergeCoverage,
      fromCoverageMapToCoverage,
      getTestLineStart,
      getTestEndLine,
      removeInvalidMetadata,
      parseAnnotations,
      getIsFaultyEarlyFlakeDetection,
      TEST_BROWSER_DRIVER,
      TEST_BROWSER_DRIVER_VERSION,
      TEST_BROWSER_NAME,
      TEST_BROWSER_VERSION,
      getTestSessionName,
      DD_CAPABILITIES_TEST_IMPACT_ANALYSIS,
      DD_CAPABILITIES_EARLY_FLAKE_DETECTION,
      DD_CAPABILITIES_AUTO_TEST_RETRIES,
      DD_CAPABILITIES_IMPACTED_TESTS,
      DD_CAPABILITIES_TEST_MANAGEMENT_QUARANTINE,
      DD_CAPABILITIES_TEST_MANAGEMENT_DISABLE,
      DD_CAPABILITIES_TEST_MANAGEMENT_ATTEMPT_TO_FIX,
      DD_CAPABILITIES_FAILED_TEST_REPLAY,
      TEST_LEVEL_EVENT_TYPES,
      TEST_RETRY_REASON_TYPES,
      getNumFromKnownTests,
      getFileAndLineNumberFromError,
      DI_ERROR_DEBUG_INFO_CAPTURED,
      DI_DEBUG_ERROR_PREFIX,
      DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX,
      DI_DEBUG_ERROR_FILE_SUFFIX,
      DI_DEBUG_ERROR_LINE_SUFFIX,
      getFormattedError,
      DD_TEST_IS_USER_PROVIDED_SERVICE,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      getLibraryCapabilitiesTags,
      checkShaDiscrepancies,
      getPullRequestDiff,
      getPullRequestBaseBranch,
      getModifiedFilesFromDiff,
      isModifiedTest,
      POSSIBLE_BASE_BRANCHES,
    }
    function getPkgManager() {
      try {
        return getEnvironmentVariable('npm_config_user_agent').split(' ')[0].replace('/', '-')
      } catch {
        return ''
      }
    }
    function validateUrl(url) {
      try {
        const urlObject = new URL2(url)
        return urlObject.protocol === 'https:' || urlObject.protocol === 'http:'
      } catch {
        return false
      }
    }
    function removeInvalidMetadata(metadata) {
      return Object.keys(metadata).reduce((filteredTags, tag) => {
        if (tag === GIT_REPOSITORY_URL && !validateGitRepositoryUrl(metadata[GIT_REPOSITORY_URL])) {
          log.error('Repository URL is not a valid repository URL: %s.', metadata[GIT_REPOSITORY_URL])
          return filteredTags
        }
        if (tag === GIT_COMMIT_SHA && !validateGitCommitSha(metadata[GIT_COMMIT_SHA])) {
          log.error('Git commit SHA must be a full-length git SHA: %s.', metadata[GIT_COMMIT_SHA])
          return filteredTags
        }
        if (tag === CI_PIPELINE_URL && !validateUrl(metadata[CI_PIPELINE_URL])) {
          return filteredTags
        }
        filteredTags[tag] = metadata[tag]
        return filteredTags
      }, {})
    }
    function checkShaDiscrepancies(ciMetadata, userProvidedGitMetadata) {
      const { [GIT_COMMIT_SHA]: ciCommitSHA, [GIT_REPOSITORY_URL]: ciRepositoryUrl } = ciMetadata
      const { [GIT_COMMIT_SHA]: userProvidedCommitSHA, [GIT_REPOSITORY_URL]: userProvidedRepositoryUrl } =
        userProvidedGitMetadata
      const { gitRepositoryUrl, gitCommitSHA } = getGitInformationDiscrepancy()
      const checkDiscrepancyAndSendMetrics = (
        valueExpected,
        valueDiscrepant,
        discrepancyType,
        expectedProvider,
        discrepantProvider
      ) => {
        if (valueExpected && valueDiscrepant && valueExpected !== valueDiscrepant) {
          incrementCountMetric(TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY, {
            type: discrepancyType,
            expected_provider: expectedProvider,
            discrepant_provider: discrepantProvider,
          })
          return true
        }
        return false
      }
      const checkConfigs = [
        // User provided vs Git metadata
        {
          v1: userProvidedRepositoryUrl,
          v2: gitRepositoryUrl,
          type: 'repository_discrepancy',
          expected: 'user_supplied',
          discrepant: 'git_client',
        },
        {
          v1: userProvidedCommitSHA,
          v2: gitCommitSHA,
          type: 'commit_discrepancy',
          expected: 'user_supplied',
          discrepant: 'git_client',
        },
        // User provided vs CI metadata
        {
          v1: userProvidedRepositoryUrl,
          v2: ciRepositoryUrl,
          type: 'repository_discrepancy',
          expected: 'user_supplied',
          discrepant: 'ci_provider',
        },
        {
          v1: userProvidedCommitSHA,
          v2: ciCommitSHA,
          type: 'commit_discrepancy',
          expected: 'user_supplied',
          discrepant: 'ci_provider',
        },
        // CI metadata vs Git metadata
        {
          v1: ciRepositoryUrl,
          v2: gitRepositoryUrl,
          type: 'repository_discrepancy',
          expected: 'ci_provider',
          discrepant: 'git_client',
        },
        {
          v1: ciCommitSHA,
          v2: gitCommitSHA,
          type: 'commit_discrepancy',
          expected: 'ci_provider',
          discrepant: 'git_client',
        },
      ]
      let gitCommitShaMatch = true
      for (const checkConfig of checkConfigs) {
        const { v1, v2, type, expected, discrepant } = checkConfig
        const discrepancy = checkDiscrepancyAndSendMetrics(v1, v2, type, expected, discrepant)
        if (discrepancy) {
          gitCommitShaMatch = false
        }
      }
      incrementCountMetric(TELEMETRY_GIT_SHA_MATCH, { matched: gitCommitShaMatch })
    }
    function getTestEnvironmentMetadata(testFramework, config, shouldSkipGitMetadataExtraction = false) {
      const ciMetadata = getCIMetadata()
      const userProvidedGitMetadata = getUserProviderGitMetadata()
      let gitMetadata = {}
      if (!shouldSkipGitMetadataExtraction) {
        checkShaDiscrepancies(ciMetadata, userProvidedGitMetadata)
        const {
          [GIT_COMMIT_SHA]: commitSHA,
          [GIT_BRANCH]: branch,
          [GIT_REPOSITORY_URL]: repositoryUrl,
          [GIT_TAG]: tag,
          [GIT_COMMIT_AUTHOR_NAME]: authorName,
          [GIT_COMMIT_AUTHOR_EMAIL]: authorEmail,
          [GIT_COMMIT_MESSAGE]: commitMessage,
          [CI_WORKSPACE_PATH]: ciWorkspacePath,
          [GIT_COMMIT_HEAD_SHA]: headCommitSha,
        } = ciMetadata
        gitMetadata = getGitMetadata({
          commitSHA,
          branch,
          repositoryUrl,
          tag,
          authorName,
          authorEmail,
          commitMessage,
          ciWorkspacePath,
          headCommitSha,
        })
      }
      const runtimeAndOSMetadata = getRuntimeAndOSMetadata()
      const metadata = {
        [TEST_FRAMEWORK]: testFramework,
        [DD_TEST_IS_USER_PROVIDED_SERVICE]: config && config.isServiceUserProvided ? 'true' : 'false',
        ...gitMetadata,
        ...ciMetadata,
        ...userProvidedGitMetadata,
        ...runtimeAndOSMetadata,
      }
      if (config && config.service) {
        metadata['service.name'] = config.service
      }
      return removeInvalidMetadata(metadata)
    }
    function getTestParametersString(parametersByTestName, testName) {
      if (!parametersByTestName[testName]) {
        return ''
      }
      try {
        const testParameters = parametersByTestName[testName].shift()
        return JSON.stringify({ arguments: testParameters, metadata: {} })
      } catch {
        return ''
      }
    }
    function getTestTypeFromFramework(testFramework) {
      if (testFramework === 'playwright' || testFramework === 'cypress') {
        return 'browser'
      }
      return 'test'
    }
    function finishAllTraceSpans(span) {
      span.context()._trace.started.forEach((traceSpan) => {
        if (traceSpan !== span) {
          traceSpan.finish()
        }
      })
    }
    function getTestParentSpan(tracer2) {
      return tracer2.extract('text_map', {
        'x-datadog-trace-id': id().toString(10),
        'x-datadog-parent-id': '0000000000000000',
      })
    }
    function getTestCommonTags(name, suite, version, testFramework) {
      return {
        [SPAN_TYPE]: 'test',
        [TEST_TYPE]: getTestTypeFromFramework(testFramework),
        [SAMPLING_RULE_DECISION]: 1,
        [SAMPLING_PRIORITY]: AUTO_KEEP,
        [TEST_NAME]: name,
        [TEST_SUITE]: suite,
        [RESOURCE_NAME]: `${suite}.${name}`,
        [TEST_FRAMEWORK_VERSION]: version,
        [LIBRARY_VERSION]: ddTraceVersion,
      }
    }
    function getTestSuitePath(testSuiteAbsolutePath, sourceRoot) {
      if (!testSuiteAbsolutePath) {
        return sourceRoot
      }
      const testSuitePath =
        testSuiteAbsolutePath === sourceRoot ? testSuiteAbsolutePath : path.relative(sourceRoot, testSuiteAbsolutePath)
      return testSuitePath.replace(path.sep, '/')
    }
    var POSSIBLE_CODEOWNERS_LOCATIONS = ['CODEOWNERS', '.github/CODEOWNERS', 'docs/CODEOWNERS', '.gitlab/CODEOWNERS']
    function readCodeOwners(rootDir) {
      for (const location of POSSIBLE_CODEOWNERS_LOCATIONS) {
        try {
          return fs.readFileSync(path.join(rootDir, location)).toString()
        } catch {}
      }
      return ''
    }
    function getCodeOwnersFileEntries(rootDir) {
      let codeOwnersContent
      let usedRootDir = rootDir
      let isTriedCwd = false
      const processCwd = process.cwd()
      if (!usedRootDir || usedRootDir === processCwd) {
        usedRootDir = processCwd
        isTriedCwd = true
      }
      codeOwnersContent = readCodeOwners(usedRootDir)
      if (!codeOwnersContent && !isTriedCwd) {
        codeOwnersContent = readCodeOwners(processCwd)
      }
      if (!codeOwnersContent) {
        return null
      }
      const entries = []
      const lines = codeOwnersContent.split('\n')
      for (const line of lines) {
        const [content] = line.split('#')
        const trimmed = content.trim()
        if (trimmed === '') continue
        const [pattern, ...owners] = trimmed.split(/\s+/)
        entries.push({ pattern, owners })
      }
      return entries.reverse()
    }
    var codeOwnersPerFileName = /* @__PURE__ */ new Map()
    function getCodeOwnersForFilename(filename, entries) {
      if (!entries) {
        return null
      }
      if (codeOwnersPerFileName.has(filename)) {
        return codeOwnersPerFileName.get(filename)
      }
      for (const entry of entries) {
        try {
          const isResponsible = ignore().add(entry.pattern).ignores(filename)
          if (isResponsible) {
            const codeOwners = JSON.stringify(entry.owners)
            codeOwnersPerFileName.set(filename, codeOwners)
            return codeOwners
          }
        } catch {
          codeOwnersPerFileName.set(filename, null)
          return null
        }
      }
      codeOwnersPerFileName.set(filename, null)
      return null
    }
    function getTestLevelCommonTags(command, testFrameworkVersion, testFramework) {
      return {
        [TEST_FRAMEWORK_VERSION]: testFrameworkVersion,
        [LIBRARY_VERSION]: ddTraceVersion,
        [TEST_COMMAND]: command,
        [TEST_TYPE]: getTestTypeFromFramework(testFramework),
      }
    }
    function getTestSessionCommonTags(command, testFrameworkVersion, testFramework) {
      return {
        [SPAN_TYPE]: 'test_session_end',
        [RESOURCE_NAME]: `test_session.${command}`,
        [TEST_MODULE]: testFramework,
        [TEST_TOOLCHAIN]: getPkgManager(),
        ...getTestLevelCommonTags(command, testFrameworkVersion, testFramework),
      }
    }
    function getTestModuleCommonTags(command, testFrameworkVersion, testFramework) {
      return {
        [SPAN_TYPE]: 'test_module_end',
        [RESOURCE_NAME]: `test_module.${command}`,
        [TEST_MODULE]: testFramework,
        ...getTestLevelCommonTags(command, testFrameworkVersion, testFramework),
      }
    }
    function getTestSuiteCommonTags(command, testFrameworkVersion, testSuite, testFramework) {
      return {
        [SPAN_TYPE]: 'test_suite_end',
        [RESOURCE_NAME]: `test_suite.${testSuite}`,
        [TEST_MODULE]: testFramework,
        [TEST_SUITE]: testSuite,
        ...getTestLevelCommonTags(command, testFrameworkVersion, testFramework),
      }
    }
    function addIntelligentTestRunnerSpanTags(
      testSessionSpan,
      testModuleSpan,
      {
        isSuitesSkipped,
        isSuitesSkippingEnabled,
        isCodeCoverageEnabled,
        testCodeCoverageLinesTotal,
        skippingCount,
        skippingType = 'suite',
        hasUnskippableSuites,
        hasForcedToRunSuites,
      }
    ) {
      testSessionSpan.setTag(TEST_ITR_TESTS_SKIPPED, isSuitesSkipped ? 'true' : 'false')
      testSessionSpan.setTag(TEST_ITR_SKIPPING_ENABLED, isSuitesSkippingEnabled ? 'true' : 'false')
      testSessionSpan.setTag(TEST_ITR_SKIPPING_TYPE, skippingType)
      testSessionSpan.setTag(TEST_ITR_SKIPPING_COUNT, skippingCount)
      testSessionSpan.setTag(TEST_CODE_COVERAGE_ENABLED, isCodeCoverageEnabled ? 'true' : 'false')
      testModuleSpan.setTag(TEST_ITR_TESTS_SKIPPED, isSuitesSkipped ? 'true' : 'false')
      testModuleSpan.setTag(TEST_ITR_SKIPPING_ENABLED, isSuitesSkippingEnabled ? 'true' : 'false')
      testModuleSpan.setTag(TEST_ITR_SKIPPING_TYPE, skippingType)
      testModuleSpan.setTag(TEST_ITR_SKIPPING_COUNT, skippingCount)
      testModuleSpan.setTag(TEST_CODE_COVERAGE_ENABLED, isCodeCoverageEnabled ? 'true' : 'false')
      if (hasUnskippableSuites) {
        testSessionSpan.setTag(TEST_ITR_UNSKIPPABLE, 'true')
        testModuleSpan.setTag(TEST_ITR_UNSKIPPABLE, 'true')
      }
      if (hasForcedToRunSuites) {
        testSessionSpan.setTag(TEST_ITR_FORCED_RUN, 'true')
        testModuleSpan.setTag(TEST_ITR_FORCED_RUN, 'true')
      }
      if (testCodeCoverageLinesTotal !== void 0) {
        testSessionSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal)
        testModuleSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal)
      }
    }
    function getCoveredFilenamesFromCoverage(coverage) {
      const coverageMap = istanbul.createCoverageMap(coverage)
      return coverageMap.files().filter((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename)
        const lineCoverage = fileCoverage.getLineCoverage()
        const isAnyLineExecuted = Object.entries(lineCoverage).some(([, numExecutions]) => !!numExecutions)
        return isAnyLineExecuted
      })
    }
    function resetCoverage(coverage) {
      const coverageMap = istanbul.createCoverageMap(coverage)
      return coverageMap.files().forEach((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename)
        fileCoverage.resetHits()
      })
    }
    function mergeCoverage(coverage, targetCoverage) {
      const coverageMap = istanbul.createCoverageMap(coverage)
      return coverageMap.files().forEach((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename)
        if (!targetCoverage.data[filename]) {
          targetCoverage.addFileCoverage(istanbul.createFileCoverage(filename))
        }
        targetCoverage.addFileCoverage(fileCoverage)
        const targetFileCoverage = targetCoverage.fileCoverageFor(filename)
        Object.entries(targetFileCoverage.data.b).forEach(([key, value]) => {
          targetFileCoverage.data.b[key] = [...value]
        })
      })
    }
    function fromCoverageMapToCoverage(coverageMap) {
      return Object.entries(coverageMap.data).reduce((acc, [filename, fileCoverage]) => {
        acc[filename] = fileCoverage.data
        return acc
      }, {})
    }
    function getTestLineStart(err, testSuitePath) {
      if (!err.stack) {
        return null
      }
      const testFileLine = err.stack.split('\n').find((line) => line.includes(testSuitePath))
      try {
        const testFileLineMatch = testFileLine.match(/at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/)
        return Number.parseInt(testFileLineMatch[3], 10) || null
      } catch {
        return null
      }
    }
    function getTestEndLine(testFn, startLine = 0) {
      const source = testFn.toString()
      const lineCount = source.split('\n').length
      return startLine + lineCount - 1
    }
    function parseAnnotations(annotations) {
      return annotations.reduce((tags, annotation) => {
        if (!annotation?.type) {
          return tags
        }
        const { type, description } = annotation
        if (type.startsWith('DD_TAGS')) {
          const regex = /\[(.*?)\]/
          const match = regex.exec(type)
          let tagValue = ''
          if (match) {
            tagValue = match[1]
          }
          if (tagValue) {
            tags[tagValue] = description
          }
        }
        return tags
      }, {})
    }
    function getIsFaultyEarlyFlakeDetection(projectSuites, testsBySuiteName, faultyThresholdPercentage) {
      let newSuites = 0
      for (const suite of projectSuites) {
        if (!testsBySuiteName[suite]) {
          newSuites++
        }
      }
      const newSuitesPercentage = (newSuites / projectSuites.length) * 100
      return newSuites > faultyThresholdPercentage && newSuitesPercentage > faultyThresholdPercentage
    }
    function getTestSessionName(config, trimmedCommand, envTags) {
      if (config.ciVisibilityTestSessionName) {
        return config.ciVisibilityTestSessionName
      }
      if (envTags[CI_JOB_NAME]) {
        return `${envTags[CI_JOB_NAME]}-${trimmedCommand}`
      }
      return trimmedCommand
    }
    function getNumFromKnownTests(knownTests) {
      if (!knownTests) {
        return 0
      }
      let totalNumTests = 0
      for (const testModule of Object.values(knownTests)) {
        for (const testSuite of Object.values(testModule)) {
          totalNumTests += testSuite.length
        }
      }
      return totalNumTests
    }
    var DEPENDENCY_FOLDERS = ['node_modules', 'node:', '.pnpm', '.yarn', '.pnp']
    function getFileAndLineNumberFromError(error, repositoryRoot) {
      const stackLines = error.stack.split('\n')
      const frames = stackLines.filter((line) => line.includes('at ') && line.includes(repositoryRoot))
      const topRelevantFrameIndex = frames.findIndex(
        (line) => line.includes(repositoryRoot) && !DEPENDENCY_FOLDERS.some((pattern) => line.includes(pattern))
      )
      if (topRelevantFrameIndex === -1) {
        return []
      }
      const topFrame = frames[topRelevantFrameIndex]
      const regex = /\s*at\s+(?:.*\()?(.+):(\d+):(\d+)\)?/
      const match = topFrame.match(regex)
      if (match) {
        const filePath = match[1]
        const lineNumber = Number(match[2])
        return [filePath, lineNumber, topRelevantFrameIndex]
      }
      return []
    }
    function getFormattedError(error, repositoryRoot) {
      const newError = new Error(error.message)
      if (error.stack) {
        newError.stack = error.stack
          .split('\n')
          .filter((line) => line.includes(repositoryRoot))
          .join('\n')
      }
      newError.name = error.name
      return newError
    }
    function isTiaSupported(testFramework, isParallel) {
      return !(
        UNSUPPORTED_TIA_FRAMEWORKS.has(testFramework) ||
        (isParallel && UNSUPPORTED_TIA_FRAMEWORKS_PARALLEL_MODE.has(testFramework))
      )
    }
    function isEarlyFlakeDetectionSupported(testFramework, frameworkVersion) {
      return testFramework === 'playwright'
        ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_EFD[testFramework])
        : true
    }
    function isImpactedTestsSupported(testFramework, frameworkVersion) {
      return testFramework === 'playwright'
        ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_IMPACTED_TESTS[testFramework])
        : true
    }
    function isQuarantineSupported(testFramework, frameworkVersion) {
      return testFramework === 'playwright'
        ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_QUARANTINE[testFramework])
        : true
    }
    function isDisableSupported(testFramework, frameworkVersion) {
      return testFramework === 'playwright'
        ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_DISABLE[testFramework])
        : true
    }
    function isAttemptToFixSupported(testFramework, isParallel, frameworkVersion) {
      if (testFramework === 'playwright') {
        return satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_ATTEMPT_TO_FIX[testFramework])
      }
      return !(isParallel && UNSUPPORTED_ATTEMPT_TO_FIX_FRAMEWORKS_PARALLEL_MODE.has(testFramework))
    }
    function isFailedTestReplaySupported(testFramework, frameworkVersion) {
      return testFramework === 'playwright'
        ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_FAILED_TEST_REPLAY[testFramework])
        : true
    }
    function getLibraryCapabilitiesTags(testFramework, isParallel, frameworkVersion) {
      return {
        [DD_CAPABILITIES_TEST_IMPACT_ANALYSIS]: isTiaSupported(testFramework, isParallel) ? '1' : void 0,
        [DD_CAPABILITIES_EARLY_FLAKE_DETECTION]: isEarlyFlakeDetectionSupported(testFramework, frameworkVersion)
          ? '1'
          : void 0,
        [DD_CAPABILITIES_AUTO_TEST_RETRIES]: '1',
        [DD_CAPABILITIES_IMPACTED_TESTS]: isImpactedTestsSupported(testFramework, frameworkVersion) ? '1' : void 0,
        [DD_CAPABILITIES_TEST_MANAGEMENT_QUARANTINE]: isQuarantineSupported(testFramework, frameworkVersion)
          ? '1'
          : void 0,
        [DD_CAPABILITIES_TEST_MANAGEMENT_DISABLE]: isDisableSupported(testFramework, frameworkVersion) ? '1' : void 0,
        [DD_CAPABILITIES_TEST_MANAGEMENT_ATTEMPT_TO_FIX]: isAttemptToFixSupported(
          testFramework,
          isParallel,
          frameworkVersion
        )
          ? '5'
          : void 0,
        [DD_CAPABILITIES_FAILED_TEST_REPLAY]: isFailedTestReplaySupported(testFramework, frameworkVersion)
          ? '1'
          : void 0,
      }
    }
    function getPullRequestBaseBranch(pullRequestBaseBranch) {
      const remoteName = getGitRemoteName()
      const sourceBranch = getSourceBranch()
      const POSSIBLE_DEFAULT_BRANCHES = ['main', 'master']
      const candidateBranches = []
      if (pullRequestBaseBranch) {
        checkAndFetchBranch(pullRequestBaseBranch, remoteName)
        candidateBranches.push(pullRequestBaseBranch)
      } else {
        for (const branch of POSSIBLE_BASE_BRANCHES) {
          checkAndFetchBranch(branch, remoteName)
        }
        const localBranches = getLocalBranches(remoteName)
        for (const branch of localBranches) {
          const shortBranchName = branch.replace(new RegExp(`^${remoteName}/`), '')
          if (branch !== sourceBranch && BASE_LIKE_BRANCH_FILTER.test(shortBranchName)) {
            candidateBranches.push(branch)
          }
        }
      }
      if (candidateBranches.length === 1) {
        return getMergeBase(candidateBranches[0], sourceBranch)
      }
      const metrics = {}
      for (const candidate of candidateBranches) {
        const baseSha = getMergeBase(candidate, sourceBranch)
        if (!baseSha) {
          continue
        }
        const counts = getCounts(candidate, sourceBranch)
        if (!counts) {
          continue
        }
        const behind = counts.behind
        const ahead = counts.ahead
        metrics[candidate] = {
          behind,
          ahead,
          baseSha,
        }
      }
      function isDefaultBranch(branch) {
        return POSSIBLE_DEFAULT_BRANCHES.some(
          (defaultBranch) => branch === defaultBranch || branch === `${remoteName}/${defaultBranch}`
        )
      }
      if (Object.keys(metrics).length === 0) {
        return null
      }
      let bestBranch = null
      let bestScore = Infinity
      for (const branch of Object.keys(metrics)) {
        const score = metrics[branch].ahead
        if (score < bestScore) {
          bestScore = score
          bestBranch = branch
        } else if (score === bestScore && isDefaultBranch(branch)) {
          bestScore = score
          bestBranch = branch
        }
      }
      return bestBranch ? metrics[bestBranch].baseSha : null
    }
    function getPullRequestDiff(baseCommit, targetCommit) {
      if (!baseCommit) {
        return
      }
      return getGitDiff(baseCommit, targetCommit)
    }
    function getModifiedFilesFromDiff(diff) {
      if (!diff) return null
      const result = {}
      const filesRegex = /^diff --git a\/(?<file>.+) b\/(?<file2>.+)$/g
      const linesRegex = /^@@ -\d+(,\d+)? \+(?<start>\d+)(,(?<count>\d+))? @@/g
      let currentFile = null
      const lines = diff.split('\n')
      for (const line of lines) {
        const fileMatch = filesRegex.exec(line)
        if (fileMatch && fileMatch.groups.file) {
          currentFile = fileMatch.groups.file
          result[currentFile] = []
          continue
        }
        const lineMatch = linesRegex.exec(line)
        if (lineMatch && currentFile) {
          const start = Number(lineMatch.groups.start)
          const count = lineMatch.groups.count ? Number(lineMatch.groups.count) : 1
          for (let j = 0; j < count; j++) {
            result[currentFile].push(start + j)
          }
        }
        filesRegex.lastIndex = 0
        linesRegex.lastIndex = 0
      }
      if (Object.keys(result).length === 0) {
        return null
      }
      return result
    }
    function isModifiedTest(testPath, testStartLine, testEndLine, modifiedFiles, testFramework) {
      if (modifiedFiles === void 0) {
        return false
      }
      const lines = modifiedFiles[testPath]
      if (!lines) {
        return false
      }
      if (NOT_SUPPORTED_GRANULARITY_IMPACTED_TESTS_FRAMEWORKS.has(testFramework)) {
        return lines.length > 0
      }
      return lines.some((line) => line >= testStartLine && line <= testEndLine)
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js
var require_agentless_ci_visibility = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js'(exports2, module2) {
    'use strict'
    var { truncateSpan, normalizeSpan } = require_tags_processors()
    var { AgentEncoder } = require__()
    var { version: ddTraceVersion } = require_package()
    var { ITR_CORRELATION_ID } = require_test()
    var id = require_id()
    var { distributionMetric, TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS, TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT } =
      require_telemetry()
    var ENCODING_VERSION = 1
    var ALLOWED_CONTENT_TYPES = /* @__PURE__ */ new Set([
      'test_session_end',
      'test_module_end',
      'test_suite_end',
      'test',
    ])
    var TEST_SUITE_KEYS_LENGTH = 12
    var TEST_MODULE_KEYS_LENGTH = 11
    var TEST_SESSION_KEYS_LENGTH = 10
    var TEST_AND_SPAN_KEYS_LENGTH = 11
    var INTAKE_SOFT_LIMIT = 2 * 1024 * 1024
    function formatSpan(span) {
      let encodingVersion = ENCODING_VERSION
      if (span.type === 'test' && span.meta && span.meta.test_session_id) {
        encodingVersion = 2
      }
      return {
        type: ALLOWED_CONTENT_TYPES.has(span.type) ? span.type : 'span',
        version: encodingVersion,
        content: normalizeSpan(truncateSpan(span)),
      }
    }
    var AgentlessCiVisibilityEncoder = class extends AgentEncoder {
      constructor(writer, { runtimeId, service, env }) {
        super(writer, INTAKE_SOFT_LIMIT)
        this.runtimeId = runtimeId
        this.service = service
        this.env = env
        this._eventCount = 0
        this.metadataTags = {}
        this.reset()
      }
      addMetadataTags(tags) {
        ALLOWED_CONTENT_TYPES.forEach((type) => {
          if (tags[type]) {
            this.metadataTags[type] = {
              ...this.metadataTags[type],
              ...tags[type],
            }
          }
        })
      }
      _encodeTestSuite(bytes, content) {
        let keysLength = TEST_SUITE_KEYS_LENGTH
        const itrCorrelationId = content.meta[ITR_CORRELATION_ID]
        if (itrCorrelationId) {
          keysLength++
        }
        this._encodeMapPrefix(bytes, keysLength)
        this._encodeString(bytes, 'type')
        this._encodeString(bytes, content.type)
        this._encodeString(bytes, 'test_session_id')
        this._encodeId(bytes, content.trace_id)
        this._encodeString(bytes, 'test_module_id')
        this._encodeId(bytes, content.parent_id)
        this._encodeString(bytes, 'test_suite_id')
        this._encodeId(bytes, content.span_id)
        if (itrCorrelationId) {
          this._encodeString(bytes, ITR_CORRELATION_ID)
          this._encodeString(bytes, itrCorrelationId)
          delete content.meta[ITR_CORRELATION_ID]
        }
        this._encodeString(bytes, 'error')
        this._encodeNumber(bytes, content.error)
        this._encodeString(bytes, 'name')
        this._encodeString(bytes, content.name)
        this._encodeString(bytes, 'service')
        this._encodeString(bytes, content.service)
        this._encodeString(bytes, 'resource')
        this._encodeString(bytes, content.resource)
        this._encodeString(bytes, 'start')
        this._encodeNumber(bytes, content.start)
        this._encodeString(bytes, 'duration')
        this._encodeNumber(bytes, content.duration)
        this._encodeString(bytes, 'meta')
        this._encodeMap(bytes, content.meta)
        this._encodeString(bytes, 'metrics')
        this._encodeMap(bytes, content.metrics)
      }
      _encodeTestModule(bytes, content) {
        this._encodeMapPrefix(bytes, TEST_MODULE_KEYS_LENGTH)
        this._encodeString(bytes, 'type')
        this._encodeString(bytes, content.type)
        this._encodeString(bytes, 'test_session_id')
        this._encodeId(bytes, content.trace_id)
        this._encodeString(bytes, 'test_module_id')
        this._encodeId(bytes, content.span_id)
        this._encodeString(bytes, 'error')
        this._encodeNumber(bytes, content.error)
        this._encodeString(bytes, 'name')
        this._encodeString(bytes, content.name)
        this._encodeString(bytes, 'service')
        this._encodeString(bytes, content.service)
        this._encodeString(bytes, 'resource')
        this._encodeString(bytes, content.resource)
        this._encodeString(bytes, 'start')
        this._encodeNumber(bytes, content.start)
        this._encodeString(bytes, 'duration')
        this._encodeNumber(bytes, content.duration)
        this._encodeString(bytes, 'meta')
        this._encodeMap(bytes, content.meta)
        this._encodeString(bytes, 'metrics')
        this._encodeMap(bytes, content.metrics)
      }
      _encodeTestSession(bytes, content) {
        this._encodeMapPrefix(bytes, TEST_SESSION_KEYS_LENGTH)
        this._encodeString(bytes, 'type')
        this._encodeString(bytes, content.type)
        this._encodeString(bytes, 'test_session_id')
        this._encodeId(bytes, content.trace_id)
        this._encodeString(bytes, 'error')
        this._encodeNumber(bytes, content.error)
        this._encodeString(bytes, 'name')
        this._encodeString(bytes, content.name)
        this._encodeString(bytes, 'service')
        this._encodeString(bytes, content.service)
        this._encodeString(bytes, 'resource')
        this._encodeString(bytes, content.resource)
        this._encodeString(bytes, 'start')
        this._encodeNumber(bytes, content.start)
        this._encodeString(bytes, 'duration')
        this._encodeNumber(bytes, content.duration)
        this._encodeString(bytes, 'meta')
        this._encodeMap(bytes, content.meta)
        this._encodeString(bytes, 'metrics')
        this._encodeMap(bytes, content.metrics)
      }
      _encodeEventContent(bytes, content) {
        let totalKeysLength = TEST_AND_SPAN_KEYS_LENGTH
        if (content.meta.test_session_id) {
          totalKeysLength += 1
        }
        if (content.meta.test_module_id) {
          totalKeysLength += 1
        }
        if (content.meta.test_suite_id) {
          totalKeysLength += 1
        }
        const itrCorrelationId = content.meta[ITR_CORRELATION_ID]
        if (itrCorrelationId) {
          totalKeysLength += 1
        }
        if (content.type) {
          totalKeysLength += 1
        }
        this._encodeMapPrefix(bytes, totalKeysLength)
        if (content.type) {
          this._encodeString(bytes, 'type')
          this._encodeString(bytes, content.type)
        }
        this._encodeString(bytes, 'trace_id')
        this._encodeId(bytes, content.trace_id)
        this._encodeString(bytes, 'span_id')
        this._encodeId(bytes, content.span_id)
        this._encodeString(bytes, 'parent_id')
        this._encodeId(bytes, content.parent_id)
        this._encodeString(bytes, 'name')
        this._encodeString(bytes, content.name)
        this._encodeString(bytes, 'resource')
        this._encodeString(bytes, content.resource)
        this._encodeString(bytes, 'service')
        this._encodeString(bytes, content.service)
        this._encodeString(bytes, 'error')
        this._encodeNumber(bytes, content.error)
        this._encodeString(bytes, 'start')
        this._encodeNumber(bytes, content.start)
        this._encodeString(bytes, 'duration')
        this._encodeNumber(bytes, content.duration)
        if (content.meta.test_session_id) {
          this._encodeString(bytes, 'test_session_id')
          this._encodeId(bytes, id(content.meta.test_session_id, 10))
          delete content.meta.test_session_id
        }
        if (content.meta.test_module_id) {
          this._encodeString(bytes, 'test_module_id')
          this._encodeId(bytes, id(content.meta.test_module_id, 10))
          delete content.meta.test_module_id
        }
        if (content.meta.test_suite_id) {
          this._encodeString(bytes, 'test_suite_id')
          this._encodeId(bytes, id(content.meta.test_suite_id, 10))
          delete content.meta.test_suite_id
        }
        if (itrCorrelationId) {
          this._encodeString(bytes, ITR_CORRELATION_ID)
          this._encodeString(bytes, itrCorrelationId)
          delete content.meta[ITR_CORRELATION_ID]
        }
        this._encodeString(bytes, 'meta')
        this._encodeMap(bytes, content.meta)
        this._encodeString(bytes, 'metrics')
        this._encodeMap(bytes, content.metrics)
      }
      _encodeEvent(bytes, event) {
        this._encodeMapPrefix(bytes, Object.keys(event).length)
        this._encodeString(bytes, 'type')
        this._encodeString(bytes, event.type)
        this._encodeString(bytes, 'version')
        this._encodeNumber(bytes, event.version)
        this._encodeString(bytes, 'content')
        if (event.type === 'span' || event.type === 'test') {
          this._encodeEventContent(bytes, event.content)
        } else if (event.type === 'test_suite_end') {
          this._encodeTestSuite(bytes, event.content)
        } else if (event.type === 'test_module_end') {
          this._encodeTestModule(bytes, event.content)
        } else if (event.type === 'test_session_end') {
          this._encodeTestSession(bytes, event.content)
        }
      }
      _encode(bytes, trace) {
        if (this._isReset) {
          this._encodePayloadStart(bytes)
          this._isReset = false
        }
        const startTime = Date.now()
        const rawEvents = trace.map(formatSpan)
        const testSessionEvents = rawEvents.filter(
          (event) =>
            event.type === 'test_session_end' || event.type === 'test_suite_end' || event.type === 'test_module_end'
        )
        const isTestSessionTrace = !!testSessionEvents.length
        const events = isTestSessionTrace ? testSessionEvents : rawEvents
        this._eventCount += events.length
        for (const event of events) {
          this._encodeEvent(bytes, event)
        }
        distributionMetric(
          TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
          { endpoint: 'test_cycle' },
          Date.now() - startTime
        )
      }
      makePayload() {
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT, { endpoint: 'test_cycle' }, this._eventCount)
        const bytes = this._traceBytes
        const eventsOffset = this._eventsOffset
        const eventsCount = this._eventCount
        bytes.buffer[eventsOffset] = 221
        bytes.buffer[eventsOffset + 1] = eventsCount >> 24
        bytes.buffer[eventsOffset + 2] = eventsCount >> 16
        bytes.buffer[eventsOffset + 3] = eventsCount >> 8
        bytes.buffer[eventsOffset + 4] = eventsCount
        const traceSize = bytes.length
        const buffer = Buffer.allocUnsafe(traceSize)
        bytes.buffer.copy(buffer, 0, 0, traceSize)
        this.reset()
        return buffer
      }
      _encodePayloadStart(bytes) {
        const payload = {
          version: ENCODING_VERSION,
          metadata: {
            '*': {
              language: 'javascript',
              library_version: ddTraceVersion,
            },
            ...this.metadataTags,
          },
          events: [],
        }
        if (this.env) {
          payload.metadata['*'].env = this.env
        }
        if (this.runtimeId) {
          payload.metadata['*']['runtime-id'] = this.runtimeId
        }
        this._encodeMapPrefix(bytes, Object.keys(payload).length)
        this._encodeString(bytes, 'version')
        this._encodeNumber(bytes, payload.version)
        this._encodeString(bytes, 'metadata')
        this._encodeMapPrefix(bytes, Object.keys(payload.metadata).length)
        this._encodeString(bytes, '*')
        this._encodeMap(bytes, payload.metadata['*'])
        if (payload.metadata.test) {
          this._encodeString(bytes, 'test')
          this._encodeMap(bytes, payload.metadata.test)
        }
        if (payload.metadata.test_suite_end) {
          this._encodeString(bytes, 'test_suite_end')
          this._encodeMap(bytes, payload.metadata.test_suite_end)
        }
        if (payload.metadata.test_module_end) {
          this._encodeString(bytes, 'test_module_end')
          this._encodeMap(bytes, payload.metadata.test_module_end)
        }
        if (payload.metadata.test_session_end) {
          this._encodeString(bytes, 'test_session_end')
          this._encodeMap(bytes, payload.metadata.test_session_end)
        }
        this._encodeString(bytes, 'events')
        this._eventsOffset = bytes.length
        bytes.reserve(5)
      }
      reset() {
        this._reset()
        this._eventCount = 0
        this._isReset = true
      }
    }
    module2.exports = { AgentlessCiVisibilityEncoder }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js
var require_writer6 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var { safeJSONStringify } = require_util2()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var { AgentlessCiVisibilityEncoder } = require_agentless_ci_visibility()
    var BaseWriter = require_writer2()
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS,
      TELEMETRY_ENDPOINT_PAYLOAD_BYTES,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
      TELEMETRY_ENDPOINT_PAYLOAD_DROPPED,
    } = require_telemetry()
    var Writer = class extends BaseWriter {
      constructor({ url, tags, evpProxyPrefix = '' }) {
        super(...arguments)
        const { 'runtime-id': runtimeId, env, service } = tags
        this._url = url
        this._encoder = new AgentlessCiVisibilityEncoder(this, { runtimeId, env, service })
        this._evpProxyPrefix = evpProxyPrefix
      }
      _sendPayload(data, _, done) {
        const options = {
          path: '/api/v2/citestcycle',
          method: 'POST',
          headers: {
            'dd-api-key': getEnvironmentVariable('DD_API_KEY'),
            'Content-Type': 'application/msgpack',
          },
          timeout: 15e3,
          url: this._url,
        }
        if (this._evpProxyPrefix) {
          options.path = `${this._evpProxyPrefix}/api/v2/citestcycle`
          delete options.headers['dd-api-key']
          options.headers['X-Datadog-EVP-Subdomain'] = 'citestcycle-intake'
        }
        log.debug(() => `Request to the intake: ${safeJSONStringify(options)}`)
        const startRequestTime = Date.now()
        incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS, { endpoint: 'test_cycle' })
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_BYTES, { endpoint: 'test_cycle' }, Buffer.byteLength(data))
        request(data, options, (err, res, statusCode) => {
          distributionMetric(
            TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
            { endpoint: 'test_cycle' },
            Date.now() - startRequestTime
          )
          if (err) {
            incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS, { endpoint: 'test_cycle', statusCode })
            incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_DROPPED, { endpoint: 'test_cycle' })
            log.error('Error sending CI agentless payload', err)
            done()
            return
          }
          log.debug('Response from the intake:', res)
          done()
        })
      }
      addMetadataTags(tags) {
        this._encoder.addMetadataTags(tags)
      }
    }
    module2.exports = Writer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/form-data.js
var require_form_data = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/form-data.js'(exports2, module2) {
    'use strict'
    var { Readable } = require('stream')
    var id = require_id()
    var FormData = class extends Readable {
      constructor() {
        super()
        this._boundary = id().toString()
        this._data = []
      }
      append(key, value, options = {}) {
        this._appendBoundary()
        if (options.filename) {
          this._appendFile(key, value, options)
        } else {
          this._appendMetadata(key, value, options)
        }
      }
      size() {
        return this._data.reduce((size, chunk) => size + chunk.length, 0)
      }
      getHeaders() {
        return { 'Content-Type': 'multipart/form-data; boundary=' + this._boundary }
      }
      _appendBoundary() {
        this._data.push(`--${this._boundary}\r
`)
      }
      _appendMetadata(key, value) {
        this._data.push(`Content-Disposition: form-data; name="${key}"\r
\r
${value}\r
`)
      }
      _appendFile(key, value, { filename, contentType = 'application/octet-stream' }) {
        this._data.push(
          `Content-Disposition: form-data; name="${key}"; filename="${filename}"\r
`,
          `Content-Type: ${contentType}\r
\r
`,
          value,
          '\r\n'
        )
      }
      _read() {
        this.push(this._data.shift())
        if (this._data.length === 0) {
          this.push(`--${this._boundary}--\r
`)
          this.push(null)
        }
      }
    }
    module2.exports = FormData
  },
})

// node_modules/dd-trace/packages/dd-trace/src/encode/coverage-ci-visibility.js
var require_coverage_ci_visibility = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/encode/coverage-ci-visibility.js'(exports2, module2) {
    'use strict'
    var { AgentEncoder } = require__()
    var { MsgpackChunk } = require_msgpack()
    var { distributionMetric, TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS, TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT } =
      require_telemetry()
    var FormData = require_form_data()
    var COVERAGE_PAYLOAD_VERSION = 2
    var COVERAGE_KEYS_LENGTH = 2
    var CoverageCIVisibilityEncoder = class extends AgentEncoder {
      constructor() {
        super(...arguments)
        this._coverageBytes = new MsgpackChunk()
        this.form = new FormData()
        this._coveragesCount = 0
        this.reset()
      }
      count() {
        return this._coveragesCount
      }
      encode(coverage) {
        const startTime = Date.now()
        this._coveragesCount++
        this.encodeCodeCoverage(this._coverageBytes, coverage)
        distributionMetric(
          TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
          { endpoint: 'code_coverage' },
          Date.now() - startTime
        )
      }
      encodeCodeCoverage(bytes, coverage) {
        if (coverage.testId) {
          this._encodeMapPrefix(bytes, 4)
        } else {
          this._encodeMapPrefix(bytes, 3)
        }
        this._encodeString(bytes, 'test_session_id')
        this._encodeId(bytes, coverage.sessionId)
        this._encodeString(bytes, 'test_suite_id')
        this._encodeId(bytes, coverage.suiteId)
        if (coverage.testId) {
          this._encodeString(bytes, 'span_id')
          this._encodeId(bytes, coverage.testId)
        }
        this._encodeString(bytes, 'files')
        this._encodeArrayPrefix(bytes, coverage.files)
        for (const filename of coverage.files) {
          this._encodeMapPrefix(bytes, 1)
          this._encodeString(bytes, 'filename')
          this._encodeString(bytes, filename)
        }
      }
      reset() {
        this._reset()
        if (this._coverageBytes) {
          this._coverageBytes.length = 0
        }
        this._coveragesCount = 0
        this._encodePayloadStart(this._coverageBytes)
      }
      _encodePayloadStart(bytes) {
        const payload = {
          version: COVERAGE_PAYLOAD_VERSION,
          coverages: [],
        }
        this._encodeMapPrefix(bytes, COVERAGE_KEYS_LENGTH)
        this._encodeString(bytes, 'version')
        this._encodeInteger(bytes, payload.version)
        this._encodeString(bytes, 'coverages')
        this._coveragesOffset = bytes.length
        bytes.reserve(5)
      }
      makePayload() {
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT, { endpoint: 'code_coverage' }, this._coveragesCount)
        const bytes = this._coverageBytes
        const coveragesOffset = this._coveragesOffset
        const coveragesCount = this._coveragesCount
        bytes.buffer[coveragesOffset] = 221
        bytes.buffer[coveragesOffset + 1] = coveragesCount >> 24
        bytes.buffer[coveragesOffset + 2] = coveragesCount >> 16
        bytes.buffer[coveragesOffset + 3] = coveragesCount >> 8
        bytes.buffer[coveragesOffset + 4] = coveragesCount
        const traceSize = bytes.length
        const buffer = Buffer.allocUnsafe(traceSize)
        bytes.buffer.copy(buffer, 0, 0, bytes.length)
        this.form.append('coverage1', buffer, {
          filename: 'coverage1.msgpack',
          contentType: 'application/msgpack',
        })
        this.form.append(
          'event',
          // The intake requires a populated dictionary here. Simply having {} is not valid.
          // We use dummy: true but any other key/value pair would be valid.
          JSON.stringify({ dummy: true }),
          { filename: 'event.json', contentType: 'application/json' }
        )
        const form = this.form
        this.form = new FormData()
        this.reset()
        return form
      }
    }
    module2.exports = { CoverageCIVisibilityEncoder }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/coverage-writer.js
var require_coverage_writer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/coverage-writer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var request = require_request()
    var log = require_log2()
    var { safeJSONStringify } = require_util2()
    var { getEnvironmentVariable } = require_config_helper()
    var { CoverageCIVisibilityEncoder } = require_coverage_ci_visibility()
    var BaseWriter = require_writer2()
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS,
      TELEMETRY_ENDPOINT_PAYLOAD_BYTES,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
      TELEMETRY_ENDPOINT_PAYLOAD_DROPPED,
    } = require_telemetry()
    var Writer = class extends BaseWriter {
      constructor({ url, evpProxyPrefix = '' }) {
        super(...arguments)
        this._url = url
        this._encoder = new CoverageCIVisibilityEncoder(this)
        this._evpProxyPrefix = evpProxyPrefix
      }
      _sendPayload(form, _, done) {
        const options = {
          path: '/api/v2/citestcov',
          method: 'POST',
          headers: {
            'dd-api-key': getEnvironmentVariable('DD_API_KEY'),
            ...form.getHeaders(),
          },
          timeout: 15e3,
          url: this._url,
        }
        if (this._evpProxyPrefix) {
          options.path = `${this._evpProxyPrefix}/api/v2/citestcov`
          delete options.headers['dd-api-key']
          options.headers['X-Datadog-EVP-Subdomain'] = 'citestcov-intake'
        }
        log.debug(() => `Request to the intake: ${safeJSONStringify(options)}`)
        const startRequestTime = Date.now()
        incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS, { endpoint: 'code_coverage' })
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_BYTES, { endpoint: 'code_coverage' }, form.size())
        request(form, options, (err, res, statusCode) => {
          distributionMetric(
            TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
            { endpoint: 'code_coverage' },
            Date.now() - startRequestTime
          )
          if (err) {
            incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS, { endpoint: 'code_coverage', statusCode })
            incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_DROPPED, { endpoint: 'code_coverage' })
            log.error('Error sending CI coverage payload', err)
            done()
            return
          }
          log.debug('Response from the intake:', res)
          done()
        })
      }
    }
    module2.exports = Writer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/git/git_metadata.js
var require_git_metadata = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/git/git_metadata.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var path = require('path')
    var FormData = require_form_data()
    var request = require_request()
    var { getEnvironmentVariable } = require_config_helper()
    var log = require_log2()
    var { isFalse } = require_util()
    var {
      getLatestCommits,
      getRepositoryUrl,
      generatePackFilesForCommits,
      getCommitsRevList,
      isShallowRepository,
      unshallowRepository,
      isGitAvailable,
    } = require_git()
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES,
    } = require_telemetry()
    var isValidSha1 = (sha) => /^[0-9a-f]{40}$/.test(sha)
    var isValidSha256 = (sha) => /^[0-9a-f]{64}$/.test(sha)
    function validateCommits(commits) {
      return commits.map(({ id: commitSha, type }) => {
        if (type !== 'commit') {
          throw new Error('Invalid commit type response')
        }
        if (isValidSha1(commitSha) || isValidSha256(commitSha)) {
          return commitSha.replaceAll(/[^0-9a-f]+/g, '')
        }
        throw new Error('Invalid commit format')
      })
    }
    function getCommonRequestOptions(url) {
      return {
        method: 'POST',
        headers: {
          'dd-api-key': getEnvironmentVariable('DD_API_KEY'),
        },
        timeout: 15e3,
        url,
      }
    }
    function getCommitsToUpload({ url, repositoryUrl, latestCommits, isEvpProxy, evpProxyPrefix }, callback) {
      const commonOptions = getCommonRequestOptions(url)
      const options = {
        ...commonOptions,
        headers: {
          ...commonOptions.headers,
          'Content-Type': 'application/json',
        },
        path: '/api/v2/git/repository/search_commits',
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/git/repository/search_commits`
        options.headers['X-Datadog-EVP-Subdomain'] = 'api'
        delete options.headers['dd-api-key']
      }
      const localCommitData = JSON.stringify({
        meta: {
          repository_url: repositoryUrl,
        },
        data: latestCommits.map((commit) => ({
          id: commit,
          type: 'commit',
        })),
      })
      incrementCountMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS)
      const startTime = Date.now()
      request(localCommitData, options, (err, response, statusCode) => {
        distributionMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS, {}, Date.now() - startTime)
        if (err) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS, { statusCode })
          const error = new Error(`Error fetching commits to exclude: ${err.message}`)
          return callback(error)
        }
        let alreadySeenCommits
        try {
          alreadySeenCommits = validateCommits(JSON.parse(response).data)
        } catch (e) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS, { errorType: 'network' })
          return callback(new Error(`Can't parse commits to exclude response: ${e.message}`))
        }
        log.debug('There are %s commits to exclude.', alreadySeenCommits.length)
        const commitsToInclude = latestCommits.filter((commit) => !alreadySeenCommits.includes(commit))
        log.debug('There are %s commits to include.', commitsToInclude.length)
        if (!commitsToInclude.length) {
          return callback(null, [])
        }
        const commitsToUpload = getCommitsRevList(alreadySeenCommits, commitsToInclude)
        if (commitsToUpload === null) {
          return callback(new Error('git rev-list failed'))
        }
        callback(null, commitsToUpload)
      })
    }
    function uploadPackFile(
      { url, isEvpProxy, evpProxyPrefix, packFileToUpload, repositoryUrl, headCommit },
      callback
    ) {
      const form = new FormData()
      const pushedSha = JSON.stringify({
        data: {
          id: headCommit,
          type: 'commit',
        },
        meta: {
          repository_url: repositoryUrl,
        },
      })
      form.append('pushedSha', pushedSha, { contentType: 'application/json' })
      try {
        const packFileContent = fs.readFileSync(packFileToUpload)
        const [, filename] = path.basename(packFileToUpload).split('-')
        form.append('packfile', packFileContent, {
          filename,
          contentType: 'application/octet-stream',
        })
      } catch {
        callback(new Error(`Could not read "${packFileToUpload}"`))
        return
      }
      const commonOptions = getCommonRequestOptions(url)
      const options = {
        ...commonOptions,
        path: '/api/v2/git/repository/packfile',
        headers: {
          ...commonOptions.headers,
          ...form.getHeaders(),
        },
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/git/repository/packfile`
        options.headers['X-Datadog-EVP-Subdomain'] = 'api'
        delete options.headers['dd-api-key']
      }
      incrementCountMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES)
      const uploadSize = form.size()
      const startTime = Date.now()
      request(form, options, (err, _, statusCode) => {
        distributionMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS, {}, Date.now() - startTime)
        if (err) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS, { statusCode })
          const error = new Error(`Could not upload packfiles: status code ${statusCode}: ${err.message}`)
          return callback(error, uploadSize)
        }
        callback(null, uploadSize)
      })
    }
    function generateAndUploadPackFiles(
      { url, isEvpProxy, evpProxyPrefix, commitsToUpload, repositoryUrl, headCommit },
      callback
    ) {
      log.debug('There are %s commits to upload', commitsToUpload.length)
      const packFilesToUpload = generatePackFilesForCommits(commitsToUpload)
      log.debug('Uploading %s packfiles.', packFilesToUpload.length)
      if (!packFilesToUpload.length) {
        return callback(new Error('Failed to generate packfiles'))
      }
      distributionMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM, {}, packFilesToUpload.length)
      let packFileIndex = 0
      let totalUploadedBytes = 0
      const uploadPackFileCallback = (err, byteLength) => {
        totalUploadedBytes += byteLength
        if (err || packFileIndex === packFilesToUpload.length) {
          distributionMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES, {}, totalUploadedBytes)
          return callback(err)
        }
        return uploadPackFile(
          {
            packFileToUpload: packFilesToUpload[packFileIndex++],
            url,
            isEvpProxy,
            evpProxyPrefix,
            repositoryUrl,
            headCommit,
          },
          uploadPackFileCallback
        )
      }
      uploadPackFile(
        {
          packFileToUpload: packFilesToUpload[packFileIndex++],
          url,
          isEvpProxy,
          evpProxyPrefix,
          repositoryUrl,
          headCommit,
        },
        uploadPackFileCallback
      )
    }
    function sendGitMetadata(url, { isEvpProxy, evpProxyPrefix }, configRepositoryUrl, callback) {
      if (!isGitAvailable()) {
        return callback(new Error('Git is not available'))
      }
      let repositoryUrl = configRepositoryUrl
      if (!repositoryUrl) {
        repositoryUrl = getRepositoryUrl()
      }
      log.debug('Uploading git history for repository', repositoryUrl)
      if (!repositoryUrl) {
        return callback(new Error('Repository URL is empty'))
      }
      let latestCommits = getLatestCommits()
      log.debug('There were %s commits since last month.', latestCommits.length)
      const getOnFinishGetCommitsToUpload = (hasCheckedShallow) => (err, commitsToUpload) => {
        if (err) {
          return callback(err)
        }
        if (!commitsToUpload.length) {
          log.debug('No commits to upload')
          return callback(null)
        }
        if (hasCheckedShallow || !isShallowRepository()) {
          const [headCommit] = latestCommits
          return generateAndUploadPackFiles(
            {
              url,
              isEvpProxy,
              evpProxyPrefix,
              commitsToUpload,
              repositoryUrl,
              headCommit,
            },
            callback
          )
        }
        log.debug('It is shallow clone, unshallowing...')
        if (!isFalse(getEnvironmentVariable('DD_CIVISIBILITY_GIT_UNSHALLOW_ENABLED'))) {
          unshallowRepository(false)
        }
        latestCommits = getLatestCommits()
        getCommitsToUpload(
          {
            url,
            repositoryUrl,
            latestCommits,
            isEvpProxy,
            evpProxyPrefix,
          },
          getOnFinishGetCommitsToUpload(true)
        )
      }
      getCommitsToUpload(
        {
          url,
          repositoryUrl,
          latestCommits,
          isEvpProxy,
          evpProxyPrefix,
        },
        getOnFinishGetCommitsToUpload(false)
      )
    }
    module2.exports = {
      sendGitMetadata,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/requests/get-library-configuration.js
var require_get_library_configuration = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/requests/get-library-configuration.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var id = require_id()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_GIT_REQUESTS_SETTINGS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_MS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE,
    } = require_telemetry()
    var DEFAULT_EARLY_FLAKE_DETECTION_NUM_RETRIES = 2
    var DEFAULT_EARLY_FLAKE_DETECTION_ERROR_THRESHOLD = 30
    function getLibraryConfiguration(
      {
        url,
        isEvpProxy,
        evpProxyPrefix,
        env,
        service,
        repositoryUrl,
        sha,
        osVersion,
        osPlatform,
        osArchitecture,
        runtimeName,
        runtimeVersion,
        branch,
        testLevel = 'suite',
        custom,
        tag,
      },
      done
    ) {
      const options = {
        path: '/api/v2/libraries/tests/services/setting',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        url,
        timeout: 2e4,
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/libraries/tests/services/setting`
        options.headers['X-Datadog-EVP-Subdomain'] = 'api'
      } else {
        const apiKey = getEnvironmentVariable('DD_API_KEY')
        if (!apiKey) {
          return done(new Error('Request to settings endpoint was not done because Datadog API key is not defined.'))
        }
        options.headers['dd-api-key'] = apiKey
      }
      const data = JSON.stringify({
        data: {
          id: id().toString(10),
          type: 'ci_app_test_service_libraries_settings',
          attributes: {
            test_level: testLevel,
            configurations: {
              'os.platform': osPlatform,
              'os.version': osVersion,
              'os.architecture': osArchitecture,
              'runtime.name': runtimeName,
              'runtime.version': runtimeVersion,
              custom,
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha,
            branch: branch || tag,
          },
        },
      })
      incrementCountMetric(TELEMETRY_GIT_REQUESTS_SETTINGS)
      const startTime = Date.now()
      request(data, options, (err, res, statusCode) => {
        distributionMetric(TELEMETRY_GIT_REQUESTS_SETTINGS_MS, {}, Date.now() - startTime)
        if (err) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS, { statusCode })
          done(err)
        } else {
          try {
            const {
              data: {
                attributes: {
                  code_coverage: isCodeCoverageEnabled,
                  tests_skipping: isSuitesSkippingEnabled,
                  itr_enabled: isItrEnabled,
                  require_git: requireGit,
                  early_flake_detection: earlyFlakeDetectionConfig,
                  flaky_test_retries_enabled: isFlakyTestRetriesEnabled,
                  di_enabled: isDiEnabled,
                  known_tests_enabled: isKnownTestsEnabled,
                  test_management: testManagementConfig,
                  impacted_tests_enabled: isImpactedTestsEnabled,
                },
              },
            } = JSON.parse(res)
            const settings = {
              isCodeCoverageEnabled,
              isSuitesSkippingEnabled,
              isItrEnabled,
              requireGit,
              isEarlyFlakeDetectionEnabled: isKnownTestsEnabled && (earlyFlakeDetectionConfig?.enabled ?? false),
              earlyFlakeDetectionNumRetries:
                earlyFlakeDetectionConfig?.slow_test_retries?.['5s'] || DEFAULT_EARLY_FLAKE_DETECTION_NUM_RETRIES,
              earlyFlakeDetectionFaultyThreshold:
                earlyFlakeDetectionConfig?.faulty_session_threshold ?? DEFAULT_EARLY_FLAKE_DETECTION_ERROR_THRESHOLD,
              isFlakyTestRetriesEnabled,
              isDiEnabled: isDiEnabled && isFlakyTestRetriesEnabled,
              isKnownTestsEnabled,
              isTestManagementEnabled: testManagementConfig?.enabled ?? false,
              testManagementAttemptToFixRetries: testManagementConfig?.attempt_to_fix_retries,
              isImpactedTestsEnabled,
            }
            log.debug('Remote settings: %j', settings)
            if (getEnvironmentVariable('DD_CIVISIBILITY_DANGEROUSLY_FORCE_COVERAGE')) {
              settings.isCodeCoverageEnabled = true
              log.debug('Dangerously set code coverage to true')
            }
            if (getEnvironmentVariable('DD_CIVISIBILITY_DANGEROUSLY_FORCE_TEST_SKIPPING')) {
              settings.isSuitesSkippingEnabled = true
              log.debug('Dangerously set test skipping to true')
            }
            incrementCountMetric(TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE, settings)
            done(null, settings)
          } catch (err2) {
            done(err2)
          }
        }
      })
    }
    module2.exports = { getLibraryConfiguration }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-skippable-suites.js
var require_get_skippable_suites = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-skippable-suites.js'(
    exports2,
    module2
  ) {
    'use strict'
    var request = require_request()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_ITR_SKIPPABLE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_MS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES,
    } = require_telemetry()
    function getSkippableSuites(
      {
        url,
        isEvpProxy,
        evpProxyPrefix,
        isGzipCompatible,
        env,
        service,
        repositoryUrl,
        sha,
        osVersion,
        osPlatform,
        osArchitecture,
        runtimeName,
        runtimeVersion,
        custom,
        testLevel = 'suite',
      },
      done
    ) {
      const options = {
        path: '/api/v2/ci/tests/skippable',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: 2e4,
        url,
      }
      if (isGzipCompatible) {
        options.headers['accept-encoding'] = 'gzip'
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/ci/tests/skippable`
        options.headers['X-Datadog-EVP-Subdomain'] = 'api'
      } else {
        const apiKey = getEnvironmentVariable('DD_API_KEY')
        if (!apiKey) {
          return done(new Error('Skippable suites were not fetched because Datadog API key is not defined.'))
        }
        options.headers['dd-api-key'] = apiKey
      }
      const data = JSON.stringify({
        data: {
          type: 'test_params',
          attributes: {
            test_level: testLevel,
            configurations: {
              'os.platform': osPlatform,
              'os.version': osVersion,
              'os.architecture': osArchitecture,
              'runtime.name': runtimeName,
              'runtime.version': runtimeVersion,
              custom,
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha,
          },
        },
      })
      incrementCountMetric(TELEMETRY_ITR_SKIPPABLE_TESTS)
      const startTime = Date.now()
      request(data, options, (err, res, statusCode) => {
        distributionMetric(TELEMETRY_ITR_SKIPPABLE_TESTS_MS, {}, Date.now() - startTime)
        if (err) {
          incrementCountMetric(TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS, { statusCode })
          done(err)
        } else {
          try {
            const parsedResponse = JSON.parse(res)
            const skippableSuites = parsedResponse.data
              .filter(({ type }) => type === testLevel)
              .map(({ attributes: { suite, name } }) => {
                if (testLevel === 'suite') {
                  return suite
                }
                return { suite, name }
              })
            const {
              meta: { correlation_id: correlationId },
            } = parsedResponse
            incrementCountMetric(
              testLevel === 'test'
                ? TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS
                : TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES,
              {},
              skippableSuites.length
            )
            distributionMetric(TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES, {}, res.length)
            log.debug('Number of received skippable %ss:', testLevel, skippableSuites.length)
            done(null, skippableSuites, correlationId)
          } catch (err2) {
            done(err2)
          }
        }
      })
    }
    module2.exports = { getSkippableSuites }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/early-flake-detection/get-known-tests.js
var require_get_known_tests = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/early-flake-detection/get-known-tests.js'(
    exports2,
    module2
  ) {
    'use strict'
    var request = require_request()
    var id = require_id()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_KNOWN_TESTS,
      TELEMETRY_KNOWN_TESTS_MS,
      TELEMETRY_KNOWN_TESTS_ERRORS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES,
    } = require_telemetry()
    var { getNumFromKnownTests } = require_test()
    function getKnownTests(
      {
        url,
        isEvpProxy,
        evpProxyPrefix,
        isGzipCompatible,
        env,
        service,
        repositoryUrl,
        sha,
        osVersion,
        osPlatform,
        osArchitecture,
        runtimeName,
        runtimeVersion,
        custom,
      },
      done
    ) {
      const options = {
        path: '/api/v2/ci/libraries/tests',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: 2e4,
        url,
      }
      if (isGzipCompatible) {
        options.headers['accept-encoding'] = 'gzip'
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/ci/libraries/tests`
        options.headers['X-Datadog-EVP-Subdomain'] = 'api'
      } else {
        const apiKey = getEnvironmentVariable('DD_API_KEY')
        if (!apiKey) {
          return done(new Error('Known tests were not fetched because Datadog API key is not defined.'))
        }
        options.headers['dd-api-key'] = apiKey
      }
      const data = JSON.stringify({
        data: {
          id: id().toString(10),
          type: 'ci_app_libraries_tests_request',
          attributes: {
            configurations: {
              'os.platform': osPlatform,
              'os.version': osVersion,
              'os.architecture': osArchitecture,
              'runtime.name': runtimeName,
              'runtime.version': runtimeVersion,
              custom,
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha,
          },
        },
      })
      incrementCountMetric(TELEMETRY_KNOWN_TESTS)
      const startTime = Date.now()
      request(data, options, (err, res, statusCode) => {
        distributionMetric(TELEMETRY_KNOWN_TESTS_MS, {}, Date.now() - startTime)
        if (err) {
          incrementCountMetric(TELEMETRY_KNOWN_TESTS_ERRORS, { statusCode })
          done(err)
        } else {
          try {
            const {
              data: {
                attributes: { tests: knownTests },
              },
            } = JSON.parse(res)
            const numTests = getNumFromKnownTests(knownTests)
            incrementCountMetric(TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS, {}, numTests)
            distributionMetric(TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES, {}, res.length)
            log.debug('Number of received known tests:', numTests)
            done(null, knownTests)
          } catch (err2) {
            done(err2)
          }
        }
      })
    }
    module2.exports = { getKnownTests }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/test-management/get-test-management-tests.js
var require_get_test_management_tests = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/test-management/get-test-management-tests.js'(
    exports2,
    module2
  ) {
    'use strict'
    var request = require_request()
    var id = require_id()
    var { getEnvironmentVariable } = require_config_helper()
    var log = require_log2()
    function getTestManagementTests(
      {
        url,
        isEvpProxy,
        evpProxyPrefix,
        isGzipCompatible,
        repositoryUrl,
        commitMessage,
        sha,
        commitHeadSha,
        commitHeadMessage,
        branch,
      },
      done
    ) {
      const options = {
        path: '/api/v2/test/libraries/test-management/tests',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: 2e4,
        url,
      }
      if (isGzipCompatible) {
        options.headers['accept-encoding'] = 'gzip'
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/test/libraries/test-management/tests`
        options.headers['X-Datadog-EVP-Subdomain'] = 'api'
      } else {
        const apiKey = getEnvironmentVariable('DD_API_KEY')
        if (!apiKey) {
          return done(new Error('Test management tests were not fetched because Datadog API key is not defined.'))
        }
        options.headers['dd-api-key'] = apiKey
      }
      const data = JSON.stringify({
        data: {
          id: id().toString(10),
          type: 'ci_app_libraries_tests_request',
          attributes: {
            repository_url: repositoryUrl,
            commit_message: commitHeadMessage || commitMessage,
            sha: commitHeadSha || sha,
            branch,
          },
        },
      })
      log.debug('Requesting test management tests: %s', data)
      request(data, options, (err, res) => {
        if (err) {
          done(err)
        } else {
          try {
            const {
              data: {
                attributes: { modules: testManagementTests },
              },
            } = JSON.parse(res)
            log.debug('Test management tests received: %j', testManagementTests)
            done(null, testManagementTests)
          } catch (err2) {
            done(err2)
          }
        }
      })
    }
    module2.exports = { getTestManagementTests }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/agent-info-exporter.js
var require_agent_info_exporter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporters/common/agent-info-exporter.js'(exports2, module2) {
    'use strict'
    var { URL: URL2, format } = require('url')
    var request = require_request()
    var defaults = require_config_defaults()
    var { incrementCountMetric, TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION } = require_telemetry()
    function fetchAgentInfo(url, callback) {
      request(
        '',
        {
          path: '/info',
          url,
        },
        (err, res) => {
          if (err) {
            return callback(err)
          }
          try {
            const response = JSON.parse(res)
            return callback(null, response)
          } catch (e) {
            return callback(e)
          }
        }
      )
    }
    var AgentInfoExporter = class {
      constructor(tracerConfig) {
        this._config = tracerConfig
        const { url, hostname = defaults.hostname, port } = this._config
        this._url =
          url ||
          new URL2(
            format({
              protocol: 'http:',
              hostname,
              port,
            })
          )
        this._traceBuffer = []
        this._isInitialized = false
      }
      getAgentInfo(onReceivedInfo) {
        fetchAgentInfo(this._url, onReceivedInfo)
      }
      export(trace) {
        if (!this._isInitialized) {
          this._traceBuffer.push(trace)
          return
        }
        this._export(trace)
      }
      _export(payload, writer = this._writer, timerKey = '_timer') {
        if (this._config.isCiVisibility) {
          incrementCountMetric(TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION, {}, payload.length)
        }
        writer.append(payload)
        const { flushInterval } = this._config
        if (flushInterval === 0) {
          writer.flush()
        } else if (this[timerKey] === void 0) {
          this[timerKey] = setTimeout(() => {
            writer.flush()
            this[timerKey] = void 0
          }, flushInterval).unref()
        }
      }
      getUncodedTraces() {
        return this._traceBuffer
      }
      exportUncodedTraces() {
        this.getUncodedTraces().forEach((uncodedTrace) => {
          this.export(uncodedTrace)
        })
        this.resetUncodedTraces()
      }
      resetUncodedTraces() {
        this._traceBuffer = []
      }
    }
    module2.exports = AgentInfoExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/ci-visibility-exporter.js
var require_ci_visibility_exporter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/ci-visibility-exporter.js'(exports2, module2) {
    'use strict'
    var URL2 = require('url').URL
    var { sendGitMetadata: sendGitMetadataRequest } = require_git_metadata()
    var { getLibraryConfiguration: getLibraryConfigurationRequest } = require_get_library_configuration()
    var { getSkippableSuites: getSkippableSuitesRequest } = require_get_skippable_suites()
    var { getKnownTests: getKnownTestsRequest } = require_get_known_tests()
    var { getTestManagementTests: getTestManagementTestsRequest } = require_get_test_management_tests()
    var log = require_log2()
    var AgentInfoExporter = require_agent_info_exporter()
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2()
    function getTestConfigurationTags(tags) {
      if (!tags) {
        return {}
      }
      return Object.keys(tags).reduce((acc, key) => {
        if (key.startsWith('test.configuration.')) {
          const [, configKey] = key.split('test.configuration.')
          acc[configKey] = tags[key]
        }
        return acc
      }, {})
    }
    function getIsTestSessionTrace(trace) {
      return trace.some(
        (span) => span.type === 'test_session_end' || span.type === 'test_suite_end' || span.type === 'test_module_end'
      )
    }
    var GIT_UPLOAD_TIMEOUT = 6e4
    var CAN_USE_CI_VIS_PROTOCOL_TIMEOUT = GIT_UPLOAD_TIMEOUT
    var CiVisibilityExporter = class extends AgentInfoExporter {
      constructor(config) {
        super(config)
        this._timer = void 0
        this._coverageTimer = void 0
        this._logsTimer = void 0
        this._coverageBuffer = []
        this._canUseCiVisProtocol = false
        const gitUploadTimeoutId = setTimeout(() => {
          this._resolveGit(new Error('Timeout while uploading git metadata'))
        }, GIT_UPLOAD_TIMEOUT).unref()
        const canUseCiVisProtocolTimeoutId = setTimeout(() => {
          this._resolveCanUseCiVisProtocol(false)
        }, CAN_USE_CI_VIS_PROTOCOL_TIMEOUT).unref()
        this._gitUploadPromise = new Promise((resolve) => {
          this._resolveGit = (err) => {
            clearTimeout(gitUploadTimeoutId)
            resolve(err)
          }
        })
        this._canUseCiVisProtocolPromise = new Promise((resolve) => {
          this._resolveCanUseCiVisProtocol = (canUseCiVisProtocol) => {
            clearTimeout(canUseCiVisProtocolTimeoutId)
            this._canUseCiVisProtocol = canUseCiVisProtocol
            resolve(canUseCiVisProtocol)
          }
        })
        process.once('beforeExit', () => {
          if (this._writer) {
            this._writer.flush()
          }
          if (this._coverageWriter) {
            this._coverageWriter.flush()
          }
          if (this._logsWriter) {
            this._logsWriter.flush()
          }
        })
      }
      shouldRequestSkippableSuites() {
        return !!(
          this._config.isIntelligentTestRunnerEnabled &&
          this._canUseCiVisProtocol &&
          this._libraryConfig?.isSuitesSkippingEnabled
        )
      }
      shouldRequestKnownTests() {
        return !!(this._canUseCiVisProtocol && this._libraryConfig?.isKnownTestsEnabled)
      }
      shouldRequestTestManagementTests() {
        return !!(
          this._canUseCiVisProtocol &&
          this._config.isTestManagementEnabled &&
          this._libraryConfig?.isTestManagementEnabled
        )
      }
      shouldRequestLibraryConfiguration() {
        return this._config.isIntelligentTestRunnerEnabled
      }
      canReportSessionTraces() {
        return this._canUseCiVisProtocol
      }
      canReportCodeCoverage() {
        return this._canUseCiVisProtocol
      }
      getRequestConfiguration(testConfiguration) {
        return {
          url: this._getApiUrl(),
          env: this._config.env,
          service: this._config.service,
          isEvpProxy: !!this._isUsingEvpProxy,
          isGzipCompatible: this._isGzipCompatible,
          evpProxyPrefix: this.evpProxyPrefix,
          custom: getTestConfigurationTags(this._config.tags),
          ...testConfiguration,
        }
      }
      // We can't call the skippable endpoint until git upload has finished,
      // hence the this._gitUploadPromise.then
      getSkippableSuites(testConfiguration, callback) {
        if (!this.shouldRequestSkippableSuites()) {
          return callback(null, [])
        }
        this._gitUploadPromise.then((gitUploadError) => {
          if (gitUploadError) {
            return callback(gitUploadError, [])
          }
          getSkippableSuitesRequest(this.getRequestConfiguration(testConfiguration), callback)
        })
      }
      getKnownTests(testConfiguration, callback) {
        if (!this.shouldRequestKnownTests()) {
          return callback(null)
        }
        getKnownTestsRequest(this.getRequestConfiguration(testConfiguration), callback)
      }
      getTestManagementTests(testConfiguration, callback) {
        if (!this.shouldRequestTestManagementTests()) {
          return callback(null)
        }
        getTestManagementTestsRequest(this.getRequestConfiguration(testConfiguration), callback)
      }
      /**
       * We can't request library configuration until we know whether we can use the
       * CI Visibility Protocol, hence the this._canUseCiVisProtocol promise.
       */
      getLibraryConfiguration(testConfiguration, callback) {
        const { repositoryUrl } = testConfiguration
        this.sendGitMetadata(repositoryUrl)
        if (!this.shouldRequestLibraryConfiguration()) {
          return callback(null, {})
        }
        this._canUseCiVisProtocolPromise.then((canUseCiVisProtocol) => {
          if (!canUseCiVisProtocol) {
            return callback(null, {})
          }
          const configuration = this.getRequestConfiguration(testConfiguration)
          getLibraryConfigurationRequest(configuration, (err, libraryConfig) => {
            this._libraryConfig = this.filterConfiguration(libraryConfig)
            if (err) {
              callback(err, {})
            } else if (libraryConfig?.requireGit) {
              this._gitUploadPromise.then((gitUploadError) => {
                if (gitUploadError) {
                  return callback(gitUploadError, {})
                }
                getLibraryConfigurationRequest(configuration, (err2, finalLibraryConfig) => {
                  this._libraryConfig = this.filterConfiguration(finalLibraryConfig)
                  callback(err2, this._libraryConfig)
                })
              })
            } else {
              callback(null, this._libraryConfig)
            }
          })
        })
      }
      // Takes into account potential kill switches
      filterConfiguration(remoteConfiguration) {
        if (!remoteConfiguration) {
          return {}
        }
        const {
          isCodeCoverageEnabled,
          isSuitesSkippingEnabled,
          isItrEnabled,
          requireGit,
          isEarlyFlakeDetectionEnabled,
          earlyFlakeDetectionNumRetries,
          earlyFlakeDetectionFaultyThreshold,
          isFlakyTestRetriesEnabled,
          isDiEnabled,
          isKnownTestsEnabled,
          isTestManagementEnabled,
          testManagementAttemptToFixRetries,
          isImpactedTestsEnabled,
        } = remoteConfiguration
        return {
          isCodeCoverageEnabled,
          isSuitesSkippingEnabled,
          isItrEnabled,
          requireGit,
          isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled && this._config.isEarlyFlakeDetectionEnabled,
          earlyFlakeDetectionNumRetries,
          earlyFlakeDetectionFaultyThreshold,
          isFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled && this._config.isFlakyTestRetriesEnabled,
          flakyTestRetriesCount: this._config.flakyTestRetriesCount,
          isDiEnabled: isDiEnabled && this._config.isTestDynamicInstrumentationEnabled,
          isKnownTestsEnabled,
          isTestManagementEnabled: isTestManagementEnabled && this._config.isTestManagementEnabled,
          testManagementAttemptToFixRetries:
            testManagementAttemptToFixRetries ?? this._config.testManagementAttemptToFixRetries,
          isImpactedTestsEnabled: isImpactedTestsEnabled && this._config.isImpactedTestsEnabled,
        }
      }
      sendGitMetadata(repositoryUrl) {
        if (!this._config.isGitUploadEnabled) {
          return
        }
        this._canUseCiVisProtocolPromise.then((canUseCiVisProtocol) => {
          if (!canUseCiVisProtocol) {
            return
          }
          sendGitMetadataRequest(
            this._getApiUrl(),
            { isEvpProxy: !!this._isUsingEvpProxy, evpProxyPrefix: this.evpProxyPrefix },
            repositoryUrl,
            (err) => {
              if (err) {
                log.error('Error uploading git metadata: %s', err.message)
              } else {
                log.debug('Successfully uploaded git metadata')
              }
              this._resolveGit(err)
            }
          )
        })
      }
      export(trace) {
        if (!this._isInitialized) {
          this._traceBuffer.push(trace)
          return
        }
        if (!this.canReportSessionTraces() && getIsTestSessionTrace(trace)) {
          return
        }
        this._export(trace)
      }
      exportCoverage(formattedCoverage) {
        if (!this._isInitialized) {
          this._coverageBuffer.push(formattedCoverage)
          return
        }
        if (!this.canReportCodeCoverage()) {
          return
        }
        this._export(formattedCoverage, this._coverageWriter, '_coverageTimer')
      }
      formatLogMessage(testEnvironmentMetadata, logMessage) {
        const { [GIT_REPOSITORY_URL]: gitRepositoryUrl, [GIT_COMMIT_SHA]: gitCommitSha } = testEnvironmentMetadata
        const { service, env, version } = this._config
        return {
          ddtags: [
            ...(logMessage.ddtags || []),
            `${GIT_REPOSITORY_URL}:${gitRepositoryUrl}`,
            `${GIT_COMMIT_SHA}:${gitCommitSha}`,
          ].join(','),
          level: 'error',
          service,
          dd: {
            ...(logMessage.dd || []),
            service,
            env,
            version,
          },
          ddsource: 'dd_debugger',
          ...logMessage,
        }
      }
      // DI logs
      exportDiLogs(testEnvironmentMetadata, logMessage) {
        if (!this._config.isTestDynamicInstrumentationEnabled || !this._isInitialized || !this._canForwardLogs) {
          return
        }
        this._export(this.formatLogMessage(testEnvironmentMetadata, logMessage), this._logsWriter, '_logsTimer')
      }
      flush(done = () => {}) {
        if (!this._isInitialized) {
          return done()
        }
        const writers = [this._writer, this._coverageWriter, this._logsWriter].filter(Boolean)
        let remaining = writers.length
        if (remaining === 0) {
          return done()
        }
        const onFlushComplete = () => {
          remaining -= 1
          if (remaining === 0) {
            done()
          }
        }
        writers.forEach((writer) => writer.flush(onFlushComplete))
      }
      exportUncodedCoverages() {
        this._coverageBuffer.forEach((oldCoveragePayload) => {
          this.exportCoverage(oldCoveragePayload)
        })
        this._coverageBuffer = []
      }
      _setUrl(url, coverageUrl = url) {
        try {
          url = new URL2(url)
          coverageUrl = new URL2(coverageUrl)
          this._url = url
          this._coverageUrl = coverageUrl
          this._writer.setUrl(url)
          this._coverageWriter.setUrl(coverageUrl)
        } catch (e) {
          log.error('Error setting CI exporter url', e)
        }
      }
      _getApiUrl() {
        return this._url
      }
      // By the time addMetadataTags is called, the agent info request might not have finished
      addMetadataTags(tags) {
        if (this._writer?.addMetadataTags) {
          this._writer.addMetadataTags(tags)
        } else {
          this._canUseCiVisProtocolPromise.then(() => {
            if (this._writer?.addMetadataTags) {
              this._writer.addMetadataTags(tags)
            }
          })
        }
      }
    }
    module2.exports = CiVisibilityExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/encode/json-encoder.js
var require_json_encoder = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/encode/json-encoder.js'(exports2, module2) {
    'use strict'
    var JSONEncoder = class {
      constructor() {
        this.payloads = []
      }
      encode(payload) {
        this.payloads.push(payload)
      }
      count() {
        return this.payloads.length
      }
      reset() {
        this.payloads = []
      }
      makePayload() {
        const data = JSON.stringify(this.payloads)
        this.reset()
        return data
      }
    }
    module2.exports = { JSONEncoder }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/di-logs-writer.js
var require_di_logs_writer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/di-logs-writer.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var log = require_log2()
    var { safeJSONStringify } = require_util2()
    var { JSONEncoder } = require_json_encoder()
    var { getEnvironmentVariable } = require_config_helper()
    var BaseWriter = require_writer2()
    var DynamicInstrumentationLogsWriter = class extends BaseWriter {
      constructor({ url, timeout, isAgentProxy = false }) {
        super(...arguments)
        this._url = url
        this._encoder = new JSONEncoder()
        this._isAgentProxy = isAgentProxy
        this.timeout = timeout
      }
      _sendPayload(data, _, done) {
        const options = {
          path: '/api/v2/logs',
          method: 'POST',
          headers: {
            'dd-api-key': getEnvironmentVariable('DD_API_KEY'),
            'Content-Type': 'application/json',
          },
          // TODO: what's a good value for timeout for the logs intake?
          timeout: this.timeout || 15e3,
          url: this._url,
        }
        if (this._isAgentProxy) {
          delete options.headers['dd-api-key']
          options.path = '/debugger/v1/input'
        }
        log.debug(() => `Request to the logs intake: ${safeJSONStringify(options)}`)
        request(data, options, (err, res) => {
          if (err) {
            log.error('Error sending DI logs payload', err)
            done()
            return
          }
          log.debug('Response from the logs intake:', res)
          done()
        })
      }
    }
    module2.exports = DynamicInstrumentationLogsWriter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js
var require_agentless = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js'(exports2, module2) {
    'use strict'
    var URL2 = require('url').URL
    var Writer = require_writer6()
    var CoverageWriter = require_coverage_writer()
    var CiVisibilityExporter = require_ci_visibility_exporter()
    var log = require_log2()
    var AgentlessCiVisibilityExporter = class extends CiVisibilityExporter {
      constructor(config) {
        super(config)
        const { tags, site, url, isTestDynamicInstrumentationEnabled } = config
        this._isInitialized = true
        this._resolveCanUseCiVisProtocol(true)
        this._canForwardLogs = true
        this._url = url || new URL2(`https://citestcycle-intake.${site}`)
        this._writer = new Writer({ url: this._url, tags })
        this._coverageUrl = url || new URL2(`https://citestcov-intake.${site}`)
        this._coverageWriter = new CoverageWriter({ url: this._coverageUrl })
        if (isTestDynamicInstrumentationEnabled) {
          const DynamicInstrumentationLogsWriter = require_di_logs_writer()
          this._logsUrl = url || new URL2(`https://http-intake.logs.${site}`)
          this._logsWriter = new DynamicInstrumentationLogsWriter({ url: this._logsUrl, tags })
        }
        this._apiUrl = url || new URL2(`https://api.${site}`)
        this._isGzipCompatible = true
      }
      setUrl(url, coverageUrl = url, apiUrl = url) {
        this._setUrl(url, coverageUrl)
        try {
          apiUrl = new URL2(apiUrl)
          this._apiUrl = apiUrl
        } catch (e) {
          log.error('Error setting CI exporter api url', e)
        }
      }
      _getApiUrl() {
        return this._apiUrl
      }
    }
    module2.exports = AgentlessCiVisibilityExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agent-proxy/index.js
var require_agent_proxy = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agent-proxy/index.js'(exports2, module2) {
    'use strict'
    var AgentWriter = require_writer5()
    var AgentlessWriter = require_writer6()
    var CoverageWriter = require_coverage_writer()
    var CiVisibilityExporter = require_ci_visibility_exporter()
    var AGENT_EVP_PROXY_PATH_PREFIX = '/evp_proxy/v'
    var AGENT_EVP_PROXY_PATH_REGEX = /\/evp_proxy\/v(\d+)\/?/
    var AGENT_DEBUGGER_INPUT = '/debugger/v1/input'
    function getLatestEvpProxyVersion(err, agentInfo) {
      if (err) {
        return 0
      }
      return agentInfo.endpoints.reduce((acc, endpoint) => {
        if (endpoint.includes(AGENT_EVP_PROXY_PATH_PREFIX)) {
          const version = Number(endpoint.replace(AGENT_EVP_PROXY_PATH_REGEX, '$1'))
          if (Number.isNaN(version)) {
            return acc
          }
          return Math.max(version, acc)
        }
        return acc
      }, 0)
    }
    function getCanForwardDebuggerLogs(err, agentInfo) {
      return !err && agentInfo.endpoints.includes(AGENT_DEBUGGER_INPUT)
    }
    var AgentProxyCiVisibilityExporter = class extends CiVisibilityExporter {
      constructor(config) {
        super(config)
        const { tags, prioritySampler, lookup, protocolVersion, headers, isTestDynamicInstrumentationEnabled } = config
        this.getAgentInfo((err, agentInfo) => {
          this._isInitialized = true
          let latestEvpProxyVersion = getLatestEvpProxyVersion(err, agentInfo)
          const isEvpCompatible = latestEvpProxyVersion >= 2
          const isGzipCompatible = latestEvpProxyVersion >= 4
          if (latestEvpProxyVersion === 3) {
            latestEvpProxyVersion = 2
          }
          const evpProxyPrefix = `${AGENT_EVP_PROXY_PATH_PREFIX}${latestEvpProxyVersion}`
          if (isEvpCompatible) {
            this._isUsingEvpProxy = true
            this.evpProxyPrefix = evpProxyPrefix
            this._writer = new AgentlessWriter({
              url: this._url,
              tags,
              evpProxyPrefix,
            })
            this._coverageWriter = new CoverageWriter({
              url: this._url,
              evpProxyPrefix,
            })
            if (isTestDynamicInstrumentationEnabled) {
              const canFowardLogs = getCanForwardDebuggerLogs(err, agentInfo)
              if (canFowardLogs) {
                const DynamicInstrumentationLogsWriter = require_di_logs_writer()
                this._logsWriter = new DynamicInstrumentationLogsWriter({
                  url: this._url,
                  tags,
                  isAgentProxy: true,
                })
                this._canForwardLogs = true
              }
            }
          } else {
            this._writer = new AgentWriter({
              url: this._url,
              prioritySampler,
              lookup,
              protocolVersion,
              headers,
            })
            this._coverageBuffer = []
          }
          this._resolveCanUseCiVisProtocol(isEvpCompatible)
          this.exportUncodedTraces()
          this.exportUncodedCoverages()
          this._isGzipCompatible = isGzipCompatible
        })
      }
      setUrl(url, coverageUrl) {
        this._setUrl(url, coverageUrl)
      }
    }
    module2.exports = AgentProxyCiVisibilityExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/test-worker/writer.js
var require_writer7 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/test-worker/writer.js'(exports2, module2) {
    'use strict'
    var { JSONEncoder } = require_json_encoder()
    var { getEnvironmentVariable } = require_config_helper()
    var log = require_log2()
    var { VITEST_WORKER_TRACE_PAYLOAD_CODE, VITEST_WORKER_LOGS_PAYLOAD_CODE } = require_test()
    var Writer = class {
      constructor(interprocessCode) {
        this._encoder = new JSONEncoder()
        this._interprocessCode = interprocessCode
      }
      flush(onDone) {
        const count = this._encoder.count()
        if (count > 0) {
          const payload = this._encoder.makePayload()
          this._sendPayload(payload, onDone)
        }
      }
      append(payload) {
        this._encoder.encode(payload)
      }
      _sendPayload(data, onDone = () => {}) {
        const isVitestWorkerOld = !!getEnvironmentVariable('TINYPOOL_WORKER_ID')
        const payload = isVitestWorkerOld
          ? { __tinypool_worker_message__: true, interprocessCode: this._interprocessCode, data }
          : [this._interprocessCode, data]
        const isVitestTestWorker =
          this._interprocessCode === VITEST_WORKER_TRACE_PAYLOAD_CODE ||
          this._interprocessCode === VITEST_WORKER_LOGS_PAYLOAD_CODE
        if (process.send) {
          process.send(payload, () => {
            onDone()
          })
        } else if (isVitestTestWorker) {
          const { isMainThread, parentPort } = require('worker_threads')
          if (isMainThread) {
            return onDone()
          }
          try {
            parentPort.postMessage(payload)
          } catch (error) {
            log.error('Error posting message to parent port', error)
          } finally {
            onDone()
          }
        } else {
          onDone()
        }
      }
    }
    module2.exports = Writer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/test-worker/index.js
var require_test_worker = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/test-worker/index.js'(exports2, module2) {
    'use strict'
    var Writer = require_writer7()
    var {
      JEST_WORKER_COVERAGE_PAYLOAD_CODE,
      JEST_WORKER_TRACE_PAYLOAD_CODE,
      CUCUMBER_WORKER_TRACE_PAYLOAD_CODE,
      MOCHA_WORKER_TRACE_PAYLOAD_CODE,
      JEST_WORKER_LOGS_PAYLOAD_CODE,
      PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_LOGS_PAYLOAD_CODE,
    } = require_test()
    var { getEnvironmentVariable } = require_config_helper()
    function getInterprocessTraceCode() {
      if (getEnvironmentVariable('JEST_WORKER_ID')) {
        return JEST_WORKER_TRACE_PAYLOAD_CODE
      }
      if (getEnvironmentVariable('CUCUMBER_WORKER_ID')) {
        return CUCUMBER_WORKER_TRACE_PAYLOAD_CODE
      }
      if (getEnvironmentVariable('MOCHA_WORKER_ID')) {
        return MOCHA_WORKER_TRACE_PAYLOAD_CODE
      }
      if (getEnvironmentVariable('DD_PLAYWRIGHT_WORKER')) {
        return PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE
      }
      if (getEnvironmentVariable('TINYPOOL_WORKER_ID')) {
        return VITEST_WORKER_TRACE_PAYLOAD_CODE
      }
      if (getEnvironmentVariable('DD_VITEST_WORKER')) {
        return VITEST_WORKER_TRACE_PAYLOAD_CODE
      }
      return null
    }
    function getInterprocessCoverageCode() {
      if (getEnvironmentVariable('JEST_WORKER_ID')) {
        return JEST_WORKER_COVERAGE_PAYLOAD_CODE
      }
      return null
    }
    function getInterprocessLogsCode() {
      if (getEnvironmentVariable('JEST_WORKER_ID')) {
        return JEST_WORKER_LOGS_PAYLOAD_CODE
      }
      if (getEnvironmentVariable('TINYPOOL_WORKER_ID')) {
        return VITEST_WORKER_LOGS_PAYLOAD_CODE
      }
      if (getEnvironmentVariable('DD_VITEST_WORKER')) {
        return VITEST_WORKER_LOGS_PAYLOAD_CODE
      }
      return null
    }
    var TestWorkerCiVisibilityExporter = class {
      constructor() {
        const interprocessTraceCode = getInterprocessTraceCode()
        const interprocessCoverageCode = getInterprocessCoverageCode()
        const interprocessLogsCode = getInterprocessLogsCode()
        this._writer = new Writer(interprocessTraceCode)
        this._coverageWriter = new Writer(interprocessCoverageCode)
        this._logsWriter = new Writer(interprocessLogsCode)
      }
      export(payload) {
        this._writer.append(payload)
      }
      exportCoverage(formattedCoverage) {
        this._coverageWriter.append(formattedCoverage)
      }
      exportDiLogs(testEnvironmentMetadata, logMessage) {
        this._logsWriter.append({ testEnvironmentMetadata, logMessage })
      }
      // TODO: add to other writers
      flush(onDone) {
        this._writer.flush(onDone)
        this._coverageWriter.flush()
        this._logsWriter.flush()
      }
    }
    module2.exports = TestWorkerCiVisibilityExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/exporter.js
var require_exporter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/exporter.js'(exports2, module2) {
    'use strict'
    var exporters = require_exporters()
    var fs = require('fs')
    var constants = require_constants2()
    var { getEnvironmentVariable } = require_config_helper()
    module2.exports = function getExporter(name) {
      switch (name) {
        case exporters.LOG:
          return require_log4()
        case exporters.AGENT:
          return require_agent()
        case exporters.DATADOG:
          return require_agentless()
        case exporters.AGENT_PROXY:
          return require_agent_proxy()
        case exporters.JEST_WORKER:
        case exporters.CUCUMBER_WORKER:
        case exporters.MOCHA_WORKER:
        case exporters.PLAYWRIGHT_WORKER:
        case exporters.VITEST_WORKER:
          return require_test_worker()
        default: {
          const inAWSLambda = getEnvironmentVariable('AWS_LAMBDA_FUNCTION_NAME') !== void 0
          const usingLambdaExtension = inAWSLambda && fs.existsSync(constants.DATADOG_LAMBDA_EXTENSION_PATH)
          return inAWSLambda && !usingLambdaExtension ? require_log4() : require_agent()
        }
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js
var require_tracer3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var Span = require_span2()
    var SpanProcessor = require_span_processor2()
    var PrioritySampler = require_priority_sampler()
    var TextMapPropagator = require_text_map()
    var DSMTextMapPropagator = require_text_map_dsm()
    var HttpPropagator = require_http()
    var BinaryPropagator = require_binary()
    var LogPropagator = require_log3()
    var formats = require_formats()
    var log = require_log2()
    var runtimeMetrics = require_runtime_metrics2()
    var getExporter = require_exporter()
    var SpanContext = require_span_context()
    var REFERENCE_CHILD_OF = 'child_of'
    var REFERENCE_FOLLOWS_FROM = 'follows_from'
    var DatadogTracer = class {
      constructor(config, prioritySampler) {
        const Exporter = getExporter(config.experimental.exporter)
        this._config = config
        this._service = config.service
        this._version = config.version
        this._env = config.env
        this._logInjection = config.logInjection
        this._debug = config.debug
        this._prioritySampler = prioritySampler ?? new PrioritySampler(config.env, config.sampler)
        this._exporter = new Exporter(config, this._prioritySampler)
        this._processor = new SpanProcessor(this._exporter, this._prioritySampler, config)
        this._url = this._exporter._url
        this._enableGetRumData = config.experimental.enableGetRumData
        this._traceId128BitGenerationEnabled = config.traceId128BitGenerationEnabled
        this._propagators = {
          [formats.TEXT_MAP]: new TextMapPropagator(config),
          [formats.HTTP_HEADERS]: new HttpPropagator(config),
          [formats.BINARY]: new BinaryPropagator(config),
          [formats.LOG]: new LogPropagator(config),
          [formats.TEXT_MAP_DSM]: new DSMTextMapPropagator(config),
        }
        if (config.reportHostname) {
          this._hostname = os.hostname()
        }
      }
      startSpan(name, options = {}) {
        const parent = options.childOf ? getContext(options.childOf) : getParent(options.references)
        const tags = {
          'service.name': options?.tags?.service ? String(options.tags.service) : this._service,
        }
        if (options?.tags?.service && options.tags.service !== this._service) {
          options.tags.version = void 0
        }
        const span = new Span(
          this,
          this._processor,
          this._prioritySampler,
          {
            operationName: options.operationName || name,
            parent,
            tags,
            startTime: options.startTime,
            hostname: this._hostname,
            traceId128BitGenerationEnabled: this._traceId128BitGenerationEnabled,
            integrationName: options.integrationName,
            links: options.links,
          },
          this._debug
        )
        span.addTags(this._config.tags)
        span.addTags(options.tags)
        return span
      }
      inject(context, format, carrier) {
        if (context instanceof Span) {
          context = context.context()
        }
        try {
          if (format !== 'text_map_dsm' && format !== formats.LOG) {
            this._prioritySampler.sample(context)
          }
          this._propagators[format].inject(context, carrier)
        } catch (e) {
          log.error('Error injecting trace', e)
          runtimeMetrics.increment('datadog.tracer.node.inject.errors', true)
        }
      }
      extract(format, carrier) {
        try {
          return this._propagators[format].extract(carrier)
        } catch (e) {
          log.error('Error extracting trace', e)
          runtimeMetrics.increment('datadog.tracer.node.extract.errors', true)
          return null
        }
      }
    }
    function getContext(spanContext) {
      if (spanContext instanceof Span) {
        spanContext = spanContext.context()
      }
      if (!(spanContext instanceof SpanContext)) {
        spanContext = null
      }
      return spanContext
    }
    function getParent(references = []) {
      let parent = null
      for (const ref of references) {
        const type = ref.type()
        if (type === REFERENCE_CHILD_OF) {
          parent = ref.referencedContext()
          break
        } else if (type === REFERENCE_FOLLOWS_FROM && !parent) {
          parent = ref.referencedContext()
        }
      }
      return parent
    }
    module2.exports = DatadogTracer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/scope.js
var require_scope2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/scope.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var originals = /* @__PURE__ */ new WeakMap()
    var Scope = class {
      active() {
        const store = storage('legacy').getStore()
        return (store && store.span) || null
      }
      activate(span, callback) {
        if (typeof callback !== 'function') return callback
        const oldStore = storage('legacy').getStore()
        const newStore = span ? storage('legacy').getStore(span._store) : oldStore
        storage('legacy').enterWith({ ...newStore, span })
        try {
          return callback()
        } catch (e) {
          if (span && typeof span.setTag === 'function') {
            span.setTag('error', e)
          }
          throw e
        } finally {
          storage('legacy').enterWith(oldStore)
        }
      }
      bind(fn, span) {
        if (typeof fn !== 'function') return fn
        const scope = this
        const spanOrActive = this._spanOrActive(span)
        const bound = function () {
          return scope.activate(spanOrActive, () => {
            return fn.apply(this, arguments)
          })
        }
        originals.set(bound, fn)
        return bound
      }
      _spanOrActive(span) {
        return span === void 0 ? this.active() : span
      }
      _isPromise(promise) {
        return promise && typeof promise.then === 'function'
      }
    }
    module2.exports = Scope
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/extract-package-and-module-path.js
var require_extract_package_and_module_path = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/extract-package-and-module-path.js'(
    exports2,
    module2
  ) {
    'use strict'
    var NM = 'node_modules/'
    module2.exports = function extractPackageAndModulePath(fullPath) {
      const nm = fullPath.lastIndexOf(NM)
      if (nm === -1) {
        return { pkg: null, path: null }
      }
      const subPath = fullPath.slice(nm + NM.length)
      const firstSlash = subPath.indexOf('/')
      const firstPath = fullPath.slice(0, nm + NM.length)
      const firstSlashSubPath = subPath.slice(Math.max(0, firstSlash + 1))
      if (subPath[0] === '@') {
        const secondSlash = firstSlashSubPath.indexOf('/')
        const pkg2 = subPath.slice(0, Math.max(0, firstSlash + 1 + secondSlash))
        return {
          pkg: pkg2,
          path: subPath.slice(Math.max(0, firstSlash + 1 + secondSlash + 1)),
          pkgJson: firstPath + pkg2 + '/package.json',
        }
      }
      const pkg = subPath.slice(0, Math.max(0, firstSlash))
      return {
        pkg,
        path: firstSlashSubPath,
        pkgJson: firstPath + pkg + '/package.json',
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrumentations.js
var require_instrumentations = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrumentations.js'(exports2, module2) {
    'use strict'
    var sym = /* @__PURE__ */ Symbol.for('_ddtrace_instrumentations')
    global[sym] = global[sym] || {}
    module2.exports = global[sym]
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/instrumentations/langchain.js
var require_langchain = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/instrumentations/langchain.js'(
    exports2,
    module2
  ) {
    'use strict'
    module2.exports = [
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/runnables/base.cjs',
        },
        functionQuery: {
          methodName: 'invoke',
          kind: 'Async',
          className: 'RunnableSequence',
        },
        channelName: 'RunnableSequence_invoke',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/runnables/base.cjs',
        },
        functionQuery: {
          methodName: 'batch',
          kind: 'Async',
          className: 'RunnableSequence',
        },
        channelName: 'RunnableSequence_batch',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/language_models/chat_models.cjs',
        },
        functionQuery: {
          methodName: 'generate',
          kind: 'Async',
          className: 'BaseChatModel',
        },
        channelName: 'BaseChatModel_generate',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/language_models/llms.cjs',
        },
        functionQuery: {
          methodName: 'generate',
          kind: 'Async',
        },
        channelName: 'BaseLLM_generate',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/embeddings.cjs',
        },
        functionQuery: {
          methodName: 'embedQuery',
          kind: 'Async',
          className: 'Embeddings',
        },
        channelName: 'Embeddings_embedQuery',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/embeddings.cjs',
        },
        functionQuery: {
          methodName: 'embedDocuments',
          kind: 'Async',
          className: 'Embeddings',
        },
        channelName: 'Embeddings_embedDocuments',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/tools/index.cjs',
        },
        functionQuery: {
          methodName: 'invoke',
          kind: 'Async',
          className: 'StructuredTool',
        },
        channelName: 'Tool_invoke',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/vectorstores.cjs',
        },
        functionQuery: {
          methodName: 'similaritySearch',
          kind: 'Async',
          className: 'VectorStore',
        },
        channelName: 'VectorStore_similaritySearch',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/vectorstores.cjs',
        },
        functionQuery: {
          methodName: 'similaritySearchWithScore',
          kind: 'Async',
          className: 'VectorStore',
        },
        channelName: 'VectorStore_similaritySearchWithScore',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/runnables/base.js',
        },
        functionQuery: {
          methodName: 'invoke',
          kind: 'Async',
          className: 'RunnableSequence',
        },
        channelName: 'RunnableSequence_invoke',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/runnables/base.js',
        },
        functionQuery: {
          methodName: 'batch',
          kind: 'Async',
          className: 'RunnableSequence',
        },
        channelName: 'RunnableSequence_batch',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/language_models/chat_models.js',
        },
        functionQuery: {
          methodName: 'generate',
          kind: 'Async',
          className: 'BaseChatModel',
        },
        channelName: 'BaseChatModel_generate',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/language_models/llms.js',
        },
        functionQuery: {
          methodName: 'generate',
          kind: 'Async',
        },
        channelName: 'BaseLLM_generate',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/embeddings.js',
        },
        functionQuery: {
          methodName: 'embedQuery',
          kind: 'Async',
          className: 'Embeddings',
        },
        channelName: 'Embeddings_embedQuery',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/embeddings.js',
        },
        functionQuery: {
          methodName: 'embedDocuments',
          kind: 'Async',
          className: 'Embeddings',
        },
        channelName: 'Embeddings_embedDocuments',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/tools/index.js',
        },
        functionQuery: {
          methodName: 'invoke',
          kind: 'Async',
          className: 'StructuredTool',
        },
        channelName: 'Tool_invoke',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/vectorstores.js',
        },
        functionQuery: {
          methodName: 'similaritySearch',
          kind: 'Async',
          className: 'VectorStore',
        },
        channelName: 'VectorStore_similaritySearch',
      },
      {
        module: {
          name: '@langchain/core',
          versionRange: '>=0.1',
          filePath: 'dist/vectorstores.js',
        },
        functionQuery: {
          methodName: 'similaritySearchWithScore',
          kind: 'Async',
          className: 'VectorStore',
        },
        channelName: 'VectorStore_similaritySearchWithScore',
      },
    ]
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/instrumentations/index.js
var require_instrumentations2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/instrumentations/index.js'(
    exports2,
    module2
  ) {
    'use strict'
    module2.exports = [...require_langchain()]
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js
var require_instrument = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js'(exports2) {
    'use strict'
    var dc = require_dc_polyfill()
    var instrumentations = require_instrumentations()
    var rewriterInstrumentations = require_instrumentations2()
    var { AsyncResource } = require('async_hooks')
    var channelMap = {}
    exports2.channel = function (name) {
      const maybe = channelMap[name]
      if (maybe) return maybe
      const ch = dc.channel(name)
      channelMap[name] = ch
      return ch
    }
    var tracingChannelMap = {}
    exports2.tracingChannel = function (name) {
      const maybe = tracingChannelMap[name]
      if (maybe) return maybe
      const tc = dc.tracingChannel(name)
      tracingChannelMap[name] = tc
      return tc
    }
    exports2.getHooks = function getHooks(names) {
      names = [names].flat()
      return rewriterInstrumentations
        .map((inst) => inst.module)
        .filter(({ name }) => names.includes(name))
        .map(({ name, versionRange, filePath }) => ({ name, versions: [versionRange], file: filePath }))
    }
    exports2.addHook = function addHook({ name, versions, file, filePattern, patchDefault }, hook) {
      if (typeof name === 'string') {
        name = [name]
      }
      for (const val of name) {
        if (!instrumentations[val]) {
          instrumentations[val] = []
        }
        instrumentations[val].push({ name: val, versions, file, filePattern, hook, patchDefault })
      }
    }
    exports2.AsyncResource = AsyncResource
  },
})

// node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js
var require_shimmer = __commonJS({
  'node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js'(exports2, module2) {
    'use strict'
    var skipMethods = /* @__PURE__ */ new Set(['caller', 'arguments', 'name', 'length'])
    var skipMethodSize = skipMethods.size
    var nonConfigurableModuleExports = /* @__PURE__ */ new WeakMap()
    function copyProperties(original, wrapped) {
      if (original.constructor !== wrapped.constructor) {
        const proto = Object.getPrototypeOf(original)
        Object.setPrototypeOf(wrapped, proto)
      }
      const ownKeys = Reflect.ownKeys(original)
      if (original.length !== wrapped.length) {
        Object.defineProperty(wrapped, 'length', { value: original.length, configurable: true })
      }
      if (original.name !== wrapped.name) {
        Object.defineProperty(wrapped, 'name', { value: original.name, configurable: true })
      }
      if (ownKeys.length !== 2) {
        for (const key of ownKeys) {
          if (skipMethods.has(key)) continue
          const descriptor =
            /** @type {PropertyDescriptor} */
            Object.getOwnPropertyDescriptor(original, key)
          if (descriptor.writable && descriptor.enumerable && descriptor.configurable) {
            wrapped[key] = original[key]
          } else if (descriptor.writable || descriptor.configurable || !Object.hasOwn(wrapped, key)) {
            Object.defineProperty(wrapped, key, descriptor)
          }
        }
      }
    }
    function copyObjectProperties(original, wrapped, skipKey) {
      const ownKeys = Reflect.ownKeys(original)
      for (const key of ownKeys) {
        if (key === skipKey) continue
        const descriptor =
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(original, key)
        if (descriptor.writable && descriptor.enumerable && descriptor.configurable) {
          wrapped[key] = original[key]
        } else if (descriptor.writable || descriptor.configurable || !Object.hasOwn(wrapped, key)) {
          Object.defineProperty(wrapped, key, descriptor)
        }
      }
    }
    function wrapFunction(original, wrapper) {
      if (typeof original !== 'function') return original
      const wrapped = wrapper(original)
      if (typeof original === 'function') {
        assertNotClass(original)
        copyProperties(original, wrapped)
      }
      return wrapped
    }
    function wrap(target, name, wrapper, options) {
      if (typeof wrapper !== 'function') {
        throw new TypeError(wrapper ? 'Target is not a function' : 'No function provided')
      }
      if (target == null) {
        return
      }
      const descriptor = Object.getOwnPropertyDescriptor(target, name) ?? {
        value: target[name],
        writable: true,
        configurable: true,
        enumerable: false,
      }
      if (descriptor.set && (!descriptor.get || options?.replaceGetter)) {
        throw new Error(
          options?.replaceGetter
            ? 'Replacing a getter/setter pair is not supported. Implement if required.'
            : 'Replacing setters is not supported. Implement if required.'
        )
      }
      const original = (descriptor.value ?? options?.replaceGetter) ? target[name] : descriptor.get
      assertMethod(target, name, original)
      const wrapped = wrapper(original)
      copyProperties(original, wrapped)
      if (descriptor.writable) {
        if (descriptor.configurable && descriptor.enumerable) {
          target[name] = wrapped
          return target
        }
        descriptor.value = wrapped
      } else {
        if (descriptor.get) {
          descriptor.get = options?.replaceGetter ? () => wrapped : wrapped
        } else {
          descriptor.value = wrapped
        }
        if (descriptor.configurable === false) {
          let moduleExports = nonConfigurableModuleExports.get(target)
          if (!moduleExports) {
            if (typeof target === 'function') {
              const original2 = target
              moduleExports = function (...args) {
                return original2.apply(original2, args)
              }
              skipMethods.add(name)
              copyProperties(target, moduleExports)
              if (skipMethods.size === skipMethodSize + 1) {
                skipMethods.delete(name)
              }
            } else {
              moduleExports = Object.create(target)
              copyObjectProperties(target, moduleExports, name)
            }
            nonConfigurableModuleExports.set(target, moduleExports)
          }
          target = moduleExports
        }
      }
      Object.defineProperty(target, name, descriptor)
      return target
    }
    function massWrap(targets, names, wrapper) {
      targets = toArray(targets)
      names = toArray(names)
      for (const target of targets) {
        for (const name of names) {
          wrap(target, name, wrapper)
        }
      }
    }
    function toArray(maybeArray) {
      return Array.isArray(maybeArray) ? maybeArray : [maybeArray]
    }
    function assertMethod(target, name, method) {
      if (typeof method !== 'function') {
        let message = 'No target object provided'
        if (target) {
          if (typeof target !== 'object' && typeof target !== 'function') {
            message = 'Invalid target'
          } else {
            name = String(name)
            message = method ? `Original method ${name} is not a function` : `No original method ${name}`
          }
        }
        throw new TypeError(message)
      }
    }
    function assertNotClass(target) {
      if (Function.prototype.toString.call(target).startsWith('class')) {
        throw new TypeError('Target is a native class constructor and cannot be wrapped.')
      }
    }
    module2.exports = {
      wrap,
      wrapFunction,
      massWrap,
    }
  },
})

// node_modules/dd-trace/packages/datadog-shimmer/index.js
var require_datadog_shimmer = __commonJS({
  'node_modules/dd-trace/packages/datadog-shimmer/index.js'(exports2, module2) {
    'use strict'
    module2.exports = require_shimmer()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/anthropic.js
var require_anthropic = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/anthropic.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { channel, tracingChannel } = require_dc_polyfill()
    var anthropicTracingChannel = tracingChannel('apm:anthropic:request')
    var onStreamedChunkCh = channel('apm:anthropic:request:chunk')
    function wrapStreamIterator(iterator, ctx) {
      return function () {
        const itr = iterator.apply(this, arguments)
        shimmer.wrap(
          itr,
          'next',
          (next) =>
            function () {
              return next
                .apply(this, arguments)
                .then((res) => {
                  const { done, value: chunk } = res
                  onStreamedChunkCh.publish({ ctx, chunk, done })
                  if (done) {
                    finish(ctx)
                  }
                  return res
                })
                .catch((error) => {
                  finish(ctx, null, error)
                  throw error
                })
            }
        )
        return itr
      }
    }
    function wrapCreate(create) {
      return function () {
        if (!anthropicTracingChannel.start.hasSubscribers) {
          return create.apply(this, arguments)
        }
        const options = arguments[0]
        const stream = options.stream
        const ctx = { options, resource: 'create' }
        return anthropicTracingChannel.start.runStores(ctx, () => {
          let apiPromise
          try {
            apiPromise = create.apply(this, arguments)
          } catch (error) {
            finish(ctx, null, error)
            throw error
          }
          shimmer.wrap(
            apiPromise,
            'parse',
            (parse) =>
              function () {
                return parse
                  .apply(this, arguments)
                  .then((response) => {
                    if (stream) {
                      shimmer.wrap(response, Symbol.asyncIterator, (iterator) => wrapStreamIterator(iterator, ctx))
                    } else {
                      finish(ctx, response, null)
                    }
                    return response
                  })
                  .catch((error) => {
                    finish(ctx, null, error)
                    throw error
                  })
              }
          )
          anthropicTracingChannel.end.publish(ctx)
          return apiPromise
        })
      }
    }
    function finish(ctx, result, error) {
      if (error) {
        ctx.error = error
        anthropicTracingChannel.error.publish(ctx)
      }
      ctx.result ??= result
      anthropicTracingChannel.asyncEnd.publish(ctx)
    }
    var extensions = ['js', 'mjs']
    for (const extension of extensions) {
      addHook(
        {
          name: '@anthropic-ai/sdk',
          file: `resources/messages.${extension}`,
          versions: ['>=0.14.0 <0.33.0'],
        },
        (exports3) => {
          const Messages = exports3.Messages
          shimmer.wrap(Messages.prototype, 'create', wrapCreate)
          return exports3
        }
      )
      addHook(
        {
          name: '@anthropic-ai/sdk',
          file: `resources/messages/messages.${extension}`,
          versions: ['>=0.33.0'],
        },
        (exports3) => {
          const Messages = exports3.Messages
          shimmer.wrap(Messages.prototype, 'create', wrapCreate)
          return exports3
        }
      )
      addHook(
        {
          name: '@anthropic-ai/sdk',
          file: `resources/beta/messages/messages.${extension}`,
          versions: ['>=0.33.0'],
        },
        (exports3) => {
          const Messages = exports3.Messages
          shimmer.wrap(Messages.prototype, 'create', wrapCreate)
          return exports3
        }
      )
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/apollo-server.js
var require_apollo_server = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/apollo-server.js'() {
    'use strict'
    var dc = require_dc_polyfill()
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var graphqlMiddlewareChannel = dc.tracingChannel('datadog:apollo:middleware')
    var apolloHttpServerChannel = dc.tracingChannel('datadog:apollo:httpserver')
    var requestChannel = dc.tracingChannel('datadog:apollo:request')
    var HeaderMap
    function wrapExecuteHTTPGraphQLRequest(originalExecuteHTTPGraphQLRequest) {
      return function executeHTTPGraphQLRequest() {
        if (!HeaderMap || !requestChannel.start.hasSubscribers) {
          return originalExecuteHTTPGraphQLRequest.apply(this, arguments)
        }
        const abortController = new AbortController()
        const abortData = {}
        const graphqlResponseData = requestChannel.tracePromise(
          originalExecuteHTTPGraphQLRequest,
          { abortController, abortData },
          this,
          ...arguments
        )
        const abortPromise = new Promise((resolve, reject) => {
          abortController.signal.addEventListener(
            'abort',
            (event) => {
              const headers = new HeaderMap()
              Object.keys(abortData.headers).forEach((key) => {
                headers.set(key, abortData.headers[key])
              })
              resolve({
                headers,
                status: abortData.statusCode,
                body: {
                  kind: 'complete',
                  string: abortData.message,
                },
              })
            },
            { once: true }
          )
        })
        return Promise.race([abortPromise, graphqlResponseData])
      }
    }
    function apolloExpress4Hook(express4) {
      shimmer.wrap(express4, 'expressMiddleware', function wrapExpressMiddleware(originalExpressMiddleware) {
        return function expressMiddleware(server, options) {
          const originalMiddleware = originalExpressMiddleware.apply(this, arguments)
          return shimmer.wrapFunction(
            originalMiddleware,
            (originalMiddleware2) =>
              function (req, res, next) {
                if (!graphqlMiddlewareChannel.start.hasSubscribers) {
                  return originalMiddleware2.apply(this, arguments)
                }
                return graphqlMiddlewareChannel.traceSync(originalMiddleware2, { req }, this, ...arguments)
              }
          )
        }
      })
      return express4
    }
    function apolloHeaderMapHook(headerMap) {
      HeaderMap = headerMap.HeaderMap
      return headerMap
    }
    function apolloServerHook(apolloServer) {
      shimmer.wrap(apolloServer.ApolloServer.prototype, 'executeHTTPGraphQLRequest', wrapExecuteHTTPGraphQLRequest)
      return apolloServer
    }
    function wrapEmit(emit) {
      return function wrappedEmit(event, req, res) {
        if (event === 'request' && req && res && apolloHttpServerChannel.start.hasSubscribers) {
          return apolloHttpServerChannel.traceSync(emit, { req }, this, ...arguments)
        }
        return emit.apply(this, arguments)
      }
    }
    function wrapListen(originalListen) {
      return function wrappedListen() {
        shimmer.wrap(this, 'emit', wrapEmit)
        return originalListen.apply(this, arguments)
      }
    }
    function wrapHttpServer(original) {
      return function wrappedHttpServer(options) {
        if (options.httpServer && typeof options.httpServer.listen === 'function') {
          shimmer.wrap(options.httpServer, 'listen', wrapListen)
        }
        return original.apply(this, arguments)
      }
    }
    function apolloDrainHttpServerHook(drainModule) {
      shimmer.wrap(drainModule, 'ApolloServerPluginDrainHttpServer', wrapHttpServer)
      return drainModule
    }
    addHook({ name: '@apollo/server', file: 'dist/cjs/ApolloServer.js', versions: ['4'] }, apolloServerHook)
    addHook({ name: '@apollo/server', file: 'dist/cjs/express4/index.js', versions: ['4'] }, apolloExpress4Hook)
    addHook({ name: '@apollo/server', file: 'dist/cjs/utils/HeaderMap.js', versions: ['4'] }, apolloHeaderMapHook)
    addHook(
      { name: '@apollo/server', file: 'dist/cjs/plugin/drainHttpServer/index.js', versions: ['>=5.0.0'] },
      apolloDrainHttpServerHook
    )
    addHook(
      { name: '@apollo/server', file: 'dist/cjs/runHttpQuery.js', versions: ['>=5.0.0'] },
      (runHttpQueryModule) => {
        shimmer.wrap(runHttpQueryModule, 'runHttpQuery', function wrapRunHttpQuery(originalRunHttpQuery) {
          return wrapExecuteHTTPGraphQLRequest(originalRunHttpQuery)
        })
        return runHttpQueryModule
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/apollo.js
var require_apollo = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/apollo.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var tracingChannel = require_dc_polyfill().tracingChannel
    var CHANNELS = {
      'gateway.request': tracingChannel('apm:apollo:gateway:request'),
      'gateway.plan': tracingChannel('apm:apollo:gateway:plan'),
      'gateway.validate': tracingChannel('apm:apollo:gateway:validate'),
      'gateway.execute': tracingChannel('apm:apollo:gateway:execute'),
      'gateway.fetch': tracingChannel('apm:apollo:gateway:fetch'),
      'gateway.postprocessing': tracingChannel('apm:apollo:gateway:postprocessing'),
    }
    var generalErrorCh = channel('apm:apollo:gateway:general:error')
    function wrapApolloGateway(ApolloGateway) {
      class ApolloGatewayWrapper extends ApolloGateway {
        constructor(...args) {
          super(...args)
          shimmer.wrap(this, 'executor', (originalExecutor) => (...args2) => {
            const channel2 = CHANNELS['gateway.request']
            const ctx = { requestContext: args2[0], gateway: this }
            return channel2.tracePromise(originalExecutor, ctx, this, ...args2)
          })
        }
      }
      return ApolloGatewayWrapper
    }
    function wrapRecordExceptions(recordExceptions) {
      return function wrappedRecordExceptions(...args) {
        const errors = args[1]
        generalErrorCh.publish({ error: errors.at(-1) })
        return recordExceptions.apply(this, args)
      }
    }
    function wrapStartActiveSpan(startActiveSpan) {
      return function (...args) {
        const firstArg = args[0]
        const cb = args.at(-1)
        if (typeof firstArg !== 'string' || typeof cb !== 'function') return startActiveSpan.apply(this, args)
        const method = CHANNELS[firstArg]
        let ctx = {}
        if (firstArg === 'gateway.fetch') {
          ctx = { attributes: args[1].attributes }
        }
        switch (firstArg) {
          case 'gateway.plan':
          case 'gateway.validate': {
            args[args.length - 1] = function (...callbackArgs) {
              return method.traceSync(cb, ctx, this, ...callbackArgs)
            }
            break
          }
          // Patch `executor` instead so the requestContext can be captured.
          case 'gateway.request':
            break
          case 'gateway.execute':
          case 'gateway.postprocessing':
          case 'gateway.fetch': {
            args[args.length - 1] = function (...callbackArgs) {
              return method.tracePromise(cb, ctx, this, ...callbackArgs)
            }
            break
          }
        }
        return startActiveSpan.apply(this, args)
      }
    }
    addHook({ name: '@apollo/gateway', file: 'dist/utilities/opentelemetry.js', versions: ['>=2.3.0'] }, (obj) => {
      const newTracerObj = Object.create(obj.tracer)
      shimmer.wrap(newTracerObj, 'startActiveSpan', wrapStartActiveSpan)
      obj.tracer = newTracerObj
      return obj
    })
    addHook({ name: '@apollo/gateway', file: 'dist/utilities/opentelemetry.js', versions: ['>=2.6.0'] }, (obj) => {
      shimmer.wrap(obj, 'recordExceptions', wrapRecordExceptions)
      return obj
    })
    addHook({ name: '@apollo/gateway', versions: ['>=2.3.0'] }, (gateway) => {
      shimmer.wrap(gateway, 'ApolloGateway', wrapApolloGateway)
      return gateway
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/apollo-server-core.js
var require_apollo_server_core = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/apollo-server-core.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var dc = require_dc_polyfill()
    var requestChannel = dc.tracingChannel('datadog:apollo-server-core:request')
    addHook(
      { name: 'apollo-server-core', file: 'dist/runHttpQuery.js', versions: ['>3.0.0'] },
      (runHttpQueryModule) => {
        const HttpQueryError = runHttpQueryModule.HttpQueryError
        shimmer.wrap(runHttpQueryModule, 'runHttpQuery', function wrapRunHttpQuery(originalRunHttpQuery) {
          return function runHttpQuery() {
            if (!requestChannel.start.hasSubscribers) {
              return originalRunHttpQuery.apply(this, arguments)
            }
            const abortController = new AbortController()
            const abortData = {}
            const runHttpQueryResult = requestChannel.tracePromise(
              originalRunHttpQuery,
              { abortController, abortData },
              this,
              ...arguments
            )
            const abortPromise = new Promise((resolve, reject) => {
              abortController.signal.addEventListener(
                'abort',
                (event) => {
                  reject(new HttpQueryError(abortData.statusCode, abortData.message, true, abortData.headers))
                },
                { once: true }
              )
            })
            return Promise.race([runHttpQueryResult, abortPromise])
          }
        })
        return runHttpQueryModule
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/aws-sdk.js
var require_aws_sdk = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/aws-sdk.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var patchedClientConfigProtocols = /* @__PURE__ */ new WeakSet()
    function wrapRequest(send) {
      return function wrappedRequest(cb) {
        if (!this.service) return send.apply(this, arguments)
        const serviceIdentifier = this.service.serviceIdentifier
        const channelSuffix = getChannelSuffix(serviceIdentifier)
        const startCh = channel(`apm:aws:request:start:${channelSuffix}`)
        if (!startCh.hasSubscribers) return send.apply(this, arguments)
        const ctx = {
          serviceIdentifier,
          operation: this.operation,
          awsRegion: this.service.config && this.service.config.region,
          awsService: this.service.api && this.service.api.className,
          request: this,
          cbExists: typeof cb === 'function',
        }
        this.on('complete', (response) => {
          ctx.response = response
          channel(`apm:aws:request:complete:${channelSuffix}`).publish(ctx)
        })
        if (ctx.cbExists) {
          arguments[0] = wrapCb(cb, channelSuffix, ctx)
        }
        return startCh.runStores(ctx, send, this, ...arguments)
      }
    }
    function wrapDeserialize(deserialize, channelSuffix, responseIndex = 0) {
      const headersCh = channel(`apm:aws:response:deserialize:${channelSuffix}`)
      return function () {
        const response = arguments[responseIndex]
        if (headersCh.hasSubscribers) {
          headersCh.publish({ headers: response.headers })
        }
        return deserialize.apply(this, arguments)
      }
    }
    function wrapSmithySend(send) {
      return function (command, ...args) {
        const cb = args.at(-1)
        const serviceIdentifier = this.config.serviceId.toLowerCase()
        const channelSuffix = getChannelSuffix(serviceIdentifier)
        const commandName = command.constructor.name
        const clientName = this.constructor.name.replace(/Client$/, '')
        const operation = `${commandName[0].toLowerCase()}${commandName.slice(1).replace(/Command$/, '')}`
        const request = {
          operation,
          params: command.input,
        }
        const startCh = channel(`apm:aws:request:start:${channelSuffix}`)
        const regionCh = channel(`apm:aws:request:region:${channelSuffix}`)
        const responseStartChannel = channel(`apm:aws:response:start:${channelSuffix}`)
        const responseFinishChannel = channel(`apm:aws:response:finish:${channelSuffix}`)
        if (typeof command.deserialize === 'function') {
          shimmer.wrap(command, 'deserialize', (deserialize) => wrapDeserialize(deserialize, channelSuffix))
        } else if (
          this.config?.protocol?.deserializeResponse &&
          !patchedClientConfigProtocols.has(this.config.protocol)
        ) {
          shimmer.wrap(this.config.protocol, 'deserializeResponse', (deserializeResponse) =>
            wrapDeserialize(deserializeResponse, channelSuffix, 2)
          )
          patchedClientConfigProtocols.add(this.config.protocol)
        }
        const ctx = {
          serviceIdentifier,
          operation,
          awsService: clientName,
          request,
        }
        return startCh.runStores(ctx, () => {
          this.config.region().then((region) => {
            ctx.region = region
            regionCh.publish(ctx)
          })
          if (typeof cb === 'function') {
            args[args.length - 1] = shimmer.wrapFunction(
              cb,
              (cb2) =>
                function (err, result) {
                  addResponse(ctx, err, result)
                  handleCompletion(result, ctx, channelSuffix)
                  const responseCtx = { request, response: ctx.response }
                  responseStartChannel.runStores(responseCtx, () => {
                    cb2.apply(this, arguments)
                    responseFinishChannel.publish(responseCtx)
                  })
                }
            )
          } else {
            return send.call(this, command, ...args).then(
              (result) => {
                addResponse(ctx, null, result)
                handleCompletion(result, ctx, channelSuffix)
                return result
              },
              (error) => {
                addResponse(ctx, error)
                handleCompletion(null, ctx, channelSuffix)
                throw error
              }
            )
          }
          return send.call(this, command, ...args)
        })
      }
    }
    function handleCompletion(result, ctx, channelSuffix) {
      const completeChannel = channel(`apm:aws:request:complete:${channelSuffix}`)
      const streamedChunkChannel = channel(`apm:aws:response:streamed-chunk:${channelSuffix}`)
      const iterator = result?.body?.[Symbol.asyncIterator]
      if (!iterator) {
        completeChannel.publish(ctx)
        return
      }
      shimmer.wrap(result.body, Symbol.asyncIterator, function (asyncIterator) {
        return function () {
          const iterator2 = asyncIterator.apply(this, arguments)
          shimmer.wrap(iterator2, 'next', function (next) {
            return function () {
              return next
                .apply(this, arguments)
                .then((result2) => {
                  const { done, value: chunk } = result2
                  streamedChunkChannel.publish({ ctx, chunk, done })
                  if (done) {
                    completeChannel.publish(ctx)
                  }
                  return result2
                })
                .catch((err) => {
                  addResponse(ctx, err)
                  completeChannel.publish(ctx)
                  throw err
                })
            }
          })
          return iterator2
        }
      })
    }
    function wrapCb(cb, serviceName, ctx) {
      return shimmer.wrapFunction(
        cb,
        (cb2) =>
          function wrappedCb(err, response) {
            ctx = { request: ctx.request, response }
            return channel(`apm:aws:response:start:${serviceName}`).runStores(ctx, () => {
              const finishChannel = channel(`apm:aws:response:finish:${serviceName}`)
              try {
                let result = cb2.apply(this, arguments)
                if (result && result.then) {
                  result = result.then(
                    (x) => {
                      finishChannel.publish(ctx)
                      return x
                    },
                    (e) => {
                      ctx.error = e
                      finishChannel.publish(ctx)
                      throw e
                    }
                  )
                } else {
                  finishChannel.publish(ctx)
                }
                return result
              } catch (e) {
                ctx.error = e
                finishChannel.publish(ctx)
                throw e
              }
            })
          }
      )
    }
    function addResponse(ctx, error, result) {
      const request = ctx.request
      const response = { request, error, ...result }
      if (result && result.$metadata) {
        response.requestId = result.$metadata.requestId
      }
      ctx.response = response
    }
    function getChannelSuffix(name) {
      name = String(name).replaceAll(' ', '')
      return [
        'cloudwatchlogs',
        'dynamodb',
        'eventbridge',
        'kinesis',
        'lambda',
        'redshift',
        's3',
        'sfn',
        'sns',
        'sqs',
        'states',
        'stepfunctions',
        'bedrockruntime',
      ].includes(name)
        ? name
        : 'default'
    }
    addHook({ name: '@smithy/smithy-client', versions: ['>=1.0.3'] }, (smithy) => {
      shimmer.wrap(smithy.Client.prototype, 'send', wrapSmithySend)
      return smithy
    })
    addHook({ name: '@aws-sdk/smithy-client', versions: ['>=3'] }, (smithy) => {
      shimmer.wrap(smithy.Client.prototype, 'send', wrapSmithySend)
      return smithy
    })
    addHook({ name: 'aws-sdk', versions: ['>=2.3.0'] }, (AWS) => {
      shimmer.wrap(AWS.config, 'setPromisesDependency', (setPromisesDependency) => {
        return function wrappedSetPromisesDependency(dep) {
          const result = setPromisesDependency.apply(this, arguments)
          shimmer.wrap(AWS.Request.prototype, 'promise', wrapRequest)
          return result
        }
      })
      return AWS
    })
    addHook({ name: 'aws-sdk', file: 'lib/core.js', versions: ['>=2.3.0'] }, (AWS) => {
      shimmer.wrap(AWS.Request.prototype, 'promise', wrapRequest)
      return AWS
    })
    addHook({ name: 'aws-sdk', file: 'lib/core.js', versions: ['>=2.1.35'] }, (AWS) => {
      shimmer.wrap(AWS.Request.prototype, 'send', wrapRequest)
      return AWS
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/azure-event-hubs.js
var require_azure_event_hubs = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/azure-event-hubs.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var dc = require_dc_polyfill()
    var producerCh = dc.tracingChannel('apm:azure-event-hubs:send')
    addHook(
      {
        name: '@azure/event-hubs',
        versions: ['>=6.0.0'],
      },
      (obj) => {
        const EventHubProducerClient = obj.EventHubProducerClient
        shimmer.wrap(
          EventHubProducerClient.prototype,
          'createBatch',
          (createBatch) =>
            async function () {
              const batch = await createBatch.apply(this, arguments)
              shimmer.wrap(
                batch,
                'tryAdd',
                (tryAdd) =>
                  function (eventData) {
                    const config = this._context.config
                    const functionName = tryAdd.name
                    return producerCh.tracePromise(
                      tryAdd,
                      { functionName, eventData, batch: this, config },
                      this,
                      ...arguments
                    )
                  }
              )
              return batch
            }
        )
        shimmer.wrap(
          EventHubProducerClient.prototype,
          'sendBatch',
          (sendBatch) =>
            function (eventData) {
              const config = this._context.config
              const functionName = sendBatch.name
              return producerCh.tracePromise(sendBatch, { functionName, eventData, config }, this, ...arguments)
            }
        )
        return obj
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/azure-functions.js
var require_azure_functions = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/azure-functions.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var dc = require_dc_polyfill()
    var azureFunctionsChannel = dc.tracingChannel('datadog:azure:functions:invoke')
    addHook({ name: '@azure/functions', versions: ['>=4'], patchDefault: false }, (azureFunction) => {
      const { app } = azureFunction
      shimmer.wrap(app, 'deleteRequest', wrapHandler)
      shimmer.wrap(app, 'http', wrapHandler)
      shimmer.wrap(app, 'get', wrapHandler)
      shimmer.wrap(app, 'patch', wrapHandler)
      shimmer.wrap(app, 'post', wrapHandler)
      shimmer.wrap(app, 'put', wrapHandler)
      shimmer.wrap(app, 'serviceBusQueue', wrapHandler)
      shimmer.wrap(app, 'serviceBusTopic', wrapHandler)
      shimmer.wrap(app, 'eventHub', wrapHandler)
      return azureFunction
    })
    function wrapHandler(method) {
      return function (name, arg) {
        if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('handler')) {
          const options = arg
          shimmer.wrap(options, 'handler', (handler) => traceHandler(handler, name, method.name))
        } else if (typeof arg === 'function') {
          const handler = arg
          arguments[1] = shimmer.wrapFunction(handler, (handler2) => traceHandler(handler2, name, method.name))
        }
        return method.apply(this, arguments)
      }
    }
    function traceHandler(handler, functionName, methodName) {
      return function (...args) {
        const httpRequest = args[0]
        const invocationContext = args[1]
        return azureFunctionsChannel.tracePromise(
          handler,
          { functionName, httpRequest, invocationContext, methodName },
          this,
          ...args
        )
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/azure-service-bus.js
var require_azure_service_bus = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/azure-service-bus.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var dc = require_dc_polyfill()
    var producerCh = dc.tracingChannel('apm:azure-service-bus:send')
    var isItDefault = /* @__PURE__ */ new WeakSet()
    addHook({ name: '@azure/service-bus', versions: ['>=7.9.2'] }, (obj) => {
      const ServiceBusClient = obj.ServiceBusClient
      shimmer.wrap(
        ServiceBusClient.prototype,
        'createSender',
        (createSender) =>
          function (queueOrTopicName) {
            const sender = createSender.apply(this, arguments)
            const senderPrototype = sender.constructor.prototype
            const senderSenderPrototype = sender._sender.constructor.prototype
            if (!isItDefault.has(senderPrototype)) {
              isItDefault.add(senderPrototype)
              shimmer.wrap(
                senderPrototype,
                'scheduleMessages',
                (scheduleMessages) =>
                  function (msg, scheduledEnqueueTimeUtc) {
                    const functionName = scheduleMessages.name
                    const config = this._context.config
                    const entityPath = this._entityPath
                    return producerCh.tracePromise(
                      scheduleMessages,
                      { config, entityPath, functionName, msg, scheduledEnqueueTimeUtc },
                      this,
                      ...arguments
                    )
                  }
              )
              shimmer.wrap(
                senderPrototype,
                'createMessageBatch',
                (createMessageBatch) =>
                  async function () {
                    const batch = await createMessageBatch.apply(this, arguments)
                    shimmer.wrap(
                      batch,
                      'tryAddMessage',
                      (tryAddMessage) =>
                        function (msg) {
                          const functionName = tryAddMessage.name
                          const config = this._context.config
                          return producerCh.tracePromise(
                            tryAddMessage,
                            { config, functionName, batch, msg },
                            this,
                            ...arguments
                          )
                        }
                    )
                    return batch
                  }
              )
            }
            if (!isItDefault.has(senderSenderPrototype)) {
              isItDefault.add(senderSenderPrototype)
              shimmer.wrap(
                senderSenderPrototype,
                'send',
                (send) =>
                  function (msg) {
                    const functionName = send.name
                    const config = this._context.config
                    const entityPath = this.entityPath
                    return producerCh.tracePromise(send, { config, entityPath, functionName, msg }, this, ...arguments)
                  }
              )
              shimmer.wrap(
                senderSenderPrototype,
                'sendBatch',
                (sendBatch) =>
                  function (msg) {
                    const functionName = sendBatch.name
                    const config = this._context.config
                    const entityPath = this.entityPath
                    return producerCh.tracePromise(
                      sendBatch,
                      { config, entityPath, functionName, msg },
                      this,
                      ...arguments
                    )
                  }
              )
            }
            return sender
          }
      )
      return obj
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js
var require_cucumber = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js'() {
    'use strict'
    var { createCoverageMap } = require_istanbul_lib_coverage()
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var testStartCh = channel('ci:cucumber:test:start')
    var testRetryCh = channel('ci:cucumber:test:retry')
    var testFinishCh = channel('ci:cucumber:test:finish')
    var testFnCh = channel('ci:cucumber:test:fn')
    var testStepStartCh = channel('ci:cucumber:test-step:start')
    var errorCh = channel('ci:cucumber:error')
    var testSuiteStartCh = channel('ci:cucumber:test-suite:start')
    var testSuiteFinishCh = channel('ci:cucumber:test-suite:finish')
    var testSuiteCodeCoverageCh = channel('ci:cucumber:test-suite:code-coverage')
    var libraryConfigurationCh = channel('ci:cucumber:library-configuration')
    var knownTestsCh = channel('ci:cucumber:known-tests')
    var skippableSuitesCh = channel('ci:cucumber:test-suite:skippable')
    var sessionStartCh = channel('ci:cucumber:session:start')
    var sessionFinishCh = channel('ci:cucumber:session:finish')
    var testManagementTestsCh = channel('ci:cucumber:test-management-tests')
    var modifiedFilesCh = channel('ci:cucumber:modified-files')
    var isModifiedCh = channel('ci:cucumber:is-modified-test')
    var workerReportTraceCh = channel('ci:cucumber:worker-report:trace')
    var itrSkippedSuitesCh = channel('ci:cucumber:itr:skipped-suites')
    var getCodeCoverageCh = channel('ci:nyc:get-coverage')
    var {
      getCoveredFilenamesFromCoverage,
      resetCoverage,
      mergeCoverage,
      fromCoverageMapToCoverage,
      getTestSuitePath,
      CUCUMBER_WORKER_TRACE_PAYLOAD_CODE,
      getIsFaultyEarlyFlakeDetection,
    } = require_test()
    var satisfies = require_semifies()
    var isMarkedAsUnskippable = (pickle) => {
      return pickle.tags.some((tag) => tag.name === '@datadog:unskippable')
    }
    var originalCoverageMap = createCoverageMap()
    var patched = /* @__PURE__ */ new WeakSet()
    var lastStatusByPickleId = /* @__PURE__ */ new Map()
    var numRetriesByPickleId = /* @__PURE__ */ new Map()
    var numAttemptToCtx = /* @__PURE__ */ new Map()
    var newTestsByTestFullname = /* @__PURE__ */ new Map()
    var modifiedTestsByPickleId = /* @__PURE__ */ new Map()
    var eventDataCollector = null
    var pickleByFile = {}
    var pickleResultByFile = {}
    var skippableSuites = []
    var itrCorrelationId = ''
    var isForcedToRun = false
    var isUnskippable = false
    var isSuitesSkippingEnabled = false
    var isEarlyFlakeDetectionEnabled = false
    var earlyFlakeDetectionNumRetries = 0
    var earlyFlakeDetectionFaultyThreshold = 0
    var isEarlyFlakeDetectionFaulty = false
    var isFlakyTestRetriesEnabled = false
    var isKnownTestsEnabled = false
    var isTestManagementTestsEnabled = false
    var isImpactedTestsEnabled = false
    var testManagementAttemptToFixRetries = 0
    var testManagementTests = {}
    var modifiedFiles = {}
    var numTestRetries = 0
    var knownTests = {}
    var skippedSuites = []
    var isSuitesSkipped = false
    function isValidKnownTests(receivedKnownTests) {
      return !!receivedKnownTests.cucumber
    }
    function getSuiteStatusFromTestStatuses(testStatuses) {
      if (testStatuses.includes('fail')) {
        return 'fail'
      }
      if (testStatuses.every((status) => status === 'skip')) {
        return 'skip'
      }
      return 'pass'
    }
    function getStatusFromResult(result) {
      if (result.status === 1) {
        return { status: 'pass' }
      }
      if (result.status === 2) {
        return { status: 'skip' }
      }
      if (result.status === 4) {
        return { status: 'skip', skipReason: 'not implemented' }
      }
      return { status: 'fail', errorMessage: result.message }
    }
    function getStatusFromResultLatest(result) {
      if (result.status === 'PASSED') {
        return { status: 'pass' }
      }
      if (result.status === 'SKIPPED' || result.status === 'PENDING') {
        return { status: 'skip' }
      }
      if (result.status === 'UNDEFINED') {
        return { status: 'skip', skipReason: 'not implemented' }
      }
      return { status: 'fail', errorMessage: result.message }
    }
    function isNewTest(testSuite, testName) {
      if (!isValidKnownTests(knownTests)) {
        return false
      }
      const testsForSuite = knownTests.cucumber[testSuite] || []
      return !testsForSuite.includes(testName)
    }
    function getTestProperties(testSuite, testName) {
      const {
        attempt_to_fix: attemptToFix,
        disabled,
        quarantined,
      } = testManagementTests?.cucumber?.suites?.[testSuite]?.tests?.[testName]?.properties || {}
      return { attemptToFix, disabled, quarantined }
    }
    function getTestStatusFromRetries(testStatuses) {
      if (testStatuses.every((status) => status === 'fail')) {
        return 'fail'
      }
      if (testStatuses.includes('pass')) {
        return 'pass'
      }
      return 'pass'
    }
    function getErrorFromCucumberResult(cucumberResult) {
      if (!cucumberResult.message) {
        return
      }
      const [message] = cucumberResult.message.split('\n')
      const error = new Error(message)
      if (cucumberResult.exception) {
        error.type = cucumberResult.exception.type
      }
      error.stack = cucumberResult.message
      return error
    }
    function getChannelPromise(channelToPublishTo, isParallel = false, frameworkVersion = null) {
      return new Promise((resolve) => {
        channelToPublishTo.publish({ onDone: resolve, isParallel, frameworkVersion })
      })
    }
    function getShouldBeSkippedSuite(pickle, suitesToSkip) {
      const testSuitePath = getTestSuitePath(pickle.uri, process.cwd())
      const isUnskippable2 = isMarkedAsUnskippable(pickle)
      const isSkipped = suitesToSkip.includes(testSuitePath)
      return [isSkipped && !isUnskippable2, testSuitePath]
    }
    function getFilteredPicklesNew(coordinator, suitesToSkip) {
      return coordinator.sourcedPickles.reduce(
        (acc, sourcedPickle) => {
          const { pickle } = sourcedPickle
          const [shouldBeSkipped, testSuitePath] = getShouldBeSkippedSuite(pickle, suitesToSkip)
          if (shouldBeSkipped) {
            acc.skippedSuites.add(testSuitePath)
          } else {
            acc.picklesToRun.push(sourcedPickle)
          }
          return acc
        },
        { skippedSuites: /* @__PURE__ */ new Set(), picklesToRun: [] }
      )
    }
    function getFilteredPickles(runtime, suitesToSkip) {
      return runtime.pickleIds.reduce(
        (acc, pickleId) => {
          const pickle = runtime.eventDataCollector.getPickle(pickleId)
          const [shouldBeSkipped, testSuitePath] = getShouldBeSkippedSuite(pickle, suitesToSkip)
          if (shouldBeSkipped) {
            acc.skippedSuites.add(testSuitePath)
          } else {
            acc.picklesToRun.push(pickleId)
          }
          return acc
        },
        { skippedSuites: /* @__PURE__ */ new Set(), picklesToRun: [] }
      )
    }
    function getPickleByFileNew(coordinator) {
      return coordinator.sourcedPickles.reduce((acc, { pickle }) => {
        if (acc[pickle.uri]) {
          acc[pickle.uri].push(pickle)
        } else {
          acc[pickle.uri] = [pickle]
        }
        return acc
      }, {})
    }
    function getPickleByFile(runtimeOrCoodinator) {
      return runtimeOrCoodinator.pickleIds.reduce((acc, pickleId) => {
        const test = runtimeOrCoodinator.eventDataCollector.getPickle(pickleId)
        if (acc[test.uri]) {
          acc[test.uri].push(test)
        } else {
          acc[test.uri] = [test]
        }
        return acc
      }, {})
    }
    function wrapRun(pl, isLatestVersion, version) {
      if (patched.has(pl)) return
      patched.add(pl)
      shimmer.wrap(
        pl.prototype,
        'run',
        (run) =>
          function () {
            if (!testFinishCh.hasSubscribers) {
              return run.apply(this, arguments)
            }
            let numAttempt = 0
            const testFileAbsolutePath = this.pickle.uri
            const testSourceLine = this.gherkinDocument?.feature?.location?.line
            const testStartPayload = {
              testName: this.pickle.name,
              testFileAbsolutePath,
              testSourceLine,
              isParallel: !!getEnvironmentVariable('CUCUMBER_WORKER_ID'),
            }
            const ctx = testStartPayload
            numAttemptToCtx.set(numAttempt, ctx)
            testStartCh.runStores(ctx, () => {})
            const promises = {}
            try {
              this.eventBroadcaster.on('envelope', async (testCase) => {
                if (testCase?.testCaseFinished) {
                  const {
                    testCaseFinished: { willBeRetried },
                  } = testCase
                  if (willBeRetried) {
                    let error
                    try {
                      const cucumberResult = this.getWorstStepResult()
                      error = getErrorFromCucumberResult(cucumberResult)
                    } catch {}
                    const failedAttemptCtx = numAttemptToCtx.get(numAttempt)
                    const isFirstAttempt = numAttempt++ === 0
                    const isAtrRetry = !isFirstAttempt && isFlakyTestRetriesEnabled
                    if (promises.hitBreakpointPromise) {
                      await promises.hitBreakpointPromise
                    }
                    testRetryCh.publish({ isFirstAttempt, error, isAtrRetry, ...failedAttemptCtx.currentStore })
                    const newCtx = { ...testStartPayload, promises }
                    numAttemptToCtx.set(numAttempt, newCtx)
                    testStartCh.runStores(newCtx, () => {})
                  }
                }
              })
              let promise
              testFnCh.runStores(ctx, () => {
                promise = run.apply(this, arguments)
              })
              promise.finally(async () => {
                const result = this.getWorstStepResult()
                const { status, skipReason } = isLatestVersion
                  ? getStatusFromResultLatest(result)
                  : getStatusFromResult(result)
                if (lastStatusByPickleId.has(this.pickle.id)) {
                  lastStatusByPickleId.get(this.pickle.id).push(status)
                } else {
                  lastStatusByPickleId.set(this.pickle.id, [status])
                }
                let isNew = false
                let isEfdRetry = false
                let isAttemptToFix = false
                let isAttemptToFixRetry = false
                let hasFailedAllRetries = false
                let hasPassedAllRetries = false
                let hasFailedAttemptToFix = false
                let isDisabled = false
                let isQuarantined = false
                let isModified = false
                if (isTestManagementTestsEnabled) {
                  const testSuitePath = getTestSuitePath(testFileAbsolutePath, process.cwd())
                  const testProperties = getTestProperties(testSuitePath, this.pickle.name)
                  const numRetries2 = numRetriesByPickleId.get(this.pickle.id)
                  isAttemptToFix = testProperties.attemptToFix
                  isAttemptToFixRetry = isAttemptToFix && numRetries2 > 0
                  isDisabled = testProperties.disabled
                  isQuarantined = testProperties.quarantined
                  if (isAttemptToFixRetry) {
                    const statuses = lastStatusByPickleId.get(this.pickle.id)
                    if (statuses.length === testManagementAttemptToFixRetries + 1) {
                      const { pass, fail } = statuses.reduce(
                        (acc, status2) => {
                          acc[status2]++
                          return acc
                        },
                        { pass: 0, fail: 0 }
                      )
                      hasFailedAllRetries = fail === testManagementAttemptToFixRetries + 1
                      hasPassedAllRetries = pass === testManagementAttemptToFixRetries + 1
                      hasFailedAttemptToFix = fail > 0
                    }
                  }
                }
                const numRetries = numRetriesByPickleId.get(this.pickle.id)
                if (isImpactedTestsEnabled) {
                  isModified = modifiedTestsByPickleId.get(this.pickle.id)
                }
                if (isKnownTestsEnabled && status !== 'skip') {
                  isNew = numRetries !== void 0
                }
                if (isNew || isModified) {
                  isEfdRetry = numRetries > 0
                }
                const attemptCtx = numAttemptToCtx.get(numAttempt)
                const error = getErrorFromCucumberResult(result)
                if (promises.hitBreakpointPromise) {
                  await promises.hitBreakpointPromise
                }
                testFinishCh.publish({
                  status,
                  skipReason,
                  error,
                  isNew,
                  isEfdRetry,
                  isFlakyRetry: numAttempt > 0,
                  isAttemptToFix,
                  isAttemptToFixRetry,
                  hasFailedAllRetries,
                  hasPassedAllRetries,
                  hasFailedAttemptToFix,
                  isDisabled,
                  isQuarantined,
                  isModified,
                  ...attemptCtx.currentStore,
                })
              })
              return promise
            } catch (err) {
              ctx.err = err
              errorCh.runStores(ctx, () => {
                throw err
              })
            }
          }
      )
      shimmer.wrap(
        pl.prototype,
        'runStep',
        (runStep) =>
          function () {
            if (!testFinishCh.hasSubscribers) {
              return runStep.apply(this, arguments)
            }
            const testStep = arguments[0]
            let resource
            if (isLatestVersion) {
              resource = testStep.text
            } else {
              resource = testStep.isHook ? 'hook' : testStep.pickleStep.text
            }
            const ctx = { resource }
            return testStepStartCh.runStores(ctx, () => {
              try {
                const promise = runStep.apply(this, arguments)
                promise.then((result) => {
                  const finalResult = satisfies(version, '>=12.0.0') ? result.result : result
                  const getStatus = satisfies(version, '>=7.3.0') ? getStatusFromResultLatest : getStatusFromResult
                  const { status, skipReason, errorMessage } = getStatus(finalResult)
                  testFinishCh.publish({ isStep: true, status, skipReason, errorMessage, ...ctx.currentStore })
                })
                return promise
              } catch (err) {
                ctx.err = err
                errorCh.runStores(ctx, () => {
                  throw err
                })
              }
            })
          }
      )
    }
    function pickleHook(PickleRunner, version) {
      const pl = PickleRunner.default
      wrapRun(pl, false, version)
      return PickleRunner
    }
    function testCaseHook(TestCaseRunner, version) {
      const pl = TestCaseRunner.default
      wrapRun(pl, true, version)
      return TestCaseRunner
    }
    function getCucumberOptions(adapterOrCoordinator) {
      if (adapterOrCoordinator.adapter) {
        return adapterOrCoordinator.adapter.worker?.options || adapterOrCoordinator.adapter.options
      }
      return adapterOrCoordinator.options
    }
    function getWrappedStart(start, frameworkVersion, isParallel = false, isCoordinator = false) {
      return async function () {
        if (!libraryConfigurationCh.hasSubscribers) {
          return start.apply(this, arguments)
        }
        const options = getCucumberOptions(this)
        if (!isParallel && this.adapter?.options) {
          isParallel = options.parallel > 0
        }
        let errorSkippableRequest
        const configurationResponse = await getChannelPromise(libraryConfigurationCh, isParallel, frameworkVersion)
        isEarlyFlakeDetectionEnabled = configurationResponse.libraryConfig?.isEarlyFlakeDetectionEnabled
        earlyFlakeDetectionNumRetries = configurationResponse.libraryConfig?.earlyFlakeDetectionNumRetries
        earlyFlakeDetectionFaultyThreshold = configurationResponse.libraryConfig?.earlyFlakeDetectionFaultyThreshold
        isSuitesSkippingEnabled = configurationResponse.libraryConfig?.isSuitesSkippingEnabled
        isFlakyTestRetriesEnabled = configurationResponse.libraryConfig?.isFlakyTestRetriesEnabled
        numTestRetries = configurationResponse.libraryConfig?.flakyTestRetriesCount
        isKnownTestsEnabled = configurationResponse.libraryConfig?.isKnownTestsEnabled
        isTestManagementTestsEnabled = configurationResponse.libraryConfig?.isTestManagementEnabled
        testManagementAttemptToFixRetries = configurationResponse.libraryConfig?.testManagementAttemptToFixRetries
        isImpactedTestsEnabled = configurationResponse.libraryConfig?.isImpactedTestsEnabled
        if (isKnownTestsEnabled) {
          const knownTestsResponse = await getChannelPromise(knownTestsCh)
          if (knownTestsResponse.err) {
            isEarlyFlakeDetectionEnabled = false
            isKnownTestsEnabled = false
          } else {
            knownTests = knownTestsResponse.knownTests
          }
        }
        if (isSuitesSkippingEnabled) {
          const skippableResponse = await getChannelPromise(skippableSuitesCh)
          errorSkippableRequest = skippableResponse.err
          skippableSuites = skippableResponse.skippableSuites
          if (!errorSkippableRequest) {
            const filteredPickles = isCoordinator
              ? getFilteredPicklesNew(this, skippableSuites)
              : getFilteredPickles(this, skippableSuites)
            const { picklesToRun } = filteredPickles
            const oldPickles = isCoordinator ? this.sourcedPickles : this.pickleIds
            isSuitesSkipped = picklesToRun.length !== oldPickles.length
            log.debug('%s out of %s suites are going to run.', picklesToRun.length, oldPickles.length)
            if (isCoordinator) {
              this.sourcedPickles = picklesToRun
            } else {
              this.pickleIds = picklesToRun
            }
            skippedSuites = [...filteredPickles.skippedSuites]
            itrCorrelationId = skippableResponse.itrCorrelationId
          }
        }
        pickleByFile = isCoordinator ? getPickleByFileNew(this) : getPickleByFile(this)
        if (isKnownTestsEnabled) {
          const isFaulty =
            !isValidKnownTests(knownTests) ||
            getIsFaultyEarlyFlakeDetection(
              Object.keys(pickleByFile),
              knownTests.cucumber,
              earlyFlakeDetectionFaultyThreshold
            )
          if (isFaulty) {
            isEarlyFlakeDetectionEnabled = false
            isKnownTestsEnabled = false
            isEarlyFlakeDetectionFaulty = true
          }
        }
        if (isTestManagementTestsEnabled) {
          const testManagementTestsResponse = await getChannelPromise(testManagementTestsCh)
          if (testManagementTestsResponse.err) {
            isTestManagementTestsEnabled = false
          } else {
            testManagementTests = testManagementTestsResponse.testManagementTests
          }
        }
        if (isImpactedTestsEnabled) {
          const impactedTestsResponse = await getChannelPromise(modifiedFilesCh)
          if (!impactedTestsResponse.err) {
            modifiedFiles = impactedTestsResponse.modifiedFiles
          }
        }
        const processArgv = process.argv.slice(2).join(' ')
        const command = getEnvironmentVariable('npm_lifecycle_script') || `cucumber-js ${processArgv}`
        if (isFlakyTestRetriesEnabled && !options.retry && numTestRetries > 0) {
          options.retry = numTestRetries
        }
        sessionStartCh.publish({ command, frameworkVersion })
        if (!errorSkippableRequest && skippedSuites.length) {
          itrSkippedSuitesCh.publish({ skippedSuites, frameworkVersion })
        }
        const success = await start.apply(this, arguments)
        let untestedCoverage
        if (getCodeCoverageCh.hasSubscribers) {
          untestedCoverage = await getChannelPromise(getCodeCoverageCh)
        }
        let testCodeCoverageLinesTotal
        if (global.__coverage__) {
          try {
            if (untestedCoverage) {
              originalCoverageMap.merge(fromCoverageMapToCoverage(untestedCoverage))
            }
            testCodeCoverageLinesTotal = originalCoverageMap.getCoverageSummary().lines.pct
          } catch {}
          global.__coverage__ = fromCoverageMapToCoverage(originalCoverageMap)
        }
        sessionFinishCh.publish({
          status: success ? 'pass' : 'fail',
          isSuitesSkipped,
          testCodeCoverageLinesTotal,
          numSkippedSuites: skippedSuites.length,
          hasUnskippableSuites: isUnskippable,
          hasForcedToRunSuites: isForcedToRun,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          isParallel,
        })
        eventDataCollector = null
        return success
      }
    }
    function getWrappedRunTestCase(runTestCaseFunction, isNewerCucumberVersion = false, isWorker = false) {
      return async function () {
        if (!testSuiteFinishCh.hasSubscribers) {
          return runTestCaseFunction.apply(this, arguments)
        }
        const pickle = isNewerCucumberVersion ? arguments[0].pickle : this.eventDataCollector.getPickle(arguments[0])
        const testCase = isNewerCucumberVersion ? arguments[0].testCase : arguments[1]
        const gherkinDocument = isNewerCucumberVersion
          ? arguments[0].gherkinDocument
          : this.eventDataCollector.getGherkinDocument(pickle.uri)
        const testFileAbsolutePath = pickle.uri
        const testSuitePath = getTestSuitePath(testFileAbsolutePath, process.cwd())
        if (!isWorker && !pickleResultByFile[testFileAbsolutePath]) {
          isUnskippable = isMarkedAsUnskippable(pickle)
          isForcedToRun = isUnskippable && skippableSuites.includes(testSuitePath)
          testSuiteStartCh.publish({
            testFileAbsolutePath,
            isUnskippable,
            isForcedToRun,
            itrCorrelationId,
          })
        }
        let isNew = false
        let isAttemptToFix = false
        let isDisabled = false
        let isQuarantined = false
        let isModified = false
        if (isTestManagementTestsEnabled) {
          const testProperties = getTestProperties(testSuitePath, pickle.name)
          isAttemptToFix = testProperties.attemptToFix
          isDisabled = testProperties.disabled
          isQuarantined = testProperties.quarantined
          if (!isAttemptToFix && isDisabled) {
            this.options.dryRun = true
          }
        }
        if (isImpactedTestsEnabled) {
          const setIsModified = (receivedIsModified) => {
            isModified = receivedIsModified
          }
          const scenarios = gherkinDocument.feature?.children
            ?.filter((children) => pickle.astNodeIds.includes(children.scenario.id))
            .map((scenario) => scenario.scenario)
          const stepIds = testCase?.testSteps?.flatMap((testStep) => testStep.stepDefinitionIds)
          isModifiedCh.publish({
            scenarios,
            testFileAbsolutePath: gherkinDocument.uri,
            modifiedFiles,
            stepIds,
            stepDefinitions: this.supportCodeLibrary.stepDefinitions,
            setIsModified,
          })
          modifiedTestsByPickleId.set(pickle.id, isModified)
        }
        if (isKnownTestsEnabled && !isAttemptToFix) {
          isNew = isNewTest(testSuitePath, pickle.name)
          if (isNew) {
            numRetriesByPickleId.set(pickle.id, 0)
          }
        }
        let runTestCaseResult = await runTestCaseFunction.apply(this, arguments)
        const testStatuses = lastStatusByPickleId.get(pickle.id)
        const lastTestStatus = testStatuses.at(-1)
        if (isAttemptToFix && lastTestStatus !== 'skip') {
          for (let retryIndex = 0; retryIndex < testManagementAttemptToFixRetries; retryIndex++) {
            numRetriesByPickleId.set(pickle.id, retryIndex + 1)
            runTestCaseResult = await runTestCaseFunction.apply(this, arguments)
          }
        }
        if (isEarlyFlakeDetectionEnabled && lastTestStatus !== 'skip' && (isNew || isModified)) {
          for (let retryIndex = 0; retryIndex < earlyFlakeDetectionNumRetries; retryIndex++) {
            numRetriesByPickleId.set(pickle.id, retryIndex + 1)
            runTestCaseResult = await runTestCaseFunction.apply(this, arguments)
          }
        }
        let testStatus = lastTestStatus
        let shouldBePassedByEFD = false
        let shouldBePassedByTestManagement = false
        if ((isNew || isModified) && isEarlyFlakeDetectionEnabled) {
          testStatus = getTestStatusFromRetries(testStatuses)
          if (testStatus === 'pass') {
            shouldBePassedByEFD = true
            this.success = true
          }
        }
        if (isTestManagementTestsEnabled && (isDisabled || isQuarantined)) {
          this.success = true
          shouldBePassedByTestManagement = true
        }
        if (pickleResultByFile[testFileAbsolutePath]) {
          pickleResultByFile[testFileAbsolutePath].push(testStatus)
        } else {
          pickleResultByFile[testFileAbsolutePath] = [testStatus]
        }
        if (
          !isWorker &&
          pickleResultByFile[testFileAbsolutePath].length === pickleByFile[testFileAbsolutePath].length
        ) {
          const testSuiteStatus = getSuiteStatusFromTestStatuses(pickleResultByFile[testFileAbsolutePath])
          if (global.__coverage__) {
            const coverageFiles = getCoveredFilenamesFromCoverage(global.__coverage__)
            testSuiteCodeCoverageCh.publish({
              coverageFiles,
              suiteFile: testFileAbsolutePath,
              testSuitePath,
            })
            mergeCoverage(global.__coverage__, originalCoverageMap)
            resetCoverage(global.__coverage__)
          }
          testSuiteFinishCh.publish({ status: testSuiteStatus, testSuitePath })
        }
        if (isNewerCucumberVersion && isEarlyFlakeDetectionEnabled && (isNew || isModified)) {
          return shouldBePassedByEFD
        }
        if (isNewerCucumberVersion && isTestManagementTestsEnabled && (isQuarantined || isDisabled)) {
          return shouldBePassedByTestManagement
        }
        return runTestCaseResult
      }
    }
    function getWrappedParseWorkerMessage(parseWorkerMessageFunction, isNewVersion) {
      return function (worker, message) {
        if (!testSuiteFinishCh.hasSubscribers) {
          return parseWorkerMessageFunction.apply(this, arguments)
        }
        if (Array.isArray(message)) {
          const [messageCode, payload] = message
          if (messageCode === CUCUMBER_WORKER_TRACE_PAYLOAD_CODE) {
            workerReportTraceCh.publish(payload)
            return
          }
        }
        const envelope = isNewVersion ? message.envelope : message.jsonEnvelope
        if (!envelope) {
          return parseWorkerMessageFunction.apply(this, arguments)
        }
        let parsed = envelope
        if (typeof parsed === 'string') {
          try {
            parsed = JSON.parse(envelope)
          } catch {
            return parseWorkerMessageFunction.apply(this, arguments)
          }
        }
        let pickle
        if (parsed.testCaseStarted) {
          if (isNewVersion) {
            pickle = this.inProgress[worker.id].pickle
          } else {
            const { pickleId } = this.eventDataCollector.testCaseMap[parsed.testCaseStarted.testCaseId]
            pickle = this.eventDataCollector.getPickle(pickleId)
          }
          const testFileAbsolutePath = pickle.uri
          if (!pickleResultByFile[testFileAbsolutePath]) {
            pickleResultByFile[testFileAbsolutePath] = []
            testSuiteStartCh.publish({
              testFileAbsolutePath,
            })
          }
        }
        const parseWorkerResponse = parseWorkerMessageFunction.apply(this, arguments)
        if (parsed.testCaseFinished) {
          let worstTestStepResult
          if (isNewVersion && eventDataCollector) {
            pickle = this.inProgress[worker.id].pickle
            worstTestStepResult = eventDataCollector.getTestCaseAttempt(
              parsed.testCaseFinished.testCaseStartedId
            ).worstTestStepResult
          } else {
            const testCase = this.eventDataCollector.getTestCaseAttempt(parsed.testCaseFinished.testCaseStartedId)
            worstTestStepResult = testCase.worstTestStepResult
            pickle = testCase.pickle
          }
          const { status } = getStatusFromResultLatest(worstTestStepResult)
          let isNew = false
          if (isKnownTestsEnabled) {
            isNew = isNewTest(pickle.uri, pickle.name)
          }
          const testFileAbsolutePath = pickle.uri
          const finished = pickleResultByFile[testFileAbsolutePath]
          if (isEarlyFlakeDetectionEnabled && isNew) {
            const testFullname = `${pickle.uri}:${pickle.name}`
            let testStatuses = newTestsByTestFullname.get(testFullname)
            if (testStatuses) {
              testStatuses.push(status)
            } else {
              testStatuses = [status]
              newTestsByTestFullname.set(testFullname, testStatuses)
            }
            if (testStatuses.length === earlyFlakeDetectionNumRetries + 1) {
              const newTestFinalStatus = getTestStatusFromRetries(testStatuses)
              finished.push(newTestFinalStatus)
            }
          } else {
            const finished2 = pickleResultByFile[testFileAbsolutePath]
            finished2.push(status)
          }
          if (finished.length === pickleByFile[testFileAbsolutePath].length) {
            testSuiteFinishCh.publish({
              status: getSuiteStatusFromTestStatuses(finished),
              testSuitePath: getTestSuitePath(testFileAbsolutePath, process.cwd()),
            })
          }
        }
        return parseWorkerResponse
      }
    }
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['7.0.0 - 7.2.1'],
        file: 'lib/runtime/pickle_runner.js',
      },
      pickleHook
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=7.3.0'],
        file: 'lib/runtime/test_case_runner.js',
      },
      testCaseHook
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=7.3.0 <11.0.0'],
        file: 'lib/runtime/index.js',
      },
      (runtimePackage, frameworkVersion) => {
        shimmer.wrap(runtimePackage.default.prototype, 'runTestCase', (runTestCase) =>
          getWrappedRunTestCase(runTestCase)
        )
        shimmer.wrap(runtimePackage.default.prototype, 'start', (start) => getWrappedStart(start, frameworkVersion))
        return runtimePackage
      }
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=7.0.0 <7.3.0'],
        file: 'lib/runtime/index.js',
      },
      (runtimePackage, frameworkVersion) => {
        shimmer.wrap(runtimePackage.default.prototype, 'runPickle', (runPickle) => getWrappedRunTestCase(runPickle))
        shimmer.wrap(runtimePackage.default.prototype, 'start', (start) => getWrappedStart(start, frameworkVersion))
        return runtimePackage
      }
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=8.0.0 <11.0.0'],
        file: 'lib/runtime/parallel/coordinator.js',
      },
      (coordinatorPackage, frameworkVersion) => {
        shimmer.wrap(coordinatorPackage.default.prototype, 'start', (start) =>
          getWrappedStart(start, frameworkVersion, true)
        )
        shimmer.wrap(coordinatorPackage.default.prototype, 'parseWorkerMessage', (parseWorkerMessage) =>
          getWrappedParseWorkerMessage(parseWorkerMessage)
        )
        return coordinatorPackage
      }
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=11.0.0'],
        file: 'lib/runtime/worker.js',
      },
      (workerPackage) => {
        shimmer.wrap(workerPackage.Worker.prototype, 'runTestCase', (runTestCase) =>
          getWrappedRunTestCase(runTestCase, true, !!getEnvironmentVariable('CUCUMBER_WORKER_ID'))
        )
        return workerPackage
      }
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=11.0.0'],
        file: 'lib/runtime/coordinator.js',
      },
      (coordinatorPackage, frameworkVersion) => {
        shimmer.wrap(coordinatorPackage.Coordinator.prototype, 'run', (run) =>
          getWrappedStart(run, frameworkVersion, false, true)
        )
        return coordinatorPackage
      }
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=11.0.0'],
        file: 'lib/formatter/helpers/event_data_collector.js',
      },
      (eventDataCollectorPackage) => {
        shimmer.wrap(
          eventDataCollectorPackage.default.prototype,
          'parseEnvelope',
          (parseEnvelope) =>
            function () {
              eventDataCollector = this
              return parseEnvelope.apply(this, arguments)
            }
        )
        return eventDataCollectorPackage
      }
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=11.0.0'],
        file: 'lib/runtime/parallel/adapter.js',
      },
      (adapterPackage) => {
        shimmer.wrap(adapterPackage.ChildProcessAdapter.prototype, 'parseWorkerMessage', (parseWorkerMessage) =>
          getWrappedParseWorkerMessage(parseWorkerMessage, true)
        )
        shimmer.wrap(
          adapterPackage.ChildProcessAdapter.prototype,
          'startWorker',
          (startWorker) =>
            function () {
              if (isKnownTestsEnabled && isValidKnownTests(knownTests)) {
                this.options.worldParameters._ddIsKnownTestsEnabled = true
                this.options.worldParameters._ddIsEarlyFlakeDetectionEnabled = isEarlyFlakeDetectionEnabled
                this.options.worldParameters._ddKnownTests = knownTests
                this.options.worldParameters._ddEarlyFlakeDetectionNumRetries = earlyFlakeDetectionNumRetries
              } else {
                isEarlyFlakeDetectionEnabled = false
                isKnownTestsEnabled = false
                this.options.worldParameters._ddIsEarlyFlakeDetectionEnabled = false
                this.options.worldParameters._ddIsKnownTestsEnabled = false
                this.options.worldParameters._ddEarlyFlakeDetectionNumRetries = 0
              }
              if (isImpactedTestsEnabled) {
                this.options.worldParameters._ddImpactedTestsEnabled = isImpactedTestsEnabled
                this.options.worldParameters._ddModifiedFiles = modifiedFiles
              }
              return startWorker.apply(this, arguments)
            }
        )
        return adapterPackage
      }
    )
    addHook(
      {
        name: '@cucumber/cucumber',
        versions: ['>=11.0.0'],
        file: 'lib/runtime/parallel/worker.js',
      },
      (workerPackage) => {
        shimmer.wrap(
          workerPackage.ChildProcessWorker.prototype,
          'initialize',
          (initialize) =>
            async function () {
              await initialize.apply(this, arguments)
              isKnownTestsEnabled = !!this.options.worldParameters._ddIsKnownTestsEnabled
              if (isKnownTestsEnabled) {
                knownTests = this.options.worldParameters._ddKnownTests
                if (!isValidKnownTests(knownTests)) {
                  isKnownTestsEnabled = false
                  knownTests = {}
                }
              }
              isEarlyFlakeDetectionEnabled = !!this.options.worldParameters._ddIsEarlyFlakeDetectionEnabled
              if (isEarlyFlakeDetectionEnabled) {
                earlyFlakeDetectionNumRetries = this.options.worldParameters._ddEarlyFlakeDetectionNumRetries
              }
              isImpactedTestsEnabled = !!this.options.worldParameters._ddImpactedTestsEnabled
              if (isImpactedTestsEnabled) {
                modifiedFiles = this.options.worldParameters._ddModifiedFiles
              }
            }
        )
        return workerPackage
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/playwright.js
var require_playwright = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/playwright.js'() {
    'use strict'
    var satisfies = require_semifies()
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { parseAnnotations, getTestSuitePath, PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE, getIsFaultyEarlyFlakeDetection } =
      require_test()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var { DD_MAJOR } = require_version()
    var testStartCh = channel('ci:playwright:test:start')
    var testFinishCh = channel('ci:playwright:test:finish')
    var testSkipCh = channel('ci:playwright:test:skip')
    var testSessionStartCh = channel('ci:playwright:session:start')
    var testSessionFinishCh = channel('ci:playwright:session:finish')
    var libraryConfigurationCh = channel('ci:playwright:library-configuration')
    var knownTestsCh = channel('ci:playwright:known-tests')
    var testManagementTestsCh = channel('ci:playwright:test-management-tests')
    var modifiedFilesCh = channel('ci:playwright:modified-files')
    var isModifiedCh = channel('ci:playwright:test:is-modified')
    var testSuiteStartCh = channel('ci:playwright:test-suite:start')
    var testSuiteFinishCh = channel('ci:playwright:test-suite:finish')
    var workerReportCh = channel('ci:playwright:worker:report')
    var testPageGotoCh = channel('ci:playwright:test:page-goto')
    var testToCtx = /* @__PURE__ */ new WeakMap()
    var testSuiteToCtx = /* @__PURE__ */ new Map()
    var testSuiteToTestStatuses = /* @__PURE__ */ new Map()
    var testSuiteToErrors = /* @__PURE__ */ new Map()
    var testsToTestStatuses = /* @__PURE__ */ new Map()
    var RUM_FLUSH_WAIT_TIME = Number(getEnvironmentVariable('DD_CIVISIBILITY_RUM_FLUSH_WAIT_MILLIS')) || 1e3
    var applyRepeatEachIndex = null
    var startedSuites = []
    var STATUS_TO_TEST_STATUS = {
      passed: 'pass',
      failed: 'fail',
      timedOut: 'fail',
      skipped: 'skip',
    }
    var remainingTestsByFile = {}
    var isKnownTestsEnabled = false
    var isEarlyFlakeDetectionEnabled = false
    var earlyFlakeDetectionNumRetries = 0
    var isEarlyFlakeDetectionFaulty = false
    var earlyFlakeDetectionFaultyThreshold = 0
    var isFlakyTestRetriesEnabled = false
    var flakyTestRetriesCount = 0
    var knownTests = {}
    var isTestManagementTestsEnabled = false
    var testManagementAttemptToFixRetries = 0
    var testManagementTests = {}
    var isImpactedTestsEnabled = false
    var modifiedFiles = {}
    var quarantinedOrDisabledTestsAttemptToFix = []
    var quarantinedButNotAttemptToFixFqns = /* @__PURE__ */ new Set()
    var rootDir = ''
    var sessionProjects = []
    var MINIMUM_SUPPORTED_VERSION_RANGE_EFD = '>=1.38.0'
    function isValidKnownTests(receivedKnownTests) {
      return !!receivedKnownTests.playwright
    }
    function getTestFullyQualifiedName(test) {
      const fullname = getTestFullname(test)
      return `${test._requireFile} ${fullname}`
    }
    function getTestProperties(test) {
      const testName = getTestFullname(test)
      const testSuite = getTestSuitePath(test._requireFile, rootDir)
      const {
        attempt_to_fix: attemptToFix,
        disabled,
        quarantined,
      } = testManagementTests?.playwright?.suites?.[testSuite]?.tests?.[testName]?.properties || {}
      return { attemptToFix, disabled, quarantined }
    }
    function isNewTest(test) {
      if (!isValidKnownTests(knownTests)) {
        return false
      }
      const testSuite = getTestSuitePath(test._requireFile, rootDir)
      const testsForSuite = knownTests.playwright[testSuite] || []
      return !testsForSuite.includes(getTestFullname(test))
    }
    function getSuiteType(test, type) {
      let suite = test.parent
      while (suite && suite._type !== type) {
        suite = suite.parent
      }
      return suite
    }
    function deepCloneSuite(suite, filterTest, tags = []) {
      const copy = suite._clone()
      for (const entry of suite._entries) {
        if (entry.constructor.name === 'Suite') {
          copy._addSuite(deepCloneSuite(entry, filterTest, tags))
        } else {
          if (filterTest(entry)) {
            const copiedTest = entry._clone()
            tags.forEach((tag) => {
              const resolvedTag = typeof tag === 'function' ? tag(entry) : tag
              if (resolvedTag) {
                copiedTest[resolvedTag] = true
              }
            })
            copy._addTest(copiedTest)
          }
        }
      }
      return copy
    }
    function getTestsBySuiteFromTestGroups(testGroups) {
      return testGroups.reduce((acc, { requireFile, tests }) => {
        if (acc[requireFile]) {
          acc[requireFile].push(...tests)
        } else {
          acc[requireFile] = [...tests]
        }
        return acc
      }, {})
    }
    function getTestsBySuiteFromTestsById(testsById) {
      const testsByTestSuite = {}
      for (const { test } of testsById.values()) {
        const { _requireFile } = test
        if (test._type === 'beforeAll' || test._type === 'afterAll') {
          continue
        }
        if (testsByTestSuite[_requireFile]) {
          testsByTestSuite[_requireFile].push(test)
        } else {
          testsByTestSuite[_requireFile] = [test]
        }
      }
      return testsByTestSuite
    }
    function getPlaywrightConfig(playwrightRunner) {
      try {
        return playwrightRunner._configLoader.fullConfig()
      } catch {
        try {
          return playwrightRunner._loader.fullConfig()
        } catch {
          return playwrightRunner._config || {}
        }
      }
    }
    function getRootDir(playwrightRunner, configArg) {
      const config = configArg?.config || getPlaywrightConfig(playwrightRunner)
      if (config.rootDir) {
        return config.rootDir
      }
      if (playwrightRunner._configDir) {
        return playwrightRunner._configDir
      }
      if (playwrightRunner._config) {
        return playwrightRunner._config.config?.rootDir || process.cwd()
      }
      return process.cwd()
    }
    function getProjectsFromRunner(runner, configArg) {
      const config = configArg?.projects ? configArg : getPlaywrightConfig(runner)
      return config.projects?.map((project) => {
        if (project.project) {
          return project.project
        }
        return project
      })
    }
    function getProjectsFromDispatcher(dispatcher) {
      const newConfig = dispatcher._config?.config?.projects
      if (newConfig) {
        return newConfig
      }
      return dispatcher._loader?.fullConfig()?.projects
    }
    function getBrowserNameFromProjects(projects, test) {
      if (!projects || !test) {
        return null
      }
      const { _projectIndex, _projectId: testProjectId } = test
      if (_projectIndex !== void 0) {
        return projects[_projectIndex]?.name
      }
      return projects.find(({ __projectId, _id, name }) => {
        if (__projectId !== void 0) {
          return __projectId === testProjectId
        }
        if (_id !== void 0) {
          return _id === testProjectId
        }
        return name === testProjectId
      })?.name
    }
    function formatTestHookError(error, hookType, isTimeout) {
      let hookError = error
      if (error) {
        hookError.message = `Error in ${hookType} hook: ${error.message}`
      }
      if (!hookError && isTimeout) {
        hookError = new Error(`${hookType} hook timed out`)
      }
      return hookError
    }
    function addErrorToTestSuite(testSuiteAbsolutePath, error) {
      if (testSuiteToErrors.has(testSuiteAbsolutePath)) {
        testSuiteToErrors.get(testSuiteAbsolutePath).push(error)
      } else {
        testSuiteToErrors.set(testSuiteAbsolutePath, [error])
      }
    }
    function getTestSuiteError(testSuiteAbsolutePath) {
      const errors = testSuiteToErrors.get(testSuiteAbsolutePath)
      if (!errors) {
        return null
      }
      if (errors.length === 1) {
        return errors[0]
      }
      return new Error(`${errors.length} errors in this test suite:
${errors.map((e) => e.message).join('\n------\n')}`)
    }
    function getTestByTestId(dispatcher, testId) {
      if (dispatcher._testById) {
        return dispatcher._testById.get(testId)?.test
      }
      const allTests = dispatcher._allTests || dispatcher._ddAllTests
      if (allTests) {
        return allTests.find(({ id }) => id === testId)
      }
    }
    function getChannelPromise(channelToPublishTo, params) {
      return new Promise((resolve) => {
        channelToPublishTo.publish({ onDone: resolve, ...params })
      })
    }
    function testWillRetry(test, testStatus) {
      return testStatus === 'fail' && test.results.length <= test.retries
    }
    function getTestFullname(test) {
      let parent = test.parent
      const names = [test.title]
      while (parent?._type === 'describe' || parent?._isDescribe) {
        if (parent.title) {
          names.unshift(parent.title)
        }
        parent = parent.parent
      }
      return names.join(' ')
    }
    function shouldFinishTestSuite(testSuiteAbsolutePath) {
      const remainingTests = remainingTestsByFile[testSuiteAbsolutePath]
      return !remainingTests.length || remainingTests.every((test) => test.expectedStatus === 'skipped')
    }
    function testBeginHandler(test, browserName, shouldCreateTestSpan) {
      const {
        _requireFile: testSuiteAbsolutePath,
        location: { line: testSourceLine },
        _type,
      } = test
      if (_type === 'beforeAll' || _type === 'afterAll') {
        return
      }
      if (!remainingTestsByFile[testSuiteAbsolutePath].length) {
        return
      }
      const isNewTestSuite = !startedSuites.includes(testSuiteAbsolutePath)
      if (isNewTestSuite) {
        startedSuites.push(testSuiteAbsolutePath)
        const testSuiteCtx = { testSuiteAbsolutePath }
        testSuiteToCtx.set(testSuiteAbsolutePath, testSuiteCtx)
        testSuiteStartCh.runStores(testSuiteCtx, () => {})
      }
      if (getTestProperties(test).attemptToFix) {
        test.retries = 0
      }
      if (shouldCreateTestSpan) {
        const testName = getTestFullname(test)
        const testCtx = {
          testName,
          testSuiteAbsolutePath,
          testSourceLine,
          browserName,
          isDisabled: test._ddIsDisabled,
        }
        testToCtx.set(test, testCtx)
        testStartCh.runStores(testCtx, () => {})
      }
    }
    function testEndHandler({ test, annotations, testStatus, error, isTimeout, shouldCreateTestSpan, projects }) {
      const { _requireFile: testSuiteAbsolutePath, results, _type } = test
      let annotationTags
      if (annotations.length) {
        annotationTags = parseAnnotations(annotations)
      }
      if (_type === 'beforeAll' || _type === 'afterAll') {
        const hookError = formatTestHookError(error, _type, isTimeout)
        if (hookError) {
          addErrorToTestSuite(testSuiteAbsolutePath, hookError)
        }
        return
      }
      const testFqn = getTestFullyQualifiedName(test)
      const testStatuses = testsToTestStatuses.get(testFqn) || []
      if (testStatuses.length === 0) {
        testsToTestStatuses.set(testFqn, [testStatus])
      } else {
        testStatuses.push(testStatus)
      }
      const testProperties = getTestProperties(test)
      if (testStatuses.length === testManagementAttemptToFixRetries + 1 && testProperties.attemptToFix) {
        if (testStatuses.includes('fail')) {
          test._ddHasFailedAttemptToFixRetries = true
        }
        if (testStatuses.every((status) => status === 'fail')) {
          test._ddHasFailedAllRetries = true
        } else if (testStatuses.every((status) => status === 'pass')) {
          test._ddHasPassedAttemptToFixRetries = true
        }
      }
      if (shouldCreateTestSpan) {
        const testResult = results.at(-1)
        const testCtx = testToCtx.get(test)
        const isAtrRetry =
          testResult?.retry > 0 && isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry
        if (testCtx) {
          testFinishCh.publish({
            testStatus,
            steps: testResult?.steps || [],
            isRetry: testResult?.retry > 0,
            error,
            extraTags: annotationTags,
            isNew: test._ddIsNew,
            isAttemptToFix: test._ddIsAttemptToFix,
            isAttemptToFixRetry: test._ddIsAttemptToFixRetry,
            isQuarantined: test._ddIsQuarantined,
            isEfdRetry: test._ddIsEfdRetry,
            hasFailedAllRetries: test._ddHasFailedAllRetries,
            hasPassedAttemptToFixRetries: test._ddHasPassedAttemptToFixRetries,
            hasFailedAttemptToFixRetries: test._ddHasFailedAttemptToFixRetries,
            isAtrRetry,
            isModified: test._ddIsModified,
            ...testCtx.currentStore,
          })
        }
      }
      if (testSuiteToTestStatuses.has(testSuiteAbsolutePath)) {
        testSuiteToTestStatuses.get(testSuiteAbsolutePath).push(testStatus)
      } else {
        testSuiteToTestStatuses.set(testSuiteAbsolutePath, [testStatus])
      }
      if (error) {
        addErrorToTestSuite(testSuiteAbsolutePath, error)
      }
      if (!testWillRetry(test, testStatus)) {
        remainingTestsByFile[testSuiteAbsolutePath] = remainingTestsByFile[testSuiteAbsolutePath].filter(
          (currentTest) => currentTest !== test
        )
      }
      if (shouldFinishTestSuite(testSuiteAbsolutePath)) {
        const skippedTests = remainingTestsByFile[testSuiteAbsolutePath].filter(
          (test2) => test2.expectedStatus === 'skipped'
        )
        for (const test2 of skippedTests) {
          const browserName = getBrowserNameFromProjects(projects, test2)
          testSkipCh.publish({
            testName: getTestFullname(test2),
            testSuiteAbsolutePath,
            testSourceLine: test2.location.line,
            browserName,
            isNew: test2._ddIsNew,
            isDisabled: test2._ddIsDisabled,
            isModified: test2._ddIsModified,
            isQuarantined: test2._ddIsQuarantined,
          })
        }
        remainingTestsByFile[testSuiteAbsolutePath] = []
        const testStatuses2 = testSuiteToTestStatuses.get(testSuiteAbsolutePath)
        let testSuiteStatus = 'pass'
        if (testStatuses2.includes('fail')) {
          testSuiteStatus = 'fail'
        } else if (testStatuses2.every((status) => status === 'skip')) {
          testSuiteStatus = 'skip'
        }
        const suiteError = getTestSuiteError(testSuiteAbsolutePath)
        const testSuiteCtx = testSuiteToCtx.get(testSuiteAbsolutePath)
        testSuiteFinishCh.publish({ status: testSuiteStatus, error: suiteError, ...testSuiteCtx.currentStore })
      }
    }
    function dispatcherRunWrapper(run) {
      return function () {
        remainingTestsByFile = getTestsBySuiteFromTestsById(this._testById)
        return run.apply(this, arguments)
      }
    }
    function dispatcherRunWrapperNew(run) {
      return function (testGroups) {
        if (isTestManagementTestsEnabled) {
          testGroups.forEach((group) => {
            group.tests = group.tests.filter((test) => !test._ddIsDisabled)
          })
          testGroups = testGroups.filter((group) => group.tests.length > 0)
        }
        if (!this._allTests) {
          this._ddAllTests = testGroups.flatMap((g) => g.tests)
        }
        remainingTestsByFile = getTestsBySuiteFromTestGroups(testGroups)
        return run.apply(this, arguments)
      }
    }
    function dispatcherHook(dispatcherExport) {
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, 'run', dispatcherRunWrapper)
      shimmer.wrap(
        dispatcherExport.Dispatcher.prototype,
        '_createWorker',
        (createWorker) =>
          function () {
            const dispatcher = this
            const worker = createWorker.apply(this, arguments)
            const projects = getProjectsFromDispatcher(dispatcher)
            sessionProjects = projects
            worker.process.on('message', ({ method, params }) => {
              if (method === 'testBegin') {
                const { test } = dispatcher._testById.get(params.testId)
                const browser = getBrowserNameFromProjects(projects, test)
                testBeginHandler(test, browser, true)
              } else if (method === 'testEnd') {
                const { test } = dispatcher._testById.get(params.testId)
                const { results } = test
                const testResult = results.at(-1)
                const isTimeout = testResult.status === 'timedOut'
                testEndHandler({
                  test,
                  annotations: params.annotations,
                  testStatus: STATUS_TO_TEST_STATUS[testResult.status],
                  error: testResult.error,
                  isTimeout,
                  shouldCreateTestSpan: true,
                  projects,
                })
              }
            })
            return worker
          }
      )
      return dispatcherExport
    }
    function dispatcherHookNew(dispatcherExport, runWrapper) {
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, 'run', runWrapper)
      shimmer.wrap(
        dispatcherExport.Dispatcher.prototype,
        '_createWorker',
        (createWorker) =>
          function () {
            const dispatcher = this
            const worker = createWorker.apply(this, arguments)
            const projects = getProjectsFromDispatcher(dispatcher)
            sessionProjects = projects
            worker.on('testBegin', ({ testId }) => {
              const test = getTestByTestId(dispatcher, testId)
              const browser = getBrowserNameFromProjects(projects, test)
              const shouldCreateTestSpan = test.expectedStatus === 'skipped'
              testBeginHandler(test, browser, shouldCreateTestSpan)
            })
            worker.on('testEnd', ({ testId, status, errors, annotations }) => {
              const test = getTestByTestId(dispatcher, testId)
              const isTimeout = status === 'timedOut'
              const shouldCreateTestSpan = test.expectedStatus === 'skipped'
              testEndHandler({
                test,
                annotations,
                testStatus: STATUS_TO_TEST_STATUS[status],
                error: errors && errors[0],
                isTimeout,
                shouldCreateTestSpan,
                projects,
              })
              const testResult = test.results.at(-1)
              const isAtrRetry =
                testResult?.retry > 0 && isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry
              worker.process.send({
                type: 'ddProperties',
                testId: test.id,
                properties: {
                  _ddIsDisabled: test._ddIsDisabled,
                  _ddIsQuarantined: test._ddIsQuarantined,
                  _ddIsAttemptToFix: test._ddIsAttemptToFix,
                  _ddIsAttemptToFixRetry: test._ddIsAttemptToFixRetry,
                  _ddIsNew: test._ddIsNew,
                  _ddIsEfdRetry: test._ddIsEfdRetry,
                  _ddHasFailedAllRetries: test._ddHasFailedAllRetries,
                  _ddHasPassedAttemptToFixRetries: test._ddHasPassedAttemptToFixRetries,
                  _ddHasFailedAttemptToFixRetries: test._ddHasFailedAttemptToFixRetries,
                  _ddIsAtrRetry: isAtrRetry,
                  _ddIsModified: test._ddIsModified,
                },
              })
            })
            return worker
          }
      )
      return dispatcherExport
    }
    function runAllTestsWrapper(runAllTests, playwrightVersion) {
      return async function (config) {
        let onDone
        rootDir = getRootDir(this, config)
        const processArgv = process.argv.slice(2).join(' ')
        const command = `playwright ${processArgv}`
        testSessionStartCh.publish({ command, frameworkVersion: playwrightVersion, rootDir })
        try {
          const { err, libraryConfig } = await getChannelPromise(libraryConfigurationCh, {
            frameworkVersion: playwrightVersion,
          })
          if (!err) {
            isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled
            isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled
            earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries
            earlyFlakeDetectionFaultyThreshold = libraryConfig.earlyFlakeDetectionFaultyThreshold
            isFlakyTestRetriesEnabled = libraryConfig.isFlakyTestRetriesEnabled
            flakyTestRetriesCount = libraryConfig.flakyTestRetriesCount
            isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled
            testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries
            isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled
          }
        } catch (e) {
          isEarlyFlakeDetectionEnabled = false
          isKnownTestsEnabled = false
          isTestManagementTestsEnabled = false
          isImpactedTestsEnabled = false
          log.error('Playwright session start error', e)
        }
        if (isKnownTestsEnabled && satisfies(playwrightVersion, MINIMUM_SUPPORTED_VERSION_RANGE_EFD)) {
          try {
            const { err, knownTests: receivedKnownTests } = await getChannelPromise(knownTestsCh)
            if (err) {
              isEarlyFlakeDetectionEnabled = false
              isKnownTestsEnabled = false
            } else {
              knownTests = receivedKnownTests
            }
            if (!isValidKnownTests(receivedKnownTests)) {
              isEarlyFlakeDetectionFaulty = true
              isEarlyFlakeDetectionEnabled = false
              isKnownTestsEnabled = false
            }
          } catch (err) {
            isEarlyFlakeDetectionEnabled = false
            isKnownTestsEnabled = false
            log.error('Playwright known tests error', err)
          }
        }
        if (isTestManagementTestsEnabled && satisfies(playwrightVersion, MINIMUM_SUPPORTED_VERSION_RANGE_EFD)) {
          try {
            const { err, testManagementTests: receivedTestManagementTests } =
              await getChannelPromise(testManagementTestsCh)
            if (err) {
              isTestManagementTestsEnabled = false
            } else {
              testManagementTests = receivedTestManagementTests
            }
          } catch (err) {
            isTestManagementTestsEnabled = false
            log.error('Playwright test management tests error', err)
          }
        }
        if (isImpactedTestsEnabled && satisfies(playwrightVersion, MINIMUM_SUPPORTED_VERSION_RANGE_EFD)) {
          try {
            const { err, modifiedFiles: receivedModifiedFiles } = await getChannelPromise(modifiedFilesCh)
            if (err) {
              isImpactedTestsEnabled = false
            } else {
              modifiedFiles = receivedModifiedFiles
            }
          } catch (err) {
            isImpactedTestsEnabled = false
            log.error('Playwright impacted tests error', err)
          }
        }
        const projects = getProjectsFromRunner(this, config)
        const shouldSetATRRetries = isFlakyTestRetriesEnabled && flakyTestRetriesCount > 0
        if (shouldSetATRRetries) {
          projects.forEach((project) => {
            if (project.retries === 0) {
              project.retries = flakyTestRetriesCount
            }
          })
        }
        let runAllTestsReturn = await runAllTests.apply(this, arguments)
        Object.values(remainingTestsByFile).forEach((tests) => {
          tests.forEach((test) => {
            const browser = getBrowserNameFromProjects(projects, test)
            testBeginHandler(test, browser, true)
            testEndHandler({
              test,
              annotations: [],
              testStatus: 'skip',
              error: null,
              isTimeout: false,
              shouldCreateTestSpan: true,
              projects,
            })
          })
        })
        let preventedToFail = false
        const sessionStatus = runAllTestsReturn.status || runAllTestsReturn
        if (isTestManagementTestsEnabled && sessionStatus === 'failed') {
          let totalFailedTestCount = 0
          let totalAttemptToFixFailedTestCount = 0
          let totalPureQuarantinedFailedTestCount = 0
          for (const [fqn, testStatuses] of testsToTestStatuses.entries()) {
            const lastStatus = testStatuses[testStatuses.length - 1]
            if (lastStatus === 'fail') {
              totalFailedTestCount += 1
              if (quarantinedButNotAttemptToFixFqns.has(fqn)) {
                totalPureQuarantinedFailedTestCount += 1
              }
            }
          }
          for (const test of quarantinedOrDisabledTestsAttemptToFix) {
            const testFqn = getTestFullyQualifiedName(test)
            const testStatuses = testsToTestStatuses.get(testFqn)
            if (testStatuses && testStatuses[testStatuses.length - 1] === 'fail') {
              totalAttemptToFixFailedTestCount += 1
            }
          }
          const totalIgnorableFailures = totalAttemptToFixFailedTestCount + totalPureQuarantinedFailedTestCount
          if (totalFailedTestCount > 0 && totalFailedTestCount === totalIgnorableFailures) {
            runAllTestsReturn = 'passed'
            preventedToFail = true
          }
        }
        const flushWait = new Promise((resolve) => {
          onDone = resolve
        })
        testSessionFinishCh.publish({
          status: preventedToFail ? 'pass' : STATUS_TO_TEST_STATUS[sessionStatus],
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          onDone,
        })
        await flushWait
        startedSuites = []
        remainingTestsByFile = {}
        quarantinedButNotAttemptToFixFqns = /* @__PURE__ */ new Set()
        return runAllTestsReturn
      }
    }
    function runnerHook(runnerExport, playwrightVersion) {
      shimmer.wrap(runnerExport.Runner.prototype, 'runAllTests', (runAllTests) =>
        runAllTestsWrapper(runAllTests, playwrightVersion)
      )
    }
    function runnerHookNew(runnerExport, playwrightVersion) {
      runnerExport = shimmer.wrap(runnerExport, 'runAllTestsWithConfig', function (originalGetter) {
        const originalFunction = originalGetter.call(this)
        return function () {
          return runAllTestsWrapper(originalFunction, playwrightVersion)
        }
      })
      return runnerExport
    }
    if (DD_MAJOR < 6) {
      addHook(
        {
          name: '@playwright/test',
          file: 'lib/runner.js',
          versions: ['>=1.18.0 <=1.30.0'],
        },
        runnerHook
      )
      addHook(
        {
          name: '@playwright/test',
          file: 'lib/dispatcher.js',
          versions: ['>=1.18.0 <1.30.0'],
        },
        dispatcherHook
      )
      addHook(
        {
          name: '@playwright/test',
          file: 'lib/dispatcher.js',
          versions: ['>=1.30.0 <1.31.0'],
        },
        (dispatcher) => dispatcherHookNew(dispatcher, dispatcherRunWrapper)
      )
      addHook(
        {
          name: '@playwright/test',
          file: 'lib/runner/dispatcher.js',
          versions: ['>=1.31.0 <1.38.0'],
        },
        (dispatcher) => dispatcherHookNew(dispatcher, dispatcherRunWrapperNew)
      )
      addHook(
        {
          name: '@playwright/test',
          file: 'lib/runner/runner.js',
          versions: ['>=1.31.0 <1.38.0'],
        },
        runnerHook
      )
    }
    addHook(
      {
        name: 'playwright',
        file: 'lib/runner/runner.js',
        versions: ['>=1.38.0'],
      },
      runnerHook
    )
    addHook(
      {
        name: 'playwright',
        file: 'lib/runner/testRunner.js',
        versions: ['>=1.55.0'],
      },
      runnerHookNew
    )
    addHook(
      {
        name: 'playwright',
        file: 'lib/runner/dispatcher.js',
        versions: ['>=1.38.0'],
      },
      (dispatcher) => dispatcherHookNew(dispatcher, dispatcherRunWrapperNew)
    )
    addHook(
      {
        name: 'playwright',
        file: 'lib/common/suiteUtils.js',
        versions: ['>=1.38.0'],
      },
      (suiteUtilsPackage) => {
        applyRepeatEachIndex = suiteUtilsPackage.applyRepeatEachIndex
        return suiteUtilsPackage
      }
    )
    function applyRetriesToTests(fileSuitesWithTestsToRetry, filterTest, tagsToApply, numRetries) {
      for (const [fileSuite, projectSuite] of fileSuitesWithTestsToRetry.entries()) {
        for (let repeatEachIndex = 1; repeatEachIndex <= numRetries; repeatEachIndex++) {
          const copyFileSuite = deepCloneSuite(fileSuite, filterTest, tagsToApply)
          applyRepeatEachIndex(projectSuite._fullProject, copyFileSuite, repeatEachIndex + 1)
          projectSuite._addSuite(copyFileSuite)
        }
      }
    }
    addHook(
      {
        name: 'playwright',
        file: 'lib/runner/loadUtils.js',
        versions: ['>=1.38.0'],
      },
      (loadUtilsPackage) => {
        const oldCreateRootSuite = loadUtilsPackage.createRootSuite
        async function newCreateRootSuite() {
          if (!isKnownTestsEnabled && !isTestManagementTestsEnabled && !isImpactedTestsEnabled) {
            return oldCreateRootSuite.apply(this, arguments)
          }
          const createRootSuiteReturnValue = await oldCreateRootSuite.apply(this, arguments)
          const rootSuite = createRootSuiteReturnValue.rootSuite || createRootSuiteReturnValue
          const allTests = rootSuite.allTests()
          if (isTestManagementTestsEnabled) {
            const fileSuitesWithManagedTestsToProjects = /* @__PURE__ */ new Map()
            for (const test of allTests) {
              const testProperties = getTestProperties(test)
              if (testProperties.disabled) {
                test._ddIsDisabled = true
                test.expectedStatus = 'skipped'
                continue
              }
              if (testProperties.quarantined) {
                test._ddIsQuarantined = true
                if (!testProperties.attemptToFix) {
                  const testFqn = getTestFullyQualifiedName(test)
                  quarantinedButNotAttemptToFixFqns.add(testFqn)
                }
              }
              if (testProperties.attemptToFix) {
                test._ddIsAttemptToFix = true
                test.retries = 0
                const fileSuite = getSuiteType(test, 'file')
                if (!fileSuitesWithManagedTestsToProjects.has(fileSuite)) {
                  fileSuitesWithManagedTestsToProjects.set(fileSuite, getSuiteType(test, 'project'))
                }
                if (testProperties.disabled || testProperties.quarantined) {
                  quarantinedOrDisabledTestsAttemptToFix.push(test)
                }
              }
            }
            applyRetriesToTests(
              fileSuitesWithManagedTestsToProjects,
              (test) => test._ddIsAttemptToFix,
              [(test) => test._ddIsQuarantined && '_ddIsQuarantined', '_ddIsAttemptToFix', '_ddIsAttemptToFixRetry'],
              testManagementAttemptToFixRetries
            )
          }
          if (isImpactedTestsEnabled) {
            const impactedTests = allTests.filter((test) => {
              let isImpacted = false
              isModifiedCh.publish({
                filePath: test._requireFile,
                modifiedFiles,
                onDone: (isModified) => {
                  isImpacted = isModified
                },
              })
              return isImpacted
            })
            const fileSuitesWithImpactedTestsToProjects = /* @__PURE__ */ new Map()
            impactedTests.forEach((impactedTest) => {
              impactedTest._ddIsModified = true
              if (isEarlyFlakeDetectionEnabled && impactedTest.expectedStatus !== 'skipped') {
                const fileSuite = getSuiteType(impactedTest, 'file')
                if (!fileSuitesWithImpactedTestsToProjects.has(fileSuite)) {
                  fileSuitesWithImpactedTestsToProjects.set(fileSuite, getSuiteType(impactedTest, 'project'))
                }
              }
            })
            applyRetriesToTests(
              fileSuitesWithImpactedTestsToProjects,
              () => true,
              [
                '_ddIsModified',
                '_ddIsEfdRetry',
                (test) => (isKnownTestsEnabled && isNewTest(test) ? '_ddIsNew' : null),
              ],
              earlyFlakeDetectionNumRetries
            )
          }
          if (isKnownTestsEnabled) {
            const newTests = allTests.filter(isNewTest)
            const isFaulty = getIsFaultyEarlyFlakeDetection(
              allTests.map((test) => getTestSuitePath(test._requireFile, rootDir)),
              knownTests.playwright,
              earlyFlakeDetectionFaultyThreshold
            )
            if (isFaulty) {
              isEarlyFlakeDetectionEnabled = false
              isKnownTestsEnabled = false
              isEarlyFlakeDetectionFaulty = true
            } else {
              const fileSuitesWithNewTestsToProjects = /* @__PURE__ */ new Map()
              newTests.forEach((newTest) => {
                newTest._ddIsNew = true
                if (isEarlyFlakeDetectionEnabled && newTest.expectedStatus !== 'skipped' && !newTest._ddIsModified) {
                  newTest.retries = 0
                  const fileSuite = getSuiteType(newTest, 'file')
                  if (!fileSuitesWithNewTestsToProjects.has(fileSuite)) {
                    fileSuitesWithNewTestsToProjects.set(fileSuite, getSuiteType(newTest, 'project'))
                  }
                }
              })
              applyRetriesToTests(
                fileSuitesWithNewTestsToProjects,
                isNewTest,
                ['_ddIsNew', '_ddIsEfdRetry'],
                earlyFlakeDetectionNumRetries
              )
            }
          }
          return createRootSuiteReturnValue
        }
        const proxy = new Proxy(loadUtilsPackage, {
          get(target, prop) {
            if (prop === 'createRootSuite') {
              return newCreateRootSuite
            }
            return target[prop]
          },
        })
        return proxy
      }
    )
    addHook(
      {
        name: 'playwright',
        file: 'lib/runner/processHost.js',
        versions: ['>=1.38.0'],
      },
      (processHostPackage) => {
        shimmer.wrap(
          processHostPackage.ProcessHost.prototype,
          'startRunner',
          (startRunner) =>
            async function () {
              this._extraEnv = {
                ...this._extraEnv,
                // Used to detect that we're in a playwright worker
                DD_PLAYWRIGHT_WORKER: '1',
              }
              const res = await startRunner.apply(this, arguments)
              this.process.on('message', (message) => {
                if (Array.isArray(message) && message[0] === PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE) {
                  workerReportCh.publish(message[1])
                }
              })
              return res
            }
        )
        return processHostPackage
      }
    )
    addHook(
      {
        name: 'playwright-core',
        file: 'lib/client/page.js',
        versions: ['>=1.38.0'],
      },
      (pagePackage) => {
        shimmer.wrap(
          pagePackage.Page.prototype,
          'goto',
          (goto) =>
            async function (url, options) {
              const response = await goto.apply(this, arguments)
              const page = this
              try {
                if (page) {
                  const { isRumInstrumented, isRumActive, rumSamplingRate } = await page.evaluate(() => {
                    const isRumInstrumented2 = !!window.DD_RUM
                    const isRumActive2 =
                      window.DD_RUM && window.DD_RUM.getInternalContext ? !!window.DD_RUM.getInternalContext() : false
                    const rumSamplingRate2 =
                      window.DD_RUM && window.DD_RUM.getInitConfiguration
                        ? window.DD_RUM.getInitConfiguration().sessionSampleRate
                        : null
                    return {
                      isRumInstrumented: isRumInstrumented2,
                      isRumActive: isRumActive2,
                      rumSamplingRate: rumSamplingRate2,
                    }
                  })
                  if (isRumInstrumented && rumSamplingRate < 100 && !isRumActive) {
                    log.debug(
                      "RUM was detected on the page, but it isn't active because the sampling rate is below 100%"
                    )
                  }
                  if (isRumActive) {
                    testPageGotoCh.publish({
                      isRumActive,
                      page,
                    })
                  }
                }
              } catch (e) {
                log.error('goto hook error', e)
              }
              return response
            }
        )
        return pagePackage
      }
    )
    addHook(
      {
        name: 'playwright',
        file: 'lib/worker/workerMain.js',
        versions: ['>=1.38.0'],
      },
      (workerPackage) => {
        let steps = []
        const stepInfoByStepId = {}
        shimmer.wrap(
          workerPackage.WorkerMain.prototype,
          '_runTest',
          (_runTest) =>
            async function (test) {
              if (test.expectedStatus === 'skipped') {
                return _runTest.apply(this, arguments)
              }
              steps = []
              const {
                _requireFile: testSuiteAbsolutePath,
                location: { line: testSourceLine },
              } = test
              let res
              let testInfo
              const testName = getTestFullname(test)
              const browserName = this._project.project.name
              const testCtx = {
                testName,
                testSuiteAbsolutePath,
                testSourceLine,
                browserName,
              }
              testToCtx.set(test, testCtx)
              testStartCh.runStores(testCtx, () => {
                let existAfterEachHook = false
                for (const hook of test.parent._hooks) {
                  if (hook.type === 'afterEach' && hook._ddHook) {
                    existAfterEachHook = true
                    break
                  }
                }
                if (!existAfterEachHook) {
                  test.parent._hooks.push({
                    type: 'afterEach',
                    fn: async function ({ page }) {
                      try {
                        if (page) {
                          const isRumActive = await page.evaluate(() => {
                            if (window.DD_RUM && window.DD_RUM.stopSession) {
                              window.DD_RUM.stopSession()
                              return true
                            }
                            return false
                          })
                          if (isRumActive) {
                            await new Promise((resolve) => setTimeout(resolve, RUM_FLUSH_WAIT_TIME))
                            const url = page.url()
                            if (url) {
                              const domain = new URL(url).hostname
                              await page.context().addCookies([
                                {
                                  name: 'datadog-ci-visibility-test-execution-id',
                                  value: '',
                                  domain,
                                  path: '/',
                                },
                              ])
                            } else {
                              log.error('RUM is active but page.url() is not available')
                            }
                          }
                        }
                      } catch (e) {
                        log.error('afterEach hook error', e)
                      }
                    },
                    title: 'afterEach hook',
                    _ddHook: true,
                  })
                }
                res = _runTest.apply(this, arguments)
                testInfo = this._currentTest
              })
              await res
              const { status, error, annotations, retry, testId } = testInfo
              let annotationTags
              if (annotations.length) {
                annotationTags = parseAnnotations(annotations)
              }
              let onDone
              const flushPromise = new Promise((resolve) => {
                onDone = resolve
              })
              const ddPropertiesPromise = new Promise((resolve) => {
                const messageHandler = ({ type, testId: testId2, properties }) => {
                  if (type === 'ddProperties' && testId2 === test.id) {
                    if (properties) {
                      Object.assign(test, properties)
                    }
                    process.removeListener('message', messageHandler)
                    resolve()
                  }
                }
                process.on('message', messageHandler)
              })
              await ddPropertiesPromise
              testFinishCh.publish({
                testStatus: STATUS_TO_TEST_STATUS[status],
                steps: steps.filter((step) => step.testId === testId),
                error,
                extraTags: annotationTags,
                isNew: test._ddIsNew,
                isRetry: retry > 0,
                isEfdRetry: test._ddIsEfdRetry,
                isAttemptToFix: test._ddIsAttemptToFix,
                isDisabled: test._ddIsDisabled,
                isQuarantined: test._ddIsQuarantined,
                isAttemptToFixRetry: test._ddIsAttemptToFixRetry,
                hasFailedAllRetries: test._ddHasFailedAllRetries,
                hasPassedAttemptToFixRetries: test._ddHasPassedAttemptToFixRetries,
                hasFailedAttemptToFixRetries: test._ddHasFailedAttemptToFixRetries,
                isAtrRetry: test._ddIsAtrRetry,
                isModified: test._ddIsModified,
                onDone,
                ...testCtx.currentStore,
              })
              await flushPromise
              return res
            }
        )
        shimmer.wrap(
          workerPackage.WorkerMain.prototype,
          'dispatchEvent',
          (dispatchEvent) =>
            function (event, payload) {
              if (event === 'stepBegin') {
                stepInfoByStepId[payload.stepId] = {
                  startTime: payload.wallTime,
                  title: payload.title,
                  testId: payload.testId,
                }
              } else if (event === 'stepEnd') {
                const stepInfo = stepInfoByStepId[payload.stepId]
                delete stepInfoByStepId[payload.stepId]
                steps.push({
                  testId: stepInfo.testId,
                  startTime: new Date(stepInfo.startTime),
                  title: stepInfo.title,
                  duration: payload.wallTime - stepInfo.startTime,
                  error: payload.error,
                })
              }
              return dispatchEvent.apply(this, arguments)
            }
        )
        return workerPackage
      }
    )
    function generateSummaryWrapper(generateSummary) {
      return function () {
        for (const test of this.suite.allTests()) {
          const didNotRun = test.outcome() === 'skipped' && (!test.results.length || test.expectedStatus !== 'skipped')
          if (didNotRun) {
            const {
              _requireFile: testSuiteAbsolutePath,
              location: { line: testSourceLine },
              _ddIsNew: isNew,
              _ddIsDisabled: isDisabled,
              _ddIsModified: isModified,
              _ddIsQuarantined: isQuarantined,
            } = test
            const browserName = getBrowserNameFromProjects(sessionProjects, test)
            testSkipCh.publish({
              testName: getTestFullname(test),
              testSuiteAbsolutePath,
              testSourceLine,
              browserName,
              isNew,
              isDisabled,
              isModified,
              isQuarantined,
            })
          }
        }
        return generateSummary.apply(this, arguments)
      }
    }
    addHook(
      {
        name: 'playwright',
        file: 'lib/reporters/base.js',
        versions: ['>=1.38.0'],
      },
      (reportersPackage) => {
        if (reportersPackage.TerminalReporter) {
          shimmer.wrap(reportersPackage.TerminalReporter.prototype, 'generateSummary', generateSummaryWrapper)
        } else if (reportersPackage.BaseReporter) {
          shimmer.wrap(reportersPackage.BaseReporter.prototype, 'generateSummary', generateSummaryWrapper)
        }
        return reportersPackage
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js
var require_elasticsearch = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js'(exports2, module2) {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: '@elastic/transport', file: 'lib/Transport.js', versions: ['>=8'] }, (exports3) => {
      shimmer.wrap(exports3.default.prototype, 'request', createWrapRequest('elasticsearch'))
      shimmer.wrap(exports3.default.prototype, 'getConnection', createWrapGetConnection('elasticsearch'))
      return exports3
    })
    addHook(
      { name: '@elastic/elasticsearch', file: 'lib/Transport.js', versions: ['>=5.6.16 <8', '>=8'] },
      (Transport) => {
        shimmer.wrap(Transport.prototype, 'request', createWrapRequest('elasticsearch'))
        shimmer.wrap(Transport.prototype, 'getConnection', createWrapGetConnection('elasticsearch'))
        return Transport
      }
    )
    addHook({ name: 'elasticsearch', file: 'src/lib/transport.js', versions: ['>=10'] }, (Transport) => {
      shimmer.wrap(Transport.prototype, 'request', createWrapRequest('elasticsearch'))
      return Transport
    })
    addHook({ name: 'elasticsearch', file: 'src/lib/connection_pool.js', versions: ['>=10'] }, (ConnectionPool) => {
      shimmer.wrap(ConnectionPool.prototype, 'select', createWrapSelect('elasticsearch'))
      return ConnectionPool
    })
    function createWrapGetConnection(name) {
      const connectCh = channel(`apm:${name}:query:connect`)
      return function wrapRequest(request) {
        return function () {
          const connection = request.apply(this, arguments)
          if (connectCh.hasSubscribers && connection && connection.url) {
            connectCh.publish(connection.url)
          }
          return connection
        }
      }
    }
    function createWrapSelect() {
      const connectCh = channel('apm:elasticsearch:query:connect')
      return function wrapRequest(request) {
        return function () {
          if (arguments.length === 1) {
            const cb = arguments[0]
            arguments[0] = shimmer.wrapFunction(
              cb,
              (cb2) =>
                function (err, connection) {
                  if (connectCh.hasSubscribers && connection && connection.host) {
                    connectCh.publish({ hostname: connection.host.host, port: connection.host.port })
                  }
                  cb2(err, connection)
                }
            )
          }
          return request.apply(this, arguments)
        }
      }
    }
    function createWrapRequest(name) {
      const startCh = channel(`apm:${name}:query:start`)
      const finishCh = channel(`apm:${name}:query:finish`)
      const errorCh = channel(`apm:${name}:query:error`)
      return function wrapRequest(request) {
        return function (params, options, cb) {
          if (!startCh.hasSubscribers) {
            return request.apply(this, arguments)
          }
          if (!params) return request.apply(this, arguments)
          const ctx = { params }
          return startCh.runStores(ctx, () => {
            try {
              const lastIndex = arguments.length - 1
              cb = arguments[lastIndex]
              if (typeof cb === 'function') {
                arguments[lastIndex] = shimmer.wrapFunction(
                  cb,
                  (cb2) =>
                    function (error) {
                      if (error) {
                        ctx.error = error
                        errorCh.publish(ctx)
                      }
                      return finishCh.runStores(ctx, cb2, null, ...arguments)
                    }
                )
                return request.apply(this, arguments)
              }
              const promise = request.apply(this, arguments)
              if (promise && typeof promise.then === 'function') {
                const onResolve = () => finish(ctx)
                const onReject = (e) => finish(ctx, e)
                promise.then(onResolve, onReject)
              } else {
                finish(ctx)
              }
              return promise
            } catch (err) {
              err.stack
              errorCh.publish(err)
              throw err
            }
          })
        }
      }
      function finish(ctx, error) {
        if (error) {
          ctx.error = error
          errorCh.publish(error)
        }
        return finishCh.runStores(ctx, () => {})
      }
    }
    module2.exports = { createWrapRequest, createWrapGetConnection }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/google-genai.js
var require_google_genai = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/google-genai.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var tracingChannel = require_dc_polyfill().tracingChannel
    var channel = require_dc_polyfill().channel
    var genaiTracingChannel = tracingChannel('apm:google:genai:request')
    var onStreamedChunkCh = channel('apm:google:genai:request:chunk')
    function wrapGenerateContent(method) {
      return function wrappedGenerateContent(original) {
        return function (...args) {
          if (!genaiTracingChannel.start.hasSubscribers) {
            return original.apply(this, args)
          }
          const normalizedName = normalizeMethodName(method)
          const ctx = { args, methodName: normalizedName }
          return genaiTracingChannel.start.runStores(ctx, () => {
            let result
            try {
              result = original.apply(this, arguments)
            } catch (error) {
              finish(ctx, null, error)
              throw error
            } finally {
              genaiTracingChannel.end.publish(ctx)
            }
            return result
              .then((response) => {
                if (response[Symbol.asyncIterator]) {
                  shimmer.wrap(response, Symbol.asyncIterator, (iterator) => wrapStreamIterator(iterator, ctx))
                } else {
                  finish(ctx, response, null)
                }
                return response
              })
              .catch((error) => {
                finish(ctx, null, error)
                throw error
              })
          })
        }
      }
    }
    function wrapStreamIterator(iterator, ctx) {
      return function () {
        const itr = iterator.apply(this, arguments)
        shimmer.wrap(
          itr,
          'next',
          (next) =>
            function () {
              return next
                .apply(this, arguments)
                .then((res) => {
                  const { done, value: chunk } = res
                  onStreamedChunkCh.publish({ ctx, chunk, done })
                  if (done) {
                    finish(ctx)
                  }
                  return res
                })
                .catch((error) => {
                  finish(ctx, null, error)
                  throw error
                })
            }
        )
        return itr
      }
    }
    function finish(ctx, result, error) {
      if (error) {
        ctx.error = error
        genaiTracingChannel.error.publish(ctx)
      }
      ctx.result ??= result
      genaiTracingChannel.asyncEnd.publish(ctx)
    }
    addHook(
      {
        name: '@google/genai',
        versions: ['>=1.19.0'],
      },
      (exports3) => {
        if (!exports3.GoogleGenAI) return exports3
        shimmer.wrap(exports3, 'GoogleGenAI', (GoogleGenAI) => {
          return class extends GoogleGenAI {
            constructor(...args) {
              super(...args)
              if (this.models) {
                if (this.models.generateContent) {
                  shimmer.wrap(this.models, 'generateContent', wrapGenerateContent('generateContent'))
                }
                if (this.models.generateContentStream) {
                  shimmer.wrap(this.models, 'generateContentStream', wrapGenerateContent('generateContentStream'))
                }
                if (this.models.embedContent) {
                  shimmer.wrap(this.models, 'embedContent', wrapGenerateContent('embedContent'))
                }
              }
            }
          }
        })
        return exports3
      }
    )
    function normalizeMethodName(methodName) {
      return 'Models.' + methodName.replaceAll(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase()
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/google-cloud-pubsub.js
var require_google_cloud_pubsub = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/google-cloud-pubsub.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var requestStartCh = channel('apm:google-cloud-pubsub:request:start')
    var requestFinishCh = channel('apm:google-cloud-pubsub:request:finish')
    var requestErrorCh = channel('apm:google-cloud-pubsub:request:error')
    var receiveStartCh = channel('apm:google-cloud-pubsub:receive:start')
    var receiveFinishCh = channel('apm:google-cloud-pubsub:receive:finish')
    var receiveErrorCh = channel('apm:google-cloud-pubsub:receive:error')
    var publisherMethods = [
      'createTopic',
      'updateTopic',
      'publish',
      'getTopic',
      'listTopics',
      'listTopicSubscriptions',
      'listTopicSnapshots',
      'deleteTopic',
      'detachSubscription',
    ]
    var schemaServiceMethods = [
      'createSchema',
      'getSchema',
      'listSchemas',
      'listSchemaRevisions',
      'commitSchema',
      'rollbackSchema',
      'deleteSchemaRevision',
      'deleteSchema',
      'validateSchema',
      'validateMessage',
    ]
    var subscriberMethods = [
      'createSubscription',
      'getSubscription',
      'updateSubscription',
      'listSubscriptions',
      'deleteSubscription',
      'modifyAckDeadline',
      'acknowledge',
      'pull',
      'streamingPull',
      'modifyPushConfig',
      'getSnapshot',
      'listSnapshots',
      'createSnapshot',
      'updateSnapshot',
      'deleteSnapshot',
      'seek',
    ]
    function wrapMethod(method) {
      const api = method.name
      return function (request) {
        if (!requestStartCh.hasSubscribers) return method.apply(this, arguments)
        const ctx = { request, api, projectId: this.auth._cachedProjectId }
        return requestStartCh.runStores(ctx, () => {
          const cb = arguments[arguments.length - 1]
          if (typeof cb === 'function') {
            arguments[arguments.length - 1] = shimmer.wrapFunction(
              cb,
              (cb2) =>
                function (error) {
                  if (error) {
                    ctx.error = error
                    requestErrorCh.publish(ctx)
                  }
                  return requestFinishCh.runStores(ctx, cb2, this, ...arguments)
                }
            )
            return method.apply(this, arguments)
          }
          return method.apply(this, arguments).then(
            (response) => {
              requestFinishCh.publish(ctx)
              return response
            },
            (error) => {
              ctx.error = error
              requestErrorCh.publish(ctx)
              requestFinishCh.publish(ctx)
              throw error
            }
          )
        })
      }
    }
    function massWrap(obj, methods, wrapper) {
      for (const method of methods) {
        if (typeof obj[method] === 'function') {
          shimmer.wrap(obj, method, wrapper)
        }
      }
    }
    addHook({ name: '@google-cloud/pubsub', versions: ['>=1.2'] }, (obj) => {
      const Subscription = obj.Subscription
      shimmer.wrap(
        Subscription.prototype,
        'emit',
        (emit) =>
          function (eventName, message) {
            if (eventName !== 'message' || !message) return emit.apply(this, arguments)
            const ctx = {}
            try {
              return emit.apply(this, arguments)
            } catch (err) {
              ctx.error = err
              receiveErrorCh.publish(ctx)
              throw err
            }
          }
      )
      return obj
    })
    addHook({ name: '@google-cloud/pubsub', versions: ['>=1.2'], file: 'build/src/lease-manager.js' }, (obj) => {
      const LeaseManager = obj.LeaseManager
      const ctx = {}
      shimmer.wrap(
        LeaseManager.prototype,
        '_dispense',
        (dispense) =>
          function (message) {
            if (receiveStartCh.hasSubscribers) {
              ctx.message = message
              return receiveStartCh.runStores(ctx, dispense, this, ...arguments)
            }
            return dispense.apply(this, arguments)
          }
      )
      shimmer.wrap(
        LeaseManager.prototype,
        'remove',
        (remove) =>
          function (message) {
            return receiveFinishCh.runStores(ctx, remove, this, ...arguments)
          }
      )
      shimmer.wrap(
        LeaseManager.prototype,
        'clear',
        (clear) =>
          function () {
            for (const message of this._messages) {
              ctx.message = message
              receiveFinishCh.publish(ctx)
            }
            return clear.apply(this, arguments)
          }
      )
      return obj
    })
    addHook({ name: '@google-cloud/pubsub', versions: ['>=1.2'] }, (obj) => {
      const { PublisherClient, SchemaServiceClient, SubscriberClient } = obj.v1
      massWrap(PublisherClient.prototype, publisherMethods, wrapMethod)
      massWrap(SubscriberClient.prototype, subscriberMethods, wrapMethod)
      if (SchemaServiceClient) {
        massWrap(SchemaServiceClient.prototype, schemaServiceMethods, wrapMethod)
      }
      return obj
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/google-cloud-vertexai.js
var require_google_cloud_vertexai = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/google-cloud-vertexai.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var vertexaiTracingChannel = require_dc_polyfill().tracingChannel('apm:vertexai:request')
    function wrapGenerate(generate) {
      return function (request) {
        if (!vertexaiTracingChannel.start.hasSubscribers) {
          return generate.apply(this, arguments)
        }
        const ctx = {
          request,
          instance: this,
          resource: [this.constructor.name, generate.name].join('.'),
        }
        return vertexaiTracingChannel.tracePromise(generate, ctx, this, ...arguments)
      }
    }
    function wrapGenerateStream(generateStream) {
      return function (request) {
        if (!vertexaiTracingChannel.start.hasSubscribers) {
          return generateStream.apply(this, arguments)
        }
        const ctx = {
          request,
          instance: this,
          resource: [this.constructor.name, generateStream.name].join('.'),
          stream: true,
        }
        return vertexaiTracingChannel.start.runStores(ctx, () => {
          let streamingResult
          try {
            streamingResult = generateStream.apply(this, arguments)
          } catch (e) {
            finish(ctx, null, e, true)
            throw e
          }
          vertexaiTracingChannel.end.publish(ctx)
          return streamingResult
            .then((stream) => {
              stream.response
                .then((response) => {
                  finish(ctx, response, null)
                })
                .catch((e) => {
                  finish(ctx, null, e)
                  throw e
                })
              return stream
            })
            .catch((e) => {
              finish(ctx, null, e)
              throw e
            })
        })
      }
    }
    function finish(ctx, response, err, publishEndEvent = false) {
      if (err) {
        ctx.error = err
        vertexaiTracingChannel.error.publish(ctx)
      }
      ctx.result = { response }
      if (publishEndEvent) vertexaiTracingChannel.end.publish(ctx)
      vertexaiTracingChannel.asyncEnd.publish(ctx)
    }
    addHook(
      {
        name: '@google-cloud/vertexai',
        file: 'build/src/models/generative_models.js',
        versions: ['>=1'],
      },
      (exports3) => {
        const GenerativeModel = exports3.GenerativeModel
        shimmer.wrap(GenerativeModel.prototype, 'generateContent', wrapGenerate)
        shimmer.wrap(GenerativeModel.prototype, 'generateContentStream', wrapGenerateStream)
        return exports3
      }
    )
    addHook(
      {
        name: '@google-cloud/vertexai',
        file: 'build/src/models/chat_session.js',
        versions: ['>=1'],
      },
      (exports3) => {
        const ChatSession = exports3.ChatSession
        shimmer.wrap(ChatSession.prototype, 'sendMessage', wrapGenerate)
        shimmer.wrap(ChatSession.prototype, 'sendMessageStream', wrapGenerateStream)
        return exports3
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/graphql.js
var require_graphql = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/graphql.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var ddGlobal = (globalThis[/* @__PURE__ */ Symbol.for('dd-trace')] ??= {})
    var contexts = /* @__PURE__ */ new WeakMap()
    var documentSources = /* @__PURE__ */ new WeakMap()
    var patchedResolvers = /* @__PURE__ */ new WeakSet()
    var patchedTypes = /* @__PURE__ */ new WeakSet()
    var startExecuteCh = channel('apm:graphql:execute:start')
    var finishExecuteCh = channel('apm:graphql:execute:finish')
    var executeErrorCh = channel('apm:graphql:execute:error')
    var startResolveCh = channel('apm:graphql:resolve:start')
    var finishResolveCh = channel('apm:graphql:resolve:finish')
    var updateFieldCh = channel('apm:graphql:resolve:updateField')
    var resolveErrorCh = channel('apm:graphql:resolve:error')
    var parseStartCh = channel('apm:graphql:parser:start')
    var parseFinishCh = channel('apm:graphql:parser:finish')
    var parseErrorCh = channel('apm:graphql:parser:error')
    var validateStartCh = channel('apm:graphql:validate:start')
    var validateFinishCh = channel('apm:graphql:validate:finish')
    var validateErrorCh = channel('apm:graphql:validate:error')
    var AbortError = class extends Error {
      constructor(message) {
        super(message)
        this.name = 'AbortError'
      }
    }
    var types = /* @__PURE__ */ new Set(['query', 'mutation', 'subscription'])
    function getOperation(document, operationName) {
      if (!document || !Array.isArray(document.definitions)) {
        return
      }
      for (const definition of document.definitions) {
        if (
          definition &&
          types.has(definition.operation) &&
          (!operationName || definition.name?.value === operationName)
        ) {
          return definition
        }
      }
    }
    function normalizeArgs(args, defaultFieldResolver) {
      if (args.length !== 1) return normalizePositional(args, defaultFieldResolver)
      args[0].contextValue ||= {}
      args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver)
      return args[0]
    }
    function normalizePositional(args, defaultFieldResolver) {
      args[3] = args[3] || {}
      args[6] = wrapResolve(args[6] || defaultFieldResolver)
      args.length = Math.max(args.length, 7)
      return {
        schema: args[0],
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        fieldResolver: args[6],
      }
    }
    function wrapParse(parse) {
      return function (source) {
        if (!parseStartCh.hasSubscribers) {
          return parse.apply(this, arguments)
        }
        const ctx = { source }
        return parseStartCh.runStores(ctx, () => {
          try {
            ctx.document = parse.apply(this, arguments)
            const operation = getOperation(ctx.document)
            if (!operation) return ctx.document
            if (source) {
              documentSources.set(ctx.document, source.body || source)
            }
            ctx.docSource = documentSources.get(ctx.document)
            return ctx.document
          } catch (err) {
            err.stack
            ctx.error = err
            parseErrorCh.publish(ctx)
            throw err
          } finally {
            parseFinishCh.publish(ctx)
          }
        })
      }
    }
    function wrapValidate(validate) {
      return function (_schema, document, _rules, _typeInfo) {
        if (!validateStartCh.hasSubscribers) {
          return validate.apply(this, arguments)
        }
        const ctx = { docSource: documentSources.get(document), document }
        return validateStartCh.runStores(ctx, () => {
          let errors
          try {
            errors = validate.apply(this, arguments)
            if (errors && errors[0]) {
              ctx.error = errors && errors[0]
              validateErrorCh.publish(ctx)
            }
            return errors
          } catch (err) {
            err.stack
            ctx.error = err
            validateErrorCh.publish(ctx)
            throw err
          } finally {
            ctx.errors = errors
            validateFinishCh.publish(ctx)
          }
        })
      }
    }
    function wrapExecute(execute) {
      return function (exe) {
        const defaultFieldResolver = execute.defaultFieldResolver
        return function () {
          if (!startExecuteCh.hasSubscribers) {
            return exe.apply(this, arguments)
          }
          const args = normalizeArgs(arguments, defaultFieldResolver)
          const schema = args.schema
          const document = args.document
          const source = documentSources.get(document)
          const contextValue = args.contextValue
          const operation = getOperation(document, args.operationName)
          if (contexts.has(contextValue)) {
            return exe.apply(this, arguments)
          }
          const ctx = {
            operation,
            args,
            docSource: documentSources.get(document),
            source,
            fields: {},
            abortController: new AbortController(),
          }
          return startExecuteCh.runStores(ctx, () => {
            if (schema) {
              wrapFields(schema._queryType)
              wrapFields(schema._mutationType)
            }
            contexts.set(contextValue, ctx)
            return callInAsyncScope(exe, this, arguments, ctx.abortController, (err, res) => {
              if (finishResolveCh.hasSubscribers) finishResolvers(ctx)
              const error = err || (res && res.errors && res.errors[0])
              if (error) {
                ctx.error = error
                executeErrorCh.publish(ctx)
              }
              ctx.res = res
              finishExecuteCh.publish(ctx)
            })
          })
        }
      }
    }
    function wrapResolve(resolve) {
      if (typeof resolve !== 'function' || patchedResolvers.has(resolve)) return resolve
      function resolveAsync(source, args, contextValue, info) {
        if (!startResolveCh.hasSubscribers) return resolve.apply(this, arguments)
        const ctx = contexts.get(contextValue)
        if (!ctx) return resolve.apply(this, arguments)
        const field = assertField(ctx, info, args)
        return callInAsyncScope(resolve, this, arguments, ctx.abortController, (err) => {
          field.ctx.error = err
          field.ctx.info = info
          field.ctx.field = field
          updateFieldCh.publish(field.ctx)
        })
      }
      patchedResolvers.add(resolveAsync)
      return resolveAsync
    }
    function callInAsyncScope(fn, thisArg, args, abortController, cb) {
      cb = cb || (() => {})
      if (abortController?.signal.aborted) {
        cb(null, null)
        throw new AbortError('Aborted')
      }
      try {
        const result = fn.apply(thisArg, args)
        if (result && typeof result.then === 'function') {
          return result.then(
            (res) => {
              cb(null, res)
              return res
            },
            (err) => {
              cb(err)
              throw err
            }
          )
        }
        cb(null, result)
        return result
      } catch (err) {
        cb(err)
        throw err
      }
    }
    function pathToArray(path) {
      const flattened = []
      let curr = path
      while (curr) {
        flattened.push(curr.key)
        curr = curr.prev
      }
      return flattened.reverse()
    }
    function assertField(rootCtx, info, args) {
      const pathInfo = info && info.path
      const path = pathToArray(pathInfo)
      const pathString = path.join('.')
      const fields = rootCtx.fields
      let field = fields[pathString]
      if (!field) {
        const fieldCtx = { info, rootCtx, args }
        startResolveCh.publish(fieldCtx)
        field = fields[pathString] = {
          error: null,
          ctx: fieldCtx,
        }
      }
      return field
    }
    function wrapFields(type) {
      if (!type || !type._fields || patchedTypes.has(type)) {
        return
      }
      patchedTypes.add(type)
      Object.keys(type._fields).forEach((key) => {
        const field = type._fields[key]
        wrapFieldResolve(field)
        wrapFieldType(field)
      })
    }
    function wrapFieldResolve(field) {
      if (!field || !field.resolve) return
      field.resolve = wrapResolve(field.resolve)
    }
    function wrapFieldType(field) {
      if (!field || !field.type) return
      let unwrappedType = field.type
      while (unwrappedType.ofType) {
        unwrappedType = unwrappedType.ofType
      }
      wrapFields(unwrappedType)
    }
    function finishResolvers({ fields }) {
      Object.keys(fields)
        .reverse()
        .forEach((key) => {
          const field = fields[key]
          field.ctx.finishTime = field.finishTime
          field.ctx.field = field
          if (field.error) {
            field.ctx.error = field.error
            resolveErrorCh.publish(field.ctx)
          }
          finishResolveCh.publish(field.ctx)
        })
    }
    addHook({ name: '@graphql-tools/executor', versions: ['>=0.0.14'] }, (executor) => {
      shimmer.wrap(executor, 'execute', wrapExecute(executor))
      shimmer.wrap(executor, 'normalizedExecutor', wrapExecute(executor))
      return executor
    })
    addHook(
      { name: '@graphql-tools/executor', file: 'cjs/execution/execute.js', versions: ['>=0.0.14'] },
      (execute) => {
        shimmer.wrap(execute, 'execute', wrapExecute(execute))
        return execute
      }
    )
    addHook({ name: 'graphql', file: 'execution/execute.js', versions: ['>=0.10'] }, (execute) => {
      shimmer.wrap(execute, 'execute', wrapExecute(execute))
      return execute
    })
    addHook({ name: 'graphql', file: 'language/parser.js', versions: ['>=0.10'] }, (parser) => {
      shimmer.wrap(parser, 'parse', wrapParse)
      return parser
    })
    addHook({ name: 'graphql', file: 'validation/validate.js', versions: ['>=0.10'] }, (validate) => {
      shimmer.wrap(validate, 'validate', wrapValidate)
      return validate
    })
    addHook({ name: 'graphql', file: 'language/printer.js', versions: ['>=0.10'] }, (printer) => {
      ddGlobal.graphql_printer = printer
      return printer
    })
    addHook({ name: 'graphql', file: 'language/visitor.js', versions: ['>=0.10'] }, (visitor) => {
      ddGlobal.graphql_visitor = visitor
      return visitor
    })
    addHook({ name: 'graphql', file: 'utilities/index.js', versions: ['>=0.10'] }, (utilities) => {
      ddGlobal.graphql_utilities = utilities
      return utilities
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/types.js
var require_types2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/types.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      unary: 'unary',
      bidi: 'bidi_streaming',
      client_stream: 'client_streaming',
      clientStream: 'client_streaming',
      server_stream: 'server_streaming',
      serverStream: 'server_streaming',
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/client.js
var require_client = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/client.js'() {
    'use strict'
    var types = require_types2()
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var patched = /* @__PURE__ */ new WeakSet()
    var instances = /* @__PURE__ */ new WeakMap()
    var startChannel = channel('apm:grpc:client:request:start')
    var asyncStartChannel = channel('apm:grpc:client:request:asyncStart')
    var errorChannel = channel('apm:grpc:client:request:error')
    var finishChannel = channel('apm:grpc:client:request:finish')
    var emitChannel = channel('apm:grpc:client:request:emit')
    function createWrapMakeRequest(type, hasPeer = false) {
      return function wrapMakeRequest(makeRequest) {
        return function (path) {
          const args = ensureMetadata(this, arguments, 4)
          return callMethod(this, makeRequest, args, path, args[4], type, hasPeer)
        }
      }
    }
    function createWrapLoadPackageDefinition(hasPeer = false) {
      return function wrapLoadPackageDefinition(loadPackageDefinition) {
        return function (packageDef) {
          const result = loadPackageDefinition.apply(this, arguments)
          if (!result) return result
          wrapPackageDefinition(result, hasPeer)
          return result
        }
      }
    }
    function createWrapMakeClientConstructor(hasPeer = false) {
      return function wrapMakeClientConstructor(makeClientConstructor) {
        return function (methods) {
          const ServiceClient = makeClientConstructor.apply(this, arguments)
          wrapClientConstructor(ServiceClient, methods, hasPeer)
          return ServiceClient
        }
      }
    }
    function wrapPackageDefinition(def, hasPeer = false) {
      for (const name in def) {
        if (def[name].format) continue
        if (def[name].service && def[name].prototype) {
          wrapClientConstructor(def[name], def[name].service, hasPeer)
        } else {
          wrapPackageDefinition(def[name], hasPeer)
        }
      }
    }
    function wrapClientConstructor(ServiceClient, methods, hasPeer = false) {
      const proto = ServiceClient.prototype
      if (typeof methods !== 'object' || 'format' in methods) return
      Object.keys(methods).forEach((name) => {
        if (!methods[name]) return
        const originalName = methods[name].originalName
        const path = methods[name].path
        const type = getType(methods[name])
        if (methods[name]) {
          proto[name] = wrapMethod(proto[name], path, type, hasPeer)
        }
        if (originalName) {
          proto[originalName] = wrapMethod(proto[originalName], path, type, hasPeer)
        }
      })
    }
    function wrapMethod(method, path, type, hasPeer) {
      if (typeof method !== 'function' || patched.has(method)) {
        return method
      }
      const wrapped = shimmer.wrapFunction(
        method,
        (method2) =>
          function () {
            const args = ensureMetadata(this, arguments, 1)
            return callMethod(this, method2, args, path, args[1], type, hasPeer)
          }
      )
      patched.add(wrapped)
      return wrapped
    }
    function wrapCallback(ctx, callback = () => {}) {
      return shimmer.wrapFunction(
        callback,
        (callback2) =>
          function (err) {
            if (err) {
              ctx.error = err
              errorChannel.publish(ctx)
            }
            return asyncStartChannel.runStores(ctx, () => {
              return callback2.apply(this, arguments)
            })
          }
      )
    }
    var onStatusWithPeer = function (ctx, arg1, thisArg) {
      ctx.result = arg1
      ctx.peer = thisArg.getPeer()
      finishChannel.publish(ctx)
    }
    var onStatusWithoutPeer = function (ctx, arg1) {
      ctx.result = arg1
      finishChannel.publish(ctx)
    }
    function createWrapEmit(ctx, hasPeer = false) {
      const onStatus = hasPeer ? onStatusWithPeer : onStatusWithoutPeer
      return function wrapEmit(emit) {
        return function (event, arg1) {
          switch (event) {
            case 'error':
              ctx.error = arg1
              errorChannel.publish(ctx)
              break
            case 'status':
              onStatus(ctx, arg1, this)
              break
          }
          return emitChannel.runStores(ctx, () => {
            return emit.apply(this, arguments)
          })
        }
      }
    }
    function callMethod(client, method, args, path, metadata, type, hasPeer = false) {
      if (!startChannel.hasSubscribers) return method.apply(client, args)
      const length = args.length
      const callback = args[length - 1]
      const ctx = { metadata, path, type }
      return startChannel.runStores(ctx, () => {
        try {
          if (type === types.unary || type === types.client_stream) {
            if (typeof callback === 'function') {
              args[length - 1] = wrapCallback(ctx, callback)
            } else {
              args[length] = wrapCallback(ctx)
            }
          }
          const call = method.apply(client, args)
          if (call && typeof call.emit === 'function') {
            shimmer.wrap(call, 'emit', createWrapEmit(ctx, hasPeer))
          }
          return call
        } catch (e) {
          ctx.error = e
          errorChannel.publish(ctx)
        }
      })
    }
    function ensureMetadata(client, args, index) {
      const grpc = getGrpc(client)
      if (!client || !grpc) return args
      const meta = args[index]
      const normalized = []
      for (let i = 0; i < index; i++) {
        normalized.push(args[i])
      }
      if (!meta || !meta.constructor || meta.constructor.name !== 'Metadata') {
        normalized.push(new grpc.Metadata())
      }
      if (meta) {
        normalized.push(meta)
      }
      for (let i = index + 1; i < args.length; i++) {
        normalized.push(args[i])
      }
      return normalized
    }
    function getType(definition) {
      if (definition.requestStream) {
        if (definition.responseStream) {
          return types.bidi
        }
        return types.client_stream
      }
      if (definition.responseStream) {
        return types.server_stream
      }
      return types.unary
    }
    function getGrpc(client) {
      let proto = client
      do {
        const instance = instances.get(proto)
        if (instance) return instance
      } while ((proto = Object.getPrototypeOf(proto)))
    }
    function patch(hasPeer = false) {
      return function patch2(grpc) {
        const proto = grpc.Client.prototype
        instances.set(proto, grpc)
        shimmer.wrap(proto, 'makeBidiStreamRequest', createWrapMakeRequest(types.bidi, hasPeer))
        shimmer.wrap(proto, 'makeClientStreamRequest', createWrapMakeRequest(types.clientStream, hasPeer))
        shimmer.wrap(proto, 'makeServerStreamRequest', createWrapMakeRequest(types.serverStream, hasPeer))
        shimmer.wrap(proto, 'makeUnaryRequest', createWrapMakeRequest(types.unary, hasPeer))
        return grpc
      }
    }
    addHook({ name: '@grpc/grpc-js', versions: ['>=1.0.3 <1.1.4'] }, patch(false))
    addHook({ name: '@grpc/grpc-js', versions: ['>=1.0.3 <1.1.4'], file: 'build/src/make-client.js' }, (client) => {
      shimmer.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(false))
      shimmer.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition(false))
      return client
    })
    addHook({ name: '@grpc/grpc-js', versions: ['>=1.1.4'] }, patch(true))
    addHook({ name: '@grpc/grpc-js', versions: ['>=1.1.4'], file: 'build/src/make-client.js' }, (client) => {
      shimmer.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor(true))
      shimmer.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition(true))
      return client
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/server.js
var require_server = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/server.js'() {
    'use strict'
    var types = require_types2()
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startChannel = channel('apm:grpc:server:request:start')
    var asyncStartChannel = channel('apm:grpc:server:request:asyncStart')
    var errorChannel = channel('apm:grpc:server:request:error')
    var updateChannel = channel('apm:grpc:server:request:update')
    var finishChannel = channel('apm:grpc:server:request:finish')
    var emitChannel = channel('apm:grpc:server:request:emit')
    var OK = 0
    var CANCELLED = 1
    var isValid = (server, args) => {
      return Boolean(
        startChannel.hasSubscribers &&
        server?.type &&
        args[0] &&
        (server.type === 'unary' ? typeof args[1] === 'function' : isEmitter(args[0]))
      )
    }
    function wrapHandler(func, name) {
      return function (call, callback) {
        if (!isValid(this, arguments)) return func.apply(this, arguments)
        const metadata = call.metadata
        const type = types[this.type]
        const isStream = type !== 'unary'
        const ctx = { name, metadata, type }
        return startChannel.runStores(ctx, () => {
          try {
            const onCancel = () => {
              ctx.code = CANCELLED
              finishChannel.publish(ctx)
            }
            call.once('cancelled', onCancel)
            if (isStream) {
              wrapStream(call, ctx, onCancel)
            } else {
              arguments[1] = wrapCallback(callback, call, ctx, onCancel)
            }
            shimmer.wrap(call, 'emit', (emit) => {
              return function () {
                return emitChannel.runStores(ctx, () => {
                  return emit.apply(this, arguments)
                })
              }
            })
            return func.apply(this, arguments)
          } catch (e) {
            ctx.error = e
            errorChannel.publish(ctx)
          }
        })
      }
    }
    function wrapRegister(register) {
      return function (name, handler, serialize, deserialize, type) {
        if (typeof handler === 'function') {
          arguments[1] = wrapHandler(handler, name)
        }
        return register.apply(this, arguments)
      }
    }
    function createWrapEmit(call, ctx, onCancel) {
      return function wrapEmit(emit) {
        return function (event, arg1) {
          switch (event) {
            case 'error':
              ctx.error = arg1
              errorChannel.publish(ctx)
              ctx.code = arg1.code
              finishChannel.publish(ctx)
              call.removeListener('cancelled', onCancel)
              break
            // Streams are always cancelled before `finish` since 1.10.0 so we have
            // to use `prefinish` instead to avoid cancellation false positives.
            case 'prefinish':
              if (call.status) {
                updateChannel.publish(call.status)
              }
              if (!call.status || call.status.code === 0) {
                finishChannel.publish(ctx)
              }
              call.removeListener('cancelled', onCancel)
              break
          }
          return emit.apply(this, arguments)
        }
      }
    }
    function wrapStream(call, ctx, onCancel) {
      if (call.call && call.call.sendStatus) {
        call.call.sendStatus = wrapSendStatus(call.call.sendStatus, ctx)
      }
      shimmer.wrap(call, 'emit', createWrapEmit(call, ctx, onCancel))
    }
    function wrapCallback(callback = () => {}, call, ctx, onCancel) {
      return shimmer.wrapFunction(
        callback,
        (callback2) =>
          function (err, value, trailer, flags) {
            if (err) {
              ctx.error = err
              errorChannel.publish(ctx)
            } else {
              ctx.code = OK
              ctx.trailer = trailer
            }
            finishChannel.publish(ctx)
            call.removeListener('cancelled', onCancel)
            return asyncStartChannel.runStores(ctx, () => {
              return callback2.apply(this, arguments)
            })
          }
      )
    }
    function wrapSendStatus(sendStatus, ctx) {
      return function (status) {
        ctx.status = status
        updateChannel.publish(ctx)
        return sendStatus.apply(this, arguments)
      }
    }
    function isEmitter(obj) {
      return typeof obj.emit === 'function' && typeof obj.once === 'function'
    }
    addHook({ name: '@grpc/grpc-js', versions: ['>=1.0.3'], file: 'build/src/server.js' }, (server) => {
      shimmer.wrap(server.Server.prototype, 'register', wrapRegister)
      return server
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc.js
var require_grpc = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/grpc.js'() {
    'use strict'
    require_client()
    require_server()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/hapi.js
var require_hapi = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/hapi.js'() {
    'use strict'
    var tracingChannel = require_dc_polyfill().tracingChannel
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var handleChannel = channel('apm:hapi:request:handle')
    var routeChannel = channel('apm:hapi:request:route')
    var errorChannel = channel('apm:hapi:request:error')
    var hapiTracingChannel = tracingChannel('apm:hapi:extension')
    function wrapServer(server) {
      return function (options) {
        const app = server.apply(this, arguments)
        if (!app) return app
        if (typeof app.ext === 'function') {
          app.ext = wrapExt(app.ext)
        }
        if (typeof app.start === 'function') {
          app.start = wrapStart(app.start)
        }
        return app
      }
    }
    function wrapStart(start) {
      return shimmer.wrapFunction(
        start,
        (start2) =>
          function () {
            if (this && typeof this.ext === 'function') {
              this.ext('onPreResponse', onPreResponse)
            }
            return start2.apply(this, arguments)
          }
      )
    }
    function wrapExt(ext) {
      return shimmer.wrapFunction(
        ext,
        (ext2) =>
          function (events, method, options) {
            if (events !== null && typeof events === 'object') {
              arguments[0] = wrapEvents(events)
            } else {
              arguments[1] = Array.isArray(method) ? method.map(wrapHandler) : [wrapHandler(method)]
            }
            return ext2.apply(this, arguments)
          }
      )
    }
    function wrapDispatch(dispatch) {
      return function (options) {
        const handler = dispatch.apply(this, arguments)
        if (typeof handler !== 'function') return handler
        return function (req, res) {
          handleChannel.publish({ req, res })
          return handler.apply(this, arguments)
        }
      }
    }
    function wrapRebuild(rebuild) {
      return function (event) {
        const result = rebuild.apply(this, arguments)
        if (this && Array.isArray(this._cycle)) {
          this._cycle = this._cycle.map(wrapHandler)
        }
        return result
      }
    }
    function wrapEvents(events, flat = false) {
      const eventsArray = Array.isArray(events) ? events : [events]
      return eventsArray.map((event) => {
        if (!event?.method) return event
        return { ...event, method: wrapHandler(event.method) }
      })
    }
    function wrapHandler(handler) {
      if (typeof handler !== 'function') return handler
      return shimmer.wrapFunction(
        handler,
        (handler2) =>
          function (request, h) {
            const req = request?.raw?.req
            if (!req) return handler2.apply(this, arguments)
            return hapiTracingChannel.traceSync(() => {
              return handler2.apply(this, arguments)
            })
          }
      )
    }
    function onPreResponse(request, h) {
      if (!request || !request.raw) return reply(request, h)
      const req = request.raw.req
      if (request.response instanceof Error) {
        errorChannel.publish(request.response)
      }
      if (request.route) {
        routeChannel.publish({ req, route: request.route.path })
      }
      return reply(request, h)
    }
    function reply(request, h) {
      if (h.continue) {
        return typeof h.continue === 'function' ? h.continue() : h.continue
      } else if (typeof h === 'function') {
        return h()
      }
    }
    addHook({ name: '@hapi/hapi', versions: ['>=17.9'] }, (hapi) => {
      shimmer.massWrap(hapi, ['server', 'Server'], wrapServer)
      return hapi
    })
    addHook({ name: '@hapi/hapi', versions: ['>=17.9'], file: 'lib/core.js' }, (Core) => {
      shimmer.wrap(Core.prototype, '_dispatch', wrapDispatch)
      return Core
    })
    addHook({ name: '@hapi/hapi', versions: ['>=17.9'], file: 'lib/route.js' }, (Route) => {
      shimmer.wrap(Route.prototype, 'rebuild', wrapRebuild)
      return Route
    })
    addHook({ name: 'hapi', versions: ['>=17'] }, (hapi) => {
      shimmer.massWrap(hapi, ['server', 'Server'], wrapServer)
      return hapi
    })
    addHook({ name: 'hapi', versions: ['16'] }, (hapi) => {
      shimmer.wrap(hapi.Server.prototype, 'start', wrapStart)
      shimmer.wrap(hapi.Server.prototype, 'ext', wrapExt)
      return hapi
    })
    addHook({ name: 'hapi', versions: ['16'], file: 'lib/connection.js' }, (Connection) => {
      shimmer.wrap(Connection.prototype, '_dispatch', wrapDispatch)
      return Connection
    })
    addHook({ name: 'hapi', versions: ['>=17'], file: 'lib/core.js' }, (Core) => {
      shimmer.wrap(Core.prototype, '_dispatch', wrapDispatch)
      return Core
    })
    addHook({ name: 'hapi', versions: ['>=16'], file: 'lib/route.js' }, (Route) => {
      shimmer.wrap(Route.prototype, 'rebuild', wrapRebuild)
      return Route
    })
  },
})

// node_modules/dd-trace/vendor/dist/jest-docblock/index.js
var require_jest_docblock = __commonJS({
  'node_modules/dd-trace/vendor/dist/jest-docblock/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e = {
          './detect-newline/index.js': function (e2) {
            let r2 = (e3) => {
              if ('string' != typeof e3) throw TypeError('Expected a string')
              let r3 = e3.match(/(?:\r?\n)/g) || []
              if (0 === r3.length) return
              let t2 = r3.filter((e4) => '\r\n' === e4).length,
                n2 = r3.length - t2
              return t2 > n2 ? '\r\n' : '\n'
            }
            ;((e2.exports = r2), (e2.exports.graceful = (e3) => ('string' == typeof e3 && r2(e3)) || '\n'))
          },
          os: function (e2) {
            e2.exports = require('os')
          },
        },
        r = {}
      function t(n2) {
        var i = r[n2]
        if (void 0 !== i) return i.exports
        var l = (r[n2] = { exports: {} })
        return (e[n2](l, l.exports, t), l.exports)
      }
      var n = {}
      ;((() => {
        function e2() {
          let r3 = t('os')
          return (
            (e2 = function () {
              return r3
            }),
            r3
          )
        }
        function r2() {
          var e3
          let n2 = (e3 = t('./detect-newline/index.js')) && e3.__esModule ? e3 : { default: e3 }
          return (
            (r2 = function () {
              return n2
            }),
            n2
          )
        }
        ;(Object.defineProperty(n, '__esModule', { value: true }),
          (n.extract = function (e3) {
            let r3 = e3.match(a)
            return r3 ? r3[0].trimLeft() : ''
          }),
          (n.parse = function (e3) {
            return g(e3).pragmas
          }),
          (n.parseWithComments = g),
          (n.print = function ({ comments: t2 = '', pragmas: n2 = {} }) {
            let i2 = (0, r2().default)(t2) ?? e2().EOL,
              l2 = Object.keys(n2),
              a2 = l2
                .flatMap((e3) => m(e3, n2[e3]))
                .map((e3) => ` * ${e3}${i2}`)
                .join('')
            if (!t2) {
              if (0 === l2.length) return ''
              if (1 === l2.length && !Array.isArray(n2[l2[0]])) {
                let e3 = n2[l2[0]]
                return `/** ${m(l2[0], e3)[0]} */`
              }
            }
            let o2 =
              t2
                .split(i2)
                .map((e3) => ` * ${e3}`)
                .join(i2) + i2
            return '/**' + i2 + (t2 ? o2 : '') + (t2 && l2.length ? ' *' + i2 : '') + a2 + ' */'
          }),
          (n.strip = function (e3) {
            let r3 = e3.match(a)
            return r3 && r3[0] ? e3.substring(r3[0].length) : e3
          }))
        let i = /\*\/$/,
          l = /^\/\*\*?/,
          a = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
          o = /(^|\s+)\/\/([^\r\n]*)/g,
          u = /^(\r?\n)+/,
          c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
          s = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
          p = /(\r?\n|^) *\* ?/g,
          f = []
        function g(t2) {
          let n2,
            a2 = (0, r2().default)(t2) ?? e2().EOL
          t2 = t2.replace(l, '').replace(i, '').replace(p, '$1')
          let g2 = ''
          for (; g2 !== t2; ) ((g2 = t2), (t2 = t2.replace(c, `${a2}$1 $2${a2}`)))
          t2 = t2.replace(u, '').trimRight()
          let m2 = /* @__PURE__ */ Object.create(null),
            h = t2.replace(s, '').replace(u, '').trimRight()
          for (; (n2 = s.exec(t2)); ) {
            let e3 = n2[2].replace(o, '')
            'string' == typeof m2[n2[1]] || Array.isArray(m2[n2[1]])
              ? (m2[n2[1]] = f.concat(m2[n2[1]], e3))
              : (m2[n2[1]] = e3)
          }
          return { comments: h, pragmas: m2 }
        }
        function m(e3, r3) {
          return f.concat(r3).map((r4) => `@${e3} ${r4}`.trim())
        }
      })(),
        (module2.exports = n))
    })()
  },
})

// node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js
var require_util3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js'(exports2, module2) {
    'use strict'
    var { readFileSync } = require('fs')
    var { parse } = require_jest_docblock()
    var { getTestSuitePath } = require_test()
    var log = require_log2()
    function getFormattedJestTestParameters(testParameters) {
      if (!testParameters || !testParameters.length) {
        return
      }
      const [parameterArray, ...parameterValues] = testParameters
      if (parameterValues.length === 0) {
        return parameterArray
      }
      const parameterKeys = parameterArray[0].split('|').map((key) => key.trim())
      const formattedParameters = []
      let lastFormattedParameter = {}
      for (let index = 0; index < parameterValues.length; index++) {
        const parameterIndex = index % parameterKeys.length
        if (parameterIndex === 0) {
          lastFormattedParameter = {}
          formattedParameters.push(lastFormattedParameter)
        }
        const key = parameterKeys[parameterIndex]
        lastFormattedParameter[key] = parameterValues[index]
      }
      return formattedParameters
    }
    var SEED_SUFFIX_RE = /\s*\(with seed=-?\d+\)\s*$/i
    function getJestTestName(test, shouldStripSeed = false) {
      const titles = []
      let parent = test
      do {
        titles.unshift(parent.name)
      } while ((parent = parent.parent))
      titles.shift()
      const testName = titles.join(' ')
      if (shouldStripSeed) {
        return testName.replace(SEED_SUFFIX_RE, '')
      }
      return testName
    }
    var globalDocblockRegExp = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/
    var MAX_COMMENTS_CHECKED = 10
    function isMarkedAsUnskippable(test) {
      let testSource
      try {
        testSource = readFileSync(test.path, 'utf8')
      } catch {
        return false
      }
      const re = globalDocblockRegExp
      re.lastIndex = 0
      let commentsChecked = 0
      while (testSource.length) {
        const match = re.exec(testSource)
        if (!match) break
        const comment = match[1]
        let docblocks
        try {
          docblocks = parse(comment)
        } catch {
          if (commentsChecked++ >= MAX_COMMENTS_CHECKED) {
            return false
          }
          continue
        }
        if (docblocks?.datadog) {
          try {
            return JSON.parse(docblocks.datadog).unskippable
          } catch {
            log.warn('@datadog block comment is malformed.')
            return true
          }
        }
        if (commentsChecked++ >= MAX_COMMENTS_CHECKED) {
          return false
        }
        testSource = testSource.slice(match[0].length)
      }
      return false
    }
    function getJestSuitesToRun(skippableSuites, originalTests, rootDir) {
      const unskippableSuites = {}
      const forcedToRunSuites = {}
      const skippedSuites = []
      const suitesToRun = []
      for (const test of originalTests) {
        const relativePath = getTestSuitePath(test.path, rootDir)
        const shouldBeSkipped = skippableSuites.includes(relativePath)
        if (isMarkedAsUnskippable(test)) {
          suitesToRun.push(test)
          unskippableSuites[relativePath] = true
          if (shouldBeSkipped) {
            forcedToRunSuites[relativePath] = true
          }
          continue
        }
        if (shouldBeSkipped) {
          skippedSuites.push(relativePath)
        } else {
          suitesToRun.push(test)
        }
      }
      const hasUnskippableSuites = Object.keys(unskippableSuites).length > 0
      const hasForcedToRunSuites = Object.keys(forcedToRunSuites).length > 0
      if (originalTests.length) {
        const [test] = originalTests
        if (test?.context?.config?.testEnvironmentOptions) {
          if (hasUnskippableSuites) {
            test.context.config.testEnvironmentOptions._ddUnskippable = JSON.stringify(unskippableSuites)
          }
          if (hasForcedToRunSuites) {
            test.context.config.testEnvironmentOptions._ddForcedToRun = JSON.stringify(forcedToRunSuites)
          }
        }
      }
      return {
        skippedSuites,
        suitesToRun,
        hasUnskippableSuites,
        hasForcedToRunSuites,
      }
    }
    module2.exports = { getFormattedJestTestParameters, getJestTestName, getJestSuitesToRun, isMarkedAsUnskippable }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/jest.js
var require_jest = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/jest.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var log = require_log2()
    var path = require('path')
    var {
      getCoveredFilenamesFromCoverage,
      JEST_WORKER_TRACE_PAYLOAD_CODE,
      JEST_WORKER_COVERAGE_PAYLOAD_CODE,
      getTestLineStart,
      getTestSuitePath,
      getTestParametersString,
      getIsFaultyEarlyFlakeDetection,
      JEST_WORKER_LOGS_PAYLOAD_CODE,
      getTestEndLine,
      isModifiedTest,
    } = require_test()
    var { getFormattedJestTestParameters, getJestTestName, getJestSuitesToRun } = require_util3()
    var testSessionStartCh = channel('ci:jest:session:start')
    var testSessionFinishCh = channel('ci:jest:session:finish')
    var testSessionConfigurationCh = channel('ci:jest:session:configuration')
    var testSuiteStartCh = channel('ci:jest:test-suite:start')
    var testSuiteFinishCh = channel('ci:jest:test-suite:finish')
    var testSuiteErrorCh = channel('ci:jest:test-suite:error')
    var workerReportTraceCh = channel('ci:jest:worker-report:trace')
    var workerReportCoverageCh = channel('ci:jest:worker-report:coverage')
    var workerReportLogsCh = channel('ci:jest:worker-report:logs')
    var testSuiteCodeCoverageCh = channel('ci:jest:test-suite:code-coverage')
    var testStartCh = channel('ci:jest:test:start')
    var testSkippedCh = channel('ci:jest:test:skip')
    var testFinishCh = channel('ci:jest:test:finish')
    var testErrCh = channel('ci:jest:test:err')
    var testFnCh = channel('ci:jest:test:fn')
    var skippableSuitesCh = channel('ci:jest:test-suite:skippable')
    var libraryConfigurationCh = channel('ci:jest:library-configuration')
    var knownTestsCh = channel('ci:jest:known-tests')
    var testManagementTestsCh = channel('ci:jest:test-management-tests')
    var modifiedFilesCh = channel('ci:jest:modified-files')
    var itrSkippedSuitesCh = channel('ci:jest:itr:skipped-suites')
    var CHILD_MESSAGE_CALL = 1
    var FLUSH_TIMEOUT = 1e4
    var RETRY_TIMES = /* @__PURE__ */ Symbol.for('RETRY_TIMES')
    var skippableSuites = []
    var knownTests = {}
    var isCodeCoverageEnabled = false
    var isSuitesSkippingEnabled = false
    var isUserCodeCoverageEnabled = false
    var isSuitesSkipped = false
    var numSkippedSuites = 0
    var hasUnskippableSuites = false
    var hasForcedToRunSuites = false
    var isEarlyFlakeDetectionEnabled = false
    var earlyFlakeDetectionNumRetries = 0
    var earlyFlakeDetectionFaultyThreshold = 30
    var isEarlyFlakeDetectionFaulty = false
    var hasFilteredSkippableSuites = false
    var isKnownTestsEnabled = false
    var isTestManagementTestsEnabled = false
    var testManagementTests = {}
    var testManagementAttemptToFixRetries = 0
    var isImpactedTestsEnabled = false
    var modifiedFiles = {}
    var testContexts = /* @__PURE__ */ new WeakMap()
    var originalTestFns = /* @__PURE__ */ new WeakMap()
    var originalHookFns = /* @__PURE__ */ new WeakMap()
    var retriedTestsToNumAttempts = /* @__PURE__ */ new Map()
    var newTestsTestStatuses = /* @__PURE__ */ new Map()
    var attemptToFixRetriedTestsStatuses = /* @__PURE__ */ new Map()
    var wrappedWorkers = /* @__PURE__ */ new WeakSet()
    var testSuiteMockedFiles = /* @__PURE__ */ new Map()
    var testsToBeRetried = /* @__PURE__ */ new Set()
    var testSuiteAbsolutePathsWithFastCheck = /* @__PURE__ */ new Set()
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 200
    function formatJestError(errors) {
      let error
      if (Array.isArray(errors)) {
        const [originalError, asyncError] = errors
        if (originalError === null || !originalError.stack) {
          error = asyncError
          error.message = originalError
        } else {
          error = originalError
        }
      } else {
        error = errors
      }
      return error
    }
    function getTestEnvironmentOptions(config) {
      if (config.projectConfig && config.projectConfig.testEnvironmentOptions) {
        return config.projectConfig.testEnvironmentOptions
      }
      if (config.testEnvironmentOptions) {
        return config.testEnvironmentOptions
      }
      return {}
    }
    function getTestStats(testStatuses) {
      return testStatuses.reduce(
        (acc, testStatus) => {
          acc[testStatus]++
          return acc
        },
        { pass: 0, fail: 0 }
      )
    }
    function getWrappedEnvironment(BaseEnvironment, jestVersion) {
      return class DatadogEnvironment extends BaseEnvironment {
        constructor(config, context) {
          super(config, context)
          const rootDir = config.globalConfig ? config.globalConfig.rootDir : config.rootDir
          this.rootDir = rootDir
          this.testSuite = getTestSuitePath(context.testPath, rootDir)
          this.nameToParams = {}
          this.global._ddtrace = global._ddtrace
          this.hasSnapshotTests = void 0
          this.testSuiteAbsolutePath = context.testPath
          this.displayName = config.projectConfig?.displayName?.name || config.displayName
          this.testEnvironmentOptions = getTestEnvironmentOptions(config)
          const repositoryRoot = this.testEnvironmentOptions._ddRepositoryRoot
          if (repositoryRoot) {
            this.testSourceFile = getTestSuitePath(context.testPath, repositoryRoot)
            this.repositoryRoot = repositoryRoot
          }
          this.isEarlyFlakeDetectionEnabled = this.testEnvironmentOptions._ddIsEarlyFlakeDetectionEnabled
          this.isFlakyTestRetriesEnabled = this.testEnvironmentOptions._ddIsFlakyTestRetriesEnabled
          this.flakyTestRetriesCount = this.testEnvironmentOptions._ddFlakyTestRetriesCount
          this.isDiEnabled = this.testEnvironmentOptions._ddIsDiEnabled
          this.isKnownTestsEnabled = this.testEnvironmentOptions._ddIsKnownTestsEnabled
          this.isTestManagementTestsEnabled = this.testEnvironmentOptions._ddIsTestManagementTestsEnabled
          this.isImpactedTestsEnabled = this.testEnvironmentOptions._ddIsImpactedTestsEnabled
          if (this.isKnownTestsEnabled) {
            earlyFlakeDetectionNumRetries = this.testEnvironmentOptions._ddEarlyFlakeDetectionNumRetries
            try {
              this.knownTestsForThisSuite = this.getKnownTestsForSuite(this.testEnvironmentOptions._ddKnownTests)
              if (!Array.isArray(this.knownTestsForThisSuite)) {
                log.warn(
                  'this.knownTestsForThisSuite is not an array so new test and Early Flake detection is disabled.'
                )
                this.isEarlyFlakeDetectionEnabled = false
                this.isKnownTestsEnabled = false
              }
            } catch {
              this.isEarlyFlakeDetectionEnabled = false
              this.isKnownTestsEnabled = false
            }
          }
          if (this.isFlakyTestRetriesEnabled) {
            const currentNumRetries = this.global[RETRY_TIMES]
            if (!currentNumRetries) {
              this.global[RETRY_TIMES] = this.flakyTestRetriesCount
            }
          }
          if (this.isTestManagementTestsEnabled) {
            try {
              const hasTestManagementTests = !!testManagementTests?.jest
              testManagementAttemptToFixRetries = this.testEnvironmentOptions._ddTestManagementAttemptToFixRetries
              this.testManagementTestsForThisSuite = hasTestManagementTests
                ? this.getTestManagementTestsForSuite(testManagementTests?.jest?.suites?.[this.testSuite]?.tests)
                : this.getTestManagementTestsForSuite(this.testEnvironmentOptions._ddTestManagementTests)
            } catch (e) {
              log.error('Error parsing test management tests', e)
              this.isTestManagementTestsEnabled = false
            }
          }
          if (this.isImpactedTestsEnabled) {
            try {
              const hasImpactedTests = Object.keys(modifiedFiles).length > 0
              this.modifiedFiles = hasImpactedTests ? modifiedFiles : this.testEnvironmentOptions._ddModifiedFiles
            } catch (e) {
              log.error('Error parsing impacted tests', e)
              this.isImpactedTestsEnabled = false
            }
          }
        }
        /**
         * Jest snapshot counter issue during test retries
         *
         * Problem:
         * - Jest tracks snapshot calls using an internal counter per test name
         * - Each `toMatchSnapshot()` call increments this counter
         * - When a test is retried, it keeps the same name but the counter continues from where it left off
         *
         * Example Issue:
         * Original test run creates: `exports["test can do multiple snapshots 1"] = "hello"`
         * Retried test expects:      `exports["test can do multiple snapshots 2"] = "hello"`
         *
         * This mismatch causes snapshot tests to fail on retry because Jest is looking
         * for the wrong snapshot number. The solution is to reset the snapshot state.
         */
        resetSnapshotState() {
          try {
            const expectGlobal = this.getVmContext().expect
            const {
              snapshotState: { _counters: counters },
            } = expectGlobal.getState()
            if (counters) {
              counters.clear()
            }
          } catch (e) {
            log.warn('Error resetting snapshot state', e)
          }
        }
        // This function returns an array if the known tests are valid and null otherwise.
        getKnownTestsForSuite(suiteKnownTests) {
          if (suiteKnownTests) {
            return suiteKnownTests
          }
          if (knownTests?.jest) {
            return knownTests.jest[this.testSuite] || []
          }
          return null
        }
        getTestManagementTestsForSuite(testManagementTests2) {
          if (this.testManagementTestsForThisSuite) {
            return this.testManagementTestsForThisSuite
          }
          if (!testManagementTests2) {
            return {
              attemptToFix: [],
              disabled: [],
              quarantined: [],
            }
          }
          let testManagementTestsForSuite = testManagementTests2
          if (typeof testManagementTestsForSuite === 'string') {
            testManagementTestsForSuite = JSON.parse(testManagementTestsForSuite)
          }
          const result = {
            attemptToFix: [],
            disabled: [],
            quarantined: [],
          }
          Object.entries(testManagementTestsForSuite).forEach(([testName, { properties }]) => {
            if (properties?.attempt_to_fix) {
              result.attemptToFix.push(testName)
            }
            if (properties?.disabled) {
              result.disabled.push(testName)
            }
            if (properties?.quarantined) {
              result.quarantined.push(testName)
            }
          })
          return result
        }
        // Generic function to handle test retries
        retryTest({ jestEvent, retryCount, retryType }) {
          const { testName, fn, timeout } = jestEvent
          for (let retryIndex = 0; retryIndex < retryCount; retryIndex++) {
            if (this.global.test) {
              this.global.test(testName, fn, timeout)
            } else {
              log.error('%s could not retry test because global.test is undefined', retryType)
            }
          }
        }
        getShouldStripSeedFromTestName() {
          return testSuiteAbsolutePathsWithFastCheck.has(this.testSuiteAbsolutePath)
        }
        // At the `add_test` event we don't have the test object yet, so we can't use it
        getTestNameFromAddTestEvent(event, state) {
          const describeSuffix = getJestTestName(state.currentDescribeBlock, this.getShouldStripSeedFromTestName())
          return describeSuffix ? `${describeSuffix} ${event.testName}` : event.testName
        }
        async handleTestEvent(event, state) {
          if (super.handleTestEvent) {
            await super.handleTestEvent(event, state)
          }
          const setNameToParams = (name, params) => {
            this.nameToParams[name] = [...params]
          }
          if (event.name === 'setup' && this.global.test) {
            shimmer.wrap(
              this.global.test,
              'each',
              (each) =>
                function () {
                  const testParameters = getFormattedJestTestParameters(arguments)
                  const eachBind = each.apply(this, arguments)
                  return function () {
                    const [testName] = arguments
                    setNameToParams(testName, testParameters)
                    return eachBind.apply(this, arguments)
                  }
                }
            )
          }
          if (event.name === 'test_start') {
            const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName())
            if (testsToBeRetried.has(testName)) {
              this.resetSnapshotState()
            }
            let isNewTest = false
            let numEfdRetry = null
            let numOfAttemptsToFixRetries = null
            const testParameters = getTestParametersString(this.nameToParams, event.test.name)
            let isAttemptToFix = false
            let isDisabled = false
            let isQuarantined = false
            if (this.isTestManagementTestsEnabled) {
              isAttemptToFix = this.testManagementTestsForThisSuite?.attemptToFix?.includes(testName)
              isDisabled = this.testManagementTestsForThisSuite?.disabled?.includes(testName)
              isQuarantined = this.testManagementTestsForThisSuite?.quarantined?.includes(testName)
              if (isAttemptToFix) {
                numOfAttemptsToFixRetries = retriedTestsToNumAttempts.get(testName)
                retriedTestsToNumAttempts.set(testName, numOfAttemptsToFixRetries + 1)
              } else if (isDisabled) {
                event.test.mode = 'skip'
              }
            }
            let isModified = false
            if (this.isImpactedTestsEnabled) {
              const testStartLine = getTestLineStart(event.test.asyncError, this.testSuite)
              const testEndLine = getTestEndLine(event.test.fn, testStartLine)
              isModified = isModifiedTest(this.testSourceFile, testStartLine, testEndLine, this.modifiedFiles, 'jest')
            }
            if (this.isKnownTestsEnabled) {
              isNewTest = retriedTestsToNumAttempts.has(testName)
            }
            if (this.isEarlyFlakeDetectionEnabled && (isNewTest || isModified)) {
              numEfdRetry = retriedTestsToNumAttempts.get(testName)
              retriedTestsToNumAttempts.set(testName, numEfdRetry + 1)
            }
            const isJestRetry = event.test?.invocations > 1
            const ctx = {
              name: testName,
              suite: this.testSuite,
              testSourceFile: this.testSourceFile,
              displayName: this.displayName,
              testParameters,
              frameworkVersion: jestVersion,
              isNew: isNewTest,
              isEfdRetry: numEfdRetry > 0,
              isAttemptToFix,
              isAttemptToFixRetry: numOfAttemptsToFixRetries > 0,
              isJestRetry,
              isDisabled,
              isQuarantined,
              isModified,
              testSuiteAbsolutePath: this.testSuiteAbsolutePath,
            }
            testContexts.set(event.test, ctx)
            testStartCh.runStores(ctx, () => {
              for (const hook of event.test.parent.hooks) {
                let hookFn = hook.fn
                if (originalHookFns.has(hook)) {
                  hookFn = originalHookFns.get(hook)
                } else {
                  originalHookFns.set(hook, hookFn)
                }
                const newHookFn = shimmer.wrapFunction(
                  hookFn,
                  (hookFn2) =>
                    function () {
                      return testFnCh.runStores(ctx, () => hookFn2.apply(this, arguments))
                    }
                )
                hook.fn = newHookFn
              }
              const originalFn = event.test.fn
              originalTestFns.set(event.test, originalFn)
              const newFn = shimmer.wrapFunction(
                event.test.fn,
                (testFn) =>
                  function () {
                    return testFnCh.runStores(ctx, () => testFn.apply(this, arguments))
                  }
              )
              event.test.fn = newFn
            })
          }
          if (event.name === 'add_test') {
            if (event.failing) {
              return
            }
            const testFullName = this.getTestNameFromAddTestEvent(event, state)
            const isSkipped = event.mode === 'todo' || event.mode === 'skip'
            if (this.isTestManagementTestsEnabled) {
              const isAttemptToFix = this.testManagementTestsForThisSuite?.attemptToFix?.includes(testFullName)
              if (isAttemptToFix && !isSkipped && !retriedTestsToNumAttempts.has(testFullName)) {
                retriedTestsToNumAttempts.set(testFullName, 0)
                testsToBeRetried.add(testFullName)
                this.retryTest({
                  jestEvent: event,
                  retryCount: testManagementAttemptToFixRetries,
                  retryType: 'Test Management (Attempt to Fix)',
                })
              }
            }
            if (this.isImpactedTestsEnabled) {
              const testStartLine = getTestLineStart(event.asyncError, this.testSuite)
              const testEndLine = getTestEndLine(event.fn, testStartLine)
              const isModified = isModifiedTest(
                this.testSourceFile,
                testStartLine,
                testEndLine,
                this.modifiedFiles,
                'jest'
              )
              if (isModified && !retriedTestsToNumAttempts.has(testFullName) && this.isEarlyFlakeDetectionEnabled) {
                retriedTestsToNumAttempts.set(testFullName, 0)
                testsToBeRetried.add(testFullName)
                this.retryTest({
                  jestEvent: event,
                  retryCount: earlyFlakeDetectionNumRetries,
                  retryType: 'Impacted tests',
                })
              }
            }
            if (this.isKnownTestsEnabled) {
              const isNew = !this.knownTestsForThisSuite.includes(testFullName)
              if (isNew && !isSkipped && !retriedTestsToNumAttempts.has(testFullName)) {
                retriedTestsToNumAttempts.set(testFullName, 0)
                if (this.isEarlyFlakeDetectionEnabled) {
                  testsToBeRetried.add(testFullName)
                  this.retryTest({
                    jestEvent: event,
                    retryCount: earlyFlakeDetectionNumRetries,
                    retryType: 'Early flake detection',
                  })
                }
              }
            }
          }
          if (event.name === 'test_done') {
            let status = 'pass'
            if (event.test.errors && event.test.errors.length) {
              status = 'fail'
            }
            event.test.fn = originalTestFns.get(event.test)
            let attemptToFixPassed = false
            let attemptToFixFailed = false
            let failedAllTests = false
            let isAttemptToFix = false
            if (this.isTestManagementTestsEnabled) {
              const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName())
              isAttemptToFix = this.testManagementTestsForThisSuite?.attemptToFix?.includes(testName)
              if (isAttemptToFix) {
                if (attemptToFixRetriedTestsStatuses.has(testName)) {
                  attemptToFixRetriedTestsStatuses.get(testName).push(status)
                } else {
                  attemptToFixRetriedTestsStatuses.set(testName, [status])
                }
                const testStatuses = attemptToFixRetriedTestsStatuses.get(testName)
                if (testStatuses.length === testManagementAttemptToFixRetries + 1) {
                  if (testStatuses.includes('fail')) {
                    attemptToFixFailed = true
                  }
                  if (testStatuses.every((status2) => status2 === 'fail')) {
                    failedAllTests = true
                  } else if (testStatuses.every((status2) => status2 === 'pass')) {
                    attemptToFixPassed = true
                  }
                }
              }
            }
            let isEfdRetry = false
            if (this.isKnownTestsEnabled) {
              const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName())
              const isNewTest = retriedTestsToNumAttempts.has(testName)
              if (isNewTest) {
                if (newTestsTestStatuses.has(testName)) {
                  newTestsTestStatuses.get(testName).push(status)
                  isEfdRetry = true
                } else {
                  newTestsTestStatuses.set(testName, [status])
                }
              }
            }
            const promises = {}
            const numRetries = this.global[RETRY_TIMES]
            const numTestExecutions = event.test?.invocations
            const willBeRetried = numRetries > 0 && numTestExecutions - 1 < numRetries
            const mightHitBreakpoint = this.isDiEnabled && numTestExecutions >= 2
            const ctx = testContexts.get(event.test)
            if (status === 'fail') {
              const shouldSetProbe = this.isDiEnabled && willBeRetried && numTestExecutions === 1
              testErrCh.publish({
                ...ctx.currentStore,
                error: formatJestError(event.test.errors[0]),
                shouldSetProbe,
                promises,
              })
            }
            if (status === 'fail' && mightHitBreakpoint) {
              await new Promise((resolve) => {
                setTimeout(() => {
                  resolve()
                }, BREAKPOINT_HIT_GRACE_PERIOD_MS)
              })
            }
            let isAtrRetry = false
            if (this.isFlakyTestRetriesEnabled && event.test?.invocations > 1 && !isAttemptToFix && !isEfdRetry) {
              isAtrRetry = true
            }
            testFinishCh.publish({
              ...ctx.currentStore,
              status,
              testStartLine: getTestLineStart(event.test.asyncError, this.testSuite),
              attemptToFixPassed,
              failedAllTests,
              attemptToFixFailed,
              isAtrRetry,
            })
            if (promises.isProbeReady) {
              await promises.isProbeReady
            }
          }
          if (event.name === 'test_skip' || event.name === 'test_todo') {
            const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName())
            testSkippedCh.publish({
              test: {
                name: testName,
                suite: this.testSuite,
                testSourceFile: this.testSourceFile,
                displayName: this.displayName,
                frameworkVersion: jestVersion,
                testStartLine: getTestLineStart(event.test.asyncError, this.testSuite),
              },
              isDisabled: this.testManagementTestsForThisSuite?.disabled?.includes(testName),
            })
          }
        }
        teardown() {
          if (this._globalProxy?.propertyToValue) {
            for (const [key] of this._globalProxy.propertyToValue) {
              if (typeof key === 'string' && key.startsWith('_dd')) {
                this._globalProxy.propertyToValue.delete(key)
              }
            }
          }
          return super.teardown()
        }
      }
    }
    function getTestEnvironment(pkg, jestVersion) {
      if (pkg.default) {
        const wrappedTestEnvironment = getWrappedEnvironment(pkg.default, jestVersion)
        return new Proxy(pkg, {
          get(target, prop) {
            if (prop === 'default') {
              return wrappedTestEnvironment
            }
            if (prop === 'TestEnvironment') {
              return wrappedTestEnvironment
            }
            return target[prop]
          },
        })
      }
      return getWrappedEnvironment(pkg, jestVersion)
    }
    function applySuiteSkipping(originalTests, rootDir, frameworkVersion) {
      const jestSuitesToRun = getJestSuitesToRun(skippableSuites, originalTests, rootDir || process.cwd())
      hasFilteredSkippableSuites = true
      log.debug(() => `${jestSuitesToRun.suitesToRun.length} out of ${originalTests.length} suites are going to run.`)
      hasUnskippableSuites = jestSuitesToRun.hasUnskippableSuites
      hasForcedToRunSuites = jestSuitesToRun.hasForcedToRunSuites
      isSuitesSkipped = jestSuitesToRun.suitesToRun.length !== originalTests.length
      numSkippedSuites = jestSuitesToRun.skippedSuites.length
      itrSkippedSuitesCh.publish({ skippedSuites: jestSuitesToRun.skippedSuites, frameworkVersion })
      return jestSuitesToRun.suitesToRun
    }
    addHook(
      {
        name: 'jest-environment-node',
        versions: ['>=24.8.0'],
      },
      getTestEnvironment
    )
    addHook(
      {
        name: 'jest-environment-jsdom',
        versions: ['>=24.8.0'],
      },
      getTestEnvironment
    )
    addHook(
      {
        name: '@happy-dom/jest-environment',
        versions: ['>=10.0.0'],
      },
      getTestEnvironment
    )
    function getWrappedScheduleTests(scheduleTests, frameworkVersion) {
      return function (tests) {
        if (!isSuitesSkippingEnabled || hasFilteredSkippableSuites) {
          return scheduleTests.apply(this, arguments)
        }
        const [test] = tests
        const rootDir = test?.context?.config?.rootDir
        arguments[0] = applySuiteSkipping(tests, rootDir, frameworkVersion)
        return scheduleTests.apply(this, arguments)
      }
    }
    function searchSourceWrapper(searchSourcePackage, frameworkVersion) {
      const SearchSource = searchSourcePackage.default ?? searchSourcePackage
      shimmer.wrap(
        SearchSource.prototype,
        'getTestPaths',
        (getTestPaths) =>
          async function () {
            const testPaths = await getTestPaths.apply(this, arguments)
            const [{ rootDir, shard }] = arguments
            if (isKnownTestsEnabled) {
              const projectSuites = testPaths.tests.map((test) =>
                getTestSuitePath(test.path, test.context.config.rootDir)
              )
              const isFaulty =
                !knownTests?.jest ||
                getIsFaultyEarlyFlakeDetection(projectSuites, knownTests.jest, earlyFlakeDetectionFaultyThreshold)
              if (isFaulty) {
                log.error('Early flake detection is disabled because the number of new suites is too high.')
                isEarlyFlakeDetectionEnabled = false
                isKnownTestsEnabled = false
                const testEnvironmentOptions = testPaths.tests[0]?.context?.config?.testEnvironmentOptions
                if (testEnvironmentOptions) {
                  testEnvironmentOptions._ddIsEarlyFlakeDetectionEnabled = false
                  testEnvironmentOptions._ddIsKnownTestsEnabled = false
                }
                isEarlyFlakeDetectionFaulty = true
              }
            }
            if (shard?.shardCount > 1 || !isSuitesSkippingEnabled || !skippableSuites.length) {
              return testPaths
            }
            const { tests } = testPaths
            const suitesToRun = applySuiteSkipping(tests, rootDir, frameworkVersion)
            return { ...testPaths, tests: suitesToRun }
          }
      )
      return searchSourcePackage
    }
    function getCliWrapper(isNewJestVersion) {
      return function cliWrapper(cli, jestVersion) {
        if (isNewJestVersion) {
          cli = shimmer.wrap(cli, 'SearchSource', (searchSource) => searchSourceWrapper(searchSource, jestVersion), {
            replaceGetter: true,
          })
        }
        return shimmer.wrap(
          cli,
          'runCLI',
          (runCLI) =>
            async function () {
              let onDone
              const configurationPromise = new Promise((resolve) => {
                onDone = resolve
              })
              if (!libraryConfigurationCh.hasSubscribers) {
                return runCLI.apply(this, arguments)
              }
              libraryConfigurationCh.publish({ onDone, frameworkVersion: jestVersion })
              try {
                const { err, libraryConfig } = await configurationPromise
                if (!err) {
                  isCodeCoverageEnabled = libraryConfig.isCodeCoverageEnabled
                  isSuitesSkippingEnabled = libraryConfig.isSuitesSkippingEnabled
                  isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled
                  earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries
                  earlyFlakeDetectionFaultyThreshold = libraryConfig.earlyFlakeDetectionFaultyThreshold
                  isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled
                  isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled
                  testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries
                  isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled
                }
              } catch (err) {
                log.error('Jest library configuration error', err)
              }
              if (isKnownTestsEnabled) {
                const knownTestsPromise = new Promise((resolve) => {
                  onDone = resolve
                })
                knownTestsCh.publish({ onDone })
                try {
                  const { err, knownTests: receivedKnownTests } = await knownTestsPromise
                  if (err) {
                    isEarlyFlakeDetectionEnabled = false
                    isKnownTestsEnabled = false
                  } else {
                    knownTests = receivedKnownTests
                  }
                } catch (err) {
                  log.error('Jest known tests error', err)
                }
              }
              if (isSuitesSkippingEnabled) {
                const skippableSuitesPromise = new Promise((resolve) => {
                  onDone = resolve
                })
                skippableSuitesCh.publish({ onDone })
                try {
                  const { err, skippableSuites: receivedSkippableSuites } = await skippableSuitesPromise
                  if (!err) {
                    skippableSuites = receivedSkippableSuites
                  }
                } catch (err) {
                  log.error('Jest test-suite skippable error', err)
                }
              }
              if (isTestManagementTestsEnabled) {
                const testManagementTestsPromise = new Promise((resolve) => {
                  onDone = resolve
                })
                testManagementTestsCh.publish({ onDone })
                try {
                  const { err, testManagementTests: receivedTestManagementTests } = await testManagementTestsPromise
                  if (err) {
                    isTestManagementTestsEnabled = false
                    testManagementTests = {}
                  } else {
                    testManagementTests = receivedTestManagementTests
                  }
                } catch (err) {
                  log.error('Jest test management tests error', err)
                  isTestManagementTestsEnabled = false
                }
              }
              if (isImpactedTestsEnabled) {
                const impactedTestsPromise = new Promise((resolve) => {
                  onDone = resolve
                })
                modifiedFilesCh.publish({ onDone })
                try {
                  const { err, modifiedFiles: receivedModifiedFiles } = await impactedTestsPromise
                  if (!err) {
                    modifiedFiles = receivedModifiedFiles
                  }
                } catch (err) {
                  log.error('Jest impacted tests error', err)
                }
              }
              const processArgv = process.argv.slice(2).join(' ')
              testSessionStartCh.publish({ command: `jest ${processArgv}`, frameworkVersion: jestVersion })
              const result = await runCLI.apply(this, arguments)
              const {
                results: {
                  success,
                  coverageMap,
                  numFailedTestSuites,
                  numFailedTests,
                  numTotalTests,
                  numTotalTestSuites,
                },
              } = result
              let testCodeCoverageLinesTotal
              if (isUserCodeCoverageEnabled) {
                try {
                  const { pct, total } = coverageMap.getCoverageSummary().lines
                  testCodeCoverageLinesTotal = total === 0 ? 0 : pct
                } catch {}
              }
              let status, error
              if (success) {
                status = numTotalTests === 0 && numTotalTestSuites === 0 ? 'skip' : 'pass'
              } else {
                status = 'fail'
                error = new Error(`Failed test suites: ${numFailedTestSuites}. Failed tests: ${numFailedTests}`)
              }
              let timeoutId
              const flushPromise = new Promise((resolve) => {
                onDone = () => {
                  clearTimeout(timeoutId)
                  resolve()
                }
              })
              const timeoutPromise = new Promise((resolve) => {
                timeoutId = setTimeout(() => {
                  resolve('timeout')
                }, FLUSH_TIMEOUT).unref()
              })
              testSessionFinishCh.publish({
                status,
                isSuitesSkipped,
                isSuitesSkippingEnabled,
                isCodeCoverageEnabled,
                testCodeCoverageLinesTotal,
                numSkippedSuites,
                hasUnskippableSuites,
                hasForcedToRunSuites,
                error,
                isEarlyFlakeDetectionEnabled,
                isEarlyFlakeDetectionFaulty,
                isTestManagementTestsEnabled,
                onDone,
              })
              const waitingResult = await Promise.race([flushPromise, timeoutPromise])
              if (waitingResult === 'timeout') {
                log.error('Timeout waiting for the tracer to flush')
              }
              numSkippedSuites = 0
              if (isEarlyFlakeDetectionEnabled) {
                let numFailedTestsToIgnore = 0
                for (const testStatuses of newTestsTestStatuses.values()) {
                  const { pass, fail } = getTestStats(testStatuses)
                  if (pass > 0) {
                    numFailedTestsToIgnore += fail
                  }
                }
                if (numFailedTestsToIgnore !== 0 && result.results.numFailedTests === numFailedTestsToIgnore) {
                  result.results.success = true
                }
              }
              if (isTestManagementTestsEnabled) {
                const failedTests = result.results.testResults
                  .flatMap(({ testResults, testFilePath: testSuiteAbsolutePath }) =>
                    testResults.map(({ fullName: testName, status: status2 }) => ({
                      testName,
                      testSuiteAbsolutePath,
                      status: status2,
                    }))
                  )
                  .filter(({ status: status2 }) => status2 === 'failed')
                let numFailedQuarantinedTests = 0
                let numFailedQuarantinedOrDisabledAttemptedToFixTests = 0
                for (const { testName, testSuiteAbsolutePath } of failedTests) {
                  const testSuite = getTestSuitePath(testSuiteAbsolutePath, result.globalConfig.rootDir)
                  const testManagementTest =
                    testManagementTests?.jest?.suites?.[testSuite]?.tests?.[testName]?.properties
                  if (
                    testManagementTest?.attempt_to_fix &&
                    (testManagementTest?.quarantined || testManagementTest?.disabled)
                  ) {
                    numFailedQuarantinedOrDisabledAttemptedToFixTests++
                  } else if (testManagementTest?.quarantined) {
                    numFailedQuarantinedTests++
                  }
                }
                if (
                  (numFailedQuarantinedOrDisabledAttemptedToFixTests !== 0 || numFailedQuarantinedTests !== 0) &&
                  result.results.numFailedTests ===
                    numFailedQuarantinedTests + numFailedQuarantinedOrDisabledAttemptedToFixTests
                ) {
                  result.results.success = true
                }
              }
              return result
            },
          {
            replaceGetter: true,
          }
        )
      }
    }
    function coverageReporterWrapper(coverageReporter) {
      const CoverageReporter = coverageReporter.default ?? coverageReporter
      shimmer.wrap(
        CoverageReporter.prototype,
        '_addUntestedFiles',
        (addUntestedFiles) =>
          function () {
            if (isSuitesSkippingEnabled && !isUserCodeCoverageEnabled) {
              return Promise.resolve()
            }
            return addUntestedFiles.apply(this, arguments)
          }
      )
      return coverageReporter
    }
    addHook(
      {
        name: '@jest/core',
        file: 'build/TestScheduler.js',
        versions: ['>=27.0.0'],
      },
      (testSchedulerPackage, frameworkVersion) => {
        const oldCreateTestScheduler = testSchedulerPackage.createTestScheduler
        const newCreateTestScheduler = async function () {
          if (!isSuitesSkippingEnabled || hasFilteredSkippableSuites) {
            return oldCreateTestScheduler.apply(this, arguments)
          }
          const scheduler = await oldCreateTestScheduler.apply(this, arguments)
          shimmer.wrap(scheduler, 'scheduleTests', (scheduleTests) =>
            getWrappedScheduleTests(scheduleTests, frameworkVersion)
          )
          return scheduler
        }
        testSchedulerPackage.createTestScheduler = newCreateTestScheduler
        return testSchedulerPackage
      }
    )
    addHook(
      {
        name: '@jest/core',
        file: 'build/TestScheduler.js',
        versions: ['>=24.8.0 <27.0.0'],
      },
      (testSchedulerPackage, frameworkVersion) => {
        shimmer.wrap(testSchedulerPackage.default.prototype, 'scheduleTests', (scheduleTests) =>
          getWrappedScheduleTests(scheduleTests, frameworkVersion)
        )
        return testSchedulerPackage
      }
    )
    addHook(
      {
        name: '@jest/test-sequencer',
        versions: ['>=28'],
      },
      (sequencerPackage, frameworkVersion) => {
        shimmer.wrap(
          sequencerPackage.default.prototype,
          'shard',
          (shard) =>
            function () {
              const shardedTests = shard.apply(this, arguments)
              if (!shardedTests.length || !isSuitesSkippingEnabled || !skippableSuites.length) {
                return shardedTests
              }
              const [test] = shardedTests
              const rootDir = test?.context?.config?.rootDir
              return applySuiteSkipping(shardedTests, rootDir, frameworkVersion)
            }
        )
        return sequencerPackage
      }
    )
    addHook(
      {
        name: '@jest/reporters',
        file: 'build/coverage_reporter.js',
        versions: ['>=24.8.0 <26.6.2'],
      },
      coverageReporterWrapper
    )
    addHook(
      {
        name: '@jest/reporters',
        file: 'build/CoverageReporter.js',
        versions: ['>=26.6.2'],
      },
      coverageReporterWrapper
    )
    addHook(
      {
        name: '@jest/reporters',
        versions: ['>=30.0.0'],
      },
      (reporters) => {
        return shimmer.wrap(reporters, 'CoverageReporter', coverageReporterWrapper, { replaceGetter: true })
      }
    )
    addHook(
      {
        name: '@jest/core',
        file: 'build/cli/index.js',
        versions: ['>=24.8.0 <30.0.0'],
      },
      getCliWrapper(false)
    )
    addHook(
      {
        name: '@jest/core',
        versions: ['>=30.0.0'],
      },
      getCliWrapper(true)
    )
    function jestAdapterWrapper(jestAdapter, jestVersion) {
      const adapter = jestAdapter.default ?? jestAdapter
      const newAdapter = shimmer.wrapFunction(
        adapter,
        (adapter2) =>
          function () {
            const environment = arguments[2]
            if (!environment || !environment.testEnvironmentOptions) {
              return adapter2.apply(this, arguments)
            }
            testSuiteStartCh.publish({
              testSuite: environment.testSuite,
              testEnvironmentOptions: environment.testEnvironmentOptions,
              testSourceFile: environment.testSourceFile,
              displayName: environment.displayName,
              frameworkVersion: jestVersion,
              testSuiteAbsolutePath: environment.testSuiteAbsolutePath,
            })
            return adapter2
              .apply(this, arguments)
              .then((suiteResults) => {
                const { numFailingTests, skipped, failureMessage: errorMessage } = suiteResults
                let status = 'pass'
                if (skipped) {
                  status = 'skipped'
                } else if (numFailingTests !== 0) {
                  status = 'fail'
                }
                if (environment.testEnvironmentOptions?._ddTestCodeCoverageEnabled) {
                  const root = environment.repositoryRoot || environment.rootDir
                  const getFilesWithPath = (files) => files.map((file) => getTestSuitePath(file, root))
                  const coverageFiles = getFilesWithPath(
                    getCoveredFilenamesFromCoverage(environment.global.__coverage__)
                  )
                  const mockedFiles = getFilesWithPath(
                    testSuiteMockedFiles.get(environment.testSuiteAbsolutePath) || []
                  )
                  testSuiteCodeCoverageCh.publish({
                    coverageFiles,
                    testSuite: environment.testSourceFile,
                    mockedFiles,
                    testSuiteAbsolutePath: environment.testSuiteAbsolutePath,
                  })
                }
                testSuiteFinishCh.publish({
                  status,
                  errorMessage,
                  testSuiteAbsolutePath: environment.testSuiteAbsolutePath,
                })
                return suiteResults
              })
              .catch((error) => {
                testSuiteFinishCh.publish({
                  status: 'fail',
                  error,
                  testSuiteAbsolutePath: environment.testSuiteAbsolutePath,
                })
                throw error
              })
          }
      )
      if (jestAdapter.default) {
        jestAdapter.default = newAdapter
      } else {
        jestAdapter = newAdapter
      }
      return jestAdapter
    }
    addHook(
      {
        name: 'jest-circus',
        file: 'build/runner.js',
        versions: ['>=30.0.0'],
      },
      jestAdapterWrapper
    )
    addHook(
      {
        name: 'jest-circus',
        file: 'build/legacy-code-todo-rewrite/jestAdapter.js',
        versions: ['>=24.8.0'],
      },
      jestAdapterWrapper
    )
    function configureTestEnvironment(readConfigsResult) {
      const { configs } = readConfigsResult
      testSessionConfigurationCh.publish(configs.map((config) => config.testEnvironmentOptions))
      configs.forEach((config) => {
        config.testEnvironmentOptions._ddTestCodeCoverageEnabled = isCodeCoverageEnabled
      })
      isUserCodeCoverageEnabled = !!readConfigsResult.globalConfig.collectCoverage
      if (readConfigsResult.globalConfig.forceExit) {
        log.warn("Jest's '--forceExit' flag has been passed. This may cause loss of data.")
      }
      if (isCodeCoverageEnabled) {
        const globalConfig = {
          ...readConfigsResult.globalConfig,
          collectCoverage: true,
        }
        readConfigsResult.globalConfig = globalConfig
      }
      if (isSuitesSkippingEnabled) {
        const globalConfig = {
          ...readConfigsResult.globalConfig,
          coverageReporters: ['none'],
          passWithNoTests: true,
        }
        readConfigsResult.globalConfig = globalConfig
      }
      return readConfigsResult
    }
    function jestConfigAsyncWrapper(jestConfig) {
      return shimmer.wrap(
        jestConfig,
        'readConfigs',
        (readConfigs) =>
          async function () {
            const readConfigsResult = await readConfigs.apply(this, arguments)
            configureTestEnvironment(readConfigsResult)
            return readConfigsResult
          }
      )
    }
    function jestConfigSyncWrapper(jestConfig) {
      return shimmer.wrap(
        jestConfig,
        'readConfigs',
        (readConfigs) =>
          function () {
            const readConfigsResult = readConfigs.apply(this, arguments)
            configureTestEnvironment(readConfigsResult)
            return readConfigsResult
          }
      )
    }
    addHook(
      {
        name: '@jest/transform',
        versions: ['>=24.8.0'],
        file: 'build/ScriptTransformer.js',
      },
      (transformPackage) => {
        const originalCreateScriptTransformer = transformPackage.createScriptTransformer
        transformPackage.createScriptTransformer = function (config) {
          const { testEnvironmentOptions, ...restOfConfig } = config
          const {
            _ddTestModuleId,
            _ddTestSessionId,
            _ddTestCommand,
            _ddTestSessionName,
            _ddForcedToRun,
            _ddUnskippable,
            _ddItrCorrelationId,
            _ddKnownTests,
            _ddIsEarlyFlakeDetectionEnabled,
            _ddEarlyFlakeDetectionNumRetries,
            _ddRepositoryRoot,
            _ddIsFlakyTestRetriesEnabled,
            _ddFlakyTestRetriesCount,
            _ddIsDiEnabled,
            _ddIsKnownTestsEnabled,
            _ddIsTestManagementTestsEnabled,
            _ddTestManagementTests,
            _ddTestManagementAttemptToFixRetries,
            _ddModifiedFiles,
            ...restOfTestEnvironmentOptions
          } = testEnvironmentOptions
          restOfConfig.testEnvironmentOptions = restOfTestEnvironmentOptions
          arguments[0] = restOfConfig
          return originalCreateScriptTransformer.apply(this, arguments)
        }
        return transformPackage
      }
    )
    addHook(
      {
        name: '@jest/core',
        versions: ['>=24.8.0 <30.0.0'],
        file: 'build/SearchSource.js',
      },
      searchSourceWrapper
    )
    addHook(
      {
        name: 'jest-config',
        versions: ['>=25.1.0'],
      },
      jestConfigAsyncWrapper
    )
    addHook(
      {
        name: 'jest-config',
        versions: ['24.8.0 - 24.9.0'],
      },
      jestConfigSyncWrapper
    )
    var LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE = /* @__PURE__ */ new Set([
      'selenium-webdriver',
      'selenium-webdriver/chrome',
      'selenium-webdriver/edge',
      'selenium-webdriver/safari',
      'selenium-webdriver/firefox',
      'selenium-webdriver/ie',
      'selenium-webdriver/chromium',
      'winston',
    ])
    addHook(
      {
        name: 'jest-runtime',
        versions: ['>=24.8.0'],
      },
      (runtimePackage) => {
        const Runtime = runtimePackage.default ?? runtimePackage
        shimmer.wrap(
          Runtime.prototype,
          '_createJestObjectFor',
          (_createJestObjectFor) =>
            function (from) {
              const result = _createJestObjectFor.apply(this, arguments)
              const suiteFilePath = this._testPath || from
              shimmer.wrap(
                result,
                'mock',
                (mock) =>
                  function (moduleName2) {
                    if (LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE.has(moduleName2)) {
                      LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE.delete(moduleName2)
                    }
                    if (suiteFilePath) {
                      const existingMockedFiles = testSuiteMockedFiles.get(suiteFilePath) || []
                      const suiteDir = path.dirname(suiteFilePath)
                      const mockPath = path.resolve(suiteDir, moduleName2)
                      existingMockedFiles.push(mockPath)
                      testSuiteMockedFiles.set(suiteFilePath, existingMockedFiles)
                    }
                    return mock.apply(this, arguments)
                  }
              )
              return result
            }
        )
        shimmer.wrap(
          Runtime.prototype,
          'requireModuleOrMock',
          (requireModuleOrMock) =>
            function (from, moduleName2) {
              const originalPrepareStackTrace = Error.prepareStackTrace
              Error.prepareStackTrace = function (error, structuredStackTrace) {
                const filteredStackTrace = structuredStackTrace.filter(
                  (callSite) => !callSite.getFileName()?.includes('datadog-instrumentations/src/jest.js')
                )
                return originalPrepareStackTrace(error, filteredStackTrace)
              }
              try {
                if (LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE.has(moduleName2)) {
                  return this._requireCoreModule(moduleName2)
                }
                if (moduleName2 === '@fast-check/jest') {
                  testSuiteAbsolutePathsWithFastCheck.add(this._testPath)
                }
                const returnedValue = requireModuleOrMock.apply(this, arguments)
                if (process.exitCode === 1) {
                  if (this.loggedReferenceErrors?.size > 0) {
                    const errorMessage = [...this.loggedReferenceErrors][0]
                    testSuiteErrorCh.publish({
                      errorMessage,
                      testSuiteAbsolutePath: this._testPath,
                    })
                  } else {
                    testSuiteErrorCh.publish({
                      errorMessage: 'An error occurred while importing a module',
                      testSuiteAbsolutePath: this._testPath,
                    })
                  }
                }
                return returnedValue
              } finally {
                Error.prepareStackTrace = originalPrepareStackTrace
              }
            }
        )
        return runtimePackage
      }
    )
    function onMessageWrapper(onMessage) {
      return function () {
        const [code, data] = arguments[0]
        if (code === JEST_WORKER_TRACE_PAYLOAD_CODE) {
          workerReportTraceCh.publish(data)
          return
        }
        if (code === JEST_WORKER_COVERAGE_PAYLOAD_CODE) {
          workerReportCoverageCh.publish(data)
          return
        }
        if (code === JEST_WORKER_LOGS_PAYLOAD_CODE) {
          workerReportLogsCh.publish(data)
          return
        }
        return onMessage.apply(this, arguments)
      }
    }
    function sendWrapper(send) {
      return function (request) {
        if (!isKnownTestsEnabled && !isTestManagementTestsEnabled && !isImpactedTestsEnabled) {
          return send.apply(this, arguments)
        }
        const [type] = request
        if (type === CHILD_MESSAGE_CALL) {
          const args = request.at(-1)
          if (args.length > 1) {
            return send.apply(this, arguments)
          }
          if (!args[0]?.config) {
            return send.apply(this, arguments)
          }
          const [{ globalConfig, config, path: testSuiteAbsolutePath }] = args
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, globalConfig.rootDir || process.cwd())
          const suiteKnownTests = knownTests?.jest?.[testSuite] || []
          const suiteTestManagementTests = testManagementTests?.jest?.suites?.[testSuite]?.tests || {}
          args[0].config = {
            ...config,
            testEnvironmentOptions: {
              ...config.testEnvironmentOptions,
              _ddKnownTests: suiteKnownTests,
              _ddTestManagementTests: suiteTestManagementTests,
              // TODO: figure out if we can reduce the size of the modified files object
              // Can we use `testSuite` (it'd have to be relative to repository root though)
              _ddModifiedFiles: modifiedFiles,
            },
          }
        }
        return send.apply(this, arguments)
      }
    }
    function enqueueWrapper(enqueue) {
      return function () {
        shimmer.wrap(
          arguments[0],
          'onStart',
          (onStart) =>
            function (worker) {
              if (worker && !wrappedWorkers.has(worker)) {
                shimmer.wrap(worker._child, 'send', sendWrapper)
                shimmer.wrap(worker, '_onMessage', onMessageWrapper)
                worker._child.removeAllListeners('message')
                worker._child.on('message', worker._onMessage.bind(worker))
                wrappedWorkers.add(worker)
              }
              return onStart.apply(this, arguments)
            }
        )
        return enqueue.apply(this, arguments)
      }
    }
    addHook(
      {
        name: 'jest-worker',
        versions: ['>=24.9.0 <30.0.0'],
        file: 'build/workers/ChildProcessWorker.js',
      },
      (childProcessWorker) => {
        const ChildProcessWorker = childProcessWorker.default
        shimmer.wrap(ChildProcessWorker.prototype, 'send', sendWrapper)
        if (ChildProcessWorker.prototype._onMessage) {
          shimmer.wrap(ChildProcessWorker.prototype, '_onMessage', onMessageWrapper)
        } else if (ChildProcessWorker.prototype.onMessage) {
          shimmer.wrap(ChildProcessWorker.prototype, 'onMessage', onMessageWrapper)
        }
        return childProcessWorker
      }
    )
    addHook(
      {
        name: 'jest-worker',
        versions: ['>=30.0.0'],
      },
      (jestWorkerPackage) => {
        shimmer.wrap(jestWorkerPackage.FifoQueue.prototype, 'enqueue', enqueueWrapper)
        shimmer.wrap(jestWorkerPackage.PriorityQueue.prototype, 'enqueue', enqueueWrapper)
        return jestWorkerPackage
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/koa.js
var require_koa = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/koa.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var enterChannel = channel('apm:koa:middleware:enter')
    var exitChannel = channel('apm:koa:middleware:exit')
    var errorChannel = channel('apm:koa:middleware:error')
    var nextChannel = channel('apm:koa:middleware:next')
    var finishChannel = channel('apm:koa:middleware:finish')
    var handleChannel = channel('apm:koa:request:handle')
    var routeChannel = channel('apm:koa:request:route')
    var originals = /* @__PURE__ */ new WeakMap()
    function wrapCallback(callback) {
      return function callbackWithTrace() {
        const handleRequest = callback.apply(this, arguments)
        if (typeof handleRequest !== 'function') return handleRequest
        return function handleRequestWithTrace(req, res) {
          handleChannel.publish({ req, res })
          return handleRequest.apply(this, arguments)
        }
      }
    }
    function wrapUse(use) {
      return function useWithTrace() {
        const result = use.apply(this, arguments)
        if (!Array.isArray(this.middleware)) return result
        const fn = this.middleware.pop()
        this.middleware.push(wrapMiddleware(fn))
        return result
      }
    }
    function wrapRegister(register) {
      return function registerWithTrace(path, methods, middleware, opts) {
        const route = register.apply(this, arguments)
        if (!Array.isArray(path) && route && Array.isArray(route.stack)) {
          wrapStack(route)
        }
        return route
      }
    }
    function wrapRouterUse(use) {
      return function useWithTrace() {
        const router = use.apply(this, arguments)
        router.stack.forEach(wrapStack)
        return router
      }
    }
    function wrapStack(layer) {
      layer.stack = layer.stack.map((middleware) => {
        if (typeof middleware !== 'function') return middleware
        const original = originals.get(middleware)
        middleware = original || middleware
        const handler = shimmer.wrapFunction(middleware, (middleware2) => wrapMiddleware(middleware2, layer))
        originals.set(handler, middleware)
        return handler
      })
    }
    function wrapMiddleware(fn, layer) {
      if (typeof fn !== 'function') return fn
      const name = fn.name
      return shimmer.wrapFunction(
        fn,
        (fn2) =>
          function (ctx, next) {
            if (!ctx || !enterChannel.hasSubscribers) return fn2.apply(this, arguments)
            const req = ctx.req
            const path = layer && layer.path
            const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path
            enterChannel.publish({ req, name, route })
            if (typeof next === 'function') {
              arguments[1] = wrapNext(req, next)
            }
            try {
              const result = fn2.apply(this, arguments)
              if (result && typeof result.then === 'function') {
                return result.then(
                  (result2) => {
                    fulfill(ctx)
                    return result2
                  },
                  (err) => {
                    fulfill(ctx, err)
                    throw err
                  }
                )
              }
              fulfill(ctx)
              return result
            } catch (e) {
              fulfill(ctx, e)
              throw e
            } finally {
              exitChannel.publish({ req })
            }
          }
      )
    }
    function fulfill(ctx, error) {
      const req = ctx.req
      const route = ctx.routePath
      if (error) {
        errorChannel.publish({ req, error })
      }
      if (route) {
        routeChannel.publish({ req, route })
      }
      finishChannel.publish({ req })
    }
    function wrapNext(req, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function () {
            nextChannel.publish({ req })
            return next2.apply(this, arguments)
          }
      )
    }
    addHook({ name: 'koa', versions: ['>=2'] }, (Koa) => {
      shimmer.wrap(Koa.prototype, 'callback', wrapCallback)
      shimmer.wrap(Koa.prototype, 'use', wrapUse)
      return Koa
    })
    addHook({ name: '@koa/router', versions: ['>=8'] }, (Router) => {
      shimmer.wrap(Router.prototype, 'register', wrapRegister)
      shimmer.wrap(Router.prototype, 'use', wrapRouterUse)
      return Router
    })
    addHook({ name: 'koa-router', versions: ['>=7'] }, (Router) => {
      shimmer.wrap(Router.prototype, 'register', wrapRegister)
      shimmer.wrap(Router.prototype, 'use', wrapRouterUse)
      return Router
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/langchain.js
var require_langchain2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/langchain.js'() {
    'use strict'
    var { addHook, getHooks } = require_instrument()
    for (const hook of getHooks('@langchain/core')) {
      addHook(hook, (exports3) => exports3)
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js
var require_redis = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startCh = channel('apm:redis:command:start')
    var finishCh = channel('apm:redis:command:finish')
    var errorCh = channel('apm:redis:command:error')
    var createClientUrl
    function wrapAddCommand(addCommand) {
      return function (command) {
        if (!startCh.hasSubscribers) {
          return addCommand.apply(this, arguments)
        }
        const name = command[0]
        const args = command.slice(1)
        const ctx = getStartCtx(this, name, args, this._url)
        return startCh.runStores(ctx, () => {
          const res = addCommand.apply(this, arguments)
          res.then(
            () => finish(finishCh, errorCh, ctx),
            (err) => finish(finishCh, errorCh, ctx, err)
          )
          return res
        })
      }
    }
    function wrapCommandQueueClass(cls) {
      const ret = class RedisCommandQueue extends cls {
        constructor(...args) {
          super(...args)
          if (createClientUrl) {
            try {
              const parsed = new URL(createClientUrl)
              if (parsed) {
                this._url = { host: parsed.hostname, port: Number(parsed.port) || 6379 }
              }
            } catch {}
          }
          this._url = this._url || { host: 'localhost', port: 6379 }
        }
      }
      return ret
    }
    function wrapCreateClient(request) {
      return function (opts) {
        createClientUrl = opts && opts.url
        const ret = request.apply(this, arguments)
        createClientUrl = void 0
        return ret
      }
    }
    addHook({ name: '@node-redis/client', file: 'dist/lib/client/commands-queue.js', versions: ['>=1'] }, (redis) => {
      redis.default = wrapCommandQueueClass(redis.default)
      shimmer.wrap(redis.default.prototype, 'addCommand', wrapAddCommand)
      return redis
    })
    addHook({ name: '@node-redis/client', file: 'dist/lib/client/index.js', versions: ['>=1'] }, (redis) => {
      shimmer.wrap(redis.default, 'create', wrapCreateClient)
      return redis
    })
    addHook({ name: '@redis/client', file: 'dist/lib/client/index.js', versions: ['>=1.1'] }, (redis) => {
      shimmer.wrap(redis.default, 'create', wrapCreateClient)
      return redis
    })
    addHook({ name: '@redis/client', file: 'dist/lib/client/commands-queue.js', versions: ['>=1.1'] }, (redis) => {
      redis.default = wrapCommandQueueClass(redis.default)
      shimmer.wrap(redis.default.prototype, 'addCommand', wrapAddCommand)
      return redis
    })
    addHook({ name: 'redis', versions: ['>=2.6 <4'] }, (redis) => {
      shimmer.wrap(
        redis.RedisClient.prototype,
        'internal_send_command',
        (internalSendCommand) =>
          function (options) {
            if (!startCh.hasSubscribers) return internalSendCommand.apply(this, arguments)
            if (!options.callback) return internalSendCommand.apply(this, arguments)
            const ctx = getStartCtx(this, options.command, options.args)
            return startCh.runStores(ctx, () => {
              options.callback = wrapCallback(finishCh, errorCh, ctx, options.callback)
              try {
                return internalSendCommand.apply(this, arguments)
              } catch (err) {
                errorCh.publish(err)
                throw err
              }
            })
          }
      )
      return redis
    })
    addHook({ name: 'redis', versions: ['>=0.12 <2.6'] }, (redis) => {
      shimmer.wrap(
        redis.RedisClient.prototype,
        'send_command',
        (sendCommand) =>
          function (command, args, callback) {
            if (!startCh.hasSubscribers) {
              return sendCommand.apply(this, arguments)
            }
            const ctx = getStartCtx(this, command, args)
            return startCh.runStores(ctx, () => {
              if (typeof callback === 'function') {
                arguments[2] = wrapCallback(finishCh, errorCh, ctx, callback)
              } else if (Array.isArray(args) && typeof args.at(-1) === 'function') {
                args[args.length - 1] = wrapCallback(finishCh, errorCh, ctx, args.at(-1))
              } else {
                arguments[2] = wrapCallback(finishCh, errorCh, ctx)
              }
              try {
                return sendCommand.apply(this, arguments)
              } catch (err) {
                ctx.error = err
                errorCh.publish(ctx)
                throw err
              }
            })
          }
      )
      return redis
    })
    function getStartCtx(client, command, args, url = {}) {
      return {
        db: client.selected_db,
        command,
        args,
        connectionOptions: client.connection_options || client.connection_option || client.connectionOption || url,
      }
    }
    function wrapCallback(finishCh2, errorCh2, ctx, callback) {
      return shimmer.wrapFunction(
        callback,
        (callback2) =>
          function (err) {
            return finish(finishCh2, errorCh2, ctx, err, callback2, this, arguments)
          }
      )
    }
    function finish(finishCh2, errorCh2, ctx, error, callback, thisArg, args) {
      if (error) {
        ctx.error = error
        errorCh2.publish(ctx)
      }
      if (callback) {
        return finishCh2.runStores(ctx, callback, thisArg, ...args)
      }
      finishCh2.publish(ctx)
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/opensearch.js
var require_opensearch = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/opensearch.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { createWrapRequest, createWrapGetConnection } = require_elasticsearch()
    addHook({ name: '@opensearch-project/opensearch', file: 'lib/Transport.js', versions: ['>=1'] }, (Transport) => {
      shimmer.wrap(Transport.prototype, 'request', createWrapRequest('opensearch'))
      shimmer.wrap(Transport.prototype, 'getConnection', createWrapGetConnection('opensearch'))
      return Transport
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/otel-sdk-trace.js
var require_otel_sdk_trace = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/otel-sdk-trace.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var tracer2 = require_dd_trace()
    var { getEnvironmentVariable } = require_config_helper()
    var otelSdkEnabled =
      getEnvironmentVariable('DD_TRACE_OTEL_ENABLED') || getEnvironmentVariable('OTEL_SDK_DISABLED')
        ? !getEnvironmentVariable('OTEL_SDK_DISABLED')
        : void 0
    if (otelSdkEnabled) {
      addHook(
        {
          name: '@opentelemetry/sdk-trace-node',
          file: 'build/src/NodeTracerProvider.js',
          versions: ['*'],
        },
        (mod2) => {
          shimmer.wrap(mod2, 'NodeTracerProvider', () => {
            return tracer2.TracerProvider
          })
          return mod2
        }
      )
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/prisma.js
var require_prisma = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/prisma.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var prismaEngineStart = channel('apm:prisma:engine:start')
    var tracingChannel = require_dc_polyfill().tracingChannel
    var clientCH = tracingChannel('apm:prisma:client')
    var allowedClientSpanOperations = /* @__PURE__ */ new Set(['operation', 'serialize', 'transaction'])
    var TracingHelper = class {
      dbConfig = null
      isEnabled() {
        return true
      }
      // needs a sampled tracecontext to generate engine spans
      getTraceParent(context) {
        return '00-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa-bbbbbbbbbbbbbbbb-01'
      }
      dispatchEngineSpans(spans) {
        for (const span of spans) {
          if (span.parentId === null) {
            prismaEngineStart.publish({ engineSpan: span, allEngineSpans: spans, dbConfig: this.dbConfig })
          }
        }
      }
      getActiveContext() {}
      runInChildSpan(options, callback) {
        if (typeof options === 'string') {
          options = {
            name: options,
          }
        }
        if (allowedClientSpanOperations.has(options.name)) {
          const ctx = {
            resourceName: options.name,
            attributes: options.attributes || {},
          }
          if (options.name !== 'serialize') {
            return clientCH.tracePromise(callback, ctx, this, ...arguments)
          }
          return clientCH.traceSync(callback, ctx, this, ...arguments)
        }
        return callback()
      }
      setDbString(dbConfig) {
        this.dbConfig = dbConfig
      }
    }
    addHook({ name: '@prisma/client', versions: ['>=6.1.0'] }, (prisma, version) => {
      const tracingHelper = new TracingHelper()
      const originalRequest = prisma.PrismaClient.prototype._request
      prisma.PrismaClient.prototype._request = function () {
        if (!tracingHelper.dbConfig) {
          const inlineDatasources = this._engine?.config.inlineDatasources
          const overrideDatasources = this._engine?.config.overrideDatasources
          const datasources = inlineDatasources?.db.url?.value ?? overrideDatasources?.db?.url
          if (datasources) {
            const result = parseDBString(datasources)
            tracingHelper.setDbString(result)
          }
        }
        return originalRequest.apply(this, arguments)
      }
      const versions = version.split('.')
      if (versions[0] === '6' && versions[1] < 4) {
        global.PRISMA_INSTRUMENTATION = {
          helper: tracingHelper,
        }
      } else {
        global[`V${versions[0]}_PRISMA_INSTRUMENTATION`] = {
          helper: tracingHelper,
        }
      }
      return prisma
    })
    function parseDBString(dbString) {
      const url = new URL(dbString)
      const dbConfig = {
        user: url.username,
        password: url.password,
        host: url.hostname,
        port: url.port,
        database: url.pathname.slice(1),
        // Remove leading slash
      }
      return dbConfig
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/vitest.js
var require_vitest = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/vitest.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var log = require_log2()
    var { VITEST_WORKER_TRACE_PAYLOAD_CODE, VITEST_WORKER_LOGS_PAYLOAD_CODE } = require_test()
    var testStartCh = channel('ci:vitest:test:start')
    var testFinishTimeCh = channel('ci:vitest:test:finish-time')
    var testPassCh = channel('ci:vitest:test:pass')
    var testErrorCh = channel('ci:vitest:test:error')
    var testSkipCh = channel('ci:vitest:test:skip')
    var isNewTestCh = channel('ci:vitest:test:is-new')
    var isAttemptToFixCh = channel('ci:vitest:test:is-attempt-to-fix')
    var isDisabledCh = channel('ci:vitest:test:is-disabled')
    var isQuarantinedCh = channel('ci:vitest:test:is-quarantined')
    var isModifiedCh = channel('ci:vitest:test:is-modified')
    var testSuiteStartCh = channel('ci:vitest:test-suite:start')
    var testSuiteFinishCh = channel('ci:vitest:test-suite:finish')
    var testSuiteErrorCh = channel('ci:vitest:test-suite:error')
    var testSessionStartCh = channel('ci:vitest:session:start')
    var testSessionFinishCh = channel('ci:vitest:session:finish')
    var libraryConfigurationCh = channel('ci:vitest:library-configuration')
    var knownTestsCh = channel('ci:vitest:known-tests')
    var isEarlyFlakeDetectionFaultyCh = channel('ci:vitest:is-early-flake-detection-faulty')
    var testManagementTestsCh = channel('ci:vitest:test-management-tests')
    var modifiedFilesCh = channel('ci:vitest:modified-files')
    var workerReportTraceCh = channel('ci:vitest:worker-report:trace')
    var workerReportLogsCh = channel('ci:vitest:worker-report:logs')
    var taskToCtx = /* @__PURE__ */ new WeakMap()
    var taskToStatuses = /* @__PURE__ */ new WeakMap()
    var newTasks = /* @__PURE__ */ new WeakSet()
    var disabledTasks = /* @__PURE__ */ new WeakSet()
    var quarantinedTasks = /* @__PURE__ */ new WeakSet()
    var attemptToFixTasks = /* @__PURE__ */ new WeakSet()
    var modifiedTasks = /* @__PURE__ */ new WeakSet()
    var isRetryReasonEfd = false
    var isRetryReasonAttemptToFix = false
    var switchedStatuses = /* @__PURE__ */ new WeakSet()
    var workerProcesses = /* @__PURE__ */ new WeakSet()
    var isFlakyTestRetriesEnabled = false
    var flakyTestRetriesCount = 0
    var isEarlyFlakeDetectionEnabled = false
    var earlyFlakeDetectionNumRetries = 0
    var isEarlyFlakeDetectionFaulty = false
    var isKnownTestsEnabled = false
    var isTestManagementTestsEnabled = false
    var isImpactedTestsEnabled = false
    var testManagementAttemptToFixRetries = 0
    var isDiEnabled = false
    var testCodeCoverageLinesTotal
    var isSessionStarted = false
    var vitestPool = null
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 400
    function getTestCommand() {
      return `vitest ${process.argv.slice(2).join(' ')}`
    }
    function waitForHitProbe() {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve()
        }, BREAKPOINT_HIT_GRACE_PERIOD_MS)
      })
    }
    function isValidKnownTests(receivedKnownTests) {
      return !!receivedKnownTests.vitest
    }
    function getProvidedContext() {
      try {
        const {
          _ddIsEarlyFlakeDetectionEnabled,
          _ddIsDiEnabled,
          _ddKnownTests: knownTests,
          _ddEarlyFlakeDetectionNumRetries: numRepeats,
          _ddIsKnownTestsEnabled: isKnownTestsEnabled2,
          _ddIsTestManagementTestsEnabled: isTestManagementTestsEnabled2,
          _ddTestManagementAttemptToFixRetries: testManagementAttemptToFixRetries2,
          _ddTestManagementTests: testManagementTests,
          _ddIsFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled2,
          _ddIsImpactedTestsEnabled: isImpactedTestsEnabled2,
          _ddModifiedFiles: modifiedFiles,
        } = globalThis.__vitest_worker__.providedContext
        return {
          isDiEnabled: _ddIsDiEnabled,
          isEarlyFlakeDetectionEnabled: _ddIsEarlyFlakeDetectionEnabled,
          knownTests,
          numRepeats,
          isKnownTestsEnabled: isKnownTestsEnabled2,
          isTestManagementTestsEnabled: isTestManagementTestsEnabled2,
          testManagementAttemptToFixRetries: testManagementAttemptToFixRetries2,
          testManagementTests,
          isFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled2,
          isImpactedTestsEnabled: isImpactedTestsEnabled2,
          modifiedFiles,
        }
      } catch {
        log.error('Vitest workers could not parse provided context, so some features will not work.')
        return {
          isDiEnabled: false,
          isEarlyFlakeDetectionEnabled: false,
          knownTests: {},
          numRepeats: 0,
          isKnownTestsEnabled: false,
          isTestManagementTestsEnabled: false,
          testManagementAttemptToFixRetries: 0,
          testManagementTests: {},
          isFlakyTestRetriesEnabled: false,
          isImpactedTestsEnabled: false,
          modifiedFiles: {},
        }
      }
    }
    function isReporterPackage(vitestPackage) {
      return vitestPackage.B?.name === 'BaseSequencer'
    }
    function isReporterPackageNew(vitestPackage) {
      return vitestPackage.e?.name === 'BaseSequencer'
    }
    function isReporterPackageNewest(vitestPackage) {
      return vitestPackage.h?.name === 'BaseSequencer'
    }
    function isBaseSequencer(vitestPackage) {
      return vitestPackage.b?.name === 'BaseSequencer'
    }
    function getChannelPromise(channelToPublishTo, frameworkVersion) {
      return new Promise((resolve) => {
        channelToPublishTo.publish({ onDone: resolve, frameworkVersion })
      })
    }
    function isCliApiPackage(vitestPackage) {
      return vitestPackage.s?.name === 'startVitest'
    }
    function isTestPackage(testPackage) {
      return testPackage.V?.name === 'VitestTestRunner'
    }
    function hasForksPoolWorker(vitestPackage) {
      return vitestPackage.f?.name === 'ForksPoolWorker'
    }
    function hasThreadsPoolWorker(vitestPackage) {
      return vitestPackage.T?.name === 'ThreadsPoolWorker'
    }
    function getSessionStatus(state) {
      if (state.getCountOfFailedTests() > 0) {
        return 'fail'
      }
      if (state.pathsSet.size === 0) {
        return 'skip'
      }
      return 'pass'
    }
    function getVitestTestStatus(test, retryCount) {
      if (test.result.state !== 'fail') {
        if (!test.repeats) {
          return 'pass'
        } else if (test.repeats && (test.retry ?? 0) === retryCount) {
          return 'pass'
        }
      }
      return 'fail'
    }
    function getTypeTasks(fileTasks, type = 'test') {
      const typeTasks = []
      function getTasks(tasks) {
        for (const task of tasks) {
          if (task.type === type) {
            typeTasks.push(task)
          } else if (task.tasks) {
            getTasks(task.tasks)
          }
        }
      }
      getTasks(fileTasks)
      return typeTasks
    }
    function getTestName(task) {
      let testName = task.name
      let currentTask = task.suite
      while (currentTask) {
        if (currentTask.name) {
          testName = `${currentTask.name} ${testName}`
        }
        currentTask = currentTask.suite
      }
      return testName
    }
    function getSortWrapper(sort, frameworkVersion) {
      return async function () {
        if (!testSessionFinishCh.hasSubscribers) {
          return sort.apply(this, arguments)
        }
        try {
          const { err, libraryConfig } = await getChannelPromise(libraryConfigurationCh, frameworkVersion)
          if (!err) {
            isFlakyTestRetriesEnabled = libraryConfig.isFlakyTestRetriesEnabled
            flakyTestRetriesCount = libraryConfig.flakyTestRetriesCount
            isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled
            earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries
            isDiEnabled = libraryConfig.isDiEnabled
            isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled
            isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled
            testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries
            isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled
          }
        } catch {
          isFlakyTestRetriesEnabled = false
          isEarlyFlakeDetectionEnabled = false
          isDiEnabled = false
          isKnownTestsEnabled = false
          isImpactedTestsEnabled = false
        }
        if (isFlakyTestRetriesEnabled && !this.ctx.config.retry && flakyTestRetriesCount > 0) {
          this.ctx.config.retry = flakyTestRetriesCount
          try {
            const workspaceProject = this.ctx.getCoreWorkspaceProject
              ? this.ctx.getCoreWorkspaceProject()
              : this.ctx.getRootProject()
            workspaceProject._provided._ddIsFlakyTestRetriesEnabled = isFlakyTestRetriesEnabled
          } catch {
            log.warn('Could not send library configuration to workers.')
          }
        }
        if (isKnownTestsEnabled) {
          const knownTestsResponse = await getChannelPromise(knownTestsCh)
          if (knownTestsResponse.err) {
            isEarlyFlakeDetectionEnabled = false
          } else {
            const knownTests = knownTestsResponse.knownTests
            const getFilePaths = this.ctx.getTestFilepaths || this.ctx._globTestFilepaths
            const testFilepaths = await getFilePaths.call(this.ctx)
            if (isValidKnownTests(knownTests)) {
              isEarlyFlakeDetectionFaultyCh.publish({
                knownTests: knownTests.vitest,
                testFilepaths,
                onDone: (isFaulty) => {
                  isEarlyFlakeDetectionFaulty = isFaulty
                },
              })
              if (isEarlyFlakeDetectionFaulty) {
                isEarlyFlakeDetectionEnabled = false
                log.warn('New test detection is disabled because the number of new tests is too high.')
              } else {
                try {
                  const workspaceProject = this.ctx.getCoreWorkspaceProject
                    ? this.ctx.getCoreWorkspaceProject()
                    : this.ctx.getRootProject()
                  workspaceProject._provided._ddIsKnownTestsEnabled = isKnownTestsEnabled
                  workspaceProject._provided._ddKnownTests = knownTests
                  workspaceProject._provided._ddIsEarlyFlakeDetectionEnabled = isEarlyFlakeDetectionEnabled
                  workspaceProject._provided._ddEarlyFlakeDetectionNumRetries = earlyFlakeDetectionNumRetries
                } catch {
                  log.warn('Could not send known tests to workers so Early Flake Detection will not work.')
                }
              }
            } else {
              isEarlyFlakeDetectionFaulty = true
              isEarlyFlakeDetectionEnabled = false
            }
          }
        }
        if (isDiEnabled) {
          try {
            const workspaceProject = this.ctx.getCoreWorkspaceProject
              ? this.ctx.getCoreWorkspaceProject()
              : this.ctx.getRootProject()
            workspaceProject._provided._ddIsDiEnabled = isDiEnabled
          } catch {
            log.warn('Could not send Dynamic Instrumentation configuration to workers.')
          }
        }
        if (isTestManagementTestsEnabled) {
          const { err, testManagementTests: receivedTestManagementTests } =
            await getChannelPromise(testManagementTestsCh)
          if (err) {
            isTestManagementTestsEnabled = false
            log.error('Could not get test management tests.')
          } else {
            const testManagementTests = receivedTestManagementTests
            try {
              const workspaceProject = this.ctx.getCoreWorkspaceProject
                ? this.ctx.getCoreWorkspaceProject()
                : this.ctx.getRootProject()
              workspaceProject._provided._ddIsTestManagementTestsEnabled = isTestManagementTestsEnabled
              workspaceProject._provided._ddTestManagementAttemptToFixRetries = testManagementAttemptToFixRetries
              workspaceProject._provided._ddTestManagementTests = testManagementTests
            } catch {
              log.warn('Could not send test management tests to workers so Test Management will not work.')
            }
          }
        }
        if (isImpactedTestsEnabled) {
          const { err, modifiedFiles } = await getChannelPromise(modifiedFilesCh)
          if (err) {
            log.error('Could not get modified tests.')
          } else {
            try {
              const workspaceProject = this.ctx.getCoreWorkspaceProject
                ? this.ctx.getCoreWorkspaceProject()
                : this.ctx.getRootProject()
              workspaceProject._provided._ddIsImpactedTestsEnabled = isImpactedTestsEnabled
              workspaceProject._provided._ddModifiedFiles = modifiedFiles
            } catch {
              log.warn('Could not send modified tests to workers so Impacted Tests will not work.')
            }
          }
        }
        if (this.ctx.coverageProvider?.generateCoverage) {
          shimmer.wrap(
            this.ctx.coverageProvider,
            'generateCoverage',
            (generateCoverage) =>
              async function () {
                const totalCodeCoverage = await generateCoverage.apply(this, arguments)
                try {
                  testCodeCoverageLinesTotal = totalCodeCoverage.getCoverageSummary().lines.pct
                } catch {}
                return totalCodeCoverage
              }
          )
        }
        shimmer.wrap(this.ctx, 'exit', getFinishWrapper)
        shimmer.wrap(this.ctx, 'close', getFinishWrapper)
        return sort.apply(this, arguments)
      }
    }
    function getFinishWrapper(exitOrClose) {
      let isClosed = false
      return async function () {
        if (isClosed) {
          return exitOrClose.apply(this, arguments)
        }
        isClosed = true
        let onFinish
        const flushPromise = new Promise((resolve) => {
          onFinish = resolve
        })
        const failedSuites = this.state.getFailedFilepaths()
        let error
        if (failedSuites.length) {
          error = new Error(`Test suites failed: ${failedSuites.length}.`)
        }
        testSessionFinishCh.publish({
          status: getSessionStatus(this.state),
          testCodeCoverageLinesTotal,
          error,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          vitestPool,
          onFinish,
        })
        await flushPromise
        return exitOrClose.apply(this, arguments)
      }
    }
    function getCliOrStartVitestWrapper(frameworkVersion) {
      return function (oldCliOrStartVitest) {
        return function () {
          if (!testSessionStartCh.hasSubscribers || isSessionStarted) {
            return oldCliOrStartVitest.apply(this, arguments)
          }
          isSessionStarted = true
          testSessionStartCh.publish({ command: getTestCommand(), frameworkVersion })
          return oldCliOrStartVitest.apply(this, arguments)
        }
      }
    }
    function getCreateCliWrapper(vitestPackage, frameworkVersion) {
      shimmer.wrap(vitestPackage, 'c', getCliOrStartVitestWrapper(frameworkVersion))
      return vitestPackage
    }
    function threadHandler(thread) {
      const { runtime } = thread
      let workerProcess
      if (runtime === 'child_process') {
        vitestPool = 'child_process'
        workerProcess = thread.process
      } else if (runtime === 'worker_threads') {
        vitestPool = 'worker_threads'
        workerProcess = thread.thread
      } else {
        vitestPool = 'unknown'
      }
      if (!workerProcess) {
        log.error('Vitest error: could not get process or thread from TinyPool#run')
        return
      }
      if (workerProcesses.has(workerProcess)) {
        return
      }
      workerProcesses.add(workerProcess)
      workerProcess.on('message', (message) => {
        if (message.__tinypool_worker_message__ && message.data) {
          if (message.interprocessCode === VITEST_WORKER_TRACE_PAYLOAD_CODE) {
            workerReportTraceCh.publish(message.data)
          } else if (message.interprocessCode === VITEST_WORKER_LOGS_PAYLOAD_CODE) {
            workerReportLogsCh.publish(message.data)
          }
        }
      })
    }
    function wrapTinyPoolRun(TinyPool) {
      shimmer.wrap(
        TinyPool.prototype,
        'run',
        (run) =>
          async function () {
            this.threads.forEach(threadHandler)
            const runResult = await run.apply(this, arguments)
            this.threads.forEach(threadHandler)
            return runResult
          }
      )
    }
    addHook(
      {
        name: 'tinypool',
        // version from tinypool@0.8 was used in vitest@1.6.0
        versions: ['>=0.8.0 <1.0.0'],
        file: 'dist/esm/index.js',
      },
      (TinyPool) => {
        wrapTinyPoolRun(TinyPool)
        return TinyPool
      }
    )
    addHook(
      {
        name: 'tinypool',
        versions: ['>=1.0.0'],
        file: 'dist/index.js',
      },
      (TinyPool) => {
        wrapTinyPoolRun(TinyPool)
        return TinyPool
      }
    )
    function getWrappedOn(on) {
      return function (event, callback) {
        if (event !== 'message') {
          return on.apply(this, arguments)
        }
        arguments[1] = shimmer.wrapFunction(
          callback,
          (callback2) =>
            function (message) {
              if (message.type !== 'Buffer' && Array.isArray(message)) {
                const [interprocessCode, data] = message
                if (interprocessCode === VITEST_WORKER_TRACE_PAYLOAD_CODE) {
                  workerReportTraceCh.publish(data)
                } else if (interprocessCode === VITEST_WORKER_LOGS_PAYLOAD_CODE) {
                  workerReportLogsCh.publish(data)
                }
                return
              }
              return callback2.apply(this, arguments)
            }
        )
        return on.apply(this, arguments)
      }
    }
    function getStartVitestWrapper(cliApiPackage, frameworkVersion) {
      if (!isCliApiPackage(cliApiPackage)) {
        return cliApiPackage
      }
      shimmer.wrap(cliApiPackage, 's', getCliOrStartVitestWrapper(frameworkVersion))
      if (hasForksPoolWorker(cliApiPackage)) {
        shimmer.wrap(
          cliApiPackage.f.prototype,
          'start',
          (start) =>
            function () {
              vitestPool = 'child_process'
              this.env.DD_VITEST_WORKER = '1'
              return start.apply(this, arguments)
            }
        )
        shimmer.wrap(cliApiPackage.f.prototype, 'on', getWrappedOn)
      }
      if (hasThreadsPoolWorker(cliApiPackage)) {
        shimmer.wrap(
          cliApiPackage.T.prototype,
          'start',
          (start) =>
            function () {
              vitestPool = 'worker_threads'
              this.env.DD_VITEST_WORKER = '1'
              return start.apply(this, arguments)
            }
        )
        shimmer.wrap(cliApiPackage.T.prototype, 'on', getWrappedOn)
      }
      return cliApiPackage
    }
    function wrapVitestTestRunner(VitestTestRunner) {
      shimmer.wrap(
        VitestTestRunner.prototype,
        'onBeforeRunTask',
        (onBeforeRunTask) =>
          function (task) {
            const testName = getTestName(task)
            const {
              knownTests,
              isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled2,
              isKnownTestsEnabled: isKnownTestsEnabled2,
              numRepeats,
              isTestManagementTestsEnabled: isTestManagementTestsEnabled2,
              testManagementAttemptToFixRetries: testManagementAttemptToFixRetries2,
              testManagementTests,
              isImpactedTestsEnabled: isImpactedTestsEnabled2,
              modifiedFiles,
            } = getProvidedContext()
            if (isTestManagementTestsEnabled2) {
              isAttemptToFixCh.publish({
                testManagementTests,
                testSuiteAbsolutePath: task.file.filepath,
                testName,
                onDone: (isAttemptToFix) => {
                  if (isAttemptToFix) {
                    isRetryReasonAttemptToFix = task.repeats !== testManagementAttemptToFixRetries2
                    task.repeats = testManagementAttemptToFixRetries2
                    attemptToFixTasks.add(task)
                    taskToStatuses.set(task, [])
                  }
                },
              })
              isDisabledCh.publish({
                testManagementTests,
                testSuiteAbsolutePath: task.file.filepath,
                testName,
                onDone: (isTestDisabled) => {
                  if (isTestDisabled) {
                    disabledTasks.add(task)
                    if (!attemptToFixTasks.has(task)) {
                      task.mode = 'skip'
                    }
                  }
                },
              })
            }
            if (isImpactedTestsEnabled2) {
              isModifiedCh.publish({
                modifiedFiles,
                testSuiteAbsolutePath: task.file.filepath,
                onDone: (isImpacted) => {
                  if (isImpacted) {
                    if (isEarlyFlakeDetectionEnabled2) {
                      isRetryReasonEfd = task.repeats !== numRepeats
                      task.repeats = numRepeats
                    }
                    modifiedTasks.add(task)
                    taskToStatuses.set(task, [])
                  }
                },
              })
            }
            if (isKnownTestsEnabled2) {
              isNewTestCh.publish({
                knownTests,
                testSuiteAbsolutePath: task.file.filepath,
                testName,
                onDone: (isNew) => {
                  if (isNew && !attemptToFixTasks.has(task)) {
                    if (isEarlyFlakeDetectionEnabled2 && !modifiedTasks.has(task)) {
                      isRetryReasonEfd = task.repeats !== numRepeats
                      task.repeats = numRepeats
                    }
                    newTasks.add(task)
                    taskToStatuses.set(task, [])
                  }
                },
              })
            }
            return onBeforeRunTask.apply(this, arguments)
          }
      )
      shimmer.wrap(
        VitestTestRunner.prototype,
        'onAfterRunTask',
        (onAfterRunTask) =>
          function (task) {
            const {
              isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled2,
              isTestManagementTestsEnabled: isTestManagementTestsEnabled2,
            } = getProvidedContext()
            if (isTestManagementTestsEnabled2) {
              const isAttemptingToFix = attemptToFixTasks.has(task)
              const isDisabled = disabledTasks.has(task)
              const isQuarantined = quarantinedTasks.has(task)
              if (isAttemptingToFix && (isDisabled || isQuarantined)) {
                if (task.result.state === 'fail') {
                  switchedStatuses.add(task)
                }
                task.result.state = 'pass'
              } else if (isQuarantined) {
                task.result.state = 'pass'
              }
            }
            if (isEarlyFlakeDetectionEnabled2 && taskToStatuses.has(task) && !attemptToFixTasks.has(task)) {
              const statuses = taskToStatuses.get(task)
              if (statuses.includes('pass')) {
                if (task.result.state === 'fail') {
                  switchedStatuses.add(task)
                }
                task.result.state = 'pass'
              }
            }
            return onAfterRunTask.apply(this, arguments)
          }
      )
      shimmer.wrap(
        VitestTestRunner.prototype,
        'onBeforeTryTask',
        (onBeforeTryTask) =>
          async function (task, retryInfo) {
            if (!testPassCh.hasSubscribers && !testErrorCh.hasSubscribers && !testSkipCh.hasSubscribers) {
              return onBeforeTryTask.apply(this, arguments)
            }
            const testName = getTestName(task)
            let isNew = false
            let isQuarantined = false
            const {
              isKnownTestsEnabled: isKnownTestsEnabled2,
              isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled2,
              isDiEnabled: isDiEnabled2,
              isTestManagementTestsEnabled: isTestManagementTestsEnabled2,
              testManagementTests,
              isFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled2,
            } = getProvidedContext()
            if (isKnownTestsEnabled2) {
              isNew = newTasks.has(task)
            }
            if (isTestManagementTestsEnabled2) {
              isQuarantinedCh.publish({
                testManagementTests,
                testSuiteAbsolutePath: task.file.filepath,
                testName,
                onDone: (isTestQuarantined) => {
                  isQuarantined = isTestQuarantined
                  if (isTestQuarantined) {
                    quarantinedTasks.add(task)
                  }
                },
              })
            }
            const { retry: numAttempt, repeats: numRepetition } = retryInfo
            if (numAttempt > 0) {
              const shouldWaitForHitProbe = isDiEnabled2 && numAttempt > 1
              if (shouldWaitForHitProbe) {
                await waitForHitProbe()
              }
              const promises = {}
              const shouldSetProbe = isDiEnabled2 && numAttempt === 1
              const ctx2 = taskToCtx.get(task)
              const testError = task.result?.errors?.[0]
              if (ctx2) {
                testErrorCh.publish({
                  error: testError,
                  shouldSetProbe,
                  promises,
                  ...ctx2.currentStore,
                })
                if (promises.setProbePromise) {
                  await promises.setProbePromise
                }
              }
            }
            const lastExecutionStatus = task.result.state
            const shouldFlipStatus = isEarlyFlakeDetectionEnabled2 || attemptToFixTasks.has(task)
            const statuses = taskToStatuses.get(task)
            if (numRepetition > 0 && numRepetition < task.repeats) {
              const ctx2 = taskToCtx.get(task)
              if (ctx2) {
                if (lastExecutionStatus === 'fail') {
                  const testError = task.result?.errors?.[0]
                  testErrorCh.publish({ error: testError, ...ctx2.currentStore })
                } else {
                  testPassCh.publish({ task, ...ctx2.currentStore })
                }
                if (shouldFlipStatus) {
                  statuses.push(lastExecutionStatus)
                  task.result.state = 'pass'
                }
              }
            } else if (numRepetition === task.repeats) {
              if (shouldFlipStatus) {
                statuses.push(lastExecutionStatus)
              }
              const ctx2 = taskToCtx.get(task)
              if (lastExecutionStatus === 'fail') {
                const testError = task.result?.errors?.[0]
                testErrorCh.publish({ error: testError, ...ctx2.currentStore })
              } else {
                testPassCh.publish({ task, ...ctx2.currentStore })
              }
            }
            const isRetryReasonAtr =
              numAttempt > 0 && isFlakyTestRetriesEnabled2 && !isRetryReasonAttemptToFix && !isRetryReasonEfd
            const ctx = {
              testName,
              testSuiteAbsolutePath: task.file.filepath,
              isRetry: numAttempt > 0 || numRepetition > 0,
              isRetryReasonEfd,
              isRetryReasonAttemptToFix: isRetryReasonAttemptToFix && numRepetition > 0,
              isNew,
              mightHitProbe: isDiEnabled2 && numAttempt > 0,
              isAttemptToFix: attemptToFixTasks.has(task),
              isDisabled: disabledTasks.has(task),
              isQuarantined,
              isRetryReasonAtr,
              isModified: modifiedTasks.has(task),
            }
            taskToCtx.set(task, ctx)
            testStartCh.runStores(ctx, () => {})
            return onBeforeTryTask.apply(this, arguments)
          }
      )
      shimmer.wrap(
        VitestTestRunner.prototype,
        'onAfterTryTask',
        (onAfterTryTask) =>
          async function (task, { retry: retryCount }) {
            if (!testPassCh.hasSubscribers && !testErrorCh.hasSubscribers && !testSkipCh.hasSubscribers) {
              return onAfterTryTask.apply(this, arguments)
            }
            const result = await onAfterTryTask.apply(this, arguments)
            const { testManagementAttemptToFixRetries: testManagementAttemptToFixRetries2 } = getProvidedContext()
            const status = getVitestTestStatus(task, retryCount)
            const ctx = taskToCtx.get(task)
            const { isDiEnabled: isDiEnabled2 } = getProvidedContext()
            if (isDiEnabled2 && retryCount > 1) {
              await waitForHitProbe()
            }
            let attemptToFixPassed = false
            let attemptToFixFailed = false
            if (attemptToFixTasks.has(task)) {
              const statuses = taskToStatuses.get(task)
              if (statuses.length === testManagementAttemptToFixRetries2) {
                if (statuses.every((status2) => status2 === 'pass')) {
                  attemptToFixPassed = true
                } else if (statuses.includes('fail')) {
                  attemptToFixFailed = true
                }
              }
            }
            if (ctx) {
              ctx.status = status
              ctx.task = task
              ctx.attemptToFixPassed = attemptToFixPassed
              ctx.attemptToFixFailed = attemptToFixFailed
              testFinishTimeCh.runStores(ctx, () => {})
            }
            return result
          }
      )
    }
    addHook(
      {
        name: 'vitest',
        versions: ['>=4.0.0'],
        filePattern: 'dist/chunks/test.*',
      },
      (testPackage) => {
        if (!isTestPackage(testPackage)) {
          return testPackage
        }
        wrapVitestTestRunner(testPackage.V)
        return testPackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=1.6.0 <4.0.0'],
        file: 'dist/runners.js',
      },
      (vitestPackage) => {
        const { VitestTestRunner } = vitestPackage
        wrapVitestTestRunner(VitestTestRunner)
        return vitestPackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=1.6.0 <2.0.0'],
        filePattern: 'dist/vendor/index.*',
      },
      (vitestPackage) => {
        if (isReporterPackage(vitestPackage)) {
          shimmer.wrap(vitestPackage.B.prototype, 'sort', getSortWrapper)
        }
        return vitestPackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=2.0.0 <2.0.5'],
        filePattern: 'dist/vendor/index.*',
      },
      (vitestPackage) => {
        if (isReporterPackageNew(vitestPackage)) {
          shimmer.wrap(vitestPackage.e.prototype, 'sort', getSortWrapper)
        }
        return vitestPackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=2.0.5 <2.1.0'],
        filePattern: 'dist/chunks/index.*',
      },
      (vitestPackage) => {
        if (isReporterPackageNewest(vitestPackage)) {
          shimmer.wrap(vitestPackage.h.prototype, 'sort', getSortWrapper)
        }
        return vitestPackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=2.1.0 <3.0.0'],
        filePattern: 'dist/chunks/RandomSequencer.*',
      },
      (randomSequencerPackage) => {
        shimmer.wrap(randomSequencerPackage.B.prototype, 'sort', getSortWrapper)
        return randomSequencerPackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=3.0.9'],
        filePattern: 'dist/chunks/coverage.*',
      },
      (coveragePackage) => {
        if (isBaseSequencer(coveragePackage)) {
          shimmer.wrap(coveragePackage.b.prototype, 'sort', getSortWrapper)
        }
        return coveragePackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=3.0.0 <3.0.9'],
        filePattern: 'dist/chunks/resolveConfig.*',
      },
      (resolveConfigPackage) => {
        shimmer.wrap(resolveConfigPackage.B.prototype, 'sort', getSortWrapper)
        return resolveConfigPackage
      }
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=1.6.0 <2.0.5'],
        filePattern: 'dist/vendor/cac.*',
      },
      getCreateCliWrapper
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=2.0.5'],
        filePattern: 'dist/chunks/cac.*',
      },
      getCreateCliWrapper
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=1.6.0 <2.0.5'],
        filePattern: 'dist/vendor/cli-api.*',
      },
      getStartVitestWrapper
    )
    addHook(
      {
        name: 'vitest',
        versions: ['>=2.0.5'],
        filePattern: 'dist/chunks/cli-api.*',
      },
      getStartVitestWrapper
    )
    addHook(
      {
        name: '@vitest/runner',
        versions: ['>=1.6.0'],
        file: 'dist/index.js',
      },
      (vitestPackage, frameworkVersion) => {
        shimmer.wrap(
          vitestPackage,
          'startTests',
          (startTests) =>
            async function (testPaths) {
              let testSuiteError = null
              if (!testSuiteFinishCh.hasSubscribers) {
                return startTests.apply(this, arguments)
              }
              const testSuiteAbsolutePath = testPaths[0]?.filepath || testPaths[0]
              const testSuiteCtx = { testSuiteAbsolutePath, frameworkVersion }
              testSuiteStartCh.runStores(testSuiteCtx, () => {})
              const startTestsResponse = await startTests.apply(this, arguments)
              let onFinish = null
              const onFinishPromise = new Promise((resolve) => {
                onFinish = resolve
              })
              const testTasks = getTypeTasks(startTestsResponse[0].tasks)
              testTasks.forEach((task) => {
                const testCtx = taskToCtx.get(task)
                const { result } = task
                const isSwitchedStatus = switchedStatuses.has(task)
                if (result) {
                  const { state, duration, errors } = result
                  if (state === 'skip') {
                    testSkipCh.publish({
                      testName: getTestName(task),
                      testSuiteAbsolutePath: task.file.filepath,
                      isNew: newTasks.has(task),
                      isDisabled: disabledTasks.has(task),
                    })
                  } else if (state === 'pass' && !isSwitchedStatus) {
                    if (testCtx) {
                      testPassCh.publish({ task, ...testCtx.currentStore })
                    }
                  } else if (state === 'fail' || isSwitchedStatus) {
                    let testError
                    if (errors?.length) {
                      testError = errors[0]
                    }
                    let hasFailedAllRetries = false
                    let attemptToFixFailed = false
                    if (attemptToFixTasks.has(task)) {
                      const statuses = taskToStatuses.get(task)
                      if (statuses.includes('fail')) {
                        attemptToFixFailed = true
                      }
                      if (statuses.every((status) => status === 'fail')) {
                        hasFailedAllRetries = true
                      }
                    }
                    if (testCtx) {
                      const isRetry = task.result?.retryCount > 0
                      testErrorCh.publish({
                        duration: isRetry ? void 0 : duration,
                        error: testError,
                        hasFailedAllRetries,
                        attemptToFixFailed,
                        ...testCtx.currentStore,
                      })
                    }
                    if (errors?.length) {
                      testSuiteError = testError
                    }
                  }
                } else {
                  testSkipCh.publish({
                    testName: getTestName(task),
                    testSuiteAbsolutePath: task.file.filepath,
                    isNew: newTasks.has(task),
                    isDisabled: disabledTasks.has(task),
                  })
                }
              })
              const testSuiteResult = startTestsResponse[0].result
              if (testSuiteResult.errors?.length) {
                testSuiteError = testSuiteResult.errors[0]
              } else if (testSuiteResult.state === 'fail') {
                const suiteTasks = getTypeTasks(startTestsResponse[0].tasks, 'suite')
                const failedSuites = suiteTasks.filter((task) => task.result?.state === 'fail')
                if (failedSuites.length && failedSuites[0].result?.errors?.length) {
                  testSuiteError = failedSuites[0].result.errors[0]
                }
              }
              if (testSuiteError) {
                testSuiteCtx.error = testSuiteError
                testSuiteErrorCh.runStores(testSuiteCtx, () => {})
              }
              testSuiteFinishCh.publish({ status: testSuiteResult.state, onFinish, ...testSuiteCtx.currentStore })
              await onFinishPromise
              return startTestsResponse
            }
        )
        return vitestPackage
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/aerospike.js
var require_aerospike = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/aerospike.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var tracingChannel = require_dc_polyfill().tracingChannel
    var ch = tracingChannel('apm:aerospike:command')
    function wrapCreateCommand(createCommand) {
      if (typeof createCommand !== 'function') return createCommand
      return function commandWithTrace() {
        const CommandClass = createCommand.apply(this, arguments)
        if (!CommandClass) return CommandClass
        shimmer.wrap(CommandClass.prototype, 'process', wrapProcess)
        return CommandClass
      }
    }
    function wrapProcess(process2) {
      return function (...args) {
        const cb = args[0]
        if (typeof cb !== 'function') return process2.apply(this, args)
        const ctx = {
          commandName: this.constructor.name,
          commandArgs: this.args,
          clientConfig: this.client.config,
        }
        return ch.traceCallback(process2, -1, ctx, this, ...args)
      }
    }
    addHook(
      {
        name: 'aerospike',
        file: 'lib/commands/command.js',
        versions: ['4', '5', '6'],
      },
      (commandFactory) => {
        return shimmer.wrapFunction(commandFactory, (f) => wrapCreateCommand(f))
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/ai.js
var require_ai = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/ai.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { channel, tracingChannel } = require_dc_polyfill()
    var toolCreationChannel = channel('dd-trace:vercel-ai:tool')
    var TRACED_FUNCTIONS = {
      generateText: wrapWithTracer,
      streamText: wrapWithTracer,
      generateObject: wrapWithTracer,
      streamObject: wrapWithTracer,
      embed: wrapWithTracer,
      embedMany: wrapWithTracer,
      tool: wrapTool,
    }
    var vercelAiTracingChannel = tracingChannel('dd-trace:vercel-ai')
    var vercelAiSpanSetAttributesChannel = channel('dd-trace:vercel-ai:span:setAttributes')
    var noopTracer = {
      startActiveSpan() {
        const fn = arguments[arguments.length - 1]
        const span = {
          spanContext() {
            return { traceId: '', spanId: '', traceFlags: 0 }
          },
          setAttribute() {
            return this
          },
          setAttributes() {
            return this
          },
          addEvent() {
            return this
          },
          addLink() {
            return this
          },
          addLinks() {
            return this
          },
          setStatus() {
            return this
          },
          updateName() {
            return this
          },
          end() {
            return this
          },
          isRecording() {
            return false
          },
          recordException() {
            return this
          },
        }
        return fn(span)
      },
    }
    function wrapTracer(tracer2) {
      if (Object.hasOwn(tracer2, /* @__PURE__ */ Symbol.for('_dd.wrapped'))) return
      shimmer.wrap(tracer2, 'startActiveSpan', function (startActiveSpan) {
        return function () {
          const name = arguments[0]
          const options = arguments.length > 2 ? (arguments[1] ?? {}) : {}
          const cb = arguments[arguments.length - 1]
          const ctx = {
            name,
            attributes: options.attributes ?? {},
          }
          arguments[arguments.length - 1] = shimmer.wrapFunction(cb, function (originalCb) {
            return function (span) {
              shimmer.wrap(span, 'end', function (spanEnd) {
                return function () {
                  vercelAiTracingChannel.asyncEnd.publish(ctx)
                  return spanEnd.apply(this, arguments)
                }
              })
              shimmer.wrap(span, 'setAttributes', function (setAttributes) {
                return function (attributes) {
                  vercelAiSpanSetAttributesChannel.publish({ ctx, attributes })
                  return setAttributes.apply(this, arguments)
                }
              })
              shimmer.wrap(span, 'recordException', function (recordException) {
                return function (exception) {
                  ctx.error = exception
                  vercelAiTracingChannel.error.publish(ctx)
                  return recordException.apply(this, arguments)
                }
              })
              return originalCb.apply(this, arguments)
            }
          })
          return vercelAiTracingChannel.start.runStores(ctx, () => {
            const result = startActiveSpan.apply(this, arguments)
            vercelAiTracingChannel.end.publish(ctx)
            return result
          })
        }
      })
      Object.defineProperty(tracer2, /* @__PURE__ */ Symbol.for('_dd.wrapped'), { value: true })
    }
    function wrapWithTracer(fn) {
      return function () {
        const options = arguments[0]
        const experimentalTelemetry = options.experimental_telemetry
        if (experimentalTelemetry?.isEnabled === false) {
          return fn.apply(this, arguments)
        }
        if (experimentalTelemetry == null) {
          options.experimental_telemetry = { isEnabled: true, tracer: noopTracer }
        } else {
          experimentalTelemetry.isEnabled = true
          experimentalTelemetry.tracer ??= noopTracer
        }
        wrapTracer(options.experimental_telemetry.tracer)
        return fn.apply(this, arguments)
      }
    }
    function wrapTool(tool) {
      return function () {
        const args = arguments[0]
        toolCreationChannel.publish(args)
        return tool.apply(this, arguments)
      }
    }
    addHook(
      {
        name: 'ai',
        versions: ['>=4.0.0'],
      },
      (exports3) => {
        for (const [fnName, patchingFn] of Object.entries(TRACED_FUNCTIONS)) {
          exports3 = shimmer.wrap(exports3, fnName, patchingFn, { replaceGetter: true })
        }
        return exports3
      }
    )
    addHook(
      {
        name: 'ai',
        versions: ['>=4.0.0'],
        file: 'dist/index.mjs',
      },
      (exports3) => {
        for (const [fnName, patchingFn] of Object.entries(TRACED_FUNCTIONS)) {
          exports3 = shimmer.wrap(exports3, fnName, patchingFn, { replaceGetter: true })
        }
        return exports3
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js
var require_amqp10 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: 'amqp10', file: 'lib/sender_link.js', versions: ['>=3'] }, (SenderLink) => {
      const startCh = channel('apm:amqp10:send:start')
      const finishCh = channel('apm:amqp10:send:finish')
      const errorCh = channel('apm:amqp10:send:error')
      shimmer.wrap(
        SenderLink.prototype,
        'send',
        (send) =>
          function (msg, options) {
            if (!startCh.hasSubscribers) {
              return send.apply(this, arguments)
            }
            const ctx = { link: this }
            return startCh.runStores(ctx, () => {
              try {
                const promise = send.apply(this, arguments)
                if (!promise) {
                  finish(finishCh, errorCh)
                  return promise
                }
                promise.then(
                  () => finish(finishCh, errorCh, null, ctx),
                  (e) => finish(finishCh, errorCh, e, ctx)
                )
                return promise
              } catch (err) {
                finish(finishCh, errorCh, err, ctx)
                throw err
              }
            })
          }
      )
      return SenderLink
    })
    addHook({ name: 'amqp10', file: 'lib/receiver_link.js', versions: ['>=3'] }, (ReceiverLink) => {
      const startCh = channel('apm:amqp10:receive:start')
      const finishCh = channel('apm:amqp10:receive:finish')
      const errorCh = channel('apm:amqp10:receive:error')
      shimmer.wrap(
        ReceiverLink.prototype,
        '_messageReceived',
        (messageReceived) =>
          function (transferFrame) {
            if (!transferFrame || transferFrame.aborted || transferFrame.more) {
              return messageReceived.apply(this, arguments)
            }
            const ctx = { link: this }
            return startCh.runStores(ctx, () => {
              try {
                return messageReceived.apply(this, arguments)
              } catch (err) {
                ctx.error = err
                errorCh.publish(ctx)
                throw err
              } finally {
                finishCh.publish(ctx)
              }
            })
          }
      )
      return ReceiverLink
    })
    function finish(finishCh, errorCh, error, ctx) {
      if (error) {
        ctx.error = error
        errorCh.publish(ctx)
      }
      finishCh.publish(ctx)
    }
  },
})

// node_modules/dd-trace/packages/datadog-core/src/utils/src/kebabcase.js
var require_kebabcase = __commonJS({
  'node_modules/dd-trace/packages/datadog-core/src/utils/src/kebabcase.js'(exports2, module2) {
    'use strict'
    module2.exports = function kebabcase(str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string')
      }
      return str
        .trim()
        .replaceAll(/([a-z])([A-Z])/g, '$1-$2')
        .replaceAll(/[\s_]+/g, '-')
        .replaceAll(/^-+|-+$/g, '')
        .toLowerCase()
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js
var require_amqplib = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var kebabCase = require_kebabcase()
    var shimmer = require_datadog_shimmer()
    var { NODE_MAJOR, NODE_MINOR } = require_version()
    var MIN_VERSION = NODE_MAJOR > 22 || (NODE_MAJOR === 22 && NODE_MINOR >= 2) ? '>=0.5.3' : '>=0.5.0'
    var commandStartCh = channel('apm:amqplib:command:start')
    var commandFinishCh = channel('apm:amqplib:command:finish')
    var commandErrorCh = channel('apm:amqplib:command:error')
    var consumeStartCh = channel('apm:amqplib:consume:start')
    var consumeFinishCh = channel('apm:amqplib:consume:finish')
    var publishStartCh = channel('apm:amqplib:publish:start')
    var publishFinishCh = channel('apm:amqplib:publish:finish')
    var publishErrorCh = channel('apm:amqplib:publish:error')
    var methods = {}
    addHook({ name: 'amqplib', file: 'lib/defs.js', versions: [MIN_VERSION] }, (defs) => {
      for (const [key, value] of Object.entries(defs)) {
        if (Number.isInteger(value) && isCamelCase(key)) {
          methods[value] = kebabCase(key).replaceAll('-', '.')
        }
      }
      return defs
    })
    addHook({ name: 'amqplib', file: 'lib/channel_model.js', versions: [MIN_VERSION] }, (x) => {
      shimmer.wrap(
        x.Channel.prototype,
        'get',
        (getMessage) =>
          function (queue, options) {
            return getMessage.apply(this, arguments).then((message) => {
              if (message === null) {
                return message
              }
              const ctx = { method: 'basic.get', message, fields: message.fields, queue }
              consumeStartCh.runStores(ctx, () => {
                consumeFinishCh.publish(ctx)
              })
              return message
            })
          }
      )
      shimmer.wrap(
        x.Channel.prototype,
        'consume',
        (consume) =>
          function (queue, callback, options) {
            if (!consumeStartCh.hasSubscribers) {
              return consume.apply(this, arguments)
            }
            arguments[1] = (message, ...args) => {
              if (message === null) {
                return callback(message, ...args)
              }
              const ctx = { method: 'basic.deliver', message, fields: message.fields, queue }
              return consumeStartCh.runStores(ctx, () => {
                const result = callback(message, ...args)
                consumeFinishCh.publish(ctx)
                return result
              })
            }
            return consume.apply(this, arguments)
          }
      )
      return x
    })
    addHook({ name: 'amqplib', file: 'lib/callback_model.js', versions: [MIN_VERSION] }, (channel2) => {
      shimmer.wrap(
        channel2.Channel.prototype,
        'get',
        (getMessage) =>
          function (queue, options, callback) {
            if (!commandStartCh.hasSubscribers) {
              return getMessage.apply(this, arguments)
            }
            arguments[2] = (error, message, ...args) => {
              if (error !== null || message === null) {
                return callback(error, message, ...args)
              }
              const ctx = { method: 'basic.get', message, fields: message.fields, queue }
              return consumeStartCh.runStores(ctx, () => {
                const result = callback(error, message, ...args)
                consumeFinishCh.publish(ctx)
                return result
              })
            }
            return getMessage.apply(this, arguments)
          }
      )
      shimmer.wrap(
        channel2.Channel.prototype,
        'consume',
        (consume) =>
          function (queue, callback) {
            if (!consumeStartCh.hasSubscribers) {
              return consume.apply(this, arguments)
            }
            arguments[1] = (message, ...args) => {
              if (message === null) {
                return callback(message, ...args)
              }
              const ctx = { method: 'basic.deliver', message, fields: message.fields, queue }
              return consumeStartCh.runStores(ctx, () => {
                const result = callback(message, ...args)
                consumeFinishCh.publish(ctx)
                return result
              })
            }
            return consume.apply(this, arguments)
          }
      )
      return channel2
    })
    addHook({ name: 'amqplib', file: 'lib/channel.js', versions: [MIN_VERSION] }, (channel2) => {
      shimmer.wrap(
        channel2.Channel.prototype,
        'sendImmediately',
        (sendImmediately) =>
          function (method, fields) {
            return instrument(
              sendImmediately,
              this,
              arguments,
              methods[method],
              fields,
              null,
              commandStartCh,
              commandFinishCh,
              commandErrorCh
            )
          }
      )
      shimmer.wrap(
        channel2.Channel.prototype,
        'sendMessage',
        (sendMessage) =>
          function (fields) {
            return instrument(
              sendMessage,
              this,
              arguments,
              'basic.publish',
              fields,
              arguments[2],
              publishStartCh,
              publishFinishCh,
              publishErrorCh
            )
          }
      )
      return channel2
    })
    function instrument(send, channel2, args, method, fields, message, startCh, finishCh, errorCh) {
      if (!startCh.hasSubscribers || method === 'basic.get') {
        return send.apply(channel2, args)
      }
      const ctx = { channel: channel2, method, fields, message }
      return startCh.runStores(ctx, () => {
        try {
          return send.apply(channel2, args)
        } catch (err) {
          ctx.error = err
          errorCh.publish(ctx)
          throw err
        } finally {
          finishCh.publish(ctx)
        }
      })
    }
    function isCamelCase(str) {
      return /([A-Z][a-z0-9]+)+/.test(str)
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/avsc.js
var require_avsc = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/avsc.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook } = require_instrument()
    var dc = require_dc_polyfill()
    var serializeChannel = dc.channel('apm:avsc:serialize-start')
    var deserializeChannel = dc.channel('apm:avsc:deserialize-end')
    function wrapSerialization(Type) {
      shimmer.wrap(
        Type.prototype,
        'toBuffer',
        (original) =>
          function () {
            if (!serializeChannel.hasSubscribers) {
              return original.apply(this, arguments)
            }
            serializeChannel.publish({ messageClass: this })
            return original.apply(this, arguments)
          }
      )
    }
    function wrapDeserialization(Type) {
      shimmer.wrap(
        Type.prototype,
        'fromBuffer',
        (original) =>
          function () {
            if (!deserializeChannel.hasSubscribers) {
              return original.apply(this, arguments)
            }
            const result = original.apply(this, arguments)
            deserializeChannel.publish({ messageClass: result })
            return result
          }
      )
    }
    addHook(
      {
        name: 'avsc',
        versions: ['>=5.0.0'],
      },
      (avro) => {
        wrapDeserialization(avro.Type)
        wrapSerialization(avro.Type)
        return avro
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js
var require_promise = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js'(exports2) {
    'use strict'
    var { AsyncResource } = require('async_hooks')
    exports2.wrapThen = function wrapThen(origThen) {
      return function then(onFulfilled, onRejected, onProgress) {
        const ar = new AsyncResource('bound-anonymous-fn')
        arguments[0] = wrapCallback(ar, onFulfilled)
        arguments[1] = wrapCallback(ar, onRejected)
        if (onProgress) {
          arguments[2] = wrapCallback(ar, onProgress)
        }
        return origThen.apply(this, arguments)
      }
    }
    function wrapCallback(ar, callback) {
      if (typeof callback !== 'function') return callback
      return function () {
        return ar.runInAsyncScope(() => {
          return callback.apply(this, arguments)
        })
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js
var require_bluebird = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { wrapThen } = require_promise()
    var shimmer = require_datadog_shimmer()
    function createGetNewLibraryCopyWrap(originalLib) {
      return function wrapGetNewLibraryCopy(getNewLibraryCopy) {
        return function getNewLibraryCopyWithTrace() {
          const libraryCopy = getNewLibraryCopy.apply(this, arguments)
          shimmer.wrap(libraryCopy.prototype, '_then', wrapThen)
          shimmer.wrap(libraryCopy, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(originalLib))
          return libraryCopy
        }
      }
    }
    addHook({ name: 'bluebird', versions: ['>=2.0.2'] }, (Promise2) => {
      shimmer.wrap(Promise2.prototype, '_then', wrapThen)
      return Promise2
    })
    addHook({ name: 'bluebird', versions: ['^2.11.0', '^3.4.1'] }, (Promise2) => {
      shimmer.wrap(Promise2, 'getNewLibraryCopy', createGetNewLibraryCopyWrap(Promise2))
      return Promise2
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/body-parser.js
var require_body_parser = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/body-parser.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook, AsyncResource } = require_instrument()
    var bodyParserReadCh = channel('datadog:body-parser:read:finish')
    function publishRequestBodyAndNext(req, res, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function () {
            if (bodyParserReadCh.hasSubscribers && req) {
              const abortController = new AbortController()
              const body = req.body
              bodyParserReadCh.publish({ req, res, body, abortController })
              if (abortController.signal.aborted) return
            }
            return next2.apply(this, arguments)
          }
      )
    }
    addHook(
      {
        name: 'body-parser',
        file: 'lib/read.js',
        versions: ['>=1.4.0 <1.20.0'],
      },
      (read) => {
        return shimmer.wrapFunction(
          read,
          (read2) =>
            function (req, res, next) {
              const nextResource = new AsyncResource('bound-anonymous-fn')
              arguments[2] = nextResource.bind(publishRequestBodyAndNext(req, res, next))
              return read2.apply(this, arguments)
            }
        )
      }
    )
    addHook(
      {
        name: 'body-parser',
        file: 'lib/read.js',
        versions: ['>=1.20.0'],
      },
      (read) => {
        return shimmer.wrapFunction(
          read,
          (read2) =>
            function (req, res, next) {
              arguments[2] = publishRequestBodyAndNext(req, res, next)
              return read2.apply(this, arguments)
            }
        )
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js
var require_bunyan = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: 'bunyan', versions: ['>=1'] }, (Logger) => {
      const logCh = channel('apm:bunyan:log')
      shimmer.wrap(Logger.prototype, '_emit', (emit) => {
        return function wrappedEmit(rec) {
          if (logCh.hasSubscribers) {
            const payload = { message: rec }
            logCh.publish(payload)
            arguments[0] = payload.message
          }
          return emit.apply(this, arguments)
        }
      })
      return Logger
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js
var require_cassandra_driver = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startCh = channel('apm:cassandra-driver:query:start')
    var finishCh = channel('apm:cassandra-driver:query:finish')
    var errorCh = channel('apm:cassandra-driver:query:error')
    var connectCh = channel('apm:cassandra-driver:query:connect')
    var startCtx = {}
    addHook({ name: 'cassandra-driver', versions: ['>=3.0.0'] }, (cassandra) => {
      shimmer.wrap(
        cassandra.Client.prototype,
        'batch',
        (batch) =>
          function (queries, options, callback) {
            if (!startCh.hasSubscribers) {
              return batch.apply(this, arguments)
            }
            const lastIndex = arguments.length - 1
            const cb = arguments[lastIndex]
            startCtx = {
              keyspace: this.keyspace,
              query: queries,
              contactPoints: this.options && this.options.contactPoints,
            }
            return startCh.runStores(startCtx, () => {
              if (typeof cb === 'function') {
                arguments[lastIndex] = wrapCallback(finishCh, errorCh, startCtx, cb)
              }
              try {
                const res = batch.apply(this, arguments)
                if (typeof res === 'function' || !res) {
                  return wrapCallback(finishCh, errorCh, startCtx, res)
                }
                return res.then(
                  () => finish(finishCh, errorCh, startCtx),
                  (err) => finish(finishCh, errorCh, startCtx, err)
                )
              } catch (e) {
                finish(finishCh, errorCh, startCtx, e)
                throw e
              }
            })
          }
      )
      return cassandra
    })
    addHook({ name: 'cassandra-driver', versions: ['>=4.4'], patchDefault: false }, (cassandra) => {
      shimmer.wrap(
        cassandra.Client.prototype,
        '_execute',
        (_execute) =>
          function (query, params, execOptions, callback) {
            if (!startCh.hasSubscribers) {
              return _execute.apply(this, arguments)
            }
            startCtx = { keyspace: this.keyspace, query, contactPoints: this.options && this.options.contactPoints }
            return startCh.runStores(startCtx, () => {
              const promise = _execute.apply(this, arguments)
              promise.then(
                () => finish(finishCh, errorCh, startCtx),
                (err) => finish(finishCh, errorCh, startCtx, err)
              )
              return promise
            })
          }
      )
      return cassandra
    })
    var isValid = (args) => {
      return args.length === 4 || typeof args[3] === 'function'
    }
    addHook({ name: 'cassandra-driver', versions: ['3 - 4.3'], patchDefault: false }, (cassandra) => {
      shimmer.wrap(
        cassandra.Client.prototype,
        '_innerExecute',
        (_innerExecute) =>
          function (query, params, execOptions, callback) {
            if (!startCh.hasSubscribers) {
              return _innerExecute.apply(this, arguments)
            }
            if (!isValid(arguments)) {
              return _innerExecute.apply(this, arguments)
            }
            startCtx = { keyspace: this.keyspace, query, contactPoints: this.options && this.options.contactPoints }
            return startCh.runStores(startCtx, () => {
              const lastIndex = arguments.length - 1
              const cb = arguments[lastIndex]
              if (typeof cb === 'function') {
                arguments[lastIndex] = wrapCallback(finishCh, errorCh, startCtx, cb)
              }
              try {
                return _innerExecute.apply(this, arguments)
              } catch (e) {
                finish(finishCh, errorCh, startCtx, e)
                throw e
              }
            })
          }
      )
      return cassandra
    })
    addHook({ name: 'cassandra-driver', versions: ['>=3.3'], file: 'lib/request-execution.js' }, (RequestExecution) => {
      shimmer.wrap(
        RequestExecution.prototype,
        '_sendOnConnection',
        (_sendOnConnection) =>
          function () {
            if (!startCh.hasSubscribers) {
              return _sendOnConnection.apply(this, arguments)
            }
            startCtx = { hostname: this._connection.address, port: this._connection.port, ...startCtx }
            connectCh.publish(startCtx)
            return _sendOnConnection.apply(this, arguments)
          }
      )
      return RequestExecution
    })
    addHook(
      { name: 'cassandra-driver', versions: ['3.3 - 4.3'], file: 'lib/request-execution.js' },
      (RequestExecution) => {
        shimmer.wrap(
          RequestExecution.prototype,
          'start',
          (start) =>
            function (getHostCallback) {
              if (!startCh.hasSubscribers) {
                return getHostCallback.apply(this, arguments)
              }
              const execution = this
              if (!isRequestValid(this, arguments, 1)) {
                return start.apply(this, arguments)
              }
              arguments[0] = function () {
                startCtx = { hostname: execution._connection.address, port: execution._connection.port, ...startCtx }
                return connectCh.runStores(startCtx, getHostCallback, this, ...arguments)
              }
              return start.apply(this, arguments)
            }
        )
        return RequestExecution
      }
    )
    addHook({ name: 'cassandra-driver', versions: ['3 - 3.2'], file: 'lib/request-handler.js' }, (RequestHandler) => {
      shimmer.wrap(
        RequestHandler.prototype,
        'send',
        (send) =>
          function (request, options, callback) {
            if (!startCh.hasSubscribers) {
              return send.apply(this, arguments)
            }
            const handler = this
            if (!isRequestValid(this, arguments, 3)) {
              return send.apply(this, arguments)
            }
            arguments[2] = function () {
              startCtx = { hostname: handler.connection.address, port: handler.connection.port, ...startCtx }
              return connectCh.runStores(startCtx, callback, this, ...arguments)
            }
            return send.apply(this, arguments)
          }
      )
      return RequestHandler
    })
    function finish(finishCh2, errorCh2, ctx, error) {
      if (error) {
        ctx.error = error
        errorCh2.publish(ctx)
      }
      finishCh2.runStores(ctx, () => {})
    }
    function wrapCallback(finishCh2, errorCh2, ctx, callback) {
      return shimmer.wrapFunction(
        callback,
        (callback2) =>
          function (err) {
            if (err) {
              ctx.error = err
              errorCh2.publish(ctx)
            }
            return finishCh2.runStores(ctx, callback2, this, ...arguments)
          }
      )
    }
    function isRequestValid(exec, args, length) {
      if (!exec) return false
      if (args.length !== length || typeof args[length - 1] !== 'function') return false
      return true
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/child_process.js
var require_child_process = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/child_process.js'() {
    'use strict'
    var { errorMonitor } = require('events')
    var util = require('util')
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var dc = require_dc_polyfill()
    var childProcessChannel = dc.tracingChannel('datadog:child_process:execution')
    var execAsyncMethods = ['execFile', 'spawn']
    var names = ['child_process', 'node:child_process']
    var patched = false
    function throwSyncError(error) {
      throw error
    }
    function returnSpawnSyncError(error, context) {
      context.result = {
        error,
        status: null,
        signal: null,
        output: null,
        stdout: null,
        stderr: null,
        pid: 0,
      }
      return context.result
    }
    names.forEach((name) => {
      addHook({ name }, (childProcess) => {
        if (!patched) {
          patched = true
          shimmer.massWrap(childProcess, execAsyncMethods, wrapChildProcessAsyncMethod(childProcess.ChildProcess))
          shimmer.wrap(childProcess, 'execSync', wrapChildProcessSyncMethod(throwSyncError, true))
          shimmer.wrap(childProcess, 'execFileSync', wrapChildProcessSyncMethod(throwSyncError))
          shimmer.wrap(childProcess, 'spawnSync', wrapChildProcessSyncMethod(returnSpawnSyncError))
        }
        return childProcess
      })
    })
    function normalizeArgs(args, shell) {
      const childProcessInfo = {
        command: args[0],
        file: args[0],
      }
      if (Array.isArray(args[1])) {
        childProcessInfo.command = childProcessInfo.command + ' ' + args[1].join(' ')
        childProcessInfo.fileArgs = args[1]
        if (args[2] !== null && typeof args[2] === 'object') {
          childProcessInfo.options = args[2]
        }
      } else if (args[1] !== null && typeof args[1] === 'object') {
        childProcessInfo.options = args[1]
      }
      childProcessInfo.shell =
        shell || childProcessInfo.options?.shell === true || typeof childProcessInfo.options?.shell === 'string'
      return childProcessInfo
    }
    function createContextFromChildProcessInfo(childProcessInfo) {
      const context = {
        command: childProcessInfo.command,
        file: childProcessInfo.file,
        shell: childProcessInfo.shell,
        abortController: new AbortController(),
      }
      if (childProcessInfo.fileArgs) {
        context.fileArgs = childProcessInfo.fileArgs
      }
      return context
    }
    function wrapChildProcessSyncMethod(returnError, shell = false) {
      return function wrapMethod(childProcessMethod) {
        return function () {
          if (!childProcessChannel.start.hasSubscribers || arguments.length === 0) {
            return childProcessMethod.apply(this, arguments)
          }
          const childProcessInfo = normalizeArgs(arguments, shell)
          const context = createContextFromChildProcessInfo(childProcessInfo)
          return childProcessChannel.start.runStores(context, () => {
            try {
              if (context.abortController.signal.aborted) {
                const error = context.abortController.signal.reason || new Error('Aborted')
                return returnError(error, context)
              }
              const result = childProcessMethod.apply(this, arguments)
              context.result = result
              return result
            } catch (err) {
              context.error = err
              childProcessChannel.error.publish(context)
              throw err
            } finally {
              childProcessChannel.end.publish(context)
            }
          })
        }
      }
    }
    function wrapChildProcessCustomPromisifyMethod(customPromisifyMethod, shell) {
      return function () {
        if (!childProcessChannel.start.hasSubscribers || arguments.length === 0) {
          return customPromisifyMethod.apply(this, arguments)
        }
        const childProcessInfo = normalizeArgs(arguments, shell)
        const context = createContextFromChildProcessInfo(childProcessInfo)
        const { start, end, asyncStart, asyncEnd, error } = childProcessChannel
        start.publish(context)
        let result
        if (context.abortController.signal.aborted) {
          result = Promise.reject(context.abortController.signal.reason || new Error('Aborted'))
        } else {
          try {
            result = customPromisifyMethod.apply(this, arguments)
          } catch (error2) {
            context.error = error2
            error2.publish(context)
            throw error2
          } finally {
            end.publish(context)
          }
        }
        function reject(err) {
          context.error = err
          error.publish(context)
          asyncStart.publish(context)
          asyncEnd.publish(context)
          return Promise.reject(err)
        }
        function resolve(result2) {
          context.result = result2
          asyncStart.publish(context)
          asyncEnd.publish(context)
          return result2
        }
        return Promise.resolve(result).then(resolve, reject)
      }
    }
    function wrapChildProcessAsyncMethod(ChildProcess, shell = false) {
      return function wrapMethod(childProcessMethod) {
        function wrappedChildProcessMethod() {
          if (!childProcessChannel.start.hasSubscribers || arguments.length === 0) {
            return childProcessMethod.apply(this, arguments)
          }
          const childProcessInfo = normalizeArgs(arguments, shell)
          const context = createContextFromChildProcessInfo(childProcessInfo)
          return childProcessChannel.start.runStores(context, () => {
            let childProcess
            if (context.abortController.signal.aborted) {
              childProcess = new ChildProcess()
              childProcess.on('error', () => {})
              process.nextTick(() => {
                const error = context.abortController.signal.reason || new Error('Aborted')
                childProcess.emit('error', error)
                const cb = arguments[arguments.length - 1]
                if (typeof cb === 'function') {
                  cb(error)
                }
                childProcess.emit('close')
              })
            } else {
              childProcess = childProcessMethod.apply(this, arguments)
            }
            if (childProcess) {
              let errorExecuted = false
              childProcess.on(errorMonitor, (e) => {
                errorExecuted = true
                context.error = e
                childProcessChannel.error.publish(context)
              })
              childProcess.on('close', (code = 0) => {
                if (!errorExecuted && code !== 0) {
                  childProcessChannel.error.publish(context)
                }
                context.result = code
                childProcessChannel.asyncEnd.publish(context)
              })
            }
            return childProcess
          })
        }
        if (childProcessMethod[util.promisify.custom]) {
          const wrapedChildProcessCustomPromisifyMethod = shimmer.wrapFunction(
            childProcessMethod[util.promisify.custom],
            (promisify) => wrapChildProcessCustomPromisifyMethod(promisify, shell)
          )
          const descriptor = Object.getOwnPropertyDescriptor(childProcessMethod, util.promisify.custom)
          Object.defineProperty(wrappedChildProcessMethod, util.promisify.custom, {
            ...descriptor,
            value: wrapedChildProcessCustomPromisifyMethod,
          })
        }
        return wrappedChildProcessMethod
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/connect.js
var require_connect = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/connect.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var enterChannel = channel('apm:connect:middleware:enter')
    var exitChannel = channel('apm:connect:middleware:exit')
    var errorChannel = channel('apm:connect:middleware:error')
    var nextChannel = channel('apm:connect:middleware:next')
    var finishChannel = channel('apm:connect:middleware:finish')
    var handleChannel = channel('apm:connect:request:handle')
    function wrapConnect(connect) {
      if (typeof connect !== 'function') return connect
      return function connectWithTrace() {
        const app = connect()
        if (!app) return app
        shimmer.wrap(app, 'use', wrapUse)
        shimmer.wrap(app, 'handle', wrapHandle)
        return app
      }
    }
    function wrapUse(use) {
      if (typeof use !== 'function') return use
      return function useWithTrace(route, fn) {
        const result = use.apply(this, arguments)
        if (!this || !Array.isArray(this.stack)) return result
        const index = this.stack.length - 1
        const layer = this.stack[index]
        if (layer && layer.handle) {
          this.stack[index].handle = wrapLayerHandle(layer)
        }
        return result
      }
    }
    function wrapHandle(handle) {
      return function handleWithTrace(req, res) {
        if (handleChannel.hasSubscribers) {
          handleChannel.publish({ req, res })
        }
        return handle.apply(this, arguments)
      }
    }
    function wrapLayerHandle(layer) {
      if (typeof layer.handle !== 'function') return layer.handle
      const original = layer.handle
      return shimmer.wrapFunction(
        original,
        (original2) =>
          function () {
            if (!enterChannel.hasSubscribers) return original2.apply(this, arguments)
            const lastIndex = arguments.length - 1
            const name = original2._name || original2.name
            const req = arguments[arguments.length > 3 ? 1 : 0]
            const next = arguments[lastIndex]
            if (typeof next === 'function') {
              arguments[lastIndex] = wrapNext(req, next)
            }
            const route = layer.route
            enterChannel.publish({ name, req, route })
            try {
              return original2.apply(this, arguments)
            } catch (error) {
              errorChannel.publish({ req, error })
              nextChannel.publish({ req })
              finishChannel.publish({ req })
              throw error
            } finally {
              exitChannel.publish({ req })
            }
          }
      )
    }
    function wrapNext(req, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function (error) {
            if (error) {
              errorChannel.publish({ req, error })
            }
            nextChannel.publish({ req })
            finishChannel.publish({ req })
            next2.apply(this, arguments)
          }
      )
    }
    addHook({ name: 'connect', versions: ['>=3.4.0'] }, (connect) => {
      return shimmer.wrapFunction(connect, (connect2) => wrapConnect(connect2))
    })
    addHook({ name: 'connect', versions: ['>=3 <3.4.0'], file: 'lib/connect.js' }, (connect) => {
      return shimmer.wrapFunction(connect, (connect2) => wrapConnect(connect2))
    })
    addHook({ name: 'connect', versions: ['2.2.2'], file: 'lib/connect.js' }, (connect) => {
      shimmer.wrap(connect.proto, 'use', wrapUse)
      shimmer.wrap(connect.proto, 'handle', wrapHandle)
      return connect
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/cookie.js
var require_cookie = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/cookie.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook } = require_instrument()
    var cookieParseCh = channel('datadog:cookie:parse:finish')
    function wrapParse(originalParse) {
      return function () {
        const cookies = originalParse.apply(this, arguments)
        if (cookieParseCh.hasSubscribers && cookies) {
          cookieParseCh.publish({ cookies })
        }
        return cookies
      }
    }
    addHook({ name: 'cookie', versions: ['>=0.4'] }, (cookie) => {
      shimmer.wrap(cookie, 'parse', wrapParse)
      return cookie
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/cookie-parser.js
var require_cookie_parser = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/cookie-parser.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook } = require_instrument()
    var cookieParserReadCh = channel('datadog:cookie-parser:read:finish')
    function publishRequestCookieAndNext(req, res, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function cookieParserWrapper() {
            if (cookieParserReadCh.hasSubscribers && req) {
              const abortController = new AbortController()
              const mergedCookies = { ...req.cookies, ...req.signedCookies }
              cookieParserReadCh.publish({ req, res, abortController, cookies: mergedCookies })
              if (abortController.signal.aborted) return
            }
            return next2.apply(this, arguments)
          }
      )
    }
    addHook(
      {
        name: 'cookie-parser',
        versions: ['>=1.0.0'],
      },
      (cookieParser) => {
        return shimmer.wrapFunction(
          cookieParser,
          (cookieParser2) =>
            function () {
              const cookieMiddleware = cookieParser2.apply(this, arguments)
              return shimmer.wrapFunction(
                cookieMiddleware,
                (cookieMiddleware2) =>
                  function (req, res, next) {
                    arguments[2] = publishRequestCookieAndNext(req, res, next)
                    return cookieMiddleware2.apply(this, arguments)
                  }
              )
            }
        )
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js
var require_couchbase = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js'() {
    'use strict'
    var { errorMonitor } = require('events')
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    function findCallbackIndex(args, lowerbound = 2) {
      for (let i = args.length - 1; i >= lowerbound; i--) {
        if (typeof args[i] === 'function') return i
      }
      return -1
    }
    function getQueryResource(q) {
      return q && (typeof q === 'string' ? q : q.statement)
    }
    function wrapAllNames(names, action) {
      names.forEach((name) => action(name))
    }
    function wrapCallback(callback, ctx, channelPrefix) {
      const callbackStartCh = channel(`${channelPrefix}:callback:start`)
      const callbackFinishCh = channel(`${channelPrefix}:callback:finish`)
      const wrapped = callbackStartCh.runStores(ctx, () => {
        return function (...args) {
          return callbackFinishCh.runStores(ctx, () => {
            return callback.apply(this, args)
          })
        }
      })
      Object.defineProperty(wrapped, '_dd_wrapped', { value: true })
      return wrapped
    }
    function wrapQuery(query) {
      return function (q, params, callback) {
        const cb = arguments[arguments.length - 1]
        if (typeof cb === 'function') {
          const ctx = {}
          arguments[arguments.length - 1] = wrapCallback(cb, ctx, 'apm:couchbase:query')
        }
        return query.apply(this, arguments)
      }
    }
    function wrapCallbackFinish(callback, thisArg, _args, errorCh, finishCh, ctx, channelPrefix) {
      const callbackStartCh = channel(`${channelPrefix}:callback:start`)
      const callbackFinishCh = channel(`${channelPrefix}:callback:finish`)
      const wrapped = callbackStartCh.runStores(ctx, () => {
        return function finish(error, result) {
          return callbackFinishCh.runStores(ctx, () => {
            if (error) {
              ctx.error = error
              errorCh.publish(ctx)
            }
            finishCh.publish(ctx)
            return callback.apply(thisArg, [error, result])
          })
        }
      })
      Object.defineProperty(wrapped, '_dd_wrapped', { value: true })
      return wrapped
    }
    function wrap(prefix, fn) {
      const startCh = channel(prefix + ':start')
      const finishCh = channel(prefix + ':finish')
      const errorCh = channel(prefix + ':error')
      const wrapped = function () {
        if (!startCh.hasSubscribers) {
          return fn.apply(this, arguments)
        }
        const callbackIndex = findCallbackIndex(arguments, 1)
        if (callbackIndex < 0) return fn.apply(this, arguments)
        const ctx = { bucket: { name: this.name || this._name }, seedNodes: this._dd_hosts }
        return startCh.runStores(ctx, () => {
          const cb = arguments[callbackIndex]
          arguments[callbackIndex] = shimmer.wrapFunction(cb, (cb2) => {
            return wrapCallbackFinish(cb2, this, arguments, errorCh, finishCh, ctx, prefix)
          })
          try {
            return fn.apply(this, arguments)
          } catch (error) {
            ctx.error = error
            error.stack
            errorCh.publish(ctx)
            throw error
          }
        })
      }
      return wrapped
    }
    function wrapMaybeInvoke(_maybeInvoke, channelPrefix) {
      return function (fn, args) {
        if (!Array.isArray(args)) return _maybeInvoke.apply(this, arguments)
        const callbackIndex = findCallbackIndex(args, 0)
        if (callbackIndex === -1) return _maybeInvoke.apply(this, arguments)
        const callback = args[callbackIndex]
        if (typeof callback === 'function' && !callback._dd_wrapped) {
          const ctx = {}
          args[callbackIndex] = wrapCallback(callback, ctx, channelPrefix)
        }
        return _maybeInvoke.apply(this, arguments)
      }
    }
    function wrapCBandPromise(fn, name, startData, thisArg, args) {
      const startCh = channel(`apm:couchbase:${name}:start`)
      const finishCh = channel(`apm:couchbase:${name}:finish`)
      const errorCh = channel(`apm:couchbase:${name}:error`)
      if (!startCh.hasSubscribers) return fn.apply(thisArg, args)
      const ctx = startData
      return startCh.runStores(ctx, () => {
        try {
          const cbIndex = findCallbackIndex(args, 1)
          if (cbIndex >= 0) {
            args[cbIndex] = shimmer.wrapFunction(args[cbIndex], (cb) => {
              return wrapCallbackFinish(cb, thisArg, args, errorCh, finishCh, ctx, `apm:couchbase:${name}`)
            })
          }
          const res = fn.apply(thisArg, args)
          res.then(
            (result) => {
              ctx.result = result
              finishCh.publish(ctx)
            },
            (err) => {
              ctx.error = err
              errorCh.publish(ctx)
              finishCh.publish(ctx)
            }
          )
          return res
        } catch (e) {
          e.stack
          ctx.error = e
          errorCh.publish(ctx)
          throw e
        }
      })
    }
    function wrapWithName(name) {
      return function (operation) {
        return function () {
          return wrapCBandPromise(
            operation,
            name,
            {
              collection: { name: this._name || '_default' },
              bucket: { name: this._scope._bucket._name },
              seedNodes: this._dd_connStr,
            },
            this,
            arguments
          )
        }
      }
    }
    function wrapV3Query(query) {
      return function (q) {
        const resource = getQueryResource(q)
        return wrapCBandPromise(query, 'query', { resource, seedNodes: this._connStr }, this, arguments)
      }
    }
    addHook({ name: 'couchbase', file: 'lib/bucket.js', versions: ['^2.6.12'] }, (Bucket) => {
      shimmer.wrap(Bucket.prototype, '_maybeInvoke', (maybeInvoke) => {
        return wrapMaybeInvoke(maybeInvoke, 'apm:couchbase:bucket:maybeInvoke')
      })
      const startCh = channel('apm:couchbase:query:start')
      const finishCh = channel('apm:couchbase:query:finish')
      const errorCh = channel('apm:couchbase:query:error')
      shimmer.wrap(Bucket.prototype, 'query', (query) => wrapQuery(query))
      shimmer.wrap(
        Bucket.prototype,
        '_n1qlReq',
        (_n1qlReq) =>
          function (host, q, adhoc, emitter) {
            if (!startCh.hasSubscribers) {
              return _n1qlReq.apply(this, arguments)
            }
            if (!emitter || !emitter.once) return _n1qlReq.apply(this, arguments)
            const n1qlQuery = getQueryResource(q)
            const ctx = { resource: n1qlQuery, bucket: { name: this.name || this._name }, seedNodes: this._dd_hosts }
            return startCh.runStores(ctx, () => {
              emitter.once('rows', () => {
                finishCh.publish(ctx)
              })
              emitter.once(errorMonitor, (error) => {
                if (!error) return
                ctx.error = error
                errorCh.publish(ctx)
                finishCh.publish(ctx)
              })
              try {
                return _n1qlReq.apply(this, arguments)
              } catch (err) {
                err.stack
                ctx.error = err
                errorCh.publish(ctx)
                throw err
              }
            })
          }
      )
      wrapAllNames(['upsert', 'insert', 'replace', 'append', 'prepend'], (name) => {
        shimmer.wrap(Bucket.prototype, name, (fn) => wrap(`apm:couchbase:${name}`, fn))
      })
      return Bucket
    })
    addHook({ name: 'couchbase', file: 'lib/cluster.js', versions: ['^2.6.12'] }, (Cluster) => {
      shimmer.wrap(Cluster.prototype, '_maybeInvoke', (maybeInvoke) => {
        return wrapMaybeInvoke(maybeInvoke, 'apm:couchbase:cluster:maybeInvoke')
      })
      shimmer.wrap(Cluster.prototype, 'query', (query) => wrapQuery(query))
      shimmer.wrap(Cluster.prototype, 'openBucket', (openBucket) => {
        return function () {
          const bucket = openBucket.apply(this, arguments)
          const hosts = this.dsnObj.hosts
          bucket._dd_hosts = hosts.map((hostAndPort) => hostAndPort.join(':')).join(',')
          return bucket
        }
      })
      return Cluster
    })
    addHook({ name: 'couchbase', file: 'lib/bucket.js', versions: ['^3.0.7', '^3.1.3'] }, (Bucket) => {
      shimmer.wrap(Bucket.prototype, 'collection', (getCollection) => {
        return function () {
          const collection = getCollection.apply(this, arguments)
          const connStr = this._cluster._connStr
          collection._dd_connStr = connStr
          return collection
        }
      })
      return Bucket
    })
    addHook({ name: 'couchbase', file: 'lib/collection.js', versions: ['^3.0.7', '^3.1.3'] }, (Collection) => {
      wrapAllNames(['upsert', 'insert', 'replace'], (name) => {
        shimmer.wrap(Collection.prototype, name, wrapWithName(name))
      })
      return Collection
    })
    addHook({ name: 'couchbase', file: 'lib/cluster.js', versions: ['^3.0.7', '^3.1.3'] }, (Cluster) => {
      shimmer.wrap(Cluster.prototype, 'query', wrapV3Query)
      return Cluster
    })
    addHook({ name: 'couchbase', file: 'dist/collection.js', versions: ['>=3.2.2'] }, (collection) => {
      const Collection = collection.Collection
      wrapAllNames(['upsert', 'insert', 'replace'], (name) => {
        shimmer.wrap(Collection.prototype, name, wrapWithName(name))
      })
      return collection
    })
    addHook({ name: 'couchbase', file: 'dist/bucket.js', versions: ['>=3.2.2'] }, (bucket) => {
      const Bucket = bucket.Bucket
      shimmer.wrap(Bucket.prototype, 'collection', (getCollection) => {
        return function () {
          const collection = getCollection.apply(this, arguments)
          const connStr = this._cluster._connStr
          collection._dd_connStr = connStr
          return collection
        }
      })
      return bucket
    })
    addHook({ name: 'couchbase', file: 'dist/cluster.js', versions: ['>=3.2.2'] }, (cluster) => {
      const Cluster = cluster.Cluster
      shimmer.wrap(Cluster.prototype, 'query', wrapV3Query)
      return cluster
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/crypto.js
var require_crypto = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/crypto.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var cryptoHashCh = channel('datadog:crypto:hashing:start')
    var cryptoCipherCh = channel('datadog:crypto:cipher:start')
    var hashMethods = ['createHash', 'createHmac', 'createSign', 'createVerify', 'sign', 'verify']
    var cipherMethods = ['createCipheriv', 'createDecipheriv']
    var names = ['crypto', 'node:crypto']
    addHook({ name: names }, (crypto) => {
      shimmer.massWrap(crypto, hashMethods, wrapCryptoMethod(cryptoHashCh))
      shimmer.massWrap(crypto, cipherMethods, wrapCryptoMethod(cryptoCipherCh))
      return crypto
    })
    function wrapCryptoMethod(channel2) {
      function wrapMethod(cryptoMethod) {
        return function () {
          if (channel2.hasSubscribers && arguments.length > 0) {
            const algorithm = arguments[0]
            channel2.publish({ algorithm })
          }
          return cryptoMethod.apply(this, arguments)
        }
      }
      return wrapMethod
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/cypress.js
var require_cypress = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/cypress.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { DD_MAJOR } = require_version()
    addHook(
      {
        name: 'cypress',
        versions: DD_MAJOR >= 6 ? ['>=10.2.0'] : ['>=6.7.0'],
      },
      (lib) => lib
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/dd-trace-api.js
var require_dd_trace_api = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/dd-trace-api.js'() {
    'use strict'
    var { addHook } = require_instrument()
    addHook({ name: 'dd-trace-api' }, (api) => api)
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js
var require_dns = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var rrtypes = {
      resolveAny: 'ANY',
      resolve4: 'A',
      resolve6: 'AAAA',
      resolveCname: 'CNAME',
      resolveMx: 'MX',
      resolveNs: 'NS',
      resolveTxt: 'TXT',
      resolveSrv: 'SRV',
      resolvePtr: 'PTR',
      resolveNaptr: 'NAPTR',
      resolveSoa: 'SOA',
    }
    var rrtypeMap = /* @__PURE__ */ new WeakMap()
    var names = ['dns', 'node:dns']
    addHook({ name: names }, (dns) => {
      shimmer.wrap(dns, 'lookup', (fn) => wrap('apm:dns:lookup', fn, 2))
      shimmer.wrap(dns, 'lookupService', (fn) => wrap('apm:dns:lookup_service', fn, 2))
      shimmer.wrap(dns, 'resolve', (fn) => wrap('apm:dns:resolve', fn, 2))
      shimmer.wrap(dns, 'reverse', (fn) => wrap('apm:dns:reverse', fn, 2))
      patchResolveShorthands(dns)
      if (dns.Resolver) {
        shimmer.wrap(dns.Resolver.prototype, 'resolve', (fn) => wrap('apm:dns:resolve', fn, 2))
        shimmer.wrap(dns.Resolver.prototype, 'reverse', (fn) => wrap('apm:dns:reverse', fn, 2))
        patchResolveShorthands(dns.Resolver.prototype)
      }
      return dns
    })
    function patchResolveShorthands(prototype) {
      for (const method of Object.keys(rrtypes)) {
        if (prototype[method]) {
          rrtypeMap.set(prototype[method], rrtypes[method])
          shimmer.wrap(prototype, method, (fn) => wrap('apm:dns:resolve', fn, 2, rrtypes[method]))
        }
      }
    }
    function wrap(prefix, fn, expectedArgs, rrtype) {
      const startCh = channel(prefix + ':start')
      const finishCh = channel(prefix + ':finish')
      const errorCh = channel(prefix + ':error')
      const wrapped = function () {
        const cb = arguments[arguments.length - 1]
        if (!startCh.hasSubscribers || arguments.length < expectedArgs || typeof cb !== 'function') {
          return fn.apply(this, arguments)
        }
        const args = [...arguments]
        args.pop()
        if (rrtype) {
          args.push(rrtype)
        }
        const ctx = { args }
        return startCh.runStores(ctx, () => {
          arguments[arguments.length - 1] = shimmer.wrapFunction(
            cb,
            (cb2) =>
              function (error, result, ...args2) {
                if (error) {
                  ctx.error = error
                  errorCh.publish(ctx)
                }
                ctx.result = result
                finishCh.runStores(ctx, cb2, this, error, result, ...args2)
              }
          )
          try {
            return fn.apply(this, arguments)
          } catch (error) {
            error.stack
            ctx.error = error
            errorCh.publish(ctx)
            throw error
          }
        })
      }
      return wrapped
    }
  },
})

// node_modules/dd-trace/vendor/dist/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  'node_modules/dd-trace/vendor/dist/path-to-regexp/index.js'(exports2, module2) {
    ;(() => {
      var e = {
          './path-to-regexp/index.js': function (e2) {
            e2.exports = function e3(t2, n, o) {
              n = n || []
              var i,
                s = (o = o || {}).strict,
                a = false !== o.end,
                f = o.sensitive ? '' : 'i',
                p = false !== o.lookahead,
                u = 0,
                x = n.length,
                g = 0,
                l = 0,
                c = 0,
                h = ''
              if (t2 instanceof RegExp) {
                for (; (i = r2.exec(t2.source)); )
                  '\\' !== i[0][0] && n.push({ name: i[1] || l++, optional: false, offset: i.index })
                return t2
              }
              if (Array.isArray(t2))
                return new RegExp(
                  (t2 = t2.map(function (r3) {
                    return e3(r3, n, o).source
                  })).join('|'),
                  f
                )
              if ('string' != typeof t2)
                throw TypeError('path must be a string, array of strings, or regular expression')
              for (
                t2 = t2.replace(
                  /\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g,
                  function (e4, r3, o2, i2, s2, a2, f2, p2) {
                    if ('\\' === e4[0]) return ((h += e4), (c += 2), e4)
                    if ('.' === e4) return ((h += '\\.'), (u += 1), (c += 1), '\\.')
                    if ((r3 || o2 ? (h = '') : (h += t2.slice(c, p2)), (c = p2 + e4.length), '*' === e4))
                      return ((u += 3), '(.*)')
                    if ('/(' === e4) return ((h += '/'), (u += 2), '/(?:')
                    ;((r3 = r3 || ''),
                      (o2 = o2 ? '\\.' : ''),
                      (f2 = f2 || ''),
                      (s2 = s2
                        ? s2.replace(/\\.|\*/, function (e5) {
                            return '*' === e5 ? '(.*)' : e5
                          })
                        : h
                          ? '((?:(?!/|' + h + ').)+?)'
                          : '([^/' + o2 + ']+?)'),
                      n.push({ name: i2, optional: !!f2, offset: p2 + u }))
                    var x2 = '(?:' + o2 + r3 + s2 + (a2 ? '((?:[/' + o2 + '].+?)?)' : '') + ')' + f2
                    return ((u += x2.length - e4.length), x2)
                  }
                );
                (i = r2.exec(t2));
              )
                '\\' !== i[0][0] &&
                  ((x + g === n.length || n[x + g].offset > i.index) &&
                    n.splice(x + g, 0, { name: l++, optional: false, offset: i.index }),
                  g++)
              return (
                (t2 += s ? '' : '/' === t2[t2.length - 1] ? '?' : '/?'),
                a ? (t2 += '$') : '/' !== t2[t2.length - 1] && (t2 += p ? '(?=/|$)' : '(?:/|$)'),
                RegExp('^' + t2, f)
              )
            }
            var r2 = /\\.|\((?:\?<(.*?)>)?(?!\?)/g
          },
        },
        r = {},
        t = (function t2(n) {
          var o = r[n]
          if (void 0 !== o) return o.exports
          var i = (r[n] = { exports: {} })
          return (e[n](i, i.exports, t2), i.exports)
        })('./path-to-regexp/index.js')
      module2.exports = t
    })()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/router-helper.js
var require_router_helper = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/router-helper.js'(exports2, module2) {
    'use strict'
    var { channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var routerMountPaths = /* @__PURE__ */ new WeakMap()
    var layerMatchers = /* @__PURE__ */ new WeakMap()
    var appMountedRouters = /* @__PURE__ */ new WeakSet()
    var METHODS = [...require('http').METHODS.map((v) => v.toLowerCase()), 'all']
    var routeAddedChannel = channel('apm:express:route:added')
    function joinPath(base, path) {
      if (!base || base === '/') return path || '/'
      if (!path || path === '/') return base
      if (path !== '' && !path.startsWith('/')) return null
      if (!base.startsWith('/')) return null
      if (base.endsWith('/') && path.startsWith('/')) {
        return base + path.slice(1)
      }
      return base + path
    }
    function normalizeRoutePath(path) {
      if (path == null) return null
      if (typeof path === 'string') return path
      if (path instanceof RegExp) return path.toString()
      return String(path)
    }
    function collectRoutesFromRouter(router, prefix) {
      if (!router?.stack?.length) return
      for (const layer of router.stack) {
        if (layer.route) {
          const route = layer.route
          const fullPaths = getRouteFullPaths(route, prefix)
          for (const fullPath of fullPaths) {
            for (const [method, enabled] of Object.entries(route.methods || {})) {
              if (!enabled) continue
              routeAddedChannel.publish({
                method: normalizeMethodName(method),
                path: fullPath,
              })
            }
          }
        } else if (layer.handle?.stack?.length) {
          const mountPath = typeof layer.path === 'string' ? layer.path : getLayerMatchers(layer)?.[0]?.path || ''
          const nestedPrefix = joinPath(prefix, mountPath)
          if (nestedPrefix === null) continue
          setRouterMountPath(layer.handle, nestedPrefix)
          markAppMounted(layer.handle)
          collectRoutesFromRouter(layer.handle, nestedPrefix)
        }
      }
    }
    function normalizeRoutePaths(path) {
      if (path == null) return []
      if (Array.isArray(path) === false) {
        const normalized = normalizeRoutePath(path)
        return [normalized]
      }
      const paths = path.flat(Infinity)
      const result = []
      for (const _path of paths) {
        const normalized = normalizeRoutePath(_path)
        if (normalized !== null) {
          result.push(normalized)
        }
      }
      return result
    }
    function setRouterMountPath(router, mountPath) {
      if (!router || typeof mountPath !== 'string') return
      const existing = routerMountPaths.get(router)
      if (existing) {
        existing.add(mountPath)
      } else {
        routerMountPaths.set(router, /* @__PURE__ */ new Set([mountPath]))
      }
    }
    function getRouterMountPaths(router) {
      const paths = routerMountPaths.get(router)
      if (!paths) return []
      return [...paths]
    }
    function setLayerMatchers(layer, matchers) {
      layerMatchers.set(layer, matchers)
    }
    function getLayerMatchers(layer) {
      return layerMatchers.get(layer)
    }
    function normalizeMethodName(method) {
      return method === '_all' || method === 'all' ? '*' : method
    }
    function getRouteFullPaths(route, prefix) {
      if (!route) return []
      const routePaths = normalizeRoutePaths(route.path)
      const pathsToPublish = routePaths.length ? routePaths : ['']
      return pathsToPublish.map((routePath) => joinPath(prefix, routePath)).filter((path) => path !== null)
    }
    function markAppMounted(router) {
      if (router) appMountedRouters.add(router)
    }
    function isAppMounted(router) {
      return appMountedRouters.has(router)
    }
    function extractMountPaths(path) {
      const hasMount = typeof path === 'string' || path instanceof RegExp || Array.isArray(path)
      if (!hasMount) {
        return { mountPaths: ['/'], startIdx: 0 }
      }
      const paths = normalizeRoutePaths(path)
      return {
        mountPaths: paths.length ? paths : ['/'],
        startIdx: 1,
      }
    }
    function hasRouterCycle(router, stack = /* @__PURE__ */ new Set()) {
      if (!router?.stack?.length) return false
      if (stack.has(router)) return true
      stack.add(router)
      for (const layer of router.stack) {
        if (!layer?.route && layer?.handle?.stack?.length) {
          const hasCycle = hasRouterCycle(layer.handle, stack)
          if (hasCycle) {
            return true
          }
        }
      }
      stack.delete(router)
      return false
    }
    function wrapRouteMethodsAndPublish(route, paths, publish) {
      if (!route || !paths.length) return
      const filteredPaths = paths.filter(Boolean)
      if (!filteredPaths.length) return
      const uniquePaths = new Set(filteredPaths)
      METHODS.forEach((method) => {
        if (typeof route[method] !== 'function') return
        shimmer.wrap(
          route,
          method,
          (originalMethod) =>
            function wrappedRouteMethod(...args) {
              const normalizedMethod = normalizeMethodName(method)
              for (const path of uniquePaths) {
                publish({
                  method: normalizedMethod,
                  path,
                })
              }
              return originalMethod.apply(this, args)
            }
        )
      })
    }
    module2.exports = {
      setRouterMountPath,
      getRouterMountPaths,
      joinPath,
      setLayerMatchers,
      getLayerMatchers,
      markAppMounted,
      isAppMounted,
      normalizeRoutePath,
      normalizeRoutePaths,
      getRouteFullPaths,
      wrapRouteMethodsAndPublish,
      extractMountPaths,
      hasRouterCycle,
      collectRoutesFromRouter,
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/router.js
var require_router = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/router.js'(exports2, module2) {
    'use strict'
    var METHODS = [...require('http').METHODS.map((v) => v.toLowerCase()), 'all']
    var pathToRegExp = require_path_to_regexp()
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var {
      getRouterMountPaths,
      joinPath,
      getLayerMatchers,
      setLayerMatchers,
      isAppMounted,
      setRouterMountPath,
      extractMountPaths,
      getRouteFullPaths,
      wrapRouteMethodsAndPublish,
      collectRoutesFromRouter,
    } = require_router_helper()
    function isFastStar(layer, matchers) {
      return layer.regexp?.fast_star ?? matchers.some((matcher) => matcher.path === '*')
    }
    function isFastSlash(layer, matchers) {
      return layer.regexp?.fast_slash ?? matchers.some((matcher) => matcher.path === '/')
    }
    function createWrapRouterMethod(name) {
      const enterChannel = channel(`apm:${name}:middleware:enter`)
      const exitChannel = channel(`apm:${name}:middleware:exit`)
      const finishChannel = channel(`apm:${name}:middleware:finish`)
      const errorChannel = channel(`apm:${name}:middleware:error`)
      const nextChannel = channel(`apm:${name}:middleware:next`)
      const routeAddedChannel = channel(`apm:${name}:route:added`)
      const regexpCache = /* @__PURE__ */ Object.create(null)
      function wrapLayerHandle(layer, original) {
        original._name = original._name || layer.name
        return shimmer.wrapFunction(
          original,
          (original2) =>
            function () {
              if (!enterChannel.hasSubscribers) return original2.apply(this, arguments)
              const matchers = getLayerMatchers(layer)
              const lastIndex = arguments.length - 1
              const name2 = original2._name || original2.name
              const req = arguments[arguments.length > 3 ? 1 : 0]
              const next = arguments[lastIndex]
              if (typeof next === 'function') {
                arguments[lastIndex] = wrapNext(req, next)
              }
              let route
              if (matchers) {
                for (const matcher of matchers) {
                  if (matcher.test(layer)) {
                    route = matcher.path
                    break
                  }
                }
              }
              enterChannel.publish({ name: name2, req, route, layer })
              try {
                return original2.apply(this, arguments)
              } catch (error) {
                errorChannel.publish({ req, error })
                nextChannel.publish({ req })
                finishChannel.publish({ req })
                throw error
              } finally {
                exitChannel.publish({ req })
              }
            }
        )
      }
      function wrapStack(layers, matchers) {
        for (const layer of layers) {
          if (layer.__handle) {
            layer.__handle = wrapLayerHandle(layer, layer.__handle)
          } else {
            layer.handle = wrapLayerHandle(layer, layer.handle)
          }
          setLayerMatchers(layer, matchers)
          if (layer.route) {
            METHODS.forEach((method) => {
              if (typeof layer.route.stack === 'function') {
                layer.route.stack = [{ handle: layer.route.stack }]
              }
              layer.route[method] = wrapMethod(layer.route[method])
            })
          }
        }
      }
      function wrapNext(req, next) {
        return shimmer.wrapFunction(
          next,
          (next2) =>
            function (error) {
              if (error && error !== 'route' && error !== 'router') {
                errorChannel.publish({ req, error })
              }
              nextChannel.publish({ req })
              finishChannel.publish({ req })
              next2.apply(this, arguments)
            }
        )
      }
      function extractMatchers(fn) {
        const arg = Array.isArray(fn) ? fn.flat(Infinity) : [fn]
        if (typeof arg[0] === 'function') {
          return []
        }
        return arg.map((pattern) => ({
          path: pattern instanceof RegExp ? `(${pattern})` : pattern,
          test: (layer) => {
            const matchers = getLayerMatchers(layer)
            return (
              !isFastStar(layer, matchers) &&
              !isFastSlash(layer, matchers) &&
              cachedPathToRegExp(pattern).test(layer.path)
            )
          },
        }))
      }
      function cachedPathToRegExp(pattern) {
        const maybeCached = regexpCache[pattern]
        if (maybeCached) {
          return maybeCached
        }
        const regexp = pathToRegExp(pattern)
        regexpCache[pattern] = regexp
        return regexp
      }
      function wrapMethod(original) {
        return shimmer.wrapFunction(
          original,
          (original2) =>
            function methodWithTrace(...args) {
              let offset = 0
              if (this.stack) {
                offset = Array.isArray(this.stack) ? this.stack.length : 1
              }
              const router = original2.apply(this, args)
              if (typeof this.stack === 'function') {
                this.stack = [{ handle: this.stack }]
              }
              if (routeAddedChannel.hasSubscribers) {
                routeAddedChannel.publish({ topOfStackFunc: methodWithTrace, layer: this.stack?.at(-1) })
              }
              const fn = args[0]
              if (routeAddedChannel.hasSubscribers && isAppMounted(this) && this.stack?.length > offset) {
                if (original2.name === 'use' && args.length >= 2) {
                  const { mountPaths: mountPaths2, startIdx } = extractMountPaths(fn)
                  if (mountPaths2.length) {
                    const parentPaths = getRouterMountPaths(this)
                    for (let i = startIdx; i < args.length; i++) {
                      const nestedRouter = args[i]
                      if (!nestedRouter || typeof nestedRouter !== 'function') continue
                      for (const parentPath of parentPaths) {
                        for (const normalizedMountPath of mountPaths2) {
                          const fullMountPath = joinPath(parentPath, normalizedMountPath)
                          if (fullMountPath === null) continue
                          setRouterMountPath(nestedRouter, fullMountPath)
                          collectRoutesFromRouter(nestedRouter, fullMountPath)
                        }
                      }
                    }
                  }
                }
                const mountPaths = getRouterMountPaths(this)
                if (mountPaths.length) {
                  const layer = this.stack.at(-1)
                  if (layer?.route) {
                    const route = layer.route
                    const fullPaths = mountPaths.flatMap((mountPath) => getRouteFullPaths(route, mountPath))
                    wrapRouteMethodsAndPublish(route, fullPaths, (payload) => {
                      routeAddedChannel.publish(payload)
                    })
                  }
                }
              }
              if (this.stack?.length > offset) {
                wrapStack(this.stack.slice(offset), extractMatchers(fn))
              }
              return router
            }
        )
      }
      return wrapMethod
    }
    var wrapRouterMethod = createWrapRouterMethod('router')
    addHook({ name: 'router', versions: ['>=1 <2'] }, (Router) => {
      shimmer.wrap(Router.prototype, 'use', wrapRouterMethod)
      shimmer.wrap(Router.prototype, 'route', wrapRouterMethod)
      return Router
    })
    var queryParserReadCh = channel('datadog:query:read:finish')
    addHook({ name: 'router', versions: ['>=2'] }, (Router) => {
      const WrappedRouter = shimmer.wrapFunction(Router, function (originalRouter) {
        return function wrappedMethod() {
          const router = originalRouter.apply(this, arguments)
          shimmer.wrap(router, 'handle', function wrapHandle(originalHandle) {
            return function wrappedHandle(req, res, next) {
              const abortController = new AbortController()
              if (queryParserReadCh.hasSubscribers && req) {
                queryParserReadCh.publish({ req, res, query: req.query, abortController })
                if (abortController.signal.aborted) return
              }
              return originalHandle.apply(this, arguments)
            }
          })
          return router
        }
      })
      shimmer.wrap(WrappedRouter.prototype, 'use', wrapRouterMethod)
      shimmer.wrap(WrappedRouter.prototype, 'route', wrapRouterMethod)
      return WrappedRouter
    })
    var routerParamStartCh = channel('datadog:router:param:start')
    var visitedParams = /* @__PURE__ */ new WeakSet()
    function wrapHandleRequest(original) {
      return function wrappedHandleRequest(req, res, next) {
        if (routerParamStartCh.hasSubscribers && !visitedParams.has(req.params) && Object.keys(req.params).length) {
          visitedParams.add(req.params)
          const abortController = new AbortController()
          routerParamStartCh.publish({
            req,
            res,
            params: req?.params,
            abortController,
          })
          if (abortController.signal.aborted) return
        }
        return original.apply(this, arguments)
      }
    }
    addHook(
      {
        name: 'router',
        file: 'lib/layer.js',
        versions: ['>=2'],
      },
      (Layer) => {
        shimmer.wrap(Layer.prototype, 'handleRequest', wrapHandleRequest)
        return Layer
      }
    )
    function wrapParam(original) {
      return function wrappedProcessParams() {
        arguments[1] = shimmer.wrapFunction(arguments[1], (originalFn) => {
          return function wrappedFn(req, res) {
            if (routerParamStartCh.hasSubscribers && Object.keys(req.params).length && !visitedParams.has(req.params)) {
              visitedParams.add(req.params)
              const abortController = new AbortController()
              routerParamStartCh.publish({
                req,
                res,
                params: req?.params,
                abortController,
              })
              if (abortController.signal.aborted) return
            }
            return originalFn.apply(this, arguments)
          }
        })
        return original.apply(this, arguments)
      }
    }
    addHook(
      {
        name: 'router',
        versions: ['>=2'],
      },
      (router) => {
        shimmer.wrap(router.prototype, 'param', wrapParam)
        return router
      }
    )
    module2.exports = { createWrapRouterMethod }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/express.js
var require_express = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/express.js'() {
    'use strict'
    var { createWrapRouterMethod } = require_router()
    var shimmer = require_datadog_shimmer()
    var { addHook, channel, tracingChannel } = require_instrument()
    var {
      setRouterMountPath,
      markAppMounted,
      normalizeRoutePaths,
      wrapRouteMethodsAndPublish,
      extractMountPaths,
      hasRouterCycle,
      collectRoutesFromRouter,
    } = require_router_helper()
    var handleChannel = channel('apm:express:request:handle')
    var routeAddedChannel = channel('apm:express:route:added')
    function wrapHandle(handle) {
      return function handleWithTrace(req, res) {
        if (handleChannel.hasSubscribers) {
          handleChannel.publish({ req })
        }
        return handle.apply(this, arguments)
      }
    }
    var wrapRouterMethod = createWrapRouterMethod('express')
    var responseJsonChannel = channel('datadog:express:response:json:start')
    function wrapResponseJson(json) {
      return function wrappedJson(obj) {
        if (responseJsonChannel.hasSubscribers) {
          if (arguments.length === 2 && typeof arguments[1] !== 'number') {
            obj = arguments[1]
          }
          responseJsonChannel.publish({ req: this.req, res: this, body: obj })
        }
        return json.apply(this, arguments)
      }
    }
    var responseRenderChannel = tracingChannel('datadog:express:response:render')
    function wrapResponseRender(render) {
      return function wrappedRender(view, options, callback) {
        if (!responseRenderChannel.start.hasSubscribers) {
          return render.apply(this, arguments)
        }
        const abortController = new AbortController()
        return responseRenderChannel.traceSync(
          function () {
            if (abortController.signal.aborted) {
              const error = abortController.signal.reason || new Error('Aborted')
              throw error
            }
            return render.apply(this, arguments)
          },
          {
            req: this.req,
            view,
            options,
            abortController,
          },
          this,
          ...arguments
        )
      }
    }
    function wrapAppAll(all) {
      return function wrappedAll(...args) {
        if (!routeAddedChannel.hasSubscribers) return all.apply(this, args)
        const path = args[0]
        const paths = normalizeRoutePaths(path)
        for (const p of paths) {
          routeAddedChannel.publish({ method: '*', path: p })
        }
        return all.apply(this, args)
      }
    }
    function wrapAppRoute(route) {
      return function wrappedRoute(...args) {
        const routeObj = route.apply(this, args)
        if (!routeAddedChannel.hasSubscribers) return routeObj
        const path = args[0]
        const paths = normalizeRoutePaths(path)
        if (!paths.length) return routeObj
        wrapRouteMethodsAndPublish(routeObj, paths, ({ method, path: path2 }) => {
          routeAddedChannel.publish({ method, path: path2 })
        })
        return routeObj
      }
    }
    function wrapAppUse(use) {
      return function wrappedUse(...args) {
        if (!args.length) return use.call(this)
        const { mountPaths, startIdx } = extractMountPaths(args[0])
        const pathsToRegister = mountPaths.length ? mountPaths : ['/']
        for (let i = startIdx; i < args.length; i++) {
          const router = args[i]
          if (!router || typeof router !== 'function') continue
          markAppMounted(router)
          let skipCollection = false
          if (routeAddedChannel.hasSubscribers) {
            skipCollection = hasRouterCycle(router)
          }
          for (const mountPath of pathsToRegister) {
            const normalizedMountPath = mountPath || '/'
            setRouterMountPath(router, normalizedMountPath)
            if (!skipCollection && routeAddedChannel.hasSubscribers) {
              collectRoutesFromRouter(router, normalizedMountPath)
            }
          }
        }
        return use.apply(this, args)
      }
    }
    addHook({ name: 'express', versions: ['>=4'], file: ['lib/express.js'] }, (express) => {
      shimmer.wrap(express.application, 'handle', wrapHandle)
      shimmer.wrap(express.application, 'all', wrapAppAll)
      shimmer.wrap(express.application, 'route', wrapAppRoute)
      shimmer.wrap(express.application, 'use', wrapAppUse)
      shimmer.wrap(express.response, 'json', wrapResponseJson)
      shimmer.wrap(express.response, 'jsonp', wrapResponseJson)
      shimmer.wrap(express.response, 'render', wrapResponseRender)
      return express
    })
    addHook({ name: 'express', versions: ['4'], file: 'lib/express.js' }, (express) => {
      shimmer.wrap(express.Router, 'use', wrapRouterMethod)
      shimmer.wrap(express.Router, 'route', wrapRouterMethod)
      return express
    })
    var queryParserReadCh = channel('datadog:query:read:finish')
    function publishQueryParsedAndNext(req, res, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function () {
            if (queryParserReadCh.hasSubscribers && req) {
              const abortController = new AbortController()
              const query = req.query
              queryParserReadCh.publish({ req, res, query, abortController })
              if (abortController.signal.aborted) return
            }
            return next2.apply(this, arguments)
          }
      )
    }
    addHook(
      {
        name: 'express',
        versions: ['4'],
        file: 'lib/middleware/query.js',
      },
      (query) => {
        return shimmer.wrapFunction(
          query,
          (query2) =>
            function () {
              const queryMiddleware = query2.apply(this, arguments)
              return shimmer.wrapFunction(
                queryMiddleware,
                (queryMiddleware2) =>
                  function (req, res, next) {
                    arguments[2] = publishQueryParsedAndNext(req, res, next)
                    return queryMiddleware2.apply(this, arguments)
                  }
              )
            }
        )
      }
    )
    var processParamsStartCh = channel('datadog:express:process_params:start')
    function wrapProcessParamsMethod(requestPositionInArguments) {
      return function wrapProcessParams(original) {
        return function wrappedProcessParams() {
          if (processParamsStartCh.hasSubscribers) {
            const req = arguments[requestPositionInArguments]
            const abortController = new AbortController()
            processParamsStartCh.publish({
              req,
              res: req?.res,
              abortController,
              params: req?.params,
            })
            if (abortController.signal.aborted) return
          }
          return original.apply(this, arguments)
        }
      }
    }
    addHook({ name: 'express', versions: ['>=4.0.0 <4.3.0'], file: ['lib/express.js'] }, (express) => {
      shimmer.wrap(express.Router, 'process_params', wrapProcessParamsMethod(1))
      return express
    })
    addHook({ name: 'express', versions: ['>=4.3.0 <5.0.0'], file: ['lib/express.js'] }, (express) => {
      shimmer.wrap(express.Router, 'process_params', wrapProcessParamsMethod(2))
      return express
    })
    var queryReadCh = channel('datadog:express:query:finish')
    addHook({ name: 'express', file: ['lib/request.js'], versions: ['>=5.0.0'] }, (request) => {
      shimmer.wrap(request, 'query', function (originalGet) {
        return function wrappedGet() {
          const query = originalGet.call(this)
          if (queryReadCh.hasSubscribers && query) {
            queryReadCh.publish({ query })
          }
          return query
        }
      })
      return request
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/express-mongo-sanitize.js
var require_express_mongo_sanitize = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/express-mongo-sanitize.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var sanitizeMethodFinished = channel('datadog:express-mongo-sanitize:sanitize:finish')
    var sanitizeMiddlewareFinished = channel('datadog:express-mongo-sanitize:filter:finish')
    var propertiesToSanitize = ['body', 'params', 'headers', 'query']
    addHook({ name: 'express-mongo-sanitize', versions: ['>=1.0.0'] }, (expressMongoSanitize) => {
      shimmer.wrap(
        expressMongoSanitize,
        'sanitize',
        (sanitize) =>
          function () {
            const sanitizedObject = sanitize.apply(this, arguments)
            if (sanitizeMethodFinished.hasSubscribers) {
              sanitizeMethodFinished.publish({ sanitizedObject })
            }
            return sanitizedObject
          }
      )
      return shimmer.wrapFunction(
        expressMongoSanitize,
        (expressMongoSanitize2) =>
          function () {
            const middleware = expressMongoSanitize2.apply(this, arguments)
            return shimmer.wrapFunction(
              middleware,
              (middleware2) =>
                function (req, res, next) {
                  if (!sanitizeMiddlewareFinished.hasSubscribers) {
                    return middleware2.apply(this, arguments)
                  }
                  const wrappedNext = shimmer.wrapFunction(
                    next,
                    (next2) =>
                      function () {
                        sanitizeMiddlewareFinished.publish({
                          sanitizedProperties: propertiesToSanitize,
                          req,
                        })
                        return next2.apply(this, arguments)
                      }
                  )
                  return middleware2.call(this, req, res, wrappedNext)
                }
            )
          }
      )
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/express-session.js
var require_express_session = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/express-session.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook } = require_instrument()
    var sessionMiddlewareFinishCh = channel('datadog:express-session:middleware:finish')
    function wrapSessionMiddleware(sessionMiddleware) {
      return function wrappedSessionMiddleware(req, res, next) {
        shimmer.wrap(arguments, 2, function wrapNext(next2) {
          return function wrappedNext() {
            if (sessionMiddlewareFinishCh.hasSubscribers) {
              const abortController = new AbortController()
              sessionMiddlewareFinishCh.publish({ req, res, sessionId: req.sessionID, abortController })
              if (abortController.signal.aborted) return
            }
            return next2.apply(this, arguments)
          }
        })
        return sessionMiddleware.apply(this, arguments)
      }
    }
    function wrapSession(session) {
      return function wrappedSession() {
        const sessionMiddleware = session.apply(this, arguments)
        return shimmer.wrapFunction(sessionMiddleware, wrapSessionMiddleware)
      }
    }
    addHook(
      {
        name: 'express-session',
        versions: ['>=1.5.0'],
      },
      (session) => {
        return shimmer.wrapFunction(session, wrapSession)
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/fastify.js
var require_fastify = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/fastify.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var errorChannel = channel('apm:fastify:middleware:error')
    var handleChannel = channel('apm:fastify:request:handle')
    var routeAddedChannel = channel('apm:fastify:route:added')
    var bodyParserReadCh = channel('datadog:fastify:body-parser:finish')
    var queryParamsReadCh = channel('datadog:fastify:query-params:finish')
    var cookieParserReadCh = channel('datadog:fastify-cookie:read:finish')
    var responsePayloadReadCh = channel('datadog:fastify:response:finish')
    var pathParamsReadCh = channel('datadog:fastify:path-params:finish')
    var finishSetHeaderCh = channel('datadog:fastify:set-header:finish')
    var preParsingCh = channel('datadog:fastify:pre-parsing:start')
    var preValidationCh = channel('datadog:fastify:pre-validation:start')
    var callbackFinishCh = channel('datadog:fastify:callback:execute')
    var parsingContexts = /* @__PURE__ */ new WeakMap()
    var cookiesPublished = /* @__PURE__ */ new WeakSet()
    var bodyPublished = /* @__PURE__ */ new WeakSet()
    function wrapFastify(fastify, hasParsingEvents) {
      if (typeof fastify !== 'function') return fastify
      return function fastifyWithTrace() {
        const app = fastify.apply(this, arguments)
        if (!app || typeof app.addHook !== 'function') return app
        app.addHook('onRoute', onRoute)
        app.addHook('onRequest', onRequest)
        app.addHook('preHandler', preHandler)
        if (hasParsingEvents) {
          app.addHook('preParsing', preParsing)
          app.addHook('preValidation', preValidation)
        } else {
          app.addHook('onRequest', preParsing)
          app.addHook('preHandler', preValidation)
        }
        app.addHook = wrapAddHook(app.addHook)
        return app
      }
    }
    function wrapAddHook(addHook2) {
      return shimmer.wrapFunction(
        addHook2,
        (addHook3) =>
          function addHookWithTrace(name, fn) {
            fn = arguments[arguments.length - 1]
            if (typeof fn !== 'function') return addHook3.apply(this, arguments)
            arguments[arguments.length - 1] = shimmer.wrapFunction(
              fn,
              (fn2) =>
                function (request, reply, done) {
                  const req = getReq(request)
                  const ctx = { req }
                  try {
                    const doneCallback = arguments[arguments.length - 1]
                    if (typeof doneCallback === 'function') {
                      arguments[arguments.length - 1] = function (err) {
                        ctx.error = err
                        publishError(ctx)
                        const hasCookies = request.cookies && Object.keys(request.cookies).length > 0
                        if (cookieParserReadCh.hasSubscribers && hasCookies && !cookiesPublished.has(req)) {
                          ctx.res = getRes(reply)
                          ctx.abortController = new AbortController()
                          ctx.cookies = request.cookies
                          cookieParserReadCh.publish(ctx)
                          cookiesPublished.add(req)
                          if (ctx.abortController.signal.aborted) return
                        }
                        if (name === 'onRequest' || name === 'preParsing') {
                          parsingContexts.set(req, ctx)
                          return callbackFinishCh.runStores(ctx, () => {
                            return doneCallback.apply(this, arguments)
                          })
                        }
                        return doneCallback.apply(this, arguments)
                      }
                      return fn2.apply(this, arguments)
                    }
                    const promise = fn2.apply(this, arguments)
                    if (promise && typeof promise.catch === 'function') {
                      return promise.catch((err) => {
                        ctx.error = err
                        return publishError(ctx)
                      })
                    }
                    return promise
                  } catch (e) {
                    ctx.error = e
                    throw publishError(ctx)
                  }
                }
            )
            return addHook3.apply(this, arguments)
          }
      )
    }
    function onRequest(request, reply, done) {
      if (typeof done !== 'function') return
      const req = getReq(request)
      const res = getRes(reply)
      const routeConfig = getRouteConfig(request)
      const ctx = { req, res, routeConfig }
      handleChannel.publish(ctx)
      return done()
    }
    function preHandler(request, reply, done) {
      if (typeof done !== 'function') return
      if (!reply || typeof reply.send !== 'function') return done()
      const req = getReq(request)
      const res = getRes(reply)
      const ctx = { req, res }
      const hasBody = request.body && Object.keys(request.body).length > 0
      if (bodyParserReadCh.hasSubscribers && hasBody && !bodyPublished.has(req)) {
        ctx.abortController = new AbortController()
        ctx.body = request.body
        bodyParserReadCh.publish(ctx)
        bodyPublished.add(req)
        if (ctx.abortController.signal.aborted) return
      }
      reply.send = wrapSend(reply.send, req)
      done()
    }
    function preValidation(request, reply, done) {
      const req = getReq(request)
      const res = getRes(reply)
      const ctx = parsingContexts.get(req)
      ctx.res = res
      const processInContext = () => {
        let abortController
        if (queryParamsReadCh.hasSubscribers && request.query) {
          abortController ??= new AbortController()
          ctx.abortController = abortController
          ctx.query = request.query
          queryParamsReadCh.publish(ctx)
          if (abortController.signal.aborted) return
        }
        if (bodyParserReadCh.hasSubscribers && request.body && !bodyPublished.has(req)) {
          abortController ??= new AbortController()
          ctx.abortController = abortController
          ctx.body = request.body
          bodyParserReadCh.publish(ctx)
          bodyPublished.add(req)
          if (abortController.signal.aborted) return
        }
        if (pathParamsReadCh.hasSubscribers && request.params) {
          abortController ??= new AbortController()
          ctx.abortController = abortController
          ctx.params = request.params
          pathParamsReadCh.publish(ctx)
          if (abortController.signal.aborted) return
        }
        done()
      }
      if (!ctx) return processInContext()
      preValidationCh.runStores(ctx, processInContext)
    }
    function preParsing(request, reply, payload, done) {
      if (typeof done !== 'function') {
        done = payload
      }
      const req = getReq(request)
      const ctx = { req }
      parsingContexts.set(req, ctx)
      preParsingCh.runStores(ctx, () => done())
    }
    function wrapSend(send, req) {
      return function sendWithTrace(payload) {
        const ctx = { req }
        if (payload instanceof Error) {
          ctx.error = payload
          errorChannel.publish(ctx)
        } else if (canPublishResponsePayload(payload)) {
          const res = getRes(this)
          ctx.res = res
          ctx.body = payload
          responsePayloadReadCh.publish(ctx)
        }
        return send.apply(this, arguments)
      }
    }
    function getReq(request) {
      return request && (request.raw || request.req || request)
    }
    function getRes(reply) {
      return reply && (reply.raw || reply.res || reply)
    }
    function getRouteConfig(request) {
      return request?.routeOptions?.config
    }
    function publishError(ctx) {
      if (ctx.error) {
        errorChannel.publish(ctx)
      }
      return ctx.error
    }
    function onRoute(routeOptions) {
      const ctx = { routeOptions, onRoute }
      routeAddedChannel.publish(ctx)
    }
    function canPublishResponsePayload(payload) {
      return (
        responsePayloadReadCh.hasSubscribers &&
        payload &&
        typeof payload === 'object' &&
        typeof payload.pipe !== 'function' && // Node streams
        typeof payload.body?.pipe !== 'function' && // Response with body stream
        !Buffer.isBuffer(payload) && // Buffer
        !(payload instanceof ArrayBuffer) && // ArrayBuffer
        !ArrayBuffer.isView(payload)
      )
    }
    addHook({ name: 'fastify', versions: ['>=3'] }, (fastify) => {
      const wrapped = shimmer.wrapFunction(fastify, (fastify2) => wrapFastify(fastify2, true))
      wrapped.fastify = wrapped
      wrapped.default = wrapped
      return wrapped
    })
    addHook({ name: 'fastify', versions: ['2'] }, (fastify) => {
      return shimmer.wrapFunction(fastify, (fastify2) => wrapFastify(fastify2, true))
    })
    addHook({ name: 'fastify', versions: ['1'] }, (fastify) => {
      return shimmer.wrapFunction(fastify, (fastify2) => wrapFastify(fastify2, false))
    })
    function wrapReplyHeader(Reply) {
      shimmer.wrap(
        Reply.prototype,
        'header',
        (header) =>
          function (key, value) {
            const result = header.apply(this, arguments)
            if (finishSetHeaderCh.hasSubscribers && key && value) {
              const ctx = { name: key, value, res: getRes(this) }
              finishSetHeaderCh.publish(ctx)
            }
            return result
          }
      )
      return Reply
    }
    addHook({ name: 'fastify', file: 'lib/reply.js', versions: ['1', '2', '>=3'] }, wrapReplyHeader)
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/find-my-way.js
var require_find_my_way = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/find-my-way.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var routeChannel = channel('apm:find-my-way:request:route')
    function wrapOn(on) {
      return function onWithTrace(method, path, opts) {
        const index = typeof opts === 'function' ? 2 : 3
        const handler = arguments[index]
        if (typeof handler === 'function') {
          const wrapper = shimmer.wrapFunction(
            handler,
            (handler2) =>
              function (req) {
                routeChannel.publish({ req, route: path })
                return handler2.apply(this, arguments)
              }
          )
          arguments[index] = wrapper
        }
        return on.apply(this, arguments)
      }
    }
    addHook({ name: 'find-my-way', versions: ['>=1'] }, (Router) => {
      shimmer.wrap(Router.prototype, 'on', wrapOn)
      return Router
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/fs.js
var require_fs = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/fs.js'() {
    'use strict'
    var { errorMonitor } = require('events')
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startChannel = channel('apm:fs:operation:start')
    var finishChannel = channel('apm:fs:operation:finish')
    var errorChannel = channel('apm:fs:operation:error')
    var ddFhSym = /* @__PURE__ */ Symbol('ddFileHandle')
    var kHandle
    var kDirReadPromisified
    var kDirClosePromisified
    var paramsByMethod = {
      access: ['path', 'mode'],
      appendFile: ['path', 'data', 'options'],
      chmod: ['path', 'mode'],
      chown: ['path', 'uid', 'gid'],
      close: ['fd'],
      copyFile: ['src', 'dest', 'mode'],
      cp: ['src', 'dest', 'options'],
      exists: ['path'],
      fchmod: ['fd', 'mode'],
      fchown: ['fd', 'uid', 'gid'],
      fdatasync: ['fd'],
      fstat: ['fd', 'options'],
      fsync: ['fd'],
      ftruncate: ['fd', 'len'],
      futimes: ['fd', 'atime', 'mtime'],
      lchmod: ['path', 'mode'],
      lchown: ['path', 'uid', 'gid'],
      link: ['existingPath', 'newPath'],
      lstat: ['path', 'options'],
      lutimes: ['path', 'atime', 'mtime'],
      mkdir: ['path', 'options'],
      mkdtemp: ['prefix', 'options'],
      open: ['path', 'flag', 'mode'],
      opendir: ['path', 'options'],
      read: ['fd'],
      readdir: ['path', 'options'],
      readFile: ['path', 'options'],
      readlink: ['path', 'options'],
      readv: ['fd'],
      realpath: ['path', 'options'],
      rename: ['oldPath', 'newPath'],
      rmdir: ['path', 'options'],
      rm: ['path', 'options'],
      stat: ['path', 'options'],
      symlink: ['target', 'path', 'type'],
      truncate: ['path', 'len'],
      unlink: ['path'],
      utimes: ['path', 'atime', 'mtime'],
      write: ['fd'],
      writeFile: ['file', 'data', 'options'],
      writev: ['fd'],
    }
    var watchMethods = {
      unwatchFile: ['path', 'listener'],
      watch: ['path', 'options', 'listener'],
      watchFile: ['path', 'options', 'listener'],
    }
    var paramsByFileHandleMethods = {
      appendFile: ['data', 'options'],
      chmod: ['mode'],
      chown: ['uid', 'gid'],
      close: [],
      createReadStream: ['options'],
      createWriteStream: ['options'],
      datasync: [],
      read: ['buffer', 'offset', 'length', 'position'],
      readableWebStream: [],
      readFile: ['options'],
      readLines: ['options'],
      readv: ['buffers', 'position'],
      stat: ['options'],
      sync: [],
      truncate: ['len'],
      utimes: ['atime', 'mtime'],
      write: ['buffer', 'offset', 'length', 'position'],
      writeFile: ['data', 'options'],
      writev: ['buffers', 'position'],
    }
    var names = ['fs', 'node:fs']
    names.forEach((name) => {
      addHook({ name }, (fs) => {
        const asyncMethods = Object.keys(paramsByMethod)
        const syncMethods = asyncMethods.map((name2) => `${name2}Sync`)
        massWrap(fs, asyncMethods, createWrapFunction())
        massWrap(fs, syncMethods, createWrapFunction())
        massWrap(fs.promises, asyncMethods, createWrapFunction('promises.'))
        wrap(fs.realpath, 'native', createWrapFunction('', 'realpath.native'))
        wrap(fs.realpathSync, 'native', createWrapFunction('', 'realpath.native'))
        wrap(fs.promises.realpath, 'native', createWrapFunction('', 'realpath.native'))
        wrap(fs, 'createReadStream', wrapCreateStream)
        wrap(fs, 'createWriteStream', wrapCreateStream)
        if (fs.Dir) {
          wrap(fs.Dir.prototype, 'close', createWrapFunction('dir.'))
          wrap(fs.Dir.prototype, 'closeSync', createWrapFunction('dir.'))
          wrap(fs.Dir.prototype, 'read', createWrapFunction('dir.'))
          wrap(fs.Dir.prototype, 'readSync', createWrapFunction('dir.'))
          wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator())
        }
        wrap(fs, 'unwatchFile', createWatchWrapFunction())
        wrap(fs, 'watch', createWatchWrapFunction())
        wrap(fs, 'watchFile', createWatchWrapFunction())
        return fs
      })
    })
    function isFirstMethodReturningFileHandle(original) {
      return !kHandle && original.name === 'open'
    }
    function wrapFileHandle(fh) {
      const fileHandlePrototype = getFileHandlePrototype(fh)
      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle)
      if (!desc || !desc.get) {
        Reflect.defineProperty(fileHandlePrototype, kHandle, {
          get() {
            return this[ddFhSym]
          },
          set(h) {
            this[ddFhSym] = h
            wrap(this, 'close', createWrapFunction('filehandle.'))
          },
          configurable: true,
        })
      }
      for (const name of Reflect.ownKeys(fileHandlePrototype)) {
        if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {
          continue
        }
        wrap(fileHandlePrototype, name, createWrapFunction('filehandle.'))
      }
    }
    function getFileHandlePrototype(fh) {
      if (!kHandle) {
        kHandle = Reflect.ownKeys(fh).find((key) => typeof key === 'symbol' && key.toString().includes('kHandle'))
      }
      return Object.getPrototypeOf(fh)
    }
    function getSymbolName(sym) {
      return sym.description || sym.toString()
    }
    function initDirAsyncIteratorProperties(iterator) {
      const keys = Reflect.ownKeys(iterator)
      for (const key of keys) {
        if (kDirReadPromisified && kDirClosePromisified) break
        if (typeof key !== 'symbol') continue
        if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {
          kDirReadPromisified = key
        }
        if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {
          kDirClosePromisified = key
        }
      }
    }
    function createWrapDirAsyncIterator() {
      return function wrapDirAsyncIterator(asyncIterator) {
        return function wrappedAsyncIterator() {
          if (!kDirReadPromisified || !kDirClosePromisified) {
            initDirAsyncIteratorProperties(this)
          }
          wrap(this, kDirReadPromisified, createWrapFunction('dir.', 'read'))
          wrap(this, kDirClosePromisified, createWrapFunction('dir.', 'close'))
          return asyncIterator.apply(this, arguments)
        }
      }
    }
    function wrapCreateStream(original) {
      const classes = {
        createReadStream: 'ReadStream',
        createWriteStream: 'WriteStream',
      }
      const name = classes[original.name]
      return function (path, options) {
        if (!startChannel.hasSubscribers) return original.apply(this, arguments)
        const ctx = getMessage(name, ['path', 'options'], arguments)
        return startChannel.runStores(ctx, () => {
          try {
            const stream = original.apply(this, arguments)
            const onError = (error) => {
              ctx.error = error
              errorChannel.publish(ctx)
              onFinish()
            }
            const onFinish = () => {
              finishChannel.runStores(ctx, () => {})
              stream.removeListener('close', onFinish)
              stream.removeListener('end', onFinish)
              stream.removeListener('finish', onFinish)
              stream.removeListener(errorMonitor, onError)
            }
            stream.once('close', onFinish)
            stream.once('end', onFinish)
            stream.once('finish', onFinish)
            stream.once(errorMonitor, onError)
            return stream
          } catch (error) {
            ctx.error = error
            errorChannel.publish(ctx)
            finishChannel.runStores(ctx, () => {})
          }
        })
      }
    }
    function getMethodParamsRelationByPrefix(prefix) {
      if (prefix === 'filehandle.') {
        return paramsByFileHandleMethods
      }
      return paramsByMethod
    }
    function createWatchWrapFunction(override = '') {
      return function wrapFunction(original) {
        const name = override || original.name
        const method = name
        const operation = name
        return function () {
          if (!startChannel.hasSubscribers) return original.apply(this, arguments)
          const ctx = getMessage(method, watchMethods[operation], arguments, this)
          return startChannel.runStores(ctx, () => {
            try {
              const result = original.apply(this, arguments)
              finishChannel.runStores(ctx, () => {})
              return result
            } catch (error) {
              ctx.error = error
              errorChannel.publish(ctx)
              finishChannel.runStores(ctx, () => {})
              throw error
            }
          })
        }
      }
    }
    function createWrapFunction(prefix = '', override = '') {
      return function wrapFunction(original) {
        const name = override || original.name
        const method = `${prefix}${name}`
        const operation = name.match(/^(.+?)(Sync)?(\.native)?$/)[1]
        return function () {
          if (!startChannel.hasSubscribers) return original.apply(this, arguments)
          const lastIndex = arguments.length - 1
          const cb = typeof arguments[lastIndex] === 'function' && arguments[lastIndex]
          const params = getMethodParamsRelationByPrefix(prefix)[operation]
          const abortController = new AbortController()
          const ctx = { ...getMessage(method, params, arguments, this), abortController }
          const finish = function (error, cb2 = () => {}) {
            if (error !== null && typeof error === 'object') {
              ctx.error = error
              errorChannel.publish(ctx)
            }
            return finishChannel.runStores(ctx, cb2)
          }
          if (cb) {
            arguments[lastIndex] = shimmer.wrapFunction(
              cb,
              (cb2) =>
                function (e) {
                  return finish(e, () => cb2.apply(this, arguments))
                }
            )
          }
          return startChannel.runStores(ctx, () => {
            if (abortController.signal.aborted) {
              const error = abortController.signal.reason || new Error('Aborted')
              if (prefix === 'promises.') {
                finish(error)
                return Promise.reject(error)
              } else if (name.includes('Sync') || !cb) {
                finish(error)
                throw error
              } else if (cb) {
                arguments[lastIndex](error)
                return
              }
            }
            try {
              const result = original.apply(this, arguments)
              if (cb) return result
              if (result && typeof result.then === 'function') {
                return result.then(
                  (value) => {
                    if (isFirstMethodReturningFileHandle(original)) {
                      wrapFileHandle(value)
                    }
                    finishChannel.runStores(ctx, () => {})
                    return value
                  },
                  (error) => {
                    ctx.error = error
                    errorChannel.publish(ctx)
                    finishChannel.runStores(ctx, () => {})
                    throw error
                  }
                )
              }
              finishChannel.runStores(ctx, () => {})
              return result
            } catch (error) {
              ctx.error = error
              errorChannel.publish(ctx)
              finishChannel.runStores(ctx, () => {})
              throw error
            }
          })
        }
      }
    }
    function getMessage(operation, params, args, self2) {
      const metadata = {}
      if (params) {
        for (let i = 0; i < params.length; i++) {
          if (!params[i] || typeof args[i] === 'function') continue
          metadata[params[i]] = args[i]
        }
      }
      if (self2) {
        if (self2.path) {
          metadata.path = self2.path
        }
        if (self2.fd) {
          metadata.fd = self2.fd
        }
      }
      return { operation, ...metadata }
    }
    function massWrap(target, methods, wrapper) {
      for (const method of methods) {
        wrap(target, method, wrapper)
      }
    }
    function wrap(target, method, wrapper) {
      try {
        shimmer.wrap(target, method, wrapper)
      } catch {}
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/generic-pool.js
var require_generic_pool = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/generic-pool.js'() {
    'use strict'
    var { addHook, AsyncResource } = require_instrument()
    var shimmer = require_datadog_shimmer()
    function createWrapAcquire() {
      return function wrapAcquire(acquire) {
        return function acquireWithTrace(callback, priority) {
          if (typeof callback === 'function') {
            arguments[0] = AsyncResource.bind(callback)
          }
          return acquire.apply(this, arguments)
        }
      }
    }
    function createWrapPool() {
      return function wrapPool(Pool) {
        if (typeof Pool !== 'function') return Pool
        return function PoolWithTrace(factory) {
          const pool = Pool.apply(this, arguments)
          if (pool && typeof pool.acquire === 'function') {
            shimmer.wrap(pool, 'acquire', createWrapAcquire())
          }
          return pool
        }
      }
    }
    addHook(
      {
        name: 'generic-pool',
        versions: ['^2.4'],
      },
      (genericPool) => {
        shimmer.wrap(genericPool.Pool.prototype, 'acquire', createWrapAcquire())
        return genericPool
      }
    )
    addHook(
      {
        name: 'generic-pool',
        versions: ['2 - 2.3'],
      },
      (genericPool) => {
        shimmer.wrap(genericPool, 'Pool', createWrapPool())
        return genericPool
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/handlebars.js
var require_handlebars = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/handlebars.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook } = require_instrument()
    var handlebarsCompileCh = channel('datadog:handlebars:compile:start')
    var handlebarsRegisterPartialCh = channel('datadog:handlebars:register-partial:start')
    function wrapCompile(compile) {
      return function wrappedCompile(source) {
        if (handlebarsCompileCh.hasSubscribers) {
          handlebarsCompileCh.publish({ source })
        }
        return compile.apply(this, arguments)
      }
    }
    function wrapRegisterPartial(registerPartial) {
      return function wrappedRegisterPartial(name, partial) {
        if (handlebarsRegisterPartialCh.hasSubscribers) {
          handlebarsRegisterPartialCh.publish({ partial })
        }
        return registerPartial.apply(this, arguments)
      }
    }
    addHook(
      { name: 'handlebars', file: 'dist/cjs/handlebars/compiler/compiler.js', versions: ['>=4.0.0'] },
      (compiler) => {
        shimmer.wrap(compiler, 'compile', wrapCompile)
        shimmer.wrap(compiler, 'precompile', wrapCompile)
        return compiler
      }
    )
    addHook({ name: 'handlebars', file: 'dist/cjs/handlebars/base.js', versions: ['>=4.0.0'] }, (base) => {
      shimmer.wrap(base.HandlebarsEnvironment.prototype, 'registerPartial', wrapRegisterPartial)
      return base
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/hono.js
var require_hono = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/hono.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var routeChannel = channel('apm:hono:request:route')
    var handleChannel = channel('apm:hono:request:handle')
    var errorChannel = channel('apm:hono:request:error')
    function wrapFetch(fetch2) {
      return function (request, env, executionCtx) {
        handleChannel.publish({ req: env.incoming })
        return fetch2.apply(this, arguments)
      }
    }
    function onErrorFn(error, _context_) {
      throw error
    }
    function wrapCompose(compose) {
      return function (middlewares, onError, onNotFound) {
        onError ??= onErrorFn
        const instrumentedOnError = (...args) => {
          const [error, context] = args
          const req = context.env.incoming
          errorChannel.publish({ req, error })
          return onError(...args)
        }
        const instrumentedMiddlewares = middlewares.map((h) => {
          const [[fn, meta], params] = h
          const instrumentedFn = (...args) => {
            const context = args[0]
            routeChannel.publish({
              req: context.env.incoming,
              route: meta?.path,
            })
            return fn(...args)
          }
          return [[instrumentedFn, meta], params]
        })
        return compose.call(this, instrumentedMiddlewares, instrumentedOnError, onNotFound)
      }
    }
    addHook(
      {
        name: 'hono',
        versions: ['>=4'],
        file: 'dist/hono.js',
      },
      (hono) => {
        class Hono extends hono.Hono {
          constructor(...args) {
            super(...args)
            shimmer.wrap(this, 'fetch', wrapFetch)
          }
        }
        hono.Hono = Hono
        return hono
      }
    )
    addHook(
      {
        name: 'hono',
        versions: ['>=4'],
        file: 'dist/cjs/hono.js',
      },
      (hono) => {
        class Hono extends hono.Hono {
          constructor(...args) {
            super(...args)
            shimmer.wrap(this, 'fetch', wrapFetch)
          }
        }
        return Object.create(hono, {
          Hono: {
            get() {
              return Hono
            },
            enumerable: true,
          },
        })
      }
    )
    addHook(
      {
        name: 'hono',
        versions: ['>=4'],
        file: 'dist/cjs/compose.js',
      },
      (Compose) => {
        return shimmer.wrap(Compose, 'compose', wrapCompose, { replaceGetter: true })
      }
    )
    addHook(
      {
        name: 'hono',
        versions: ['>=4'],
        file: 'dist/compose.js',
      },
      (Compose) => {
        return shimmer.wrap(Compose, 'compose', wrapCompose)
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js
var require_client2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js'() {
    'use strict'
    var url = require('url')
    var { errorMonitor } = require('events')
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var log = require_log2()
    var startChannel = channel('apm:http:client:request:start')
    var finishChannel = channel('apm:http:client:request:finish')
    var endChannel = channel('apm:http:client:request:end')
    var asyncStartChannel = channel('apm:http:client:request:asyncStart')
    var errorChannel = channel('apm:http:client:request:error')
    var names = ['http', 'https', 'node:http', 'node:https']
    addHook({ name: names }, hookFn)
    function hookFn(http) {
      patch(http, 'request')
      patch(http, 'get')
      return http
    }
    function combineOptions(inputURL, inputOptions) {
      return inputOptions !== null && typeof inputOptions === 'object'
        ? Object.assign(inputURL || {}, inputOptions)
        : inputURL
    }
    function normalizeHeaders(options) {
      options.headers ??= {}
    }
    function normalizeCallback(inputOptions, callback, inputURL) {
      return typeof inputOptions === 'function' ? [inputOptions, inputURL || {}] : [callback, inputOptions]
    }
    function patch(http, methodName) {
      shimmer.wrap(http, methodName, instrumentRequest)
      function instrumentRequest(request) {
        return function () {
          if (!startChannel.hasSubscribers) {
            return request.apply(this, arguments)
          }
          let args
          try {
            args = normalizeArgs.apply(null, arguments)
          } catch (e) {
            log.error('Error normalising http req arguments', e)
            return request.apply(this, arguments)
          }
          const abortController = new AbortController()
          const ctx = { args, http, abortController }
          return startChannel.runStores(ctx, () => {
            let finished = false
            let callback = args.callback
            if (callback) {
              callback = shimmer.wrapFunction(
                args.callback,
                (cb) =>
                  function () {
                    return asyncStartChannel.runStores(ctx, () => {
                      return cb.apply(this, arguments)
                    })
                  }
              )
            }
            const options = args.options
            const finish = () => {
              if (!finished) {
                finished = true
                finishChannel.publish(ctx)
              }
            }
            try {
              const req = request.call(this, options, callback)
              const emit = req.emit
              const setTimeout2 = req.setTimeout
              ctx.req = req
              let customRequestTimeout = false
              req.setTimeout = function () {
                customRequestTimeout = true
                return setTimeout2.apply(this, arguments)
              }
              req.emit = function (eventName, arg) {
                switch (eventName) {
                  case 'response': {
                    const res = arg
                    ctx.res = res
                    res.on('end', finish)
                    res.on(errorMonitor, finish)
                    break
                  }
                  case 'connect':
                  case 'upgrade':
                    ctx.res = arg
                    finish()
                    break
                  case 'error':
                  case 'timeout':
                    ctx.error = arg
                    ctx.customRequestTimeout = customRequestTimeout
                    errorChannel.publish(ctx)
                  case 'abort':
                  // deprecated and replaced by `close` in node 17
                  case 'close':
                    finish()
                }
                return emit.apply(this, arguments)
              }
              if (abortController.signal.aborted) {
                req.destroy(abortController.signal.reason || new Error('Aborted'))
              }
              return req
            } catch (e) {
              ctx.error = e
              errorChannel.publish(ctx)
              if (!ctx.req) {
                finish()
              }
              throw e
            } finally {
              endChannel.publish(ctx)
            }
          })
        }
      }
      function normalizeArgs(inputURL, inputOptions, cb) {
        const originalUrl = inputURL
        inputURL = normalizeOptions(inputURL)
        const [callback, inputOptionsNormalized] = normalizeCallback(inputOptions, cb, inputURL)
        const options = combineOptions(inputURL, inputOptionsNormalized)
        normalizeHeaders(options)
        const uri = url.format(options)
        return { uri, options, callback, originalUrl }
      }
      function normalizeOptions(inputURL) {
        if (typeof inputURL === 'string') {
          try {
            return urlToOptions(new url.URL(inputURL))
          } catch {
            return url.parse(inputURL)
          }
        } else if (inputURL instanceof url.URL) {
          return urlToOptions(inputURL)
        } else {
          return inputURL
        }
      }
      function urlToOptions(url2) {
        const agent = url2.agent || http.globalAgent
        const options = {
          protocol: url2.protocol || agent.protocol,
          hostname:
            typeof url2.hostname === 'string' && url2.hostname.startsWith('[')
              ? url2.hostname.slice(1, -1)
              : url2.hostname || url2.host || 'localhost',
          hash: url2.hash,
          search: url2.search,
          pathname: url2.pathname,
          path: `${url2.pathname || ''}${url2.search || ''}`,
          href: url2.href,
        }
        if (url2.port !== '') {
          options.port = Number(url2.port)
        }
        if (url2.username || url2.password) {
          options.auth = `${url2.username}:${url2.password}`
        }
        return options
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js
var require_server2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startServerCh = channel('apm:http:server:request:start')
    var exitServerCh = channel('apm:http:server:request:exit')
    var errorServerCh = channel('apm:http:server:request:error')
    var finishServerCh = channel('apm:http:server:request:finish')
    var startWriteHeadCh = channel('apm:http:server:response:writeHead:start')
    var finishSetHeaderCh = channel('datadog:http:server:response:set-header:finish')
    var startSetHeaderCh = channel('datadog:http:server:response:set-header:start')
    var requestFinishedSet = /* @__PURE__ */ new WeakSet()
    var httpNames = ['http', 'node:http']
    var httpsNames = ['https', 'node:https']
    addHook({ name: httpNames }, (http) => {
      shimmer.wrap(http.ServerResponse.prototype, 'emit', wrapResponseEmit)
      shimmer.wrap(http.Server.prototype, 'emit', wrapEmit)
      shimmer.wrap(http.ServerResponse.prototype, 'writeHead', wrapWriteHead)
      shimmer.wrap(http.ServerResponse.prototype, 'write', wrapWrite)
      shimmer.wrap(http.ServerResponse.prototype, 'end', wrapEnd)
      shimmer.wrap(http.ServerResponse.prototype, 'setHeader', wrapSetHeader)
      shimmer.wrap(http.ServerResponse.prototype, 'removeHeader', wrapAppendOrRemoveHeader)
      if (http.ServerResponse.prototype.appendHeader) {
        shimmer.wrap(http.ServerResponse.prototype, 'appendHeader', wrapAppendOrRemoveHeader)
      }
      return http
    })
    addHook({ name: httpsNames }, (http) => {
      shimmer.wrap(http.Server.prototype, 'emit', wrapEmit)
      return http
    })
    function wrapResponseEmit(emit) {
      return function (eventName, event) {
        if (!finishServerCh.hasSubscribers) {
          return emit.apply(this, arguments)
        }
        if (['finish', 'close'].includes(eventName) && !requestFinishedSet.has(this)) {
          finishServerCh.publish({ req: this.req })
          requestFinishedSet.add(this)
        }
        return emit.apply(this, arguments)
      }
    }
    function wrapEmit(emit) {
      return function (eventName, req, res) {
        if (!startServerCh.hasSubscribers) {
          return emit.apply(this, arguments)
        }
        if (eventName === 'request') {
          res.req = req
          const abortController = new AbortController()
          startServerCh.publish({ req, res, abortController })
          try {
            if (abortController.signal.aborted) {
              return this.listenerCount(eventName) > 0
            }
            return emit.apply(this, arguments)
          } catch (err) {
            errorServerCh.publish(err)
            throw err
          } finally {
            exitServerCh.publish({ req })
          }
        }
        return emit.apply(this, arguments)
      }
    }
    function wrapWriteHead(writeHead) {
      return function wrappedWriteHead(statusCode, reason, obj) {
        if (!startWriteHeadCh.hasSubscribers) {
          return writeHead.apply(this, arguments)
        }
        const abortController = new AbortController()
        if (typeof reason !== 'string') {
          obj ??= reason
        }
        if (Array.isArray(obj)) {
          const headers = {}
          for (let i = 0; i < obj.length; i += 2) {
            headers[obj[i]] = obj[i + 1]
          }
          obj = headers
        }
        const responseHeaders = Object.assign(this.getHeaders(), obj)
        startWriteHeadCh.publish({
          req: this.req,
          res: this,
          abortController,
          statusCode,
          responseHeaders,
        })
        if (abortController.signal.aborted) {
          return this
        }
        return writeHead.apply(this, arguments)
      }
    }
    function wrapWrite(write) {
      return function wrappedWrite() {
        if (!startWriteHeadCh.hasSubscribers) {
          return write.apply(this, arguments)
        }
        const abortController = new AbortController()
        const responseHeaders = this.getHeaders()
        startWriteHeadCh.publish({
          req: this.req,
          res: this,
          abortController,
          statusCode: this.statusCode,
          responseHeaders,
        })
        if (abortController.signal.aborted) {
          return true
        }
        return write.apply(this, arguments)
      }
    }
    function wrapSetHeader(setHeader) {
      return function wrappedSetHeader(name, value) {
        if (!startSetHeaderCh.hasSubscribers && !finishSetHeaderCh.hasSubscribers) {
          return setHeader.apply(this, arguments)
        }
        if (startSetHeaderCh.hasSubscribers) {
          const abortController = new AbortController()
          startSetHeaderCh.publish({ res: this, abortController })
          if (abortController.signal.aborted) {
            return
          }
        }
        const setHeaderResult = setHeader.apply(this, arguments)
        if (finishSetHeaderCh.hasSubscribers) {
          finishSetHeaderCh.publish({ name, value, res: this })
        }
        return setHeaderResult
      }
    }
    function wrapAppendOrRemoveHeader(originalMethod) {
      return function wrappedAppendOrRemoveHeader() {
        if (!startSetHeaderCh.hasSubscribers) {
          return originalMethod.apply(this, arguments)
        }
        const abortController = new AbortController()
        startSetHeaderCh.publish({ res: this, abortController })
        if (abortController.signal.aborted) {
          return this
        }
        return originalMethod.apply(this, arguments)
      }
    }
    function wrapEnd(end) {
      return function wrappedEnd() {
        if (!startWriteHeadCh.hasSubscribers) {
          return end.apply(this, arguments)
        }
        const abortController = new AbortController()
        const responseHeaders = this.getHeaders()
        startWriteHeadCh.publish({
          req: this.req,
          res: this,
          abortController,
          statusCode: this.statusCode,
          responseHeaders,
        })
        if (abortController.signal.aborted) {
          return this
        }
        return end.apply(this, arguments)
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/http.js
var require_http2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/http.js'() {
    'use strict'
    require_client2()
    require_server2()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/http2/client.js
var require_client3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/http2/client.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var connectChannel = channel('apm:http2:client:connect:start')
    var startChannel = channel('apm:http2:client:request:start')
    var endChannel = channel('apm:http2:client:request:end')
    var asyncStartChannel = channel('apm:http2:client:request:asyncStart')
    var asyncEndChannel = channel('apm:http2:client:request:asyncEnd')
    var errorChannel = channel('apm:http2:client:request:error')
    var names = ['http2', 'node:http2']
    function createWrapEmit(ctx) {
      return function wrapEmit(emit) {
        return function (event, arg1) {
          ctx.eventName = event
          ctx.eventData = arg1
          return asyncStartChannel.runStores(ctx, () => {
            try {
              return emit.apply(this, arguments)
            } finally {
              asyncEndChannel.publish(ctx)
            }
          })
        }
      }
    }
    function createWrapRequest(authority, options) {
      return function wrapRequest(request) {
        return function (headers) {
          if (!startChannel.hasSubscribers) return request.apply(this, arguments)
          const ctx = { headers, authority, options }
          return startChannel.runStores(ctx, () => {
            try {
              const req = request.apply(this, arguments)
              shimmer.wrap(req, 'emit', createWrapEmit(ctx))
              return req
            } catch (e) {
              ctx.error = e
              errorChannel.publish(ctx)
              throw e
            } finally {
              endChannel.publish(ctx)
            }
          })
        }
      }
    }
    function wrapConnect(connect) {
      return function (authority, options) {
        if (connectChannel.hasSubscribers) {
          connectChannel.publish({ authority })
        }
        const session = connect.apply(this, arguments)
        shimmer.wrap(session, 'request', createWrapRequest(authority, options))
        return session
      }
    }
    addHook({ name: names }, (http2) => {
      shimmer.wrap(http2, 'connect', wrapConnect)
      if (http2.default) http2.default.connect = http2.connect
      return http2
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/http2/server.js
var require_server3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/http2/server.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startServerCh = channel('apm:http2:server:request:start')
    var errorServerCh = channel('apm:http2:server:request:error')
    var emitCh = channel('apm:http2:server:response:emit')
    var names = ['http2', 'node:http2']
    addHook({ name: names }, (http2) => {
      shimmer.wrap(http2, 'createSecureServer', wrapCreateServer)
      shimmer.wrap(http2, 'createServer', wrapCreateServer)
    })
    function wrapCreateServer(createServer) {
      return function (...args) {
        const server = createServer.apply(this, args)
        shimmer.wrap(server, 'emit', wrapEmit)
        return server
      }
    }
    function wrapResponseEmit(emit, ctx) {
      return function (eventName, event) {
        ctx.req = this.req
        ctx.eventName = eventName
        return emitCh.runStores(ctx, emit, this, ...arguments)
      }
    }
    function wrapEmit(emit) {
      return function (eventName, req, res) {
        if (!startServerCh.hasSubscribers) {
          return emit.apply(this, arguments)
        }
        if (eventName === 'request') {
          res.req = req
          const ctx = { req, res }
          return startServerCh.runStores(ctx, () => {
            shimmer.wrap(res, 'emit', (emit2) => wrapResponseEmit(emit2, ctx))
            try {
              return emit.apply(this, arguments)
            } catch (error) {
              ctx.error = error
              errorServerCh.publish(ctx)
              throw error
            }
          })
        }
        return emit.apply(this, arguments)
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/http2.js
var require_http22 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/http2.js'() {
    'use strict'
    require_client3()
    require_server3()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js
var require_ioredis = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startCh = channel('apm:ioredis:command:start')
    var finishCh = channel('apm:ioredis:command:finish')
    var errorCh = channel('apm:ioredis:command:error')
    function wrapRedis(Redis) {
      shimmer.wrap(
        Redis.prototype,
        'sendCommand',
        (sendCommand) =>
          function (command, stream) {
            if (!startCh.hasSubscribers) return sendCommand.apply(this, arguments)
            if (!command || !command.promise) return sendCommand.apply(this, arguments)
            const options = this.options || {}
            const connectionName = options.connectionName
            const db = options.db
            const connectionOptions = { host: options.host, port: options.port }
            const ctx = { db, command: command.name, args: command.args, connectionOptions, connectionName }
            return startCh.runStores(ctx, () => {
              command.promise.then(
                () => finish(finishCh, errorCh, ctx),
                (err) => finish(finishCh, errorCh, ctx, err)
              )
              try {
                return sendCommand.apply(this, arguments)
              } catch (err) {
                errorCh.publish(err)
                throw err
              }
            })
          }
      )
      return Redis
    }
    addHook({ name: 'ioredis', versions: ['>=2 <4'], file: 'lib/redis.js' }, wrapRedis)
    addHook({ name: 'ioredis', versions: ['>=4 <4.11.0'], file: 'built/redis.js' }, wrapRedis)
    addHook({ name: 'ioredis', versions: ['>=4.11.0 <5'], file: 'built/redis/index.js' }, (exports3) => {
      wrapRedis(exports3.default)
      return exports3
    })
    addHook({ name: 'ioredis', versions: ['>=5'] }, wrapRedis)
    function finish(finishCh2, errorCh2, ctx, error) {
      if (error) {
        ctx.error = error
        errorCh2.publish(ctx)
      }
      finishCh2.publish(ctx)
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/iovalkey.js
var require_iovalkey = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/iovalkey.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startCh = channel('apm:iovalkey:command:start')
    var finishCh = channel('apm:iovalkey:command:finish')
    var errorCh = channel('apm:iovalkey:command:error')
    addHook({ name: 'iovalkey', versions: ['>=0.0.1'] }, (Valkey) => {
      shimmer.wrap(
        Valkey.prototype,
        'sendCommand',
        (sendCommand) =>
          function (command, stream) {
            if (!startCh.hasSubscribers) return sendCommand.apply(this, arguments)
            if (!command?.promise) return sendCommand.apply(this, arguments)
            const options = this.options || {}
            const connectionName = options.connectionName
            const db = options.db
            const connectionOptions = { host: options.host, port: options.port }
            const ctx = { db, command: command.name, args: command.args, connectionOptions, connectionName }
            return startCh.runStores(ctx, () => {
              command.promise.then(
                () => finish(finishCh, errorCh, ctx),
                (err) => finish(finishCh, errorCh, ctx, err)
              )
              try {
                return sendCommand.apply(this, arguments)
              } catch (err) {
                ctx.error = err
                errorCh.publish(ctx)
                throw err
              }
            })
          }
      )
      return Valkey
    })
    function finish(finishCh2, errorCh2, ctx, error) {
      if (error) {
        ctx.error = error
        errorCh2.publish(ctx)
      }
      finishCh2.publish(ctx)
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/knex.js
var require_knex = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/knex.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var { wrapThen } = require_promise()
    var shimmer = require_datadog_shimmer()
    var startRawQueryCh = channel('datadog:knex:raw:start')
    var rawQuerySubscribes = channel('datadog:knex:raw:subscribes')
    var finishRawQueryCh = channel('datadog:knex:raw:finish')
    patch('lib/query/builder.js')
    patch('lib/raw.js')
    patch('lib/schema/builder.js')
    function patch(file) {
      addHook(
        {
          name: 'knex',
          versions: ['>=0.8.0'],
          file,
        },
        (Builder) => {
          shimmer.wrap(Builder.prototype, 'then', wrapThen)
          return Builder
        }
      )
    }
    function finish(context, cb) {
      finishRawQueryCh.runStores(context, cb)
    }
    addHook(
      {
        name: 'knex',
        versions: ['>=2'],
        file: 'lib/knex-builder/Knex.js',
      },
      (Knex) => {
        shimmer.wrap(
          Knex.Client.prototype,
          'raw',
          (raw) =>
            function () {
              if (!startRawQueryCh.hasSubscribers) {
                return raw.apply(this, arguments)
              }
              const sql = arguments[0]
              if (sql === 'DEFAULT') {
                return raw.apply(this, arguments)
              }
              const context = { sql, dialect: this.dialect }
              return startRawQueryCh.runStores(context, () => {
                const rawResult = raw.apply(this, arguments)
                shimmer.wrap(
                  rawResult,
                  'then',
                  (originalThen) =>
                    function () {
                      return rawQuerySubscribes.runStores(context, () => {
                        arguments[0] = wrapCallbackWithFinish(arguments[0], finish, context)
                        if (arguments[1]) arguments[1] = wrapCallbackWithFinish(arguments[1], finish, context)
                        const originalThenResult = originalThen.apply(this, arguments)
                        shimmer.wrap(
                          originalThenResult,
                          'catch',
                          (originalCatch) =>
                            function () {
                              arguments[0] = wrapCallbackWithFinish(arguments[0], finish, context)
                              return originalCatch.apply(this, arguments)
                            }
                        )
                        return originalThenResult
                      })
                    }
                )
                shimmer.wrap(
                  rawResult,
                  'asCallback',
                  (originalAsCallback) =>
                    function () {
                      return rawQuerySubscribes.runStores(context, () => {
                        arguments[0] = wrapCallbackWithFinish(arguments[0], finish, context)
                        return originalAsCallback.apply(this, arguments)
                      })
                    }
                )
                return rawResult
              })
            }
        )
        return Knex
      }
    )
    function wrapCallbackWithFinish(callback, finish2, context) {
      if (typeof callback !== 'function') return callback
      return shimmer.wrapFunction(
        callback,
        (callback2) =>
          function () {
            finish2(context, () => callback2.apply(this, arguments))
          }
      )
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/confluentinc-kafka-javascript.js
var require_confluentinc_kafka_javascript = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/confluentinc-kafka-javascript.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var log = require_log2()
    var channels = {
      producerStart: channel('apm:confluentinc-kafka-javascript:produce:start'),
      producerFinish: channel('apm:confluentinc-kafka-javascript:produce:finish'),
      producerError: channel('apm:confluentinc-kafka-javascript:produce:error'),
      producerCommit: channel('apm:confluentinc-kafka-javascript:produce:commit'),
      consumerStart: channel('apm:confluentinc-kafka-javascript:consume:start'),
      consumerFinish: channel('apm:confluentinc-kafka-javascript:consume:finish'),
      consumerError: channel('apm:confluentinc-kafka-javascript:consume:error'),
      consumerCommit: channel('apm:confluentinc-kafka-javascript:consume:commit'),
      // batch operations
      batchConsumerStart: channel('apm:confluentinc-kafka-javascript:consume-batch:start'),
      batchConsumerFinish: channel('apm:confluentinc-kafka-javascript:consume-batch:finish'),
      batchConsumerError: channel('apm:confluentinc-kafka-javascript:consume-batch:error'),
      batchConsumerCommit: channel('apm:confluentinc-kafka-javascript:consume-batch:commit'),
    }
    var disabledHeaderWeakSet = /* @__PURE__ */ new WeakSet()
    var latestConsumerOffsets = /* @__PURE__ */ new Map()
    addHook({ name: '@confluentinc/kafka-javascript', versions: ['>=1.0.0'] }, (module3) => {
      instrumentBaseModule(module3)
      if (module3.KafkaJS) {
        instrumentKafkaJS(module3.KafkaJS)
      }
      return module3
    })
    function instrumentBaseModule(module3) {
      function wrapProducerClass(ProducerClass, className) {
        return shimmer.wrap(module3, className, function wrapProducer(Original) {
          return function wrappedProducer() {
            const producer = new Original(...arguments)
            if (typeof producer?.produce === 'function') {
              shimmer.wrap(producer, 'produce', function wrapProduce(produce) {
                return function wrappedProduce(topic, partition, message, key, timestamp, opaque, headers) {
                  if (!channels.producerStart.hasSubscribers) {
                    return produce.apply(this, arguments)
                  }
                  const brokers = this.globalConfig?.['bootstrap.servers']
                  const ctx = {
                    topic,
                    messages: [{ key, value: message }],
                    bootstrapServers: brokers,
                  }
                  return channels.producerStart.runStores(ctx, () => {
                    try {
                      const headers2 = convertHeaders(ctx.messages[0].headers)
                      const result = produce.apply(this, [topic, partition, message, key, timestamp, opaque, headers2])
                      ctx.result = result
                      channels.producerCommit.publish(ctx)
                      channels.producerFinish.publish(ctx)
                      return result
                    } catch (error) {
                      ctx.error = error
                      channels.producerError.publish(ctx)
                      channels.producerFinish.publish(ctx)
                      throw error
                    }
                  })
                }
              })
            }
            return producer
          }
        })
      }
      function wrapConsumerClass(ConsumerClass, className) {
        return shimmer.wrap(module3, className, function wrapConsumer(Original) {
          return function wrappedConsumer() {
            const consumer = new Original(...arguments)
            const groupId = this.groupId || arguments[0]?.['group.id']
            if (typeof consumer?.consume === 'function') {
              shimmer.wrap(consumer, 'consume', function wrapConsume(consume) {
                return function wrappedConsume(numMessages, callback) {
                  if (!channels.consumerStart.hasSubscribers) {
                    return consume.apply(this, arguments)
                  }
                  if (!callback && typeof numMessages === 'function') {
                    callback = numMessages
                  }
                  const ctx = {
                    groupId,
                  }
                  if (typeof callback === 'function') {
                    return consume.call(this, numMessages, function wrappedCallback(err, messages) {
                      if (messages && messages.length > 0) {
                        messages.forEach((message) => {
                          ctx.topic = message?.topic
                          ctx.partition = message?.partition
                          ctx.message = message
                          channels.consumerStart.runStores(ctx, () => {})
                          updateLatestOffset(message?.topic, message?.partition, message?.offset, groupId)
                        })
                      }
                      if (err) {
                        ctx.error = err
                        channels.consumerError.publish(ctx)
                      }
                      try {
                        const result = callback.apply(this, arguments)
                        if (messages && messages.length > 0) {
                          channels.consumerFinish.publish(ctx)
                        }
                        return result
                      } catch (error) {
                        ctx.error = error
                        channels.consumerError.publish(ctx)
                        channels.consumerFinish.publish(ctx)
                        throw error
                      }
                    })
                  }
                  return consume.apply(this, arguments)
                }
              })
              if (consumer && typeof consumer.commit === 'function') {
                shimmer.wrap(consumer, 'commit', wrapCommit)
              }
            }
            return consumer
          }
        })
      }
      if (typeof module3.Producer === 'function') {
        wrapProducerClass(module3.Producer, 'Producer')
      }
      if (typeof module3.KafkaProducer === 'function') {
        wrapProducerClass(module3.KafkaProducer, 'KafkaProducer')
      }
      if (typeof module3.Consumer === 'function') {
        wrapConsumerClass(module3.Consumer, 'Consumer')
      }
      if (typeof module3.KafkaConsumer === 'function') {
        wrapConsumerClass(module3.KafkaConsumer, 'KafkaConsumer')
      }
    }
    function instrumentKafkaJS(kafkaJS) {
      if (typeof kafkaJS?.Kafka === 'function') {
        shimmer.wrap(kafkaJS, 'Kafka', function wrapKafka(OriginalKafka) {
          return function KafkaWrapper(options) {
            const kafka = new OriginalKafka(options)
            const kafkaJSOptions = options?.kafkaJS || options
            const brokers = kafkaJSOptions?.brokers ? kafkaJSOptions.brokers.join(',') : ''
            kafka._ddBrokers = brokers
            if (typeof kafka?.producer === 'function') {
              shimmer.wrap(kafka, 'producer', function wrapProducerMethod(producerMethod) {
                return function wrappedProducerMethod() {
                  const producer = producerMethod.apply(this, arguments)
                  if (!brokers && arguments?.[0]?.['bootstrap.servers']) {
                    kafka._ddBrokers = arguments[0]['bootstrap.servers']
                  }
                  if (producer && typeof producer.send === 'function') {
                    shimmer.wrap(producer, 'send', function wrapSend(send) {
                      return function wrappedSend(payload) {
                        if (!channels.producerStart.hasSubscribers) {
                          return send.apply(this, arguments)
                        }
                        const ctx = {
                          topic: payload?.topic,
                          messages: payload?.messages || [],
                          bootstrapServers: kafka._ddBrokers,
                          disableHeaderInjection: disabledHeaderWeakSet.has(producer),
                        }
                        return channels.producerStart.runStores(ctx, () => {
                          try {
                            const result = send.apply(this, arguments)
                            result.then(
                              (res) => {
                                ctx.result = res
                                channels.producerCommit.publish(ctx)
                                channels.producerFinish.publish(ctx)
                              },
                              (err) => {
                                if (err) {
                                  if (err.name === 'KafkaJSError' && err.type === 'ERR_UNKNOWN') {
                                    disabledHeaderWeakSet.add(producer)
                                    log.error(
                                      'Kafka Broker responded with UNKNOWN_SERVER_ERROR (-1). Please look at broker logs for more information. Tracer message header injection for Kafka is disabled.'
                                    )
                                  }
                                  ctx.error = err
                                  channels.producerError.publish(ctx)
                                }
                                channels.producerFinish.publish(ctx)
                              }
                            )
                            return result
                          } catch (e) {
                            ctx.error = e
                            channels.producerError.publish(ctx)
                            channels.producerFinish.publish(ctx)
                            throw e
                          }
                        })
                      }
                    })
                  }
                  return producer
                }
              })
            }
            if (typeof kafka?.consumer === 'function') {
              shimmer.wrap(kafka, 'consumer', function wrapConsumerMethod(consumerMethod) {
                return function wrappedConsumerMethod(config) {
                  const consumer = consumerMethod.apply(this, arguments)
                  const groupId = getGroupId(config)
                  if (typeof consumer?.run === 'function') {
                    shimmer.wrap(consumer, 'run', function wrapRun(run) {
                      return function wrappedRun(options2) {
                        if (!channels.consumerStart.hasSubscribers) {
                          return run.apply(this, arguments)
                        }
                        const eachMessage = options2?.eachMessage
                        const eachBatch = options2?.eachBatch
                        if (eachMessage) {
                          options2.eachMessage = wrapKafkaCallback(
                            eachMessage,
                            {
                              startCh: channels.consumerStart,
                              commitCh: channels.consumerCommit,
                              finishCh: channels.consumerFinish,
                              errorCh: channels.consumerError,
                            },
                            (payload) => {
                              return {
                                topic: payload?.topic,
                                partition: payload?.partition,
                                offset: payload?.message?.offset,
                                message: payload?.message,
                                groupId,
                              }
                            }
                          )
                        } else if (eachBatch) {
                          options2.eachBatch = wrapKafkaCallback(
                            eachBatch,
                            {
                              startCh: channels.batchConsumerStart,
                              commitCh: channels.batchConsumerCommit,
                              finishCh: channels.batchConsumerFinish,
                              errorCh: channels.batchConsumerError,
                            },
                            (payload) => {
                              const { batch } = payload
                              return {
                                topic: batch?.topic,
                                partition: batch?.partition,
                                offset: batch?.messages[batch?.messages?.length - 1]?.offset,
                                messages: batch?.messages,
                                groupId,
                              }
                            }
                          )
                        }
                        return run.apply(this, arguments)
                      }
                    })
                  }
                  if (typeof consumer?.commitOffsets === 'function') {
                    shimmer.wrap(consumer, 'commitOffsets', wrapCommit)
                  }
                  return consumer
                }
              })
            }
            return kafka
          }
        })
      }
    }
    function wrapCommit(commit) {
      return function wrappedCommit(options) {
        if (!channels.consumerCommit.hasSubscribers) {
          return commit.apply(this, arguments)
        }
        const result = commit.apply(this, arguments)
        channels.consumerCommit.publish(getLatestOffsets())
        latestConsumerOffsets.clear()
        return result
      }
    }
    function wrapKafkaCallback(callback, { startCh, commitCh, finishCh, errorCh }, getPayload) {
      return function wrappedKafkaCallback(payload) {
        const commitPayload = getPayload(payload)
        const ctx = {
          extractedArgs: commitPayload,
        }
        return startCh.runStores(ctx, () => {
          updateLatestOffset(
            commitPayload?.topic,
            commitPayload?.partition,
            commitPayload?.offset,
            commitPayload?.groupId
          )
          try {
            const result = callback.apply(this, arguments)
            if (result && typeof result.then === 'function') {
              return result
                .then((res) => {
                  ctx.result = res
                  finishCh.publish(ctx)
                  return res
                })
                .catch((err) => {
                  ctx.error = err
                  errorCh.publish(ctx)
                  finishCh.publish(ctx)
                  throw err
                })
            }
            finishCh.publish(ctx)
            return result
          } catch (error) {
            ctx.error = error
            errorCh.publish(ctx)
            finishCh.publish(ctx)
            throw error
          }
        })
      }
    }
    function getGroupId(config) {
      if (!config) return ''
      if (config.kafkaJS?.groupId) return config.kafkaJS.groupId
      if (config?.groupId) return config.groupId
      if (config['group.id']) return config['group.id']
      return ''
    }
    function updateLatestOffset(topic, partition, offset, groupId) {
      const key = `${topic}:${partition}`
      latestConsumerOffsets.set(key, {
        topic,
        partition,
        offset,
        groupId,
      })
    }
    function getLatestOffsets() {
      return [...latestConsumerOffsets.values()]
    }
    function convertHeaders(headers) {
      return Object.entries(headers).map(([key, value]) => ({ [key.toString()]: value.toString() }))
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/kafkajs.js
var require_kafkajs = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/kafkajs.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var log = require_log2()
    var producerStartCh = channel('apm:kafkajs:produce:start')
    var producerCommitCh = channel('apm:kafkajs:produce:commit')
    var producerFinishCh = channel('apm:kafkajs:produce:finish')
    var producerErrorCh = channel('apm:kafkajs:produce:error')
    var consumerStartCh = channel('apm:kafkajs:consume:start')
    var consumerCommitCh = channel('apm:kafkajs:consume:commit')
    var consumerFinishCh = channel('apm:kafkajs:consume:finish')
    var consumerErrorCh = channel('apm:kafkajs:consume:error')
    var batchConsumerStartCh = channel('apm:kafkajs:consume-batch:start')
    var batchConsumerFinishCh = channel('apm:kafkajs:consume-batch:finish')
    var batchConsumerErrorCh = channel('apm:kafkajs:consume-batch:error')
    var disabledHeaderWeakSet = /* @__PURE__ */ new WeakSet()
    function commitsFromEvent(event) {
      const {
        payload: { groupId, topics },
      } = event
      const commitList = []
      for (const { topic, partitions } of topics) {
        for (const { partition, offset } of partitions) {
          commitList.push({
            groupId,
            partition,
            offset,
            topic,
          })
        }
      }
      consumerCommitCh.publish(commitList)
    }
    addHook({ name: 'kafkajs', file: 'src/index.js', versions: ['>=1.4'] }, (BaseKafka) => {
      class Kafka extends BaseKafka {
        constructor(options) {
          super(options)
          this._brokers = options.brokers && typeof options.brokers !== 'function' ? options.brokers.join(',') : void 0
        }
      }
      shimmer.wrap(
        Kafka.prototype,
        'producer',
        (createProducer) =>
          function () {
            const producer = createProducer.apply(this, arguments)
            const send = producer.send
            const bootstrapServers = this._brokers
            const kafkaClusterIdPromise = getKafkaClusterId(this)
            producer.send = function () {
              const wrappedSend = (clusterId) => {
                const { topic, messages = [] } = arguments[0]
                const ctx = {
                  bootstrapServers,
                  clusterId,
                  disableHeaderInjection: disabledHeaderWeakSet.has(producer),
                  messages,
                  topic,
                }
                for (const message of messages) {
                  if (message !== null && typeof message === 'object' && !ctx.disableHeaderInjection) {
                    message.headers = message.headers || {}
                  }
                }
                return producerStartCh.runStores(ctx, () => {
                  try {
                    const result = send.apply(this, arguments)
                    result.then(
                      (res) => {
                        ctx.result = res
                        producerFinishCh.publish(ctx)
                        producerCommitCh.publish(ctx)
                      },
                      (err) => {
                        ctx.error = err
                        if (err) {
                          if (err.name === 'KafkaJSProtocolError' && err.type === 'UNKNOWN') {
                            disabledHeaderWeakSet.add(producer)
                            log.error(
                              'Kafka Broker responded with UNKNOWN_SERVER_ERROR (-1). Please look at broker logs for more information. Tracer message header injection for Kafka is disabled.'
                            )
                          }
                          producerErrorCh.publish(err)
                        }
                        producerFinishCh.publish(ctx)
                      }
                    )
                    return result
                  } catch (e) {
                    ctx.error = e
                    producerErrorCh.publish(ctx)
                    producerFinishCh.publish(ctx)
                    throw e
                  }
                })
              }
              if (isPromise(kafkaClusterIdPromise)) {
                return kafkaClusterIdPromise.then((clusterId) => {
                  return wrappedSend(clusterId)
                })
              }
              return wrappedSend(kafkaClusterIdPromise)
            }
            return producer
          }
      )
      shimmer.wrap(
        Kafka.prototype,
        'consumer',
        (createConsumer) =>
          function () {
            if (!consumerStartCh.hasSubscribers) {
              return createConsumer.apply(this, arguments)
            }
            const kafkaClusterIdPromise = getKafkaClusterId(this)
            const eachMessageExtractor = (args, clusterId) => {
              const { topic, partition, message } = args[0]
              return { topic, partition, message, groupId, clusterId }
            }
            const eachBatchExtractor = (args, clusterId) => {
              const { batch } = args[0]
              const { topic, partition, messages } = batch
              return { topic, partition, messages, groupId, clusterId }
            }
            const consumer = createConsumer.apply(this, arguments)
            consumer.on(consumer.events.COMMIT_OFFSETS, commitsFromEvent)
            const run = consumer.run
            const groupId = arguments[0].groupId
            consumer.run = function ({ eachMessage, eachBatch, ...runArgs }) {
              const wrapConsume = (clusterId) => {
                return run({
                  eachMessage: wrappedCallback(
                    eachMessage,
                    consumerStartCh,
                    consumerFinishCh,
                    consumerErrorCh,
                    eachMessageExtractor,
                    clusterId
                  ),
                  eachBatch: wrappedCallback(
                    eachBatch,
                    batchConsumerStartCh,
                    batchConsumerFinishCh,
                    batchConsumerErrorCh,
                    eachBatchExtractor,
                    clusterId
                  ),
                  ...runArgs,
                })
              }
              if (isPromise(kafkaClusterIdPromise)) {
                return kafkaClusterIdPromise.then((clusterId) => {
                  return wrapConsume(clusterId)
                })
              }
              return wrapConsume(kafkaClusterIdPromise)
            }
            return consumer
          }
      )
      return Kafka
    })
    var wrappedCallback = (fn, startCh, finishCh, errorCh, extractArgs, clusterId) => {
      return typeof fn === 'function'
        ? function (...args) {
            const extractedArgs = extractArgs(args, clusterId)
            const ctx = {
              extractedArgs,
            }
            return startCh.runStores(ctx, () => {
              try {
                const result = fn.apply(this, args)
                if (result && typeof result.then === 'function') {
                  result.then(
                    (res) => {
                      ctx.result = res
                      finishCh.publish(ctx)
                    },
                    (err) => {
                      ctx.error = err
                      if (err) {
                        errorCh.publish(ctx)
                      }
                      finishCh.publish(ctx)
                    }
                  )
                } else {
                  finishCh.publish(ctx)
                }
                return result
              } catch (e) {
                ctx.error = e
                errorCh.publish(ctx)
                finishCh.publish(ctx)
                throw e
              }
            })
          }
        : fn
    }
    var getKafkaClusterId = (kafka) => {
      if (kafka._ddKafkaClusterId) {
        return kafka._ddKafkaClusterId
      }
      if (!kafka.admin) {
        return null
      }
      const admin = kafka.admin()
      if (!admin.describeCluster) {
        return null
      }
      return admin
        .connect()
        .then(() => {
          return admin.describeCluster()
        })
        .then((clusterInfo) => {
          const clusterId = clusterInfo?.clusterId
          kafka._ddKafkaClusterId = clusterId
          admin.disconnect()
          return clusterId
        })
        .catch((error) => {
          throw error
        })
    }
    function isPromise(obj) {
      return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/ldapjs.js
var require_ldapjs = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/ldapjs.js'() {
    'use strict'
    var { channel, addHook, AsyncResource } = require_instrument()
    var shimmer = require_datadog_shimmer()
    function isString(value) {
      return typeof value === 'string' || value instanceof String
    }
    function getCallbackArgIndex(args) {
      let callbackIndex = -1
      for (let i = args.length - 1; i >= 0; i--) {
        if (typeof args[i] === 'function') {
          callbackIndex = i
          break
        }
      }
      return callbackIndex
    }
    function wrapEmitter(corkedEmitter) {
      const callbackMap = /* @__PURE__ */ new WeakMap()
      const addListener = (on) =>
        function (name, fn) {
          if (typeof fn === 'function') {
            let bindedFn = callbackMap.get(fn)
            if (!bindedFn) {
              const callbackResource = new AsyncResource('bound-anonymous-fn')
              bindedFn = callbackResource.bind(fn)
              callbackMap.set(fn, bindedFn)
            }
            arguments[1] = bindedFn
          }
          return on.apply(this, arguments)
        }
      shimmer.wrap(corkedEmitter, 'on', addListener)
      shimmer.wrap(corkedEmitter, 'addListener', addListener)
      const removeListener = (off) =>
        function (name, fn) {
          if (typeof fn === 'function') {
            const emitterOn = callbackMap.get(fn)
            if (emitterOn) {
              arguments[1] = emitterOn
            }
          }
          return off.apply(this, arguments)
        }
      shimmer.wrap(corkedEmitter, 'off', removeListener)
      shimmer.wrap(corkedEmitter, 'removeListener', removeListener)
    }
    addHook({ name: 'ldapjs', versions: ['>=2'] }, (ldapjs) => {
      const ldapSearchCh = channel('datadog:ldapjs:client:search')
      shimmer.wrap(
        ldapjs.Client.prototype,
        'search',
        (search) =>
          function (base, options) {
            if (ldapSearchCh.hasSubscribers) {
              let filter
              if (isString(options)) {
                filter = options
              } else if (
                options !== null &&
                typeof options === 'object' &&
                options.filter &&
                isString(options.filter)
              ) {
                filter = options.filter
              }
              ldapSearchCh.publish({ base, filter })
            }
            return search.apply(this, arguments)
          }
      )
      shimmer.wrap(
        ldapjs.Client.prototype,
        '_send',
        (_send) =>
          function () {
            const callbackIndex = getCallbackArgIndex(arguments)
            if (callbackIndex > -1) {
              const callback = arguments[callbackIndex]
              arguments[callbackIndex] = shimmer.wrapFunction(
                callback,
                (callback2) =>
                  function (err, corkedEmitter) {
                    if (
                      corkedEmitter !== null &&
                      typeof corkedEmitter === 'object' &&
                      typeof corkedEmitter.on === 'function'
                    ) {
                      wrapEmitter(corkedEmitter)
                    }
                    callback2.apply(this, arguments)
                  }
              )
            }
            return _send.apply(this, arguments)
          }
      )
      shimmer.wrap(
        ldapjs.Client.prototype,
        'bind',
        (bind) =>
          function (dn, password, controls, callback) {
            if (typeof controls === 'function') {
              arguments[2] = AsyncResource.bind(controls)
            } else if (typeof callback === 'function') {
              arguments[3] = AsyncResource.bind(callback)
            }
            return bind.apply(this, arguments)
          }
      )
      return ldapjs
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/limitd-client.js
var require_limitd_client = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/limitd-client.js'() {
    'use strict'
    var { addHook, AsyncResource } = require_instrument()
    var shimmer = require_datadog_shimmer()
    function wrapRequest(original) {
      return function () {
        const id = arguments.length - 1
        arguments[id] = AsyncResource.bind(arguments[id])
        return original.apply(this, arguments)
      }
    }
    addHook(
      {
        name: 'limitd-client',
        versions: ['>=2.8'],
        file: ['client.js'],
      },
      (LimitdClient) => {
        shimmer.wrap(LimitdClient.prototype, '_directRequest', wrapRequest)
        shimmer.wrap(LimitdClient.prototype, '_retriedRequest', wrapRequest)
        return LimitdClient
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/lodash.js
var require_lodash = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/lodash.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: 'lodash', versions: ['>=4'] }, (lodash) => {
      const lodashOperationCh = channel('datadog:lodash:operation')
      const instrumentedLodashFn = ['trim', 'trimStart', 'trimEnd', 'toLower', 'toUpper', 'join']
      shimmer.massWrap(lodash, instrumentedLodashFn, (lodashFn) => {
        return function () {
          if (!lodashOperationCh.hasSubscribers) {
            return lodashFn.apply(this, arguments)
          }
          const result = lodashFn.apply(this, arguments)
          const message = { operation: lodashFn.name, arguments, result }
          lodashOperationCh.publish(message)
          return message.result
        }
      })
      return lodash
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mariadb.js
var require_mariadb = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mariadb.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var commandAddCh = channel('apm:mariadb:command:add')
    var connectionStartCh = channel('apm:mariadb:connection:start')
    var connectionFinishCh = channel('apm:mariadb:connection:finish')
    var startCh = channel('apm:mariadb:query:start')
    var finishCh = channel('apm:mariadb:query:finish')
    var errorCh = channel('apm:mariadb:query:error')
    var skipCh = channel('apm:mariadb:pool:skip')
    function wrapCommandStart(start, ctx) {
      return shimmer.wrapFunction(
        start,
        (start2) =>
          function () {
            if (!startCh.hasSubscribers) return start2.apply(this, arguments)
            const { reject, resolve } = this
            shimmer.wrap(this, 'resolve', function wrapResolve() {
              return function () {
                return finishCh.runStores(ctx, resolve, this, ...arguments)
              }
            })
            shimmer.wrap(this, 'reject', function wrapReject() {
              return function (error) {
                ctx.error = error
                errorCh.publish(ctx)
                return finishCh.runStores(ctx, reject, this, ...arguments)
              }
            })
            return startCh.runStores(ctx, start2, this, ...arguments)
          }
      )
    }
    function wrapCommand(Command) {
      return class extends Command {
        constructor(...args) {
          super(...args)
          if (!this.start) return
          const ctx = { sql: this.sql, conf: this.opts }
          commandAddCh.publish(ctx)
          this.start = wrapCommandStart(this.start, ctx)
        }
      }
    }
    function createWrapQuery(options) {
      return function wrapQuery(query) {
        return function (sql) {
          if (!startCh.hasSubscribers) return query.apply(this, arguments)
          const ctx = { sql, conf: options }
          return startCh.runStores(ctx, query, this, ...arguments).then(
            (result) => {
              ctx.result = result
              finishCh.publish(ctx)
              return result
            },
            (error) => {
              ctx.error
              errorCh.publish(ctx)
              finishCh.publish(ctx)
              throw error
            }
          )
        }
      }
    }
    function createWrapQueryCallback(options) {
      return function wrapQuery(query) {
        return function (sql) {
          if (!startCh.hasSubscribers) return query.apply(this, arguments)
          const cb = arguments[arguments.length - 1]
          const ctx = { sql, conf: options }
          const wrapper = (cb2) =>
            function (err) {
              if (err) {
                ctx.error = err
                errorCh.publish(ctx)
              }
              return typeof cb2 === 'function'
                ? finishCh.runStores(ctx, cb2, this, ...arguments)
                : finishCh.publish(ctx)
            }
          if (typeof cb === 'function') {
            arguments[arguments.length - 1] = shimmer.wrapFunction(cb, wrapper)
          } else {
            arguments.length += 1
            arguments[arguments.length - 1] = wrapper()
          }
          return startCh.runStores(ctx, query, this, ...arguments)
        }
      }
    }
    function wrapConnection(promiseMethod, Connection) {
      return function (options) {
        Connection.apply(this, arguments)
        shimmer.wrap(this, promiseMethod, createWrapQuery(options))
        shimmer.wrap(this, '_queryCallback', createWrapQueryCallback(options))
      }
    }
    function wrapPoolBase(PoolBase) {
      return function (options, processTask, createConnectionPool, pingPromise) {
        arguments[1] = wrapPoolMethod(processTask)
        arguments[2] = wrapPoolMethod(createConnectionPool)
        PoolBase.apply(this, arguments)
        shimmer.wrap(this, 'query', createWrapQuery(options.connOptions))
      }
    }
    function wrapPoolMethod(createConnection) {
      return function () {
        return skipCh.runStores({}, createConnection, this, ...arguments)
      }
    }
    function wrapPoolGetConnectionMethod(getConnection) {
      return function wrappedGetConnection() {
        const cb = arguments[arguments.length - 1]
        if (typeof cb !== 'function') return getConnection.apply(this, arguments)
        const ctx = {}
        arguments[arguments.length - 1] = function () {
          return connectionFinishCh.runStores(ctx, cb, this, ...arguments)
        }
        connectionStartCh.publish(ctx)
        return getConnection.apply(this, arguments)
      }
    }
    var name = 'mariadb'
    addHook({ name, file: 'lib/cmd/query.js', versions: ['>=3'] }, (Query) => {
      return wrapCommand(Query)
    })
    addHook({ name, file: 'lib/cmd/execute.js', versions: ['>=3'] }, (Execute) => {
      return wrapCommand(Execute)
    })
    addHook({ name, file: 'lib/pool.js', versions: ['>=3.4.1'] }, (Pool) => {
      shimmer.wrap(Pool.prototype, 'getConnection', wrapPoolGetConnectionMethod)
      return Pool
    })
    addHook({ name, file: 'lib/pool.js', versions: ['>=3'] }, (Pool) => {
      shimmer.wrap(Pool.prototype, '_createConnection', wrapPoolMethod)
      return Pool
    })
    addHook({ name, file: 'lib/connection.js', versions: ['>=2.5.2 <3'] }, (Connection) => {
      return shimmer.wrapFunction(Connection, wrapConnection.bind(null, '_queryPromise'))
    })
    addHook({ name, file: 'lib/connection.js', versions: ['>=2.0.4 <=2.5.1'] }, (Connection) => {
      return shimmer.wrapFunction(Connection, wrapConnection.bind(null, 'query'))
    })
    addHook({ name, file: 'lib/pool-base.js', versions: ['>=2.0.4 <3'] }, (PoolBase) => {
      return shimmer.wrapFunction(PoolBase, wrapPoolBase)
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js
var require_memcached = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: 'memcached', versions: ['>=2.2'] }, (Memcached) => {
      const startCh = channel('apm:memcached:command:start')
      const finishCh = channel('apm:memcached:command:finish')
      const errorCh = channel('apm:memcached:command:error')
      shimmer.wrap(
        Memcached.prototype,
        'command',
        (command) =>
          function (queryCompiler, server) {
            if (!startCh.hasSubscribers) {
              return command.apply(this, arguments)
            }
            const client = this
            const wrappedQueryCompiler = function () {
              const query = queryCompiler.apply(this, arguments)
              const ctx = { client, server, query }
              startCh.runStores(ctx, () => {
                query.callback = shimmer.wrapFunction(
                  query.callback,
                  (callback) =>
                    function (err) {
                      if (err) {
                        ctx.error = err
                        errorCh.publish(ctx)
                      }
                      finishCh.publish(ctx)
                      return finishCh.runStores(ctx, callback, this, ...arguments)
                    }
                )
              })
              return query
            }
            arguments[0] = wrappedQueryCompiler
            return command.apply(this, arguments)
          }
      )
      return Memcached
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/microgateway-core.js
var require_microgateway_core = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/microgateway-core.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var handleChannel = channel('apm:microgateway-core:request:handle')
    var routeChannel = channel('apm:microgateway-core:request:route')
    var errorChannel = channel('apm:microgateway-core:request:error')
    var name = 'microgateway-core'
    var versions = ['>=2.1 <=3.0.0']
    var requestContexts = /* @__PURE__ */ new WeakMap()
    function wrapConfigProxyFactory(configProxyFactory) {
      return function () {
        const configProxy = configProxyFactory.apply(this, arguments)
        return function (req, res, next) {
          const ctx = { req, res }
          requestContexts.set(req, ctx)
          handleChannel.publish(ctx)
          return configProxy.apply(this, arguments)
        }
      }
    }
    function wrapPluginsFactory(pluginsFactory) {
      return function (plugins) {
        const pluginsMiddleware = pluginsFactory.apply(this, arguments)
        return function pluginsMiddlewareWithTrace(req, res, next) {
          arguments[2] = wrapNext(req, res, next)
          return pluginsMiddleware.apply(this, arguments)
        }
      }
    }
    function wrapNext(req, res, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function nextWithTrace(err) {
            const ctx = requestContexts.get(req)
            if (err) {
              ctx.error = err
              errorChannel.publish(ctx)
            }
            if (res.proxy && res.proxy.base_path) {
              ctx.req = req
              ctx.res = res
              ctx.route = res.proxy.base_path
              routeChannel.publish(ctx)
            }
            return next2.apply(this, arguments)
          }
      )
    }
    addHook({ name, versions, file: 'lib/config-proxy-middleware.js' }, (configProxyFactory) => {
      return shimmer.wrapFunction(configProxyFactory, wrapConfigProxyFactory)
    })
    addHook({ name, versions, file: 'lib/plugins-middleware.js' }, (pluginsFactory) => {
      return shimmer.wrapFunction(pluginsFactory, wrapPluginsFactory)
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/utils.js
var require_utils2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/utils.js'(exports2, module2) {
    'use strict'
    var { getTestSuitePath } = require_test()
    var { channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var testStartCh = channel('ci:mocha:test:start')
    var testFinishCh = channel('ci:mocha:test:finish')
    var testRetryCh = channel('ci:mocha:test:retry')
    var errorCh = channel('ci:mocha:test:error')
    var skipCh = channel('ci:mocha:test:skip')
    var testFnCh = channel('ci:mocha:test:fn')
    var isModifiedCh = channel('ci:mocha:test:is-modified')
    var testSuiteErrorCh = channel('ci:mocha:test-suite:error')
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 200
    var testToContext = /* @__PURE__ */ new WeakMap()
    var originalFns = /* @__PURE__ */ new WeakMap()
    var testToStartLine = /* @__PURE__ */ new WeakMap()
    var testFileToSuiteCtx = /* @__PURE__ */ new Map()
    var wrappedFunctions = /* @__PURE__ */ new WeakSet()
    var newTests = {}
    var testsAttemptToFix = /* @__PURE__ */ new Set()
    var testsQuarantined = /* @__PURE__ */ new Set()
    var testsStatuses = /* @__PURE__ */ new Map()
    function getAfterEachHooks(testOrHook) {
      const hooks = []
      while (testOrHook.parent) {
        if (testOrHook.parent._afterEach) {
          hooks.push(...testOrHook.parent._afterEach)
        }
        testOrHook = testOrHook.parent
      }
      return hooks
    }
    function getTestProperties(test, testManagementTests) {
      const testSuite = getTestSuitePath(test.file, process.cwd())
      const testName = test.fullTitle()
      const {
        attempt_to_fix: isAttemptToFix,
        disabled: isDisabled,
        quarantined: isQuarantined,
      } = testManagementTests?.mocha?.suites?.[testSuite]?.tests?.[testName]?.properties || {}
      return { isAttemptToFix, isDisabled, isQuarantined }
    }
    function isNewTest(test, knownTests) {
      if (!knownTests?.mocha) {
        return false
      }
      const testSuite = getTestSuitePath(test.file, process.cwd())
      const testName = test.fullTitle()
      const testsForSuite = knownTests.mocha?.[testSuite] || []
      return !testsForSuite.includes(testName)
    }
    function retryTest(test, numRetries, tags) {
      const suite = test.parent
      for (let retryIndex = 0; retryIndex < numRetries; retryIndex++) {
        const clonedTest = test.clone()
        suite.addTest(clonedTest)
        tags.forEach((tag) => {
          if (tag) {
            clonedTest[tag] = true
          }
        })
      }
    }
    function getSuitesByTestFile(root) {
      const suitesByTestFile = {}
      function getSuites(suite) {
        if (suite.file) {
          if (suitesByTestFile[suite.file]) {
            suitesByTestFile[suite.file].push(suite)
          } else {
            suitesByTestFile[suite.file] = [suite]
          }
        }
        suite.suites.forEach((suite2) => {
          getSuites(suite2)
        })
      }
      getSuites(root)
      const numSuitesByTestFile = Object.keys(suitesByTestFile).reduce((acc, testFile) => {
        acc[testFile] = suitesByTestFile[testFile].length
        return acc
      }, {})
      return { suitesByTestFile, numSuitesByTestFile }
    }
    function isMochaRetry(test) {
      return test._currentRetry !== void 0 && test._currentRetry !== 0
    }
    function getIsLastRetry(test) {
      return test._currentRetry === test._retries
    }
    function getTestFullName(test) {
      return `mocha.${getTestSuitePath(test.file, process.cwd())}.${test.fullTitle()}`
    }
    function getTestStatus(test) {
      if (test.isPending()) {
        return 'skip'
      }
      if (test.isFailed() || test.timedOut) {
        return 'fail'
      }
      return 'pass'
    }
    function getTestToContextKey(test) {
      if (!test.fn) {
        return test
      }
      if (!wrappedFunctions.has(test.fn)) {
        return test.fn
      }
      const originalFn = originalFns.get(test.fn)
      return originalFn
    }
    function getTestContext(test) {
      const key = getTestToContextKey(test)
      return testToContext.get(key)
    }
    function runnableWrapper(RunnablePackage, libraryConfig) {
      shimmer.wrap(
        RunnablePackage.prototype,
        'run',
        (run) =>
          function () {
            if (!testFinishCh.hasSubscribers) {
              return run.apply(this, arguments)
            }
            if (libraryConfig?.isFlakyTestRetriesEnabled) {
              this.retries(libraryConfig?.flakyTestRetriesCount)
            }
            const isBeforeEach = this.parent._beforeEach.includes(this)
            const isAfterEach = this.parent._afterEach.includes(this)
            const isTestHook = isBeforeEach || isAfterEach
            if (wrappedFunctions.has(this.fn)) {
              const originalFn = originalFns.get(this.fn)
              this.fn = originalFn
              wrappedFunctions.delete(this.fn)
            }
            if (isTestHook || this.type === 'test') {
              const test = isTestHook ? this.ctx.currentTest : this
              const ctx = getTestContext(test)
              if (ctx) {
                const newFn = shimmer.wrapFunction(
                  this.fn,
                  (originalFn) =>
                    function () {
                      return testFnCh.runStores(ctx, () => originalFn.apply(this, arguments))
                    }
                )
                originalFns.set(newFn, this.fn)
                this.fn = newFn
                wrappedFunctions.add(this.fn)
              }
            }
            return run.apply(this, arguments)
          }
      )
      return RunnablePackage
    }
    function getOnTestHandler(isMain) {
      return function (test) {
        const testStartLine = testToStartLine.get(test)
        if (wrappedFunctions.has(test.fn)) {
          const originalFn = originalFns.get(test.fn)
          test.fn = originalFn
          wrappedFunctions.delete(test.fn)
        }
        const {
          file: testSuiteAbsolutePath,
          title,
          _ddIsNew: isNew,
          _ddIsEfdRetry: isEfdRetry,
          _ddIsAttemptToFix: isAttemptToFix,
          _ddIsDisabled: isDisabled,
          _ddIsQuarantined: isQuarantined,
          _ddIsModified: isModified,
        } = test
        const testInfo = {
          testName: test.fullTitle(),
          testSuiteAbsolutePath,
          title,
          testStartLine,
        }
        if (!isMain) {
          testInfo.isParallel = true
        }
        testInfo.isNew = isNew
        testInfo.isEfdRetry = isEfdRetry
        testInfo.isAttemptToFix = isAttemptToFix
        testInfo.isDisabled = isDisabled
        testInfo.isQuarantined = isQuarantined
        testInfo.isModified = isModified
        if (isNew) {
          const testFullName = getTestFullName(test)
          if (newTests[testFullName]) {
            newTests[testFullName].push(test)
          } else {
            newTests[testFullName] = [test]
          }
        }
        if (!isAttemptToFix && isDisabled) {
          test.pending = true
        }
        const ctx = testInfo
        testToContext.set(test.fn, ctx)
        testStartCh.runStores(ctx, () => {})
      }
    }
    function getOnTestEndHandler(config) {
      return async function (test) {
        const ctx = getTestContext(test)
        const status = getTestStatus(test)
        if (test._ddShouldWaitForHitProbe || test._retriedTest?._ddShouldWaitForHitProbe) {
          await new Promise((resolve) => {
            setTimeout(() => {
              resolve()
            }, BREAKPOINT_HIT_GRACE_PERIOD_MS)
          })
        }
        let hasFailedAllRetries = false
        let attemptToFixPassed = false
        let attemptToFixFailed = false
        const testName = getTestFullName(test)
        if (testsStatuses.get(testName)) {
          testsStatuses.get(testName).push(status)
        } else {
          testsStatuses.set(testName, [status])
        }
        const testStatuses = testsStatuses.get(testName)
        const isLastAttempt = testStatuses.length === config.testManagementAttemptToFixRetries + 1
        if (test._ddIsAttemptToFix && isLastAttempt) {
          if (testStatuses.includes('fail')) {
            attemptToFixFailed = true
          }
          if (testStatuses.every((status2) => status2 === 'fail')) {
            hasFailedAllRetries = true
          } else if (testStatuses.every((status2) => status2 === 'pass')) {
            attemptToFixPassed = true
          }
        }
        const isAttemptToFixRetry = test._ddIsAttemptToFix && testStatuses.length > 1
        const isAtrRetry = config.isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry
        if (ctx && !getAfterEachHooks(test).length) {
          testFinishCh.publish({
            status,
            hasBeenRetried: isMochaRetry(test),
            isLastRetry: getIsLastRetry(test),
            hasFailedAllRetries,
            attemptToFixPassed,
            attemptToFixFailed,
            isAttemptToFixRetry,
            isAtrRetry,
            ...ctx.currentStore,
          })
        }
      }
    }
    function getOnHookEndHandler() {
      return function (hook) {
        const test = hook.ctx.currentTest
        const afterEachHooks = getAfterEachHooks(hook)
        if (test && afterEachHooks.includes(hook)) {
          const isLastAfterEach = afterEachHooks.indexOf(hook) === afterEachHooks.length - 1
          if (isLastAfterEach) {
            const status = getTestStatus(test)
            const ctx = getTestContext(test)
            if (ctx) {
              testFinishCh.publish({
                status,
                hasBeenRetried: isMochaRetry(test),
                isLastRetry: getIsLastRetry(test),
                ...ctx.currentStore,
              })
            }
          }
        }
      }
    }
    function getOnFailHandler(isMain) {
      return function (testOrHook, err) {
        const testFile = testOrHook.file
        let test = testOrHook
        const isHook = testOrHook.type === 'hook'
        if (isHook && testOrHook.ctx) {
          test = testOrHook.ctx.currentTest
        }
        let testContext
        if (test) {
          testContext = getTestContext(test)
        }
        if (testContext) {
          if (isHook) {
            err.message = `${testOrHook.fullTitle()}: ${err.message}`
            testContext.err = err
            errorCh.runStores(testContext, () => {})
            testFinishCh.publish({ status: 'fail', hasBeenRetried: isMochaRetry(test), ...testContext.currentStore })
          } else {
            testContext.err = err
            errorCh.runStores(testContext, () => {})
          }
        }
        if (isMain) {
          const testSuiteContext = testFileToSuiteCtx.get(testFile)
          if (testSuiteContext) {
            const testSuiteError = new Error(`"${testOrHook.parent.fullTitle()}" failed with message "${err.message}"`)
            testSuiteError.stack = err.stack
            testSuiteContext.error = testSuiteError
            testSuiteErrorCh.runStores(testSuiteContext, () => {})
          }
        }
      }
    }
    function getOnTestRetryHandler(config) {
      return function (test, err) {
        const ctx = getTestContext(test)
        if (ctx) {
          const isFirstAttempt = test._currentRetry === 0
          const willBeRetried = test._currentRetry < test._retries
          const isAtrRetry =
            !isFirstAttempt && config.isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry
          testRetryCh.publish({ isFirstAttempt, err, willBeRetried, test, isAtrRetry, ...ctx.currentStore })
        }
        const key = getTestToContextKey(test)
        testToContext.delete(key)
      }
    }
    function getOnPendingHandler() {
      return function (test) {
        const testStartLine = testToStartLine.get(test)
        const { file: testSuiteAbsolutePath, title } = test
        const testInfo = {
          testName: test.fullTitle(),
          testSuiteAbsolutePath,
          title,
          testStartLine,
        }
        const ctx = getTestContext(test)
        if (ctx) {
          skipCh.publish(testInfo)
        } else {
          const testCtx = testInfo
          if (test.fn) {
            testToContext.set(test.fn, testCtx)
          } else {
            testToContext.set(test, testCtx)
          }
          skipCh.runStores(testCtx, () => {})
        }
      }
    }
    function getRunTestsWrapper(runTests, config) {
      return function (suite) {
        if (config.isTestManagementTestsEnabled) {
          suite.tests.forEach((test) => {
            const { isAttemptToFix, isDisabled, isQuarantined } = getTestProperties(test, config.testManagementTests)
            if (isAttemptToFix && !test.isPending()) {
              test._ddIsAttemptToFix = true
              test._ddIsDisabled = isDisabled
              test._ddIsQuarantined = isQuarantined
              testsAttemptToFix.add(test)
              retryTest(test, config.testManagementAttemptToFixRetries, [
                '_ddIsAttemptToFix',
                isDisabled && '_ddIsDisabled',
                isQuarantined && '_ddIsQuarantined',
              ])
            } else if (isDisabled) {
              test._ddIsDisabled = true
            } else if (isQuarantined) {
              testsQuarantined.add(test)
              test._ddIsQuarantined = true
            }
          })
        }
        if (config.isImpactedTestsEnabled) {
          suite.tests.forEach((test) => {
            isModifiedCh.publish({
              modifiedFiles: config.modifiedFiles,
              file: suite.file,
              onDone: (isModified) => {
                if (isModified) {
                  test._ddIsModified = true
                  if (!test.isPending() && !test._ddIsAttemptToFix && config.isEarlyFlakeDetectionEnabled) {
                    retryTest(test, config.earlyFlakeDetectionNumRetries, ['_ddIsModified', '_ddIsEfdRetry'])
                  }
                }
              },
            })
          })
        }
        if (config.isKnownTestsEnabled) {
          suite.tests.forEach((test) => {
            if (!test.isPending() && isNewTest(test, config.knownTests)) {
              test._ddIsNew = true
              if (config.isEarlyFlakeDetectionEnabled && !test._ddIsAttemptToFix && !test._ddIsModified) {
                retryTest(test, config.earlyFlakeDetectionNumRetries, ['_ddIsNew', '_ddIsEfdRetry'])
              }
            }
          })
        }
        return runTests.apply(this, arguments)
      }
    }
    module2.exports = {
      isNewTest,
      getTestProperties,
      getSuitesByTestFile,
      isMochaRetry,
      getTestFullName,
      getTestStatus,
      runnableWrapper,
      testToContext,
      originalFns,
      getTestContext,
      testToStartLine,
      getOnTestHandler,
      getOnTestEndHandler,
      getOnTestRetryHandler,
      getOnHookEndHandler,
      getOnFailHandler,
      getOnPendingHandler,
      testFileToSuiteCtx,
      getRunTestsWrapper,
      newTests,
      testsQuarantined,
      testsAttemptToFix,
      testsStatuses,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/stacktrace.js
var require_stacktrace = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/stacktrace.js'(exports2, module2) {
    'use strict'
    var { relative, sep, join } = require('path')
    var cwd = process.cwd()
    var NODE_MODULES_PATTERN_MIDDLE = `${sep}node_modules${sep}`
    var NODE_MODULES_PATTERN_START = `node_modules${sep}`
    var SHOULD_FILTER_DD_TRACE_INSTRUMENTAION = __filename.endsWith(
      join(sep, 'dd-trace-js', 'packages', 'dd-trace', 'src', 'plugins', 'util', 'stacktrace.js')
    )
    module2.exports = {
      getCallSites,
      parseUserLandFrames,
    }
    function getCallSites(constructorOpt) {
      const oldLimit = Error.stackTraceLimit
      Error.stackTraceLimit = Infinity
      const dummy = {}
      const v8Handler = Error.prepareStackTrace
      Error.prepareStackTrace = function (_, v8StackTrace2) {
        return v8StackTrace2
      }
      Error.captureStackTrace(dummy, constructorOpt)
      const v8StackTrace = dummy.stack
      Error.prepareStackTrace = v8Handler
      Error.stackTraceLimit = oldLimit
      return v8StackTrace
    }
    function parseUserLandFrames(stack, limit = Infinity) {
      let index = stack.indexOf('\n    at ')
      const frames = []
      while (index !== -1 && frames.length !== limit) {
        const nextIndex = stack.indexOf('\n', index + 1)
        const frame = parseLine(stack, index, nextIndex === -1 ? stack.length : nextIndex)
        if (frame !== void 0) frames.push(frame)
        index = nextIndex
      }
      return frames
    }
    function parseLine(stack, start, end) {
      let index
      if (stack[end - 1] === ')') {
        index = end - 2
        const code = stack.charCodeAt(index)
        if (code < 48 || code > 57) return
      } else {
        index = end - 1
      }
      start += 8
      if (stack.startsWith('new ', start)) start += 4
      else if (stack.startsWith('async ', start)) start += 6
      let fileName, lineNumber, columnNumber
      const result = parseLocation(stack, start, index)
      if (result === void 0) return
      ;[fileName, lineNumber, columnNumber, index] = result
      if (isNodeModulesFrame(fileName)) return
      if (SHOULD_FILTER_DD_TRACE_INSTRUMENTAION && isDDInstrumentationFile(fileName)) return
      let methodName, functionName
      if (stack[index] === ']') {
        methodName = ''
        index--
        for (; index >= start; index--) {
          const char = stack[index]
          if (char === ' ' && stack.slice(index - 4, index) === ' [as') {
            index -= 4
            break
          } else if (char === '[') {
            functionName = `${stack.slice(start, index)}[${methodName}]`
            methodName = void 0
            break
          }
          methodName = char + methodName
        }
        index--
      }
      functionName ??= start <= index ? stack.slice(start, index + 1) : void 0
      let typeName
      if (functionName !== void 0 && functionName[0] !== '[') {
        const periodIndex = functionName.indexOf('.')
        if (periodIndex !== -1) {
          typeName = functionName.slice(0, periodIndex)
          functionName = functionName.slice(periodIndex + 1)
        }
      }
      return {
        lineNumber,
        columnNumber,
        fileName,
        methodName,
        functionName,
        typeName,
      }
    }
    function isNodeModulesFrame(fileName) {
      if (!fileName.includes(NODE_MODULES_PATTERN_MIDDLE)) {
        return false
      }
      const actualPath = fileName.startsWith('file:') ? fileName.slice(7) : fileName
      const relativePath = relative(cwd, actualPath)
      return relativePath.startsWith(NODE_MODULES_PATTERN_START) || relativePath.includes(NODE_MODULES_PATTERN_MIDDLE)
    }
    function isDDInstrumentationFile(fileName) {
      return fileName.includes(`packages${sep}datadog-instrumentations${sep}src`)
    }
    function parseLocation(stack, start, index) {
      let columnNumber = ''
      for (; index >= start; index--) {
        const code = stack.charCodeAt(index)
        if (code === 41) {
          continue
        }
        if (code < 48 || code > 57) break
        columnNumber = stack[index] + columnNumber
      }
      index--
      let lineNumber = ''
      for (; index >= start; index--) {
        const code = stack.charCodeAt(index)
        if (code < 48 || code > 57) break
        lineNumber = stack[index] + lineNumber
      }
      index--
      let nestedParenthesis = 1
      let fileName = ''
      for (; index >= start; index--) {
        const char = stack[index]
        if (char === ')') {
          nestedParenthesis++
        } else if (char === '(' && --nestedParenthesis === 0) {
          index -= 2
          break
        } else if (nestedParenthesis === 1 && char === ':' && stack.slice(index - 4, index) === 'node') {
          return
        }
        fileName = char + fileName
      }
      if (fileName.startsWith('eval at ')) {
        const result = parseLocation(fileName, 0, fileName.lastIndexOf(',') - 2)
        if (result === void 0) return
        ;[fileName, lineNumber, columnNumber] = result
      }
      return [
        fileName,
        lineNumber,
        columnNumber,
        index,
        // return the index, so the caller knows how far we got
      ]
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/common.js
var require_common = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/common.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { getCallSites } = require_stacktrace()
    var { testToStartLine } = require_utils2()
    var parameterizedTestCh = channel('ci:mocha:test:parameterize')
    var patched = /* @__PURE__ */ new WeakSet()
    addHook(
      {
        name: 'mocha-each',
        versions: ['>=2.0.1'],
      },
      (mochaEach) => {
        if (patched.has(mochaEach)) return mochaEach
        patched.add(mochaEach)
        return shimmer.wrapFunction(
          mochaEach,
          (mochaEach2) =>
            function () {
              const [params] = arguments
              const { it, ...rest } = mochaEach2.apply(this, arguments)
              return {
                it: function (title) {
                  parameterizedTestCh.publish({ title, params })
                  it.apply(this, arguments)
                },
                ...rest,
              }
            }
        )
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=5.2.0'],
        file: 'lib/suite.js',
      },
      (Suite) => {
        shimmer.wrap(
          Suite.prototype,
          'addTest',
          (addTest) =>
            function (test) {
              const callSites = getCallSites()
              let startLine
              const testCallSite = callSites.find((site) => site.getFileName() === test.file)
              if (testCallSite) {
                startLine = testCallSite.getLineNumber()
                testToStartLine.set(test, startLine)
              }
              return addTest.apply(this, arguments)
            }
        )
        return Suite
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/worker.js
var require_worker = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/worker.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var {
      runnableWrapper,
      getOnTestHandler,
      getOnTestEndHandler,
      getOnHookEndHandler,
      getOnFailHandler,
      getOnPendingHandler,
      getRunTestsWrapper,
    } = require_utils2()
    require_common()
    var workerFinishCh = channel('ci:mocha:worker:finish')
    var config = {}
    addHook(
      {
        name: 'mocha',
        versions: ['>=8.0.0'],
        file: 'lib/mocha.js',
      },
      (Mocha) => {
        shimmer.wrap(
          Mocha.prototype,
          'run',
          (run) =>
            function () {
              if (this.options._ddIsKnownTestsEnabled) {
                config.isKnownTestsEnabled = true
                config.isEarlyFlakeDetectionEnabled = this.options._ddIsEfdEnabled
                config.knownTests = this.options._ddKnownTests
                config.earlyFlakeDetectionNumRetries = this.options._ddEfdNumRetries
                delete this.options._ddIsEfdEnabled
                delete this.options._ddKnownTests
                delete this.options._ddEfdNumRetries
                delete this.options._ddIsKnownTestsEnabled
              }
              if (this.options._ddIsImpactedTestsEnabled) {
                config.isImpactedTestsEnabled = true
                config.modifiedFiles = this.options._ddModifiedFiles
                delete this.options._ddIsImpactedTestsEnabled
                delete this.options._ddModifiedFiles
              }
              if (this.options._ddIsTestManagementTestsEnabled) {
                config.isTestManagementTestsEnabled = true
                config.testManagementTests = this.options._ddTestManagementTests
                delete this.options._ddIsTestManagementTestsEnabled
                delete this.options._ddTestManagementTests
              }
              return run.apply(this, arguments)
            }
        )
        return Mocha
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=5.2.0'],
        file: 'lib/runner.js',
      },
      function (Runner) {
        shimmer.wrap(Runner.prototype, 'runTests', (runTests) => getRunTestsWrapper(runTests, config))
        shimmer.wrap(
          Runner.prototype,
          'run',
          (run) =>
            function () {
              if (!workerFinishCh.hasSubscribers) {
                return run.apply(this, arguments)
              }
              this.on('end', () => {
                workerFinishCh.publish()
              })
              this.on('test', getOnTestHandler(false))
              this.on('test end', getOnTestEndHandler(config))
              this.on('hook end', getOnHookEndHandler())
              this.on('fail', getOnFailHandler(false))
              this.on('pending', getOnPendingHandler())
              return run.apply(this, arguments)
            }
        )
        return Runner
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=5.2.0'],
        file: 'lib/runnable.js',
      },
      runnableWrapper
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/main.js
var require_main = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mocha/main.js'() {
    'use strict'
    var { createCoverageMap } = require_istanbul_lib_coverage()
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { isMarkedAsUnskippable } = require_util3()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      getTestSuitePath,
      MOCHA_WORKER_TRACE_PAYLOAD_CODE,
      fromCoverageMapToCoverage,
      getCoveredFilenamesFromCoverage,
      mergeCoverage,
      resetCoverage,
      getIsFaultyEarlyFlakeDetection,
    } = require_test()
    var {
      isNewTest,
      getTestProperties,
      getSuitesByTestFile,
      runnableWrapper,
      getOnTestHandler,
      getOnTestEndHandler,
      getOnTestRetryHandler,
      getOnHookEndHandler,
      getOnFailHandler,
      getOnPendingHandler,
      testFileToSuiteCtx,
      newTests,
      testsQuarantined,
      getTestFullName,
      getRunTestsWrapper,
      testsAttemptToFix,
      testsStatuses,
    } = require_utils2()
    require_common()
    var patched = /* @__PURE__ */ new WeakSet()
    var unskippableSuites = []
    var suitesToSkip = []
    var isSuitesSkipped = false
    var skippedSuites = []
    var itrCorrelationId = ''
    var isForcedToRun = false
    var config = {}
    var originalCoverageMap = createCoverageMap()
    var untestedCoverage
    var testFinishCh = channel('ci:mocha:test:finish')
    var testSuiteStartCh = channel('ci:mocha:test-suite:start')
    var testSuiteFinishCh = channel('ci:mocha:test-suite:finish')
    var testSuiteErrorCh = channel('ci:mocha:test-suite:error')
    var testSuiteCodeCoverageCh = channel('ci:mocha:test-suite:code-coverage')
    var libraryConfigurationCh = channel('ci:mocha:library-configuration')
    var knownTestsCh = channel('ci:mocha:known-tests')
    var skippableSuitesCh = channel('ci:mocha:test-suite:skippable')
    var mochaGlobalRunCh = channel('ci:mocha:global:run')
    var testManagementTestsCh = channel('ci:mocha:test-management-tests')
    var modifiedFilesCh = channel('ci:mocha:modified-files')
    var workerReportTraceCh = channel('ci:mocha:worker-report:trace')
    var testSessionStartCh = channel('ci:mocha:session:start')
    var testSessionFinishCh = channel('ci:mocha:session:finish')
    var itrSkippedSuitesCh = channel('ci:mocha:itr:skipped-suites')
    var getCodeCoverageCh = channel('ci:nyc:get-coverage')
    function isTestFailed(test) {
      if (test.isFailed) {
        return test.isFailed()
      }
      if (test.isPending) {
        return !test.isPending() && test.state === 'failed'
      }
      return false
    }
    function getFilteredSuites(originalSuites) {
      return originalSuites.reduce(
        (acc, suite) => {
          const testPath = getTestSuitePath(suite.file, process.cwd())
          const shouldSkip = suitesToSkip.includes(testPath)
          const isUnskippable = unskippableSuites.includes(suite.file)
          if (shouldSkip && !isUnskippable) {
            acc.skippedSuites.add(testPath)
          } else {
            acc.suitesToRun.push(suite)
          }
          return acc
        },
        { suitesToRun: [], skippedSuites: /* @__PURE__ */ new Set() }
      )
    }
    function getOnStartHandler(isParallel, frameworkVersion) {
      return function () {
        const processArgv = process.argv.slice(2).join(' ')
        const command = `mocha ${processArgv}`
        testSessionStartCh.publish({ command, frameworkVersion })
        if (!isParallel && skippedSuites.length) {
          itrSkippedSuitesCh.publish({ skippedSuites, frameworkVersion })
        }
      }
    }
    function getOnEndHandler(isParallel) {
      return function () {
        let status = 'pass'
        let error
        if (this.stats) {
          status = this.stats.failures === 0 ? 'pass' : 'fail'
          if (this.stats.tests === 0) {
            status = 'skip'
          }
        } else if (this.failures !== 0) {
          status = 'fail'
        }
        if (config.isEarlyFlakeDetectionEnabled) {
          for (const tests of Object.values(newTests)) {
            const failingNewTests = tests.filter((test) => isTestFailed(test))
            const areAllNewTestsFailing = failingNewTests.length === tests.length
            if (failingNewTests.length && !areAllNewTestsFailing) {
              this.stats.failures -= failingNewTests.length
              this.failures -= failingNewTests.length
            }
          }
        }
        if (config.isTestManagementTestsEnabled) {
          let numFailedQuarantinedTests = 0
          let numFailedRetriedQuarantinedOrDisabledTests = 0
          for (const test of testsAttemptToFix) {
            const testName = getTestFullName(test)
            const testProperties = getTestProperties(test, config.testManagementTests)
            if (isTestFailed(test) && (testProperties.isQuarantined || testProperties.isDisabled)) {
              const numFailedTests = testsStatuses.get(testName).filter((status2) => status2 === 'fail').length
              numFailedRetriedQuarantinedOrDisabledTests += numFailedTests
            }
          }
          for (const test of testsQuarantined) {
            if (isTestFailed(test)) {
              numFailedQuarantinedTests++
            }
          }
          this.stats.failures -= numFailedQuarantinedTests + numFailedRetriedQuarantinedOrDisabledTests
          this.failures -= numFailedQuarantinedTests + numFailedRetriedQuarantinedOrDisabledTests
        }
        if (status === 'fail') {
          error = new Error(`Failed tests: ${this.failures}.`)
        }
        testFileToSuiteCtx.clear()
        let testCodeCoverageLinesTotal
        if (global.__coverage__) {
          try {
            if (untestedCoverage) {
              originalCoverageMap.merge(fromCoverageMapToCoverage(untestedCoverage))
            }
            testCodeCoverageLinesTotal = originalCoverageMap.getCoverageSummary().lines.pct
          } catch {}
          global.__coverage__ = fromCoverageMapToCoverage(originalCoverageMap)
        }
        testSessionFinishCh.publish({
          status,
          isSuitesSkipped,
          testCodeCoverageLinesTotal,
          numSkippedSuites: skippedSuites.length,
          hasForcedToRunSuites: isForcedToRun,
          hasUnskippableSuites: !!unskippableSuites.length,
          error,
          isEarlyFlakeDetectionEnabled: config.isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty: config.isEarlyFlakeDetectionFaulty,
          isTestManagementEnabled: config.isTestManagementTestsEnabled,
          isParallel,
        })
      }
    }
    function getExecutionConfiguration(runner, isParallel, frameworkVersion, onFinishRequest) {
      const ctx = {
        isParallel,
        frameworkVersion,
      }
      const onReceivedSkippableSuites = ({ err, skippableSuites, itrCorrelationId: responseItrCorrelationId }) => {
        if (err) {
          suitesToSkip = []
        } else {
          suitesToSkip = skippableSuites
          itrCorrelationId = responseItrCorrelationId
        }
        const filteredSuites = getFilteredSuites(runner.suite.suites)
        const { suitesToRun } = filteredSuites
        isSuitesSkipped = suitesToRun.length !== runner.suite.suites.length
        log.debug(() => `${suitesToRun.length} out of ${runner.suite.suites.length} suites are going to run.`)
        runner.suite.suites = suitesToRun
        skippedSuites = [...filteredSuites.skippedSuites]
        mochaGlobalRunCh.runStores(ctx, () => {
          onFinishRequest()
        })
      }
      const onReceivedImpactedTests = ({ err, modifiedFiles: receivedModifiedFiles }) => {
        if (err) {
          config.modifiedFiles = []
          config.isImpactedTestsEnabled = false
        } else {
          config.modifiedFiles = receivedModifiedFiles
        }
        if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites
          skippableSuitesCh.runStores(ctx, () => {})
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest()
          })
        }
      }
      const onReceivedTestManagementTests = ({ err, testManagementTests: receivedTestManagementTests }) => {
        if (err) {
          config.testManagementTests = {}
          config.isTestManagementTestsEnabled = false
          config.testManagementAttemptToFixRetries = 0
        } else {
          config.testManagementTests = receivedTestManagementTests
        }
        if (config.isImpactedTestsEnabled) {
          ctx.onDone = onReceivedImpactedTests
          modifiedFilesCh.runStores(ctx, () => {})
        } else if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites
          skippableSuitesCh.runStores(ctx, () => {})
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest()
          })
        }
      }
      const onReceivedKnownTests = ({ err, knownTests }) => {
        if (err) {
          config.knownTests = []
          config.isEarlyFlakeDetectionEnabled = false
          config.isKnownTestsEnabled = false
        } else {
          config.knownTests = knownTests
        }
        if (config.isTestManagementTestsEnabled) {
          ctx.onDone = onReceivedTestManagementTests
          testManagementTestsCh.runStores(ctx, () => {})
        }
        if (config.isImpactedTestsEnabled) {
          ctx.onDone = onReceivedImpactedTests
          modifiedFilesCh.runStores(ctx, () => {})
        } else if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites
          skippableSuitesCh.runStores(ctx, () => {})
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest()
          })
        }
      }
      const onReceivedConfiguration = ({ err, libraryConfig }) => {
        if (err || !skippableSuitesCh.hasSubscribers || !knownTestsCh.hasSubscribers) {
          return mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest()
          })
        }
        config.isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled
        config.earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries
        config.earlyFlakeDetectionFaultyThreshold = libraryConfig.earlyFlakeDetectionFaultyThreshold
        config.isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled
        config.isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled
        config.testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries
        config.isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled
        config.isSuitesSkippingEnabled = !isParallel && libraryConfig.isSuitesSkippingEnabled
        config.isFlakyTestRetriesEnabled = !isParallel && libraryConfig.isFlakyTestRetriesEnabled
        config.flakyTestRetriesCount = !isParallel && libraryConfig.flakyTestRetriesCount
        if (config.isKnownTestsEnabled) {
          ctx.onDone = onReceivedKnownTests
          knownTestsCh.runStores(ctx, () => {})
        } else if (config.isTestManagementTestsEnabled) {
          ctx.onDone = onReceivedTestManagementTests
          testManagementTestsCh.runStores(ctx, () => {})
        } else if (config.isImpactedTestsEnabled) {
          ctx.onDone = onReceivedImpactedTests
          modifiedFilesCh.runStores(ctx, () => {})
        } else if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites
          skippableSuitesCh.runStores(ctx, () => {})
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest()
          })
        }
      }
      ctx.onDone = onReceivedConfiguration
      libraryConfigurationCh.runStores(ctx, () => {})
    }
    addHook(
      {
        name: 'mocha',
        versions: ['>=5.2.0'],
        file: 'lib/mocha.js',
      },
      (Mocha, frameworkVersion) => {
        shimmer.wrap(
          Mocha.prototype,
          'run',
          (run) =>
            function () {
              if (!testFinishCh.hasSubscribers || getEnvironmentVariable('MOCHA_WORKER_ID') || this.options.parallel) {
                return run.apply(this, arguments)
              }
              this.options.delay = true
              const runner = run.apply(this, arguments)
              this.files.forEach((path) => {
                const isUnskippable = isMarkedAsUnskippable({ path })
                if (isUnskippable) {
                  unskippableSuites.push(path)
                }
              })
              getExecutionConfiguration(runner, false, frameworkVersion, () => {
                if (config.isKnownTestsEnabled) {
                  const testSuites = this.files.map((file) => getTestSuitePath(file, process.cwd()))
                  const isFaulty = getIsFaultyEarlyFlakeDetection(
                    testSuites,
                    config.knownTests?.mocha || {},
                    config.earlyFlakeDetectionFaultyThreshold
                  )
                  if (isFaulty) {
                    config.isEarlyFlakeDetectionEnabled = false
                    config.isEarlyFlakeDetectionFaulty = true
                    config.isKnownTestsEnabled = false
                  }
                }
                if (getCodeCoverageCh.hasSubscribers) {
                  getCodeCoverageCh.publish({
                    onDone: (receivedCodeCoverage) => {
                      untestedCoverage = receivedCodeCoverage
                      global.run()
                    },
                  })
                } else {
                  global.run()
                }
              })
              return runner
            }
        )
        return Mocha
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=5.2.0'],
        file: 'lib/cli/run-helpers.js',
      },
      (run) => {
        shimmer.wrap(
          run,
          'runMocha',
          (runMocha) =>
            function () {
              if (!testFinishCh.hasSubscribers) {
                return runMocha.apply(this, arguments)
              }
              const mocha = arguments[0]
              if (!mocha.options.parallel) {
                mocha.options.delay = true
              }
              return runMocha.apply(this, arguments)
            }
        )
        return run
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=5.2.0'],
        file: 'lib/runner.js',
      },
      function (Runner, frameworkVersion) {
        if (patched.has(Runner)) return Runner
        patched.add(Runner)
        shimmer.wrap(Runner.prototype, 'runTests', (runTests) => getRunTestsWrapper(runTests, config))
        shimmer.wrap(
          Runner.prototype,
          'run',
          (run) =>
            function () {
              if (!testFinishCh.hasSubscribers) {
                return run.apply(this, arguments)
              }
              const { suitesByTestFile, numSuitesByTestFile } = getSuitesByTestFile(this.suite)
              this.once('start', getOnStartHandler(false, frameworkVersion))
              this.once('end', getOnEndHandler(false))
              this.on('test', getOnTestHandler(true))
              this.on('test end', getOnTestEndHandler(config))
              this.on('retry', getOnTestRetryHandler(config))
              this.on('hook end', getOnHookEndHandler())
              this.on('fail', getOnFailHandler(true))
              this.on('pending', getOnPendingHandler())
              this.on('suite', function (suite) {
                if (suite.root || !suite.tests.length) {
                  return
                }
                let ctx = testFileToSuiteCtx.get(suite.file)
                if (!ctx) {
                  const isUnskippable = unskippableSuites.includes(suite.file)
                  isForcedToRun = isUnskippable && suitesToSkip.includes(getTestSuitePath(suite.file, process.cwd()))
                  ctx = {
                    testSuiteAbsolutePath: suite.file,
                    isUnskippable,
                    isForcedToRun,
                    itrCorrelationId,
                  }
                  testFileToSuiteCtx.set(suite.file, ctx)
                  testSuiteStartCh.runStores(ctx, () => {})
                }
              })
              this.on('suite end', function (suite) {
                if (suite.root) {
                  return
                }
                const suitesInTestFile = suitesByTestFile[suite.file]
                const isLastSuite = --numSuitesByTestFile[suite.file] === 0
                if (!isLastSuite) {
                  return
                }
                let status = 'pass'
                if (suitesInTestFile.every((suite2) => suite2.pending)) {
                  status = 'skip'
                } else {
                  suitesInTestFile.forEach((suite2) => {
                    suite2.eachTest((test) => {
                      if (test.state === 'failed' || test.timedOut) {
                        status = 'fail'
                      }
                    })
                  })
                }
                if (global.__coverage__) {
                  const coverageFiles = getCoveredFilenamesFromCoverage(global.__coverage__)
                  testSuiteCodeCoverageCh.publish({
                    coverageFiles,
                    suiteFile: suite.file,
                  })
                  mergeCoverage(global.__coverage__, originalCoverageMap)
                  resetCoverage(global.__coverage__)
                }
                const ctx = testFileToSuiteCtx.get(suite.file)
                if (ctx) {
                  testSuiteFinishCh.publish({ status, ...ctx.currentStore }, () => {})
                } else {
                  log.warn('No ctx found for suite', suite.file)
                }
              })
              return run.apply(this, arguments)
            }
        )
        return Runner
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=5.2.0'],
        file: 'lib/runnable.js',
      },
      (runnablePackage) => runnableWrapper(runnablePackage, config)
    )
    function onMessage(message) {
      if (Array.isArray(message)) {
        const [messageCode, payload] = message
        if (messageCode === MOCHA_WORKER_TRACE_PAYLOAD_CODE) {
          workerReportTraceCh.publish(payload)
        }
      }
    }
    addHook(
      {
        name: 'workerpool',
        // mocha@8.0.0 added parallel support and uses workerpool for it
        // The version they use is 6.0.0:
        // https://github.com/mochajs/mocha/blob/612fa31228c695f16173ac675f40ccdf26b4cfb5/package.json#L75
        versions: ['>=6.0.0'],
        file: 'src/WorkerHandler.js',
      },
      (workerHandlerPackage) => {
        shimmer.wrap(
          workerHandlerPackage.prototype,
          'exec',
          (exec) =>
            function (_, path) {
              if (!testFinishCh.hasSubscribers) {
                return exec.apply(this, arguments)
              }
              if (!path?.length) {
                return exec.apply(this, arguments)
              }
              const [testSuiteAbsolutePath] = path
              const testSuiteContext = {}
              this.worker.on('message', onMessage)
              testSuiteContext.testSuiteAbsolutePath = testSuiteAbsolutePath
              testSuiteStartCh.runStores(testSuiteContext, () => {})
              try {
                const promise = exec.apply(this, arguments)
                promise.then(
                  (result) => {
                    const status = result.failureCount === 0 ? 'pass' : 'fail'
                    testSuiteFinishCh.publish({ status, ...testSuiteContext.currentStore }, () => {})
                    this.worker.off('message', onMessage)
                  },
                  (err) => {
                    testSuiteContext.error = err
                    testSuiteErrorCh.runStores(testSuiteContext, () => {})
                    testSuiteFinishCh.publish({ status: 'fail', ...testSuiteContext.currentStore }, () => {})
                    this.worker.off('message', onMessage)
                  }
                )
                return promise
              } catch (err) {
                testSuiteContext.error = err
                testSuiteErrorCh.runStores(testSuiteContext, () => {})
                testSuiteFinishCh.publish({ status: 'fail', ...testSuiteContext.currentStore }, () => {})
                this.worker.off('message', onMessage)
                throw err
              }
            }
        )
        return workerHandlerPackage
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=8.0.0'],
        file: 'lib/nodejs/parallel-buffered-runner.js',
      },
      (ParallelBufferedRunner, frameworkVersion) => {
        shimmer.wrap(
          ParallelBufferedRunner.prototype,
          'run',
          (run) =>
            function (cb, { files }) {
              if (!testFinishCh.hasSubscribers) {
                return run.apply(this, arguments)
              }
              this.once('start', getOnStartHandler(true, frameworkVersion))
              this.once('end', getOnEndHandler(true))
              getExecutionConfiguration(this, true, frameworkVersion, () => {
                if (config.isKnownTestsEnabled) {
                  const testSuites = files.map((file) => getTestSuitePath(file, process.cwd()))
                  const isFaulty = getIsFaultyEarlyFlakeDetection(
                    testSuites,
                    config.knownTests?.mocha || {},
                    config.earlyFlakeDetectionFaultyThreshold
                  )
                  if (isFaulty) {
                    config.isKnownTestsEnabled = false
                    config.isEarlyFlakeDetectionEnabled = false
                    config.isEarlyFlakeDetectionFaulty = true
                  }
                }
                run.apply(this, arguments)
              })
              return this
            }
        )
        return ParallelBufferedRunner
      }
    )
    addHook(
      {
        name: 'mocha',
        versions: ['>=8.0.0'],
        file: 'lib/nodejs/buffered-worker-pool.js',
      },
      (BufferedWorkerPoolPackage) => {
        const { BufferedWorkerPool } = BufferedWorkerPoolPackage
        shimmer.wrap(
          BufferedWorkerPool.prototype,
          'run',
          (run) =>
            async function (testSuiteAbsolutePath, workerArgs) {
              if (
                !testFinishCh.hasSubscribers ||
                (!config.isKnownTestsEnabled && !config.isTestManagementTestsEnabled && !config.isImpactedTestsEnabled)
              ) {
                return run.apply(this, arguments)
              }
              const testPath = getTestSuitePath(testSuiteAbsolutePath, process.cwd())
              const newWorkerArgs = { ...workerArgs }
              if (config.isKnownTestsEnabled) {
                if (config.knownTests?.mocha) {
                  const testSuiteKnownTests = config.knownTests.mocha[testPath] || []
                  newWorkerArgs._ddEfdNumRetries = config.earlyFlakeDetectionNumRetries
                  newWorkerArgs._ddIsEfdEnabled = config.isEarlyFlakeDetectionEnabled
                  newWorkerArgs._ddIsKnownTestsEnabled = true
                  newWorkerArgs._ddKnownTests = {
                    mocha: {
                      [testPath]: testSuiteKnownTests,
                    },
                  }
                } else {
                  config.isEarlyFlakeDetectionEnabled = false
                  config.isKnownTestsEnabled = false
                  newWorkerArgs._ddIsKnownTestsEnabled = false
                  newWorkerArgs._ddIsEfdEnabled = false
                  newWorkerArgs._ddKnownTests = {}
                }
              }
              if (config.isTestManagementTestsEnabled) {
                const testSuiteTestManagementTests = config.testManagementTests?.mocha?.suites?.[testPath] || {}
                newWorkerArgs._ddIsTestManagementTestsEnabled = true
                newWorkerArgs._ddTestManagementTests = {
                  mocha: {
                    suites: {
                      [testPath]: testSuiteTestManagementTests,
                    },
                  },
                }
              }
              if (config.isImpactedTestsEnabled) {
                newWorkerArgs._ddIsImpactedTestsEnabled = true
                newWorkerArgs._ddModifiedFiles = config.modifiedFiles || {}
              }
              const testFileResult = await run.apply(this, [testSuiteAbsolutePath, newWorkerArgs])
              const tests = testFileResult.events
                .filter((event) => event.eventName === 'test end')
                .map((event) => event.data)
              for (const test of tests) {
                if (config.isKnownTestsEnabled && isNewTest(test, config.knownTests)) {
                  const testFullName = getTestFullName(test)
                  const tests2 = newTests[testFullName]
                  if (tests2) {
                    tests2.push(test)
                  } else {
                    newTests[testFullName] = [test]
                  }
                }
                if (
                  config.isTestManagementTestsEnabled &&
                  getTestProperties(test, config.testManagementTests).isQuarantined
                ) {
                  testsQuarantined.add(test)
                }
              }
              return testFileResult
            }
        )
        return BufferedWorkerPoolPackage
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js
var require_mocha = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js'() {
    'use strict'
    var { getEnvironmentVariable } = require_config_helper()
    if (getEnvironmentVariable('MOCHA_WORKER_ID')) {
      require_worker()
    } else {
      require_main()
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/client.js
var require_client4 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/client.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startChannel = channel('apm:moleculer:call:start')
    var finishChannel = channel('apm:moleculer:call:finish')
    var errorChannel = channel('apm:moleculer:call:error')
    function wrapCall(call) {
      return function (actionName, params, opts) {
        opts = arguments[2] = opts || {}
        opts.meta = opts.meta || {}
        arguments.length = Math.max(3, arguments.length)
        const ctx = { actionName, params, opts }
        return startChannel.runStores(ctx, () => {
          const promise = call.apply(this, arguments)
          const broker = this
          ctx.promiseCtx = promise.ctx
          ctx.broker = broker
          promise.then(
            (result) => {
              finishChannel.publish(ctx)
            },
            (error) => {
              ctx.error = error
              errorChannel.publish(ctx)
              finishChannel.publish(ctx)
            }
          )
          return promise
        })
      }
    }
    addHook({ name: 'moleculer', versions: ['>=0.14'] }, (moleculer) => {
      shimmer.wrap(moleculer.ServiceBroker.prototype, 'call', wrapCall)
      return moleculer
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/server.js
var require_server4 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/server.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startChannel = channel('apm:moleculer:action:start')
    var finishChannel = channel('apm:moleculer:action:finish')
    var errorChannel = channel('apm:moleculer:action:error')
    function wrapRegisterMiddlewares(registerMiddlewares) {
      return function (userMiddlewares) {
        if (this.middlewares && this.middlewares.add) {
          this.middlewares.add(createMiddleware())
        }
        return registerMiddlewares.apply(this, arguments)
      }
    }
    function createMiddleware() {
      return {
        name: 'Datadog',
        localAction(next, action) {
          const broker = this
          return shimmer.wrapFunction(
            next,
            (next2) =>
              function datadogMiddleware(middlewareCtx) {
                const ctx = { action, middlewareCtx, broker }
                return startChannel.runStores(ctx, () => {
                  try {
                    return next2(middlewareCtx).then(
                      (result) => {
                        finishChannel.publish(ctx)
                        return result
                      },
                      (error) => {
                        ctx.error = error
                        errorChannel.publish(ctx)
                        finishChannel.publish(ctx)
                        throw error
                      }
                    )
                  } catch (e) {
                    ctx.error = e
                    errorChannel.publish(ctx)
                    finishChannel.publish(ctx)
                  }
                })
              }
          )
        },
      }
    }
    addHook({ name: 'moleculer', versions: ['>=0.14'] }, (moleculer) => {
      shimmer.wrap(moleculer.ServiceBroker.prototype, 'registerMiddlewares', wrapRegisterMiddlewares)
      return moleculer
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer.js
var require_moleculer = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer.js'() {
    'use strict'
    require_client4()
    require_server4()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js
var require_mongodb_core = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js'() {
    'use strict'
    var { channel, addHook, AsyncResource } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startCh = channel('apm:mongodb:query:start')
    var finishCh = channel('apm:mongodb:query:finish')
    var errorCh = channel('apm:mongodb:query:error')
    addHook({ name: 'mongodb-core', versions: ['2 - 3.1.9'] }, (Server) => {
      const serverProto = Server.Server.prototype
      shimmer.wrap(serverProto, 'command', (command) => wrapCommand(command, 'command'))
      shimmer.wrap(serverProto, 'insert', (insert) => wrapCommand(insert, 'insert', 'insert'))
      shimmer.wrap(serverProto, 'update', (update) => wrapCommand(update, 'update', 'update'))
      shimmer.wrap(serverProto, 'remove', (remove) => wrapCommand(remove, 'remove', 'remove'))
      const cursorProto = Server.Cursor.prototype
      shimmer.wrap(cursorProto, '_getmore', (_getmore) => wrapCursor(_getmore, 'getMore', 'getMore'))
      shimmer.wrap(cursorProto, '_find', (_find) => wrapQuery(_find, '_find'))
      shimmer.wrap(cursorProto, 'kill', (kill) => wrapCursor(kill, 'killCursors', 'killCursors'))
      return Server
    })
    addHook({ name: 'mongodb', versions: ['>=4 <4.6.0'], file: 'lib/cmap/connection.js' }, (Connection) => {
      const proto = Connection.Connection.prototype
      shimmer.wrap(proto, 'command', (command) => wrapConnectionCommand(command, 'command'))
      shimmer.wrap(proto, 'query', (query) => wrapConnectionCommand(query, 'query'))
      return Connection
    })
    addHook({ name: 'mongodb', versions: ['>=4.6.0 <6.4.0'], file: 'lib/cmap/connection.js' }, (Connection) => {
      const proto = Connection.Connection.prototype
      shimmer.wrap(proto, 'command', (command) => wrapConnectionCommand(command, 'command'))
      return Connection
    })
    addHook({ name: 'mongodb', versions: ['>=6.4.0'], file: 'lib/cmap/connection.js' }, (Connection) => {
      const proto = Connection.Connection.prototype
      shimmer.wrap(proto, 'command', (command) => wrapConnectionCommand(command, 'command', void 0, instrumentPromise))
      return Connection
    })
    addHook({ name: 'mongodb', versions: ['>=3.3 <4'], file: 'lib/core/wireprotocol/index.js' }, (wp) => wrapWp(wp))
    addHook({ name: 'mongodb-core', versions: ['>=3.2'], file: 'lib/wireprotocol/index.js' }, (wp) => wrapWp(wp))
    addHook(
      { name: 'mongodb-core', versions: ['~3.1.10'], file: 'lib/wireprotocol/3_2_support.js' },
      (WireProtocol) => {
        shimmer.wrap(WireProtocol.prototype, 'command', (command) => wrapUnifiedCommand(command, 'command'))
        return WireProtocol
      }
    )
    addHook(
      { name: 'mongodb-core', versions: ['~3.1.10'], file: 'lib/wireprotocol/2_6_support.js' },
      (WireProtocol) => {
        shimmer.wrap(WireProtocol.prototype, 'command', (command) => wrapUnifiedCommand(command, 'command'))
        return WireProtocol
      }
    )
    addHook({ name: 'mongodb', versions: ['>=3.5.4 <4.11.0'], file: 'lib/utils.js' }, (util) => {
      shimmer.wrap(
        util,
        'maybePromise',
        (maybePromise) =>
          function (parent, callback, fn) {
            const asyncResource = new AsyncResource('bound-anonymous-fn')
            const callbackIndex = arguments.length - 2
            callback = arguments[callbackIndex]
            if (typeof callback === 'function') {
              arguments[callbackIndex] = asyncResource.bind(callback)
            }
            return maybePromise.apply(this, arguments)
          }
      )
      return util
    })
    function wrapWp(wp) {
      shimmer.wrap(wp, 'command', (command) => wrapUnifiedCommand(command, 'command'))
      shimmer.wrap(wp, 'insert', (insert) => wrapUnifiedCommand(insert, 'insert', 'insert'))
      shimmer.wrap(wp, 'update', (update) => wrapUnifiedCommand(update, 'update', 'update'))
      shimmer.wrap(wp, 'remove', (remove) => wrapUnifiedCommand(remove, 'remove', 'remove'))
      shimmer.wrap(wp, 'query', (query) => wrapUnifiedCommand(query, 'query'))
      shimmer.wrap(wp, 'getMore', (getMore) => wrapUnifiedCommand(getMore, 'getMore', 'getMore'))
      shimmer.wrap(wp, 'killCursors', (killCursors) => wrapUnifiedCommand(killCursors, 'killCursors', 'killCursors'))
      return wp
    }
    function wrapUnifiedCommand(command, operation, name) {
      const wrapped = function (server, ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments)
        }
        return instrument(operation, command, this, arguments, server, ns, ops, { name })
      }
      return wrapped
    }
    function wrapConnectionCommand(command, operation, name, instrumentFn = instrument) {
      const wrapped = function (ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments)
        }
        const hostParts = typeof this.address === 'string' ? this.address.split(':') : ''
        const options = hostParts.length === 2 ? { host: hostParts[0], port: hostParts[1] } : {}
        const topology = { s: { options } }
        ns = `${ns.db}.${ns.collection}`
        return instrumentFn(operation, command, this, arguments, topology, ns, ops, { name })
      }
      return wrapped
    }
    function wrapQuery(query, operation, name) {
      const wrapped = function () {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments)
        }
        const pool = this.server.s.pool
        const ns = this.ns
        const ops = this.cmd
        return instrument(operation, query, this, arguments, pool, ns, ops)
      }
      return wrapped
    }
    function wrapCursor(cursor, operation, name) {
      const wrapped = function () {
        if (!startCh.hasSubscribers) {
          return cursor.apply(this, arguments)
        }
        const pool = this.server.s.pool
        const ns = this.ns
        return instrument(operation, cursor, this, arguments, pool, ns, {}, { name })
      }
      return wrapped
    }
    function wrapCommand(command, operation, name) {
      const wrapped = function (ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments)
        }
        return instrument(operation, command, this, arguments, this, ns, ops, { name })
      }
      return wrapped
    }
    function instrument(operation, command, instance, args, server, ns, ops, options = {}) {
      const name = options.name || (ops && Object.keys(ops)[0])
      const index = args.length - 1
      const callback = args[index]
      if (typeof callback !== 'function') return command.apply(instance, args)
      const serverInfo = server && server.s && server.s.options
      const ctx = {
        ns,
        ops,
        options: serverInfo,
        name,
      }
      return startCh.runStores(ctx, () => {
        args[index] = shimmer.wrapFunction(
          callback,
          (callback2) =>
            function (err, res) {
              if (err) {
                ctx.error = err
                errorCh.publish(ctx)
              }
              return finishCh.runStores(ctx, callback2, this, ...arguments)
            }
        )
        try {
          return command.apply(instance, args)
        } catch (err) {
          ctx.error = err
          errorCh.publish(ctx)
          throw err
        }
      })
    }
    function instrumentPromise(operation, command, instance, args, server, ns, ops, options = {}) {
      const name = options.name || (ops && Object.keys(ops)[0])
      const serverInfo = server && server.s && server.s.options
      const ctx = {
        ns,
        ops,
        options: serverInfo,
        name,
      }
      return startCh.runStores(ctx, () => {
        const promise = command.apply(instance, args)
        promise.then(
          function (res) {
            ctx.result = res
            finishCh.publish(ctx)
          },
          function (err) {
            ctx.error = err
            errorCh.publish(ctx)
            finishCh.publish(ctx)
          }
        )
        return promise
      })
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb.js
var require_mongodb = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb.js'() {
    'use strict'
    require_mongodb_core()
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var collectionMethodsWithFilter = [
      'count',
      'countDocuments',
      'deleteMany',
      'deleteOne',
      'find',
      'findOneAndDelete',
      'findOneAndReplace',
      'replaceOne',
    ]
    var collectionMethodsWithTwoFilters = ['findOneAndUpdate', 'updateMany', 'updateOne']
    var startCh = channel('datadog:mongodb:collection:filter:start')
    addHook({ name: 'mongodb', versions: ['>=3.3 <5', '5', '>=6'] }, (mongodb) => {
      ;[...collectionMethodsWithFilter, ...collectionMethodsWithTwoFilters].forEach((methodName) => {
        if (!(methodName in mongodb.Collection.prototype)) return
        const useTwoArguments = collectionMethodsWithTwoFilters.includes(methodName)
        shimmer.wrap(mongodb.Collection.prototype, methodName, (method) => {
          return function () {
            if (!startCh.hasSubscribers) {
              return method.apply(this, arguments)
            }
            const ctx = {
              filters: [arguments[0]],
              methodName,
            }
            if (useTwoArguments) {
              ctx.filters.push(arguments[1])
            }
            return startCh.runStores(ctx, () => {
              return method.apply(this, arguments)
            })
          }
        })
      })
      return mongodb
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js
var require_mongoose = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var { wrapThen } = require_promise()
    var shimmer = require_datadog_shimmer()
    var startCh = channel('datadog:mongoose:model:filter:start')
    var finishCh = channel('datadog:mongoose:model:filter:finish')
    var execStartCh = channel('apm:mongoose:exec:start')
    var execFinishCh = channel('apm:mongoose:exec:finish')
    function wrapAddQueue(addQueue) {
      const ctx = {}
      return execStartCh.runStores(ctx, () => {
        return function addQueueWithTrace(name) {
          return execFinishCh.runStores(ctx, () => {
            return addQueue.apply(this, arguments)
          })
        }
      })
    }
    addHook(
      {
        name: 'mongoose',
        versions: ['>=4.6.4 <5', '5', '6', '>=7'],
        file: 'lib/index.js',
      },
      (mongoose) => {
        if (mongoose.Promise && mongoose.Promise !== global.Promise) {
          shimmer.wrap(mongoose.Promise.prototype, 'then', wrapThen)
        }
        shimmer.wrap(mongoose.Collection.prototype, 'addQueue', wrapAddQueue)
        return mongoose
      }
    )
    var collectionMethodsWithFilter = [
      'count',
      'countDocuments',
      'deleteMany',
      'deleteOne',
      'find',
      'findOne',
      'findOneAndDelete',
      'findOneAndReplace',
      'replaceOne',
      'remove',
    ]
    var collectionMethodsWithTwoFilters = ['findOneAndUpdate', 'updateMany', 'updateOne']
    addHook(
      {
        name: 'mongoose',
        versions: ['>=4.6.4 <5', '5', '6', '>=7'],
        file: 'lib/model.js',
      },
      (Model) => {
        ;[...collectionMethodsWithFilter, ...collectionMethodsWithTwoFilters].forEach((methodName) => {
          const useTwoArguments = collectionMethodsWithTwoFilters.includes(methodName)
          if (!(methodName in Model)) return
          shimmer.wrap(Model, methodName, (method) => {
            return function wrappedModelMethod() {
              if (!startCh.hasSubscribers) {
                return method.apply(this, arguments)
              }
              const filters = [arguments[0]]
              if (useTwoArguments) {
                filters.push(arguments[1])
              }
              let callbackWrapped = false
              const wrapCallbackIfExist = (args, ctx2) => {
                const lastArgumentIndex = args.length - 1
                if (typeof args[lastArgumentIndex] === 'function') {
                  shimmer.wrap(args, lastArgumentIndex, (originalCb) => {
                    return function () {
                      finishCh.publish(ctx2)
                      return originalCb.apply(this, arguments)
                    }
                  })
                  callbackWrapped = true
                }
              }
              const ctx = {
                filters,
                methodName,
              }
              return startCh.runStores(ctx, () => {
                wrapCallbackIfExist(arguments, ctx)
                const res = method.apply(this, arguments)
                if (!callbackWrapped) {
                  shimmer.wrap(res, 'exec', (originalExec) => {
                    return function wrappedExec() {
                      if (!callbackWrapped) {
                        wrapCallbackIfExist(arguments, ctx)
                      }
                      const execResult = originalExec.apply(this, arguments)
                      if (callbackWrapped || typeof execResult?.then !== 'function') {
                        return execResult
                      }
                      shimmer.wrap(execResult, 'then', (originalThen) => {
                        return function wrappedThen() {
                          const resolve = arguments[0]
                          const reject = arguments[1]
                          arguments[0] = shimmer.wrapFunction(
                            resolve,
                            (resolve2) =>
                              function wrappedResolve() {
                                finishCh.publish(ctx)
                                if (resolve2) {
                                  return resolve2.apply(this, arguments)
                                }
                              }
                          )
                          arguments[1] = shimmer.wrapFunction(
                            reject,
                            (reject2) =>
                              function wrappedReject() {
                                finishCh.publish(ctx)
                                if (reject2) {
                                  return reject2.apply(this, arguments)
                                }
                              }
                          )
                          return originalThen.apply(this, arguments)
                        }
                      })
                      return execResult
                    }
                  })
                }
                return res
              })
            }
          })
        })
        return Model
      }
    )
    var sanitizeFilterFinishCh = channel('datadog:mongoose:sanitize-filter:finish')
    addHook(
      {
        name: 'mongoose',
        versions: ['6', '>=7'],
        file: 'lib/helpers/query/sanitizeFilter.js',
      },
      (sanitizeFilter) => {
        return shimmer.wrapFunction(
          sanitizeFilter,
          (sanitizeFilter2) =>
            function wrappedSanitizeFilter() {
              const sanitizedObject = sanitizeFilter2.apply(this, arguments)
              if (sanitizeFilterFinishCh.hasSubscribers) {
                sanitizeFilterFinishCh.publish({
                  sanitizedObject,
                })
              }
              return sanitizedObject
            }
        )
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mquery.js
var require_mquery = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mquery.js'() {
    'use strict'
    var dc = require_dc_polyfill()
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var prepareCh = channel('datadog:mquery:filter:prepare')
    var tracingCh = dc.tracingChannel('datadog:mquery:filter')
    var methods = ['find', 'findOne', 'findOneAndRemove', 'findOneAndDelete', 'count', 'distinct', 'where']
    var methodsOptionalArgs = ['findOneAndUpdate']
    function getFilters(args, methodName) {
      const [arg0, arg1] = args
      const filters = arg0 !== null && typeof arg0 === 'object' ? [arg0] : []
      if (arg1 !== null && typeof arg1 === 'object' && methodsOptionalArgs.includes(methodName)) {
        filters.push(arg1)
      }
      return filters
    }
    addHook(
      {
        name: 'mquery',
        versions: ['>=5.0.0'],
      },
      (Query) => {
        ;[...methods, ...methodsOptionalArgs].forEach((methodName) => {
          if (!(methodName in Query.prototype)) return
          shimmer.wrap(Query.prototype, methodName, (method) => {
            return function () {
              if (prepareCh.hasSubscribers) {
                const filters = getFilters(arguments, methodName)
                if (filters?.length) {
                  prepareCh.publish({ filters })
                }
              }
              return method.apply(this, arguments)
            }
          })
        })
        shimmer.wrap(Query.prototype, 'exec', (originalExec) => {
          return function wrappedExec() {
            return tracingCh.tracePromise(originalExec, {}, this, arguments)
          }
        })
        return Query
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/multer.js
var require_multer = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/multer.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook, AsyncResource } = require_instrument()
    var multerReadCh = channel('datadog:multer:read:finish')
    function publishRequestBodyAndNext(req, res, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function () {
            if (multerReadCh.hasSubscribers && req) {
              const abortController = new AbortController()
              const body = req.body
              multerReadCh.publish({ req, res, body, abortController })
              if (abortController.signal.aborted) return
            }
            return next2.apply(this, arguments)
          }
      )
    }
    addHook(
      {
        name: 'multer',
        file: 'lib/make-middleware.js',
        versions: ['^1.4.4-lts.1'],
      },
      (makeMiddleware) => {
        return shimmer.wrapFunction(
          makeMiddleware,
          (makeMiddleware2) =>
            function () {
              const middleware = makeMiddleware2.apply(this, arguments)
              return shimmer.wrapFunction(
                middleware,
                (middleware2) =>
                  function wrapMulterMiddleware(req, res, next) {
                    const nextResource = new AsyncResource('bound-anonymous-fn')
                    arguments[2] = nextResource.bind(publishRequestBodyAndNext(req, res, next))
                    return middleware2.apply(this, arguments)
                  }
              )
            }
        )
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js
var require_mysql = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: 'mysql', file: 'lib/Connection.js', versions: ['>=2'] }, (Connection) => {
      const startCh = channel('apm:mysql:query:start')
      const finishCh = channel('apm:mysql:query:finish')
      const errorCh = channel('apm:mysql:query:error')
      shimmer.wrap(
        Connection.prototype,
        'query',
        (query) =>
          function () {
            if (!startCh.hasSubscribers) {
              return query.apply(this, arguments)
            }
            const sql = arguments[0].sql || arguments[0]
            const conf = this.config
            const ctx = { sql, conf }
            return startCh.runStores(ctx, () => {
              if (arguments[0].sql) {
                arguments[0].sql = ctx.sql
              } else {
                arguments[0] = ctx.sql
              }
              try {
                const res = query.apply(this, arguments)
                if (res._callback) {
                  const cb = res._callback
                  res._callback = shimmer.wrapFunction(
                    cb,
                    (cb2) =>
                      function (error, result) {
                        if (error) {
                          ctx.error = error
                          errorCh.publish(ctx)
                        }
                        ctx.result = result
                        return finishCh.runStores(ctx, cb2, this, error, result)
                      }
                  )
                } else {
                  res.on('end', () => finishCh.publish(ctx))
                }
                return res
              } catch (err) {
                err.stack
                ctx.error = err
                errorCh.publish(ctx)
                throw err
              }
            })
          }
      )
      return Connection
    })
    addHook({ name: 'mysql', file: 'lib/Pool.js', versions: ['>=2'] }, (Pool) => {
      const connectionStartCh = channel('apm:mysql:connection:start')
      const connectionFinishCh = channel('apm:mysql:connection:finish')
      const startPoolQueryCh = channel('datadog:mysql:pool:query:start')
      const finishPoolQueryCh = channel('datadog:mysql:pool:query:finish')
      shimmer.wrap(
        Pool.prototype,
        'getConnection',
        (getConnection) =>
          function (cb) {
            arguments[0] = function () {
              return connectionFinishCh.runStores(ctx, cb, this, ...arguments)
            }
            const ctx = {}
            connectionStartCh.publish(ctx)
            return getConnection.apply(this, arguments)
          }
      )
      shimmer.wrap(
        Pool.prototype,
        'query',
        (query) =>
          function () {
            if (!startPoolQueryCh.hasSubscribers) {
              return query.apply(this, arguments)
            }
            const sql = arguments[0].sql || arguments[0]
            const ctx = { sql }
            const finish = () => finishPoolQueryCh.publish(ctx)
            return startPoolQueryCh.runStores(ctx, () => {
              const cb = arguments[arguments.length - 1]
              if (typeof cb === 'function') {
                arguments[arguments.length - 1] = shimmer.wrapFunction(
                  cb,
                  (cb2) =>
                    function () {
                      return finishPoolQueryCh.runStores(ctx, cb2, this, ...arguments)
                    }
                )
              }
              const retval = query.apply(this, arguments)
              if (retval && retval.then) {
                retval.then(finish).catch(finish)
              }
              return retval
            })
          }
      )
      return Pool
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js
var require_mysql2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js'() {
    'use strict'
    var { errorMonitor } = require('node:events')
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var satisfies = require_semifies()
    function wrapConnection(Connection, version) {
      const startCh = channel('apm:mysql2:query:start')
      const finishCh = channel('apm:mysql2:query:finish')
      const errorCh = channel('apm:mysql2:query:error')
      const startOuterQueryCh = channel('datadog:mysql2:outerquery:start')
      const commandAddCh = channel('apm:mysql2:command:add')
      const commandStartCh = channel('apm:mysql2:command:start')
      const commandFinishCh = channel('apm:mysql2:command:finish')
      const shouldEmitEndAfterQueryAbort = satisfies(version, '>=1.3.3')
      shimmer.wrap(
        Connection.prototype,
        'addCommand',
        (addCommand) =>
          function (cmd) {
            if (!startCh.hasSubscribers) return addCommand.apply(this, arguments)
            const name = cmd && cmd.constructor && cmd.constructor.name
            const isCommand = typeof cmd.execute === 'function'
            const isQuery = isCommand && (name === 'Execute' || name === 'Query')
            const ctx = {}
            cmd.execute = isQuery ? wrapExecute(cmd, cmd.execute, ctx, this.config) : bindExecute(cmd.execute, ctx)
            return commandAddCh.runStores(ctx, addCommand, this, ...arguments)
          }
      )
      shimmer.wrap(
        Connection.prototype,
        'query',
        (query) =>
          function (sql, values, cb) {
            if (!startOuterQueryCh.hasSubscribers) return query.apply(this, arguments)
            if (sql !== null && typeof sql === 'object') sql = sql.sql
            if (!sql) return query.apply(this, arguments)
            const abortController = new AbortController()
            startOuterQueryCh.publish({ sql, abortController })
            if (abortController.signal.aborted) {
              const addCommand = this.addCommand
              this.addCommand = function (cmd) {
                return cmd
              }
              let queryCommand
              try {
                queryCommand = query.apply(this, arguments)
              } finally {
                this.addCommand = addCommand
              }
              cb = queryCommand.onResult
              process.nextTick(() => {
                if (cb) {
                  cb(abortController.signal.reason)
                } else {
                  queryCommand.emit('error', abortController.signal.reason)
                }
                if (shouldEmitEndAfterQueryAbort) {
                  queryCommand.emit('end')
                }
              })
              return queryCommand
            }
            return query.apply(this, arguments)
          }
      )
      shimmer.wrap(
        Connection.prototype,
        'execute',
        (execute) =>
          function (sql, values, cb) {
            if (!startOuterQueryCh.hasSubscribers) return execute.apply(this, arguments)
            if (sql !== null && typeof sql === 'object') sql = sql.sql
            if (!sql) return execute.apply(this, arguments)
            const abortController = new AbortController()
            startOuterQueryCh.publish({ sql, abortController })
            if (abortController.signal.aborted) {
              const addCommand = this.addCommand
              this.addCommand = function (cmd) {
                return cmd
              }
              let result
              try {
                result = execute.apply(this, arguments)
              } finally {
                this.addCommand = addCommand
              }
              result?.onResult(abortController.signal.reason)
              return result
            }
            return execute.apply(this, arguments)
          }
      )
      return Connection
      function bindExecute(execute, ctx) {
        return shimmer.wrapFunction(
          execute,
          (execute2) =>
            function executeWithTrace(packet, connection) {
              const onResult = this.onResult
              if (onResult) {
                this.onResult = function () {
                  return commandFinishCh.runStores(ctx, onResult, this, ...arguments)
                }
              }
              return commandStartCh.runStores(ctx, execute2, this, ...arguments)
            }
        )
      }
      function wrapExecute(cmd, execute, ctx, config) {
        return shimmer.wrapFunction(
          execute,
          (execute2) =>
            function executeWithTrace(packet, connection) {
              ctx.sql = cmd.statement ? cmd.statement.query : cmd.sql
              ctx.conf = config
              return startCh.runStores(ctx, () => {
                if (cmd.statement) {
                  cmd.statement.query = ctx.sql
                } else {
                  cmd.sql = ctx.sql
                }
                if (this.onResult) {
                  const onResult = this.onResult
                  this.onResult = shimmer.wrapFunction(
                    onResult,
                    (onResult2) =>
                      function (error) {
                        if (error) {
                          ctx.error = error
                          errorCh.publish(ctx)
                        }
                        finishCh.runStores(ctx, onResult2, this, ...arguments)
                      }
                  )
                } else {
                  this.on(errorMonitor, (error) => {
                    ctx.error = error
                    errorCh.publish(ctx)
                  })
                  this.on('end', () => finishCh.publish(ctx))
                }
                this.execute = execute2
                try {
                  return execute2.apply(this, arguments)
                } catch (err) {
                  ctx.error = err
                  errorCh.publish(ctx)
                }
              })
            },
          cmd
        )
      }
    }
    function wrapPool(Pool, version) {
      const startOuterQueryCh = channel('datadog:mysql2:outerquery:start')
      const shouldEmitEndAfterQueryAbort = satisfies(version, '>=1.3.3')
      shimmer.wrap(
        Pool.prototype,
        'query',
        (query) =>
          function (sql, values, cb) {
            if (!startOuterQueryCh.hasSubscribers) return query.apply(this, arguments)
            if (sql !== null && typeof sql === 'object') sql = sql.sql
            if (!sql) return query.apply(this, arguments)
            const abortController = new AbortController()
            startOuterQueryCh.publish({ sql, abortController })
            if (abortController.signal.aborted) {
              const getConnection = this.getConnection
              this.getConnection = function () {}
              let queryCommand
              try {
                queryCommand = query.apply(this, arguments)
              } finally {
                this.getConnection = getConnection
              }
              process.nextTick(() => {
                if (queryCommand.onResult) {
                  queryCommand.onResult(abortController.signal.reason)
                } else {
                  queryCommand.emit('error', abortController.signal.reason)
                }
                if (shouldEmitEndAfterQueryAbort) {
                  queryCommand.emit('end')
                }
              })
              return queryCommand
            }
            return query.apply(this, arguments)
          }
      )
      shimmer.wrap(
        Pool.prototype,
        'execute',
        (execute) =>
          function (sql, values, cb) {
            if (!startOuterQueryCh.hasSubscribers) return execute.apply(this, arguments)
            if (sql !== null && typeof sql === 'object') sql = sql.sql
            if (!sql) return execute.apply(this, arguments)
            const abortController = new AbortController()
            startOuterQueryCh.publish({ sql, abortController })
            if (abortController.signal.aborted) {
              if (typeof values === 'function') {
                cb = values
              }
              process.nextTick(() => {
                cb(abortController.signal.reason)
              })
              return
            }
            return execute.apply(this, arguments)
          }
      )
      return Pool
    }
    function wrapPoolCluster(PoolCluster) {
      const startOuterQueryCh = channel('datadog:mysql2:outerquery:start')
      const wrappedPoolNamespaces = /* @__PURE__ */ new WeakSet()
      shimmer.wrap(
        PoolCluster.prototype,
        'of',
        (of) =>
          function () {
            const poolNamespace = of.apply(this, arguments)
            if (startOuterQueryCh.hasSubscribers && !wrappedPoolNamespaces.has(poolNamespace)) {
              shimmer.wrap(
                poolNamespace,
                'query',
                (query) =>
                  function (sql, values, cb) {
                    if (sql !== null && typeof sql === 'object') sql = sql.sql
                    if (!sql) return query.apply(this, arguments)
                    const abortController = new AbortController()
                    startOuterQueryCh.publish({ sql, abortController })
                    if (abortController.signal.aborted) {
                      const getConnection = this.getConnection
                      this.getConnection = function () {}
                      let queryCommand
                      try {
                        queryCommand = query.apply(this, arguments)
                      } finally {
                        this.getConnection = getConnection
                      }
                      process.nextTick(() => {
                        if (queryCommand.onResult) {
                          queryCommand.onResult(abortController.signal.reason)
                        } else {
                          queryCommand.emit('error', abortController.signal.reason)
                        }
                        queryCommand.emit('end')
                      })
                      return queryCommand
                    }
                    return query.apply(this, arguments)
                  }
              )
              shimmer.wrap(
                poolNamespace,
                'execute',
                (execute) =>
                  function (sql, values, cb) {
                    if (sql !== null && typeof sql === 'object') sql = sql.sql
                    if (!sql) return execute.apply(this, arguments)
                    const abortController = new AbortController()
                    startOuterQueryCh.publish({ sql, abortController })
                    if (abortController.signal.aborted) {
                      if (typeof values === 'function') {
                        cb = values
                      }
                      process.nextTick(() => {
                        cb(abortController.signal.reason)
                      })
                      return
                    }
                    return execute.apply(this, arguments)
                  }
              )
              wrappedPoolNamespaces.add(poolNamespace)
            }
            return poolNamespace
          }
      )
      return PoolCluster
    }
    addHook({ name: 'mysql2', file: 'lib/base/connection.js', versions: ['>=3.11.5'] }, wrapConnection)
    addHook({ name: 'mysql2', file: 'lib/connection.js', versions: ['1 - 3.11.4'] }, wrapConnection)
    addHook({ name: 'mysql2', file: 'lib/pool.js', versions: ['1 - 3.11.4'] }, wrapPool)
    addHook({ name: 'mysql2', file: 'lib/pool_cluster.js', versions: ['2.3.0 - 3.11.4'] }, wrapPoolCluster)
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/net.js
var require_net = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/net.js'() {
    'use strict'
    var { errorMonitor } = require('events')
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startICPCh = channel('apm:net:ipc:start')
    var finishICPCh = channel('apm:net:ipc:finish')
    var errorICPCh = channel('apm:net:ipc:error')
    var startTCPCh = channel('apm:net:tcp:start')
    var finishTCPCh = channel('apm:net:tcp:finish')
    var errorTCPCh = channel('apm:net:tcp:error')
    var readyCh = channel('apm:net:tcp:ready')
    var connectionCh = channel('apm:net:tcp:connection')
    var names = ['net', 'node:net']
    addHook({ name: names }, (net, version, name) => {
      if (name === 'net') {
        require('dns')
      } else {
        require('node:dns')
      }
      shimmer.wrap(
        net.Socket.prototype,
        'connect',
        (connect) =>
          function () {
            if (!startICPCh.hasSubscribers || !startTCPCh.hasSubscribers) {
              return connect.apply(this, arguments)
            }
            const options = getOptions(arguments)
            const lastIndex = arguments.length - 1
            const callback = arguments[lastIndex]
            if (!options) return connect.apply(this, arguments)
            const protocol = options.path ? 'ipc' : 'tcp'
            const startCh = protocol === 'ipc' ? startICPCh : startTCPCh
            const finishCh = protocol === 'ipc' ? finishICPCh : finishTCPCh
            const errorCh = protocol === 'ipc' ? errorICPCh : errorTCPCh
            const ctx = { options }
            if (typeof callback === 'function') {
              arguments[lastIndex] = function (...args) {
                return finishCh.runStores(ctx, callback, this, ...args)
              }
            }
            return startCh.runStores(ctx, () => {
              setupListeners(this, protocol, ctx, finishCh, errorCh)
              const emit = this.emit
              this.emit = shimmer.wrapFunction(
                emit,
                (emit2) =>
                  function (eventName) {
                    switch (eventName) {
                      case 'ready':
                      case 'connect':
                        return readyCh.runStores(ctx, () => {
                          return emit2.apply(this, arguments)
                        })
                      default:
                        return emit2.apply(this, arguments)
                    }
                  }
              )
              try {
                return connect.apply(this, arguments)
              } catch (err) {
                errorCh.publish(err)
                throw err
              }
            })
          }
      )
      return net
    })
    function getOptions(args) {
      if (!args[0]) return
      switch (typeof args[0]) {
        case 'object':
          if (Array.isArray(args[0])) return getOptions(args[0])
          return args[0]
        case 'string':
          if (Number.isNaN(Number.parseFloat(args[0]))) {
            return {
              path: args[0],
            }
          }
        case 'number':
          return {
            port: args[0],
            host: typeof args[1] === 'string' ? args[1] : 'localhost',
          }
      }
    }
    function setupListeners(socket, protocol, ctx, finishCh, errorCh) {
      const events = ['connect', errorMonitor, 'close', 'timeout']
      const wrapListener = function (error) {
        if (error) {
          ctx.error = error
          errorCh.publish(ctx)
        }
        finishCh.runStores(ctx, () => {})
      }
      const localListener = function () {
        ctx.socket = socket
        connectionCh.publish(ctx)
      }
      const cleanupListener = function () {
        socket.removeListener('connect', localListener)
        events.forEach((event) => {
          socket.removeListener(event, wrapListener)
          socket.removeListener(event, cleanupListener)
        })
      }
      if (protocol === 'tcp') {
        socket.once('connect', localListener)
      }
      events.forEach((event) => {
        socket.once(event, wrapListener)
        socket.once(event, cleanupListener)
      })
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/next.js
var require_next = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/next.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startChannel = channel('apm:next:request:start')
    var finishChannel = channel('apm:next:request:finish')
    var errorChannel = channel('apm:next:request:error')
    var pageLoadChannel = channel('apm:next:page:load')
    var bodyParsedChannel = channel('apm:next:body-parsed')
    var queryParsedChannel = channel('apm:next:query-parsed')
    var requests = /* @__PURE__ */ new WeakSet()
    var nodeNextRequestsToNextRequests = /* @__PURE__ */ new WeakMap()
    var MIDDLEWARE_HEADER = 'x-middleware-invoke'
    var NEXT_REQUEST_META = /* @__PURE__ */ Symbol.for('NextInternalRequestMeta')
    var META_IS_MIDDLEWARE = 'middlewareInvoke'
    var encounteredMiddleware = /* @__PURE__ */ new WeakSet()
    function wrapHandleRequest(handleRequest) {
      return function (req, res, pathname, query) {
        return instrument(req, res, () => handleRequest.apply(this, arguments))
      }
    }
    function wrapHandleApiRequest(handleApiRequest) {
      return function (req, res, pathname, query) {
        return instrument(req, res, () => {
          const promise = handleApiRequest.apply(this, arguments)
          return promise.then((handled) => {
            if (!handled) return handled
            return this.hasPage(pathname).then((pageFound) => {
              const pageData = pageFound ? { page: pathname } : getPageFromPath(pathname, this.dynamicRoutes)
              pageLoadChannel.publish(pageData)
              return handled
            })
          })
        })
      }
    }
    function wrapHandleApiRequestWithMatch(handleApiRequest) {
      return function (req, res, query, match) {
        return instrument(req, res, () => {
          const page =
            match !== null &&
            typeof match === 'object' &&
            match.definition !== null &&
            typeof match.definition === 'object'
              ? match.definition.pathname
              : void 0
          pageLoadChannel.publish({ page })
          return handleApiRequest.apply(this, arguments)
        })
      }
    }
    function wrapRenderToHTML(renderToHTML) {
      return function (req, res, pathname, query, parsedUrl) {
        return instrument(req, res, () => renderToHTML.apply(this, arguments))
      }
    }
    function wrapRenderErrorToHTML(renderErrorToHTML) {
      return function (err, req, res, pathname, query) {
        return instrument(req, res, () => renderErrorToHTML.apply(this, arguments), err)
      }
    }
    function wrapRenderToResponse(renderToResponse) {
      return function (ctx) {
        return instrument(ctx.req, ctx.res, () => renderToResponse.apply(this, arguments))
      }
    }
    function wrapRenderErrorToResponse(renderErrorToResponse) {
      return function (ctx, err) {
        return instrument(ctx.req, ctx.res, () => renderErrorToResponse.apply(this, arguments), err)
      }
    }
    function wrapFindPageComponents(findPageComponents) {
      return function (pathname, query) {
        const result = findPageComponents.apply(this, arguments)
        if (result) {
          pageLoadChannel.publish(getPagePath(pathname))
        }
        return result
      }
    }
    function getPagePath(maybePage) {
      if (typeof maybePage !== 'object') return { page: maybePage }
      const isAppPath = maybePage.isAppPath
      const page = maybePage.pathname || maybePage.page
      return { page, isAppPath }
    }
    function getPageFromPath(page, dynamicRoutes = []) {
      for (const dynamicRoute of dynamicRoutes) {
        if (dynamicRoute.page.startsWith('/api') && dynamicRoute.match(page)) {
          return getPagePath(dynamicRoute.page)
        }
      }
      return getPagePath(page)
    }
    function getRequestMeta(req, key) {
      const meta = req[NEXT_REQUEST_META] || {}
      return typeof key === 'string' ? meta[key] : meta
    }
    function instrument(req, res, handler, error) {
      req = req.originalRequest || req
      res = res.originalResponse || res
      const isMiddleware = req.headers[MIDDLEWARE_HEADER] || getRequestMeta(req, META_IS_MIDDLEWARE)
      if ((isMiddleware && !encounteredMiddleware.has(req)) || requests.has(req)) {
        encounteredMiddleware.add(req)
        if (error) {
          errorChannel.publish({ error })
        }
        return handler()
      }
      requests.add(req)
      const ctx = { req, res }
      if (queryParsedChannel.hasSubscribers && req.url) {
        const { searchParams } = new URL(req.url, 'http://dummy')
        const query = {}
        for (const key of searchParams.keys()) {
          if (!query[key]) {
            query[key] = searchParams.getAll(key)
          }
        }
        queryParsedChannel.publish({ query })
      }
      return startChannel.runStores(ctx, () => {
        try {
          const promise = handler(ctx)
          promise.then(
            (result) => finish(ctx, result),
            (err) => finish(ctx, null, err)
          )
          return promise
        } catch (e) {
          finish(ctx, null, e)
          throw e
        }
      })
    }
    function wrapServeStatic(serveStatic) {
      return function (req, res, path) {
        return instrument(req, res, () => {
          if (pageLoadChannel.hasSubscribers && path) {
            pageLoadChannel.publish({ page: path, isStatic: true })
          }
          return serveStatic.apply(this, arguments)
        })
      }
    }
    function finish(ctx, result, err) {
      if (err) {
        ctx.error = err
        errorChannel.publish(ctx)
      }
      const maybeNextRequest = nodeNextRequestsToNextRequests.get(ctx.req)
      if (maybeNextRequest) {
        ctx.nextRequest = maybeNextRequest
      }
      finishChannel.publish(ctx)
    }
    addHook(
      {
        name: 'next',
        versions: ['>=13.3.0'],
        file: 'dist/server/web/spec-extension/adapters/next-request.js',
      },
      (NextRequestAdapter) => {
        shimmer.wrap(NextRequestAdapter.NextRequestAdapter, 'fromNodeNextRequest', (fromNodeNextRequest) => {
          return function (nodeNextRequest) {
            const nextRequest = fromNodeNextRequest.apply(this, arguments)
            nodeNextRequestsToNextRequests.set(nodeNextRequest.originalRequest, nextRequest)
            return nextRequest
          }
        })
        return NextRequestAdapter
      }
    )
    addHook(
      {
        name: 'next',
        versions: ['>=11.1'],
        file: 'dist/server/serve-static.js',
      },
      (serveStatic) => shimmer.wrap(serveStatic, 'serveStatic', wrapServeStatic, { replaceGetter: true })
    )
    addHook(
      {
        name: 'next',
        versions: ['>=10.2 <11.1'],
        file: 'dist/next-server/server/serve-static.js',
      },
      (serveStatic) => shimmer.wrap(serveStatic, 'serveStatic', wrapServeStatic, { replaceGetter: true })
    )
    addHook({ name: 'next', versions: ['>=11.1'], file: 'dist/server/next-server.js' }, (nextServer) => {
      const Server = nextServer.default
      shimmer.wrap(Server.prototype, 'handleRequest', wrapHandleRequest)
      shimmer.wrap(Server.prototype, 'renderToResponse', wrapRenderToResponse)
      shimmer.wrap(Server.prototype, 'renderErrorToResponse', wrapRenderErrorToResponse)
      shimmer.wrap(Server.prototype, 'findPageComponents', wrapFindPageComponents)
      return nextServer
    })
    addHook({ name: 'next', versions: ['>=13.2'], file: 'dist/server/next-server.js' }, (nextServer) => {
      const Server = nextServer.default
      shimmer.wrap(Server.prototype, 'handleApiRequest', wrapHandleApiRequestWithMatch)
      return nextServer
    })
    addHook(
      {
        name: 'next',
        versions: ['>=11.1 <13.2'],
        file: 'dist/server/next-server.js',
      },
      (nextServer) => {
        const Server = nextServer.default
        shimmer.wrap(Server.prototype, 'handleApiRequest', wrapHandleApiRequest)
        return nextServer
      }
    )
    addHook(
      {
        name: 'next',
        versions: ['>=10.2 <11.1'],
        file: 'dist/next-server/server/next-server.js',
      },
      (nextServer) => {
        const Server = nextServer.default
        shimmer.wrap(Server.prototype, 'handleRequest', wrapHandleRequest)
        shimmer.wrap(Server.prototype, 'handleApiRequest', wrapHandleApiRequest)
        shimmer.wrap(Server.prototype, 'renderToHTML', wrapRenderToHTML)
        shimmer.wrap(Server.prototype, 'renderErrorToHTML', wrapRenderErrorToHTML)
        shimmer.wrap(Server.prototype, 'findPageComponents', wrapFindPageComponents)
        return nextServer
      }
    )
    addHook(
      {
        name: 'next',
        versions: ['>=13'],
        file: 'dist/server/web/spec-extension/request.js',
      },
      (request) => {
        const requestProto = Object.getPrototypeOf(request.NextRequest.prototype)
        shimmer.massWrap(requestProto, ['text', 'json'], function (originalMethod) {
          return async function wrappedJson() {
            const body = await originalMethod.apply(this, arguments)
            bodyParsedChannel.publish({ body })
            return body
          }
        })
        shimmer.wrap(requestProto, 'formData', function (originalFormData) {
          return async function wrappedFormData() {
            const body = await originalFormData.apply(this, arguments)
            let normalizedBody = body
            if (typeof body.entries === 'function') {
              normalizedBody = Object.fromEntries(body.entries())
            }
            bodyParsedChannel.publish({ body: normalizedBody })
            return body
          }
        })
        return request
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/node-serialize.js
var require_node_serialize = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/node-serialize.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook } = require_instrument()
    var nodeUnserializeCh = channel('datadog:node-serialize:unserialize:start')
    function wrapUnserialize(serialize) {
      return function wrappedUnserialize(obj) {
        if (nodeUnserializeCh.hasSubscribers) {
          nodeUnserializeCh.publish({ obj })
        }
        return serialize.apply(this, arguments)
      }
    }
    addHook({ name: 'node-serialize', versions: ['0.0.4'] }, (serialize) => {
      shimmer.wrap(serialize, 'unserialize', wrapUnserialize)
      return serialize
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/url.js
var require_url2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/url.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var names = ['url', 'node:url']
    var parseFinishedChannel = channel('datadog:url:parse:finish')
    var urlGetterChannel = channel('datadog:url:getter:finish')
    var instrumentedGetters = ['host', 'origin', 'hostname']
    addHook({ name: names }, function (url) {
      shimmer.wrap(url, 'parse', (parse) => {
        return function wrappedParse(input) {
          const parsedValue = parse.apply(this, arguments)
          if (!parseFinishedChannel.hasSubscribers) return parsedValue
          parseFinishedChannel.publish({
            input,
            parsed: parsedValue,
            isURL: false,
          })
          return parsedValue
        }
      })
      const URLPrototype = url.URL.prototype.constructor.prototype
      instrumentedGetters.forEach((property) => {
        shimmer.wrap(URLPrototype, property, function (originalGet) {
          return function get() {
            const result = originalGet.call(this)
            if (!urlGetterChannel.hasSubscribers) return result
            const context = { urlObject: this, result, property }
            urlGetterChannel.publish(context)
            return context.result
          }
        })
      })
      shimmer.wrap(url, 'URL', (URL2) => {
        return class extends URL2 {
          constructor(input, base) {
            super(...arguments)
            if (!parseFinishedChannel.hasSubscribers) return
            parseFinishedChannel.publish({
              input,
              base,
              parsed: this,
              isURL: true,
            })
          }
          static [Symbol.hasInstance](instance) {
            return instance instanceof URL2
          }
        }
      })
      if (url.URL.parse) {
        shimmer.wrap(url.URL, 'parse', (parse) => {
          return function wrappedParse(input, base) {
            const parsedValue = parse.apply(this, arguments)
            if (!parseFinishedChannel.hasSubscribers) return parsedValue
            parseFinishedChannel.publish({
              input,
              base,
              parsed: parsedValue,
              isURL: true,
            })
            return parsedValue
          }
        })
      }
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/vm.js
var require_vm = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/vm.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var names = ['vm', 'node:vm']
    var runScriptStartChannel = channel('datadog:vm:run-script:start')
    var sourceTextModuleStartChannel = channel('datadog:vm:source-text-module:start')
    addHook({ name: names }, function (vm) {
      vm.Script = class extends vm.Script {
        constructor(code) {
          super(...arguments)
          if (runScriptStartChannel.hasSubscribers && code) {
            runScriptStartChannel.publish({ code })
          }
        }
      }
      if (vm.SourceTextModule && typeof vm.SourceTextModule === 'function') {
        vm.SourceTextModule = class extends vm.SourceTextModule {
          constructor(code) {
            super(...arguments)
            if (sourceTextModuleStartChannel.hasSubscribers && code) {
              sourceTextModuleStartChannel.publish({ code })
            }
          }
        }
      }
      shimmer.wrap(vm, 'runInContext', wrapVMMethod)
      shimmer.wrap(vm, 'runInNewContext', wrapVMMethod)
      shimmer.wrap(vm, 'runInThisContext', wrapVMMethod)
      shimmer.wrap(vm, 'compileFunction', wrapVMMethod)
      return vm
    })
    function wrapVMMethod(original) {
      return function wrappedVMMethod(code) {
        if (runScriptStartChannel.hasSubscribers && code) {
          runScriptStartChannel.publish({ code })
        }
        return original.apply(this, arguments)
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/nyc.js
var require_nyc = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/nyc.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { getEnvironmentVariable } = require_config_helper()
    var codeCoverageWrapCh = channel('ci:nyc:wrap')
    addHook(
      {
        name: 'nyc',
        versions: ['>=17'],
      },
      (nycPackage) => {
        shimmer.wrap(
          nycPackage.prototype,
          'wrap',
          (wrap) =>
            function () {
              try {
                if (JSON.parse(getEnvironmentVariable('NYC_CONFIG')).all) {
                  codeCoverageWrapCh.publish(this)
                }
              } catch {}
              return wrap.apply(this, arguments)
            }
        )
        return nycPackage
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/oracledb.js
var require_oracledb = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/oracledb.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var connectionAttributes = /* @__PURE__ */ new WeakMap()
    var poolAttributes = /* @__PURE__ */ new WeakMap()
    var startChannel = channel('apm:oracledb:query:start')
    var errorChannel = channel('apm:oracledb:query:error')
    var finishChannel = channel('apm:oracledb:query:finish')
    function finish(ctx) {
      if (ctx.error) {
        errorChannel.publish(ctx)
      }
      finishChannel.publish(ctx)
    }
    addHook({ name: 'oracledb', versions: ['>=5'], file: 'lib/oracledb.js' }, (oracledb) => {
      shimmer.wrap(oracledb.Connection.prototype, 'execute', (execute) => {
        return function wrappedExecute(dbQuery, ...args) {
          if (!startChannel.hasSubscribers) {
            return execute.apply(this, arguments)
          }
          if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
            const cb = arguments[arguments.length - 1]
            arguments[arguments.length - 1] = shimmer.wrapFunction(
              cb,
              (cb2) =>
                function wrappedCb(err, result) {
                  if (err) {
                    ctx.error = err
                    errorChannel.publish(ctx)
                  }
                  return finishChannel.runStores(ctx, () => {
                    return cb2.apply(this, arguments)
                  })
                }
            )
          }
          let hostname
          let port
          let dbInstance
          try {
            if (this.thin) {
              const details = this._impl ?? this
              dbInstance = this.serviceName ?? details.serviceName
              hostname = this.hostName ?? details.nscon?.ntAdapter?.hostName
              const p = this.port ?? details.nscon?.ntAdapter?.port
              if (p != null) port = String(p)
            } else {
              dbInstance = this.serviceName
            }
          } catch {}
          const connAttrs = connectionAttributes.get(this)
          const ctx = {
            dbInstance,
            port,
            hostname,
            query: dbQuery,
            connAttrs,
          }
          return startChannel.runStores(ctx, () => {
            try {
              let result = execute.apply(this, arguments)
              if (typeof result?.then === 'function') {
                result = result.then(
                  (x) => {
                    finish(ctx)
                    return x
                  },
                  (e) => {
                    ctx.error = e
                    finish(ctx)
                    throw e
                  }
                )
              }
              return result
            } catch (err) {
              ctx.error = err
              finish(ctx)
              throw err
            }
          })
        }
      })
      shimmer.wrap(oracledb, 'getConnection', (getConnection) => {
        return function wrappedGetConnection(connAttrs, callback) {
          if (callback) {
            arguments[1] = shimmer.wrapFunction(callback, (callback2) => (err, connection) => {
              if (connection) {
                connectionAttributes.set(connection, connAttrs)
              }
              callback2(err, connection)
            })
            getConnection.apply(this, arguments)
          } else {
            return getConnection.apply(this, arguments).then((connection) => {
              connectionAttributes.set(connection, connAttrs)
              return connection
            })
          }
        }
      })
      shimmer.wrap(oracledb, 'createPool', (createPool) => {
        return function wrappedCreatePool(poolAttrs, callback) {
          if (callback) {
            arguments[1] = shimmer.wrapFunction(callback, (callback2) => (err, pool) => {
              if (pool) {
                poolAttributes.set(pool, poolAttrs)
              }
              callback2(err, pool)
            })
            createPool.apply(this, arguments)
          } else {
            return createPool.apply(this, arguments).then((pool) => {
              poolAttributes.set(pool, poolAttrs)
              return pool
            })
          }
        }
      })
      shimmer.wrap(oracledb.Pool.prototype, 'getConnection', (getConnection) => {
        return function wrappedGetConnection() {
          let callback
          if (typeof arguments[arguments.length - 1] === 'function') {
            callback = arguments[arguments.length - 1]
          }
          if (callback) {
            arguments[arguments.length - 1] = shimmer.wrapFunction(callback, (callback2) => (err, connection) => {
              if (connection) {
                connectionAttributes.set(connection, poolAttributes.get(this))
              }
              callback2(err, connection)
            })
            getConnection.apply(this, arguments)
          } else {
            return getConnection.apply(this, arguments).then((connection) => {
              connectionAttributes.set(connection, poolAttributes.get(this))
              return connection
            })
          }
        }
      })
      return oracledb
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/openai.js
var require_openai = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/openai.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var dc = require_dc_polyfill()
    var ch = dc.tracingChannel('apm:openai:request')
    var onStreamedChunkCh = dc.channel('apm:openai:request:chunk')
    var V4_PACKAGE_SHIMS = [
      {
        file: 'resources/chat/completions',
        targetClass: 'Completions',
        baseResource: 'chat.completions',
        methods: ['create'],
        streamedResponse: true,
      },
      {
        file: 'resources/completions',
        targetClass: 'Completions',
        baseResource: 'completions',
        methods: ['create'],
        streamedResponse: true,
      },
      {
        file: 'resources/responses/responses',
        targetClass: 'Responses',
        baseResource: 'responses',
        methods: ['create'],
        streamedResponse: true,
        versions: ['>=4.87.0'],
      },
      {
        file: 'resources/embeddings',
        targetClass: 'Embeddings',
        baseResource: 'embeddings',
        methods: ['create'],
      },
      {
        file: 'resources/files',
        targetClass: 'Files',
        baseResource: 'files',
        methods: ['create', 'list', 'retrieve'],
      },
      {
        file: 'resources/files',
        targetClass: 'Files',
        baseResource: 'files',
        methods: ['del'],
        versions: ['>=4.0.0 <5.0.0'],
      },
      {
        file: 'resources/files',
        targetClass: 'Files',
        baseResource: 'files',
        methods: ['delete'],
        versions: ['>=5'],
      },
      {
        file: 'resources/files',
        targetClass: 'Files',
        baseResource: 'files',
        methods: ['retrieveContent'],
        versions: ['>=4.0.0 <4.17.1'],
      },
      {
        file: 'resources/files',
        targetClass: 'Files',
        baseResource: 'files',
        methods: ['content'],
        // replaced `retrieveContent` in v4.17.1
        versions: ['>=4.17.1'],
      },
      {
        file: 'resources/images',
        targetClass: 'Images',
        baseResource: 'images',
        methods: ['createVariation', 'edit', 'generate'],
      },
      {
        file: 'resources/fine-tuning/jobs/jobs',
        targetClass: 'Jobs',
        baseResource: 'fine_tuning.jobs',
        methods: ['cancel', 'create', 'list', 'listEvents', 'retrieve'],
        versions: ['>=4.34.0'],
        // file location changed in 4.34.0
      },
      {
        file: 'resources/fine-tuning/jobs',
        targetClass: 'Jobs',
        baseResource: 'fine_tuning.jobs',
        methods: ['cancel', 'create', 'list', 'listEvents', 'retrieve'],
        versions: ['>=4.1.0 <4.34.0'],
      },
      {
        file: 'resources/fine-tunes',
        // deprecated after 4.1.0
        targetClass: 'FineTunes',
        baseResource: 'fine-tune',
        methods: ['cancel', 'create', 'list', 'listEvents', 'retrieve'],
        versions: ['>=4.0.0 <4.1.0'],
      },
      {
        file: 'resources/models',
        targetClass: 'Models',
        baseResource: 'models',
        methods: ['list', 'retrieve'],
      },
      {
        file: 'resources/models',
        targetClass: 'Models',
        baseResource: 'models',
        methods: ['del'],
        versions: ['>=4 <5'],
      },
      {
        file: 'resources/models',
        targetClass: 'Models',
        baseResource: 'models',
        methods: ['delete'],
        versions: ['>=5'],
      },
      {
        file: 'resources/moderations',
        targetClass: 'Moderations',
        baseResource: 'moderations',
        methods: ['create'],
      },
      {
        file: 'resources/audio/transcriptions',
        targetClass: 'Transcriptions',
        baseResource: 'audio.transcriptions',
        methods: ['create'],
      },
      {
        file: 'resources/audio/translations',
        targetClass: 'Translations',
        baseResource: 'audio.translations',
        methods: ['create'],
      },
      {
        file: 'resources/chat/completions/completions',
        targetClass: 'Completions',
        baseResource: 'chat.completions',
        methods: ['create'],
        streamedResponse: true,
        versions: ['>=4.85.0'],
      },
    ]
    addHook({ name: 'openai', file: 'dist/api.js', versions: ['>=3.0.0 <4'] }, (exports3) => {
      const methodNames = Object.getOwnPropertyNames(exports3.OpenAIApi.prototype)
      methodNames.shift()
      for (const methodName of methodNames) {
        shimmer.wrap(
          exports3.OpenAIApi.prototype,
          methodName,
          (fn) =>
            function () {
              if (!ch.start.hasSubscribers) {
                return fn.apply(this, arguments)
              }
              const ctx = {
                methodName,
                args: arguments,
                basePath: this.basePath,
              }
              return ch.tracePromise(fn, ctx, this, ...arguments)
            }
        )
      }
      return exports3
    })
    function wrapStreamIterator(response, options, ctx) {
      return function (itr) {
        return function () {
          const iterator = itr.apply(this, arguments)
          shimmer.wrap(
            iterator,
            'next',
            (next) =>
              function () {
                return next
                  .apply(this, arguments)
                  .then((res) => {
                    const { done, value: chunk } = res
                    onStreamedChunkCh.publish({ ctx, chunk, done })
                    if (done) {
                      finish(ctx, {
                        headers: response.headers,
                        request: {
                          path: response.url,
                          method: options.method,
                        },
                      })
                    }
                    return res
                  })
                  .catch((err) => {
                    finish(ctx, void 0, err)
                    throw err
                  })
              }
          )
          return iterator
        }
      }
    }
    var extensions = ['.js', '.mjs']
    for (const extension of extensions) {
      for (const shim of V4_PACKAGE_SHIMS) {
        const { file, targetClass, baseResource, methods, versions, streamedResponse } = shim
        addHook({ name: 'openai', file: file + extension, versions: versions || ['>=4'] }, (exports3) => {
          const targetPrototype = exports3[targetClass].prototype
          for (const methodName of methods) {
            shimmer.wrap(
              targetPrototype,
              methodName,
              (methodFn) =>
                function () {
                  if (!ch.start.hasSubscribers) {
                    return methodFn.apply(this, arguments)
                  }
                  const stream = streamedResponse && getOption(arguments, 'stream', false)
                  const client = this._client || this.client
                  const ctx = {
                    methodName: `${baseResource}.${methodName}`,
                    args: arguments,
                    basePath: client.baseURL,
                  }
                  return ch.start.runStores(ctx, () => {
                    const apiProm = methodFn.apply(this, arguments)
                    if (baseResource === 'chat.completions' && typeof apiProm._thenUnwrap === 'function') {
                      shimmer.wrap(
                        apiProm,
                        '_thenUnwrap',
                        (origApiPromThenUnwrap) =>
                          function () {
                            const unwrappedPromise = origApiPromThenUnwrap.apply(this, arguments)
                            shimmer.wrap(
                              unwrappedPromise,
                              'parse',
                              (origApiPromParse) =>
                                function () {
                                  const parsedPromise = origApiPromParse
                                    .apply(this, arguments)
                                    .then((body) => Promise.all([this.responsePromise, body]))
                                  return handleUnwrappedAPIPromise(parsedPromise, ctx, stream)
                                }
                            )
                            return unwrappedPromise
                          }
                      )
                    }
                    shimmer.wrap(
                      apiProm,
                      'parse',
                      (origApiPromParse) =>
                        function () {
                          const parsedPromise = origApiPromParse
                            .apply(this, arguments)
                            .then((body) => Promise.all([this.responsePromise, body]))
                          return handleUnwrappedAPIPromise(parsedPromise, ctx, stream)
                        }
                    )
                    ch.end.publish(ctx)
                    return apiProm
                  })
                }
            )
          }
          return exports3
        })
      }
    }
    function handleUnwrappedAPIPromise(apiProm, ctx, stream) {
      return apiProm
        .then(([{ response, options }, body]) => {
          if (stream) {
            if (body.iterator) {
              shimmer.wrap(body, 'iterator', wrapStreamIterator(response, options, ctx))
            } else {
              shimmer.wrap(body.response.body, Symbol.asyncIterator, wrapStreamIterator(response, options, ctx))
            }
          } else {
            finish(ctx, {
              headers: response.headers,
              data: body,
              request: {
                path: response.url,
                method: options.method,
              },
            })
          }
          return body
        })
        .catch((error) => {
          finish(ctx, void 0, error)
          throw error
        })
    }
    function finish(ctx, response, error) {
      if (error) {
        ctx.error = error
        ch.error.publish(ctx)
      }
      ctx.result ??= {}
      Object.assign(ctx.result, response)
      ch.asyncEnd.publish(ctx)
    }
    function getOption(args, option, defaultValue) {
      return args[0]?.[option] || defaultValue
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/passport.js
var require_passport = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/passport.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook } = require_instrument()
    var onPassportDeserializeUserChannel = channel('datadog:passport:deserializeUser:finish')
    function wrapDone(done) {
      return function wrappedDone(err, user) {
        if (!err && user) {
          const abortController = new AbortController()
          onPassportDeserializeUserChannel.publish({ user, abortController })
          if (abortController.signal.aborted) return
        }
        return done.apply(this, arguments)
      }
    }
    function wrapDeserializeUser(deserializeUser) {
      return function wrappedDeserializeUser(fn, req, done) {
        if (typeof fn === 'function') return deserializeUser.apply(this, arguments)
        if (typeof req === 'function') {
          done = req
          arguments[1] = wrapDone(done)
        } else {
          arguments[2] = wrapDone(done)
        }
        return deserializeUser.apply(this, arguments)
      }
    }
    addHook(
      {
        name: 'passport',
        file: 'lib/authenticator.js',
        versions: ['>=0.3.0'],
      },
      (Authenticator) => {
        shimmer.wrap(Authenticator.prototype, 'deserializeUser', wrapDeserializeUser)
        return Authenticator
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/passport-utils.js
var require_passport_utils = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/passport-utils.js'(exports2, module2) {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel } = require_instrument()
    var passportVerifyChannel = channel('datadog:passport:verify:finish')
    function wrapVerifiedAndPublish(framework, username, verified) {
      return shimmer.wrapFunction(verified, function wrapVerified(verified2) {
        return function wrappedVerified(err, user) {
          if (!err) {
            const abortController = new AbortController()
            passportVerifyChannel.publish({ framework, login: username, user, success: !!user, abortController })
            if (abortController.signal.aborted) return
          }
          return verified2.apply(this, arguments)
        }
      })
    }
    function wrapVerify(verify) {
      return function wrappedVerify(req, username, password, verified) {
        if (passportVerifyChannel.hasSubscribers) {
          const framework = `passport-${this.name}`
          if (this._passReqToCallback) {
            arguments[3] = wrapVerifiedAndPublish(framework, arguments[1], arguments[3])
          } else {
            arguments[2] = wrapVerifiedAndPublish(framework, arguments[0], arguments[2])
          }
        }
        return verify.apply(this, arguments)
      }
    }
    function wrapStrategy(Strategy) {
      return function wrappedStrategy() {
        if (typeof arguments[0] === 'function') {
          arguments[0] = wrapVerify(arguments[0])
        } else {
          arguments[1] = wrapVerify(arguments[1])
        }
        return Strategy.apply(this, arguments)
      }
    }
    function strategyHook(Strategy) {
      return shimmer.wrapFunction(Strategy, wrapStrategy)
    }
    module2.exports = {
      strategyHook,
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/passport-http.js
var require_passport_http = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/passport-http.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { strategyHook } = require_passport_utils()
    addHook(
      {
        name: 'passport-http',
        file: 'lib/passport-http/strategies/basic.js',
        versions: ['>=0.3.0'],
      },
      strategyHook
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/passport-local.js
var require_passport_local = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/passport-local.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { strategyHook } = require_passport_utils()
    addHook(
      {
        name: 'passport-local',
        file: 'lib/strategy.js',
        versions: ['>=1.0.0'],
      },
      strategyHook
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js
var require_pg = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var startCh = channel('apm:pg:query:start')
    var finishCh = channel('apm:pg:query:finish')
    var errorCh = channel('apm:pg:query:error')
    var startPoolQueryCh = channel('datadog:pg:pool:query:start')
    var finishPoolQueryCh = channel('datadog:pg:pool:query:finish')
    var { errorMonitor } = require('node:events')
    addHook({ name: 'pg', versions: ['>=8.0.3'], file: 'lib/native/client.js' }, (Client) => {
      shimmer.wrap(Client.prototype, 'query', (query) => wrapQuery(query))
      return Client
    })
    addHook({ name: 'pg', versions: ['>=8.0.3'], file: 'lib/client.js' }, (Client) => {
      shimmer.wrap(Client.prototype, 'query', (query) => wrapQuery(query))
      return Client
    })
    addHook({ name: 'pg', versions: ['>=8.0.3'] }, (pg) => {
      shimmer.wrap(pg.Pool.prototype, 'query', (query) => wrapPoolQuery(query))
      return pg
    })
    function wrapQuery(query) {
      return function () {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments)
        }
        const processId = this.processID
        const pgQuery =
          arguments[0] !== null && typeof arguments[0] === 'object' ? arguments[0] : { text: arguments[0] }
        const textPropObj = pgQuery.cursor ?? pgQuery
        const textProp = Object.getOwnPropertyDescriptor(textPropObj, 'text')
        const stream = typeof textPropObj.read === 'function'
        let originalText
        if (!textProp || textProp.configurable) {
          originalText = textPropObj.text
          Object.defineProperty(textPropObj, 'text', {
            get() {
              return this?.__ddInjectableQuery || originalText
            },
          })
        }
        const abortController = new AbortController()
        const ctx = {
          params: this.connectionParameters,
          query: textPropObj,
          originalText,
          processId,
          abortController,
          stream,
        }
        const finish2 = (error, res) => {
          if (error) {
            ctx.error = error
            errorCh.publish(ctx)
          }
          ctx.result = res?.rows
          return finishCh.publish(ctx)
        }
        return startCh.runStores(ctx, () => {
          if (abortController.signal.aborted) {
            const error = abortController.signal.reason || new Error('Aborted')
            const reusingQuery = typeof pgQuery.submit === 'function'
            const callback = arguments[arguments.length - 1]
            finish2(error)
            if (reusingQuery) {
              if (!pgQuery.callback && typeof callback === 'function') {
                pgQuery.callback = callback
              }
              if (pgQuery.callback) {
                pgQuery.callback(error)
              } else {
                process.nextTick(() => {
                  pgQuery.emit('error', error)
                })
              }
              return pgQuery
            }
            if (typeof callback === 'function') {
              callback(error)
              return
            }
            return Promise.reject(error)
          }
          arguments[0] = pgQuery
          const retval = query.apply(this, arguments)
          const queryQueue = this.queryQueue || this._queryQueue
          const activeQuery = this.activeQuery || this._activeQuery
          const newQuery = queryQueue.at(-1) || activeQuery
          if (!newQuery) {
            return retval
          }
          if (newQuery.callback) {
            const originalCallback = newQuery.callback
            newQuery.callback = function (err, ...args) {
              finish2(err, ...args)
              return finishCh.runStores(ctx, originalCallback, this, err, ...args)
            }
          } else if (newQuery.once) {
            newQuery.once(errorMonitor, finish2).once('end', (res) => finish2(null, res))
          } else {
            newQuery.then((res) => finish2(null, res), finish2)
          }
          try {
            return retval
          } catch (error) {
            ctx.error = error
            errorCh.publish(ctx)
          }
        })
      }
    }
    var finish = (ctx) => {
      finishPoolQueryCh.publish(ctx)
    }
    function wrapPoolQuery(query) {
      return function () {
        if (!startPoolQueryCh.hasSubscribers) {
          return query.apply(this, arguments)
        }
        const pgQuery =
          arguments[0] !== null && typeof arguments[0] === 'object' ? arguments[0] : { text: arguments[0] }
        const abortController = new AbortController()
        const ctx = { query: pgQuery, abortController }
        return startPoolQueryCh.runStores(ctx, () => {
          const cb = arguments[arguments.length - 1]
          if (abortController.signal.aborted) {
            const error = abortController.signal.reason || new Error('Aborted')
            finish(ctx)
            if (typeof cb === 'function') {
              cb(error)
              return
            }
            return Promise.reject(error)
          }
          if (typeof cb === 'function') {
            arguments[arguments.length - 1] = shimmer.wrapFunction(
              cb,
              (cb2) =>
                function () {
                  finish(ctx)
                  return cb2.apply(this, arguments)
                }
            )
          }
          const retval = query.apply(this, arguments)
          if (retval?.then) {
            retval
              .then(() => {
                finish(ctx)
              })
              .catch(() => {
                finish(ctx)
              })
          }
          return retval
        })
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js
var require_pino = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    function wrapPino(symbol, wrapper, pino) {
      return function pinoWithTrace() {
        const instance = pino.apply(this, arguments)
        Object.defineProperty(instance, symbol, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: wrapper(instance[symbol]),
        })
        return instance
      }
    }
    function wrapAsJson(asJson) {
      const ch = channel('apm:pino:log')
      return function asJsonWithTrace(obj, msg, num, time) {
        obj = arguments[0] = obj || {}
        const payload = { message: obj }
        ch.publish(payload)
        arguments[0] = payload.message
        return asJson.apply(this, arguments)
      }
    }
    function wrapMixin(mixin) {
      const ch = channel('apm:pino:log')
      return function mixinWithTrace() {
        let obj = {}
        if (mixin) {
          obj = mixin.apply(this, arguments)
        }
        const payload = { message: obj }
        ch.publish(payload)
        return payload.message
      }
    }
    function wrapPrettifyObject(prettifyObject) {
      const ch = channel('apm:pino:log')
      return function prettifyObjectWithTrace(input) {
        const payload = { message: input.input }
        ch.publish(payload)
        input.input = payload.message
        return prettifyObject.apply(this, arguments)
      }
    }
    function wrapPrettyFactory(prettyFactory) {
      const ch = channel('apm:pino:log')
      return function prettyFactoryWithTrace() {
        const pretty = prettyFactory.apply(this, arguments)
        return function prettyWithTrace(obj) {
          const payload = { message: obj }
          ch.publish(payload)
          arguments[0] = payload.message
          return pretty.apply(this, arguments)
        }
      }
    }
    addHook({ name: 'pino', versions: ['2 - 3', '4'], patchDefault: true }, (pino) => {
      const asJsonSym = (pino.symbols && pino.symbols.asJsonSym) || 'asJson'
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(asJsonSym, wrapAsJson, pino2))
      return wrapped
    })
    addHook({ name: 'pino', versions: ['>=5 <5.14.0'], patchDefault: true }, (pino) => {
      const asJsonSym = (pino.default || pino)?.symbols.asJsonSym || 'asJson'
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(asJsonSym, wrapAsJson, pino2))
      return wrapped
    })
    addHook({ name: 'pino', versions: ['>=5.14.0 <6.8.0'] }, (pino) => {
      const mixinSym = (pino.default || pino).symbols.mixinSym
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(mixinSym, wrapMixin, pino2.default || pino2))
      return wrapped
    })
    addHook({ name: 'pino', versions: ['>=6.8.0'], patchDefault: false }, (pino, _1, _2, isIitm) => {
      const mixinSym = pino.symbols.mixinSym
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(mixinSym, wrapMixin, pino2))
      wrapped.pino = wrapped
      wrapped.default = wrapped
      return wrapped
    })
    addHook({ name: 'pino-pretty', file: 'lib/utils.js', versions: ['>=3'] }, (utils) => {
      shimmer.wrap(utils, 'prettifyObject', wrapPrettifyObject)
      return utils
    })
    addHook({ name: 'pino-pretty', versions: ['1 - 2'] }, (prettyFactory) => {
      return shimmer.wrapFunction(prettyFactory, wrapPrettyFactory)
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js
var require_promise_js = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { wrapThen } = require_promise()
    var shimmer = require_datadog_shimmer()
    addHook(
      {
        name: 'promise-js',
        versions: ['>=0.0.3'],
      },
      (Promise2) => {
        if (Promise2 !== global.Promise) {
          shimmer.wrap(Promise2.prototype, 'then', wrapThen)
        }
        return Promise2
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js
var require_promise2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { wrapThen } = require_promise()
    var shimmer = require_datadog_shimmer()
    addHook(
      {
        name: 'promise',
        file: 'lib/core.js',
        versions: ['>=7'],
      },
      (Promise2) => {
        shimmer.wrap(Promise2.prototype, 'then', wrapThen)
        return Promise2
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/protobufjs.js
var require_protobufjs = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/protobufjs.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook } = require_instrument()
    var dc = require_dc_polyfill()
    var serializeChannel = dc.channel('apm:protobufjs:serialize-start')
    var deserializeChannel = dc.channel('apm:protobufjs:deserialize-end')
    function wrapSerialization(messageClass) {
      if (messageClass?.encode) {
        shimmer.wrap(
          messageClass,
          'encode',
          (original) =>
            function () {
              if (!serializeChannel.hasSubscribers) {
                return original.apply(this, arguments)
              }
              serializeChannel.publish({ messageClass: this })
              return original.apply(this, arguments)
            }
        )
      }
    }
    function wrapDeserialization(messageClass) {
      if (messageClass?.decode) {
        shimmer.wrap(
          messageClass,
          'decode',
          (original) =>
            function () {
              if (!deserializeChannel.hasSubscribers) {
                return original.apply(this, arguments)
              }
              const result = original.apply(this, arguments)
              deserializeChannel.publish({ messageClass: result })
              return result
            }
        )
      }
    }
    function wrapSetup(messageClass) {
      if (messageClass?.setup) {
        shimmer.wrap(
          messageClass,
          'setup',
          (original) =>
            function () {
              const result = original.apply(this, arguments)
              wrapSerialization(messageClass)
              wrapDeserialization(messageClass)
              return result
            }
        )
      }
    }
    function wrapProtobufClasses(root) {
      if (!root) {
        return
      }
      if (root.decode) {
        wrapSetup(root)
      }
      if (root.nestedArray) {
        for (const subRoot of root.nestedArray) {
          wrapProtobufClasses(subRoot)
        }
      }
    }
    function wrapReflection(protobuf) {
      const reflectionMethods = [
        {
          target: protobuf.Root,
          name: 'fromJSON',
        },
        {
          target: protobuf.Type.prototype,
          name: 'fromObject',
        },
      ]
      reflectionMethods.forEach((method) => {
        shimmer.wrap(
          method.target,
          method.name,
          (original) =>
            function () {
              const result = original.apply(this, arguments)
              if (result.nested) {
                for (const type in result.nested) {
                  wrapSetup(result.nested[type])
                }
              }
              if (result.$type) {
                wrapSetup(result.$type)
              }
              return result
            }
        )
      })
    }
    function isPromise(obj) {
      return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'
    }
    addHook(
      {
        name: 'protobufjs',
        versions: ['>=6.8.0'],
      },
      (protobuf) => {
        shimmer.wrap(
          protobuf.Root.prototype,
          'load',
          (original) =>
            function () {
              const result = original.apply(this, arguments)
              if (isPromise(result)) {
                return result.then((root) => {
                  wrapProtobufClasses(root)
                  return root
                })
              }
              wrapProtobufClasses(result)
              return result
            }
        )
        shimmer.wrap(
          protobuf.Root.prototype,
          'loadSync',
          (original) =>
            function () {
              const root = original.apply(this, arguments)
              wrapProtobufClasses(root)
              return root
            }
        )
        shimmer.wrap(
          protobuf,
          'Type',
          (Original) =>
            function () {
              const typeInstance = new Original(...arguments)
              wrapSetup(typeInstance)
              return typeInstance
            }
        )
        wrapReflection(protobuf)
        return protobuf
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/pug.js
var require_pug = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/pug.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel, addHook } = require_instrument()
    var pugCompileCh = channel('datadog:pug:compile:start')
    function wrapCompile(compile) {
      return function wrappedCompile(source) {
        if (pugCompileCh.hasSubscribers) {
          pugCompileCh.publish({ source })
        }
        return compile.apply(this, arguments)
      }
    }
    addHook({ name: 'pug', versions: ['>=2.0.4'] }, (compiler) => {
      shimmer.wrap(compiler, 'compile', wrapCompile)
      shimmer.wrap(compiler, 'compileClientWithDependenciesTracked', wrapCompile)
      return compiler
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/q.js
var require_q = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/q.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { wrapThen } = require_promise()
    var shimmer = require_datadog_shimmer()
    addHook(
      {
        name: 'q',
        versions: ['1'],
      },
      (Q) => {
        shimmer.wrap(Q.makePromise.prototype, 'then', wrapThen)
        return Q
      }
    )
    addHook(
      {
        name: 'q',
        versions: ['>=2'],
      },
      (Q) => {
        shimmer.wrap(Q.Promise.prototype, 'then', wrapThen)
        return Q
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/restify.js
var require_restify = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/restify.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { addHook, channel } = require_instrument()
    var handlers = ['use', 'pre']
    var methods = ['del', 'get', 'head', 'opts', 'post', 'put', 'patch']
    var handleChannel = channel('apm:restify:request:handle')
    var errorChannel = channel('apm:restify:middleware:error')
    var enterChannel = channel('apm:restify:middleware:enter')
    var exitChannel = channel('apm:restify:middleware:exit')
    var finishChannel = channel('apm:restify:middleware:finish')
    var nextChannel = channel('apm:restify:middleware:next')
    function wrapSetupRequest(setupRequest) {
      return function (req, res) {
        handleChannel.publish({ req, res })
        return setupRequest.apply(this, arguments)
      }
    }
    function wrapMethod(method) {
      return function (path, ...middlewares) {
        const wrappedMiddlewares = middlewares.map(wrapFn)
        return method.apply(this, [path, ...wrappedMiddlewares])
      }
    }
    function wrapHandler(method) {
      return function (...middlewares) {
        return method.apply(this, middlewares.map(wrapFn))
      }
    }
    function wrapFn(fn) {
      if (Array.isArray(fn)) return fn.map(wrapFn)
      return shimmer.wrapFunction(
        fn,
        (fn2) =>
          function (req, res, next) {
            if (typeof next === 'function') {
              arguments[2] = wrapNext(req, next)
            }
            const route = req.route && req.route.path
            enterChannel.publish({ req, route })
            try {
              const result = fn2.apply(this, arguments)
              if (typeof result?.then === 'function') {
                return result
                  .then(function (result2) {
                    nextChannel.publish({ req })
                    finishChannel.publish({ req })
                    return result2
                  })
                  .catch(function (error) {
                    errorChannel.publish({ req, error })
                    nextChannel.publish({ req })
                    finishChannel.publish({ req })
                    throw error
                  })
              }
              return result
            } catch (error) {
              errorChannel.publish({ req, error })
              nextChannel.publish({ req })
              finishChannel.publish({ req })
              throw error
            } finally {
              exitChannel.publish({ req })
            }
          }
      )
    }
    function wrapNext(req, next) {
      return shimmer.wrapFunction(
        next,
        (next2) =>
          function () {
            nextChannel.publish({ req })
            finishChannel.publish({ req })
            next2.apply(this, arguments)
          }
      )
    }
    addHook({ name: 'restify', versions: ['>=3'], file: 'lib/server.js' }, (Server) => {
      shimmer.wrap(Server.prototype, '_setupRequest', wrapSetupRequest)
      shimmer.massWrap(Server.prototype, handlers, wrapHandler)
      shimmer.massWrap(Server.prototype, methods, wrapMethod)
      return Server
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js
var require_rhea = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js'(exports2, module2) {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var circularBufferConstructor = /* @__PURE__ */ Symbol('circularBufferConstructor')
    var inFlightDeliveries = /* @__PURE__ */ Symbol('inFlightDeliveries')
    var patched = /* @__PURE__ */ new WeakSet()
    var startSendCh = channel('apm:rhea:send:start')
    var encodeSendCh = channel('apm:rhea:send:encode')
    var errorSendCh = channel('apm:rhea:send:error')
    var finishSendCh = channel('apm:rhea:send:finish')
    var startReceiveCh = channel('apm:rhea:receive:start')
    var dispatchReceiveCh = channel('apm:rhea:receive:dispatch')
    var errorReceiveCh = channel('apm:rhea:receive:error')
    var finishReceiveCh = channel('apm:rhea:receive:finish')
    var contexts = /* @__PURE__ */ new WeakMap()
    addHook({ name: 'rhea', versions: ['>=1'] }, (rhea) => {
      shimmer.wrap(
        rhea.message,
        'encode',
        (encode) =>
          function (msg) {
            encodeSendCh.publish(msg)
            return encode.apply(this, arguments)
          }
      )
      return rhea
    })
    addHook({ name: 'rhea', versions: ['>=1'], file: 'lib/link.js' }, (obj) => {
      const Sender = obj.Sender
      const Receiver = obj.Receiver
      shimmer.wrap(
        Sender.prototype,
        'send',
        (send) =>
          function (msg, tag, format) {
            if (!canTrace(this)) {
              return send.apply(this, arguments)
            }
            const { host, port } = getHostAndPort(this.connection)
            const targetAddress =
              this.options && this.options.target && this.options.target.address ? this.options.target.address : void 0
            const ctx = { targetAddress, host, port, msg, connection: this.connection }
            return startSendCh.runStores(ctx, () => {
              const delivery = send.apply(this, arguments)
              contexts.set(delivery, ctx)
              addToInFlightDeliveries(this.connection, delivery)
              try {
                return delivery
              } catch (err) {
                ctx.error = err
                errorSendCh.publish(ctx)
                throw err
              }
            })
          }
      )
      shimmer.wrap(
        Receiver.prototype,
        'dispatch',
        (dispatch) =>
          function (eventName, msgObj) {
            if (!canTrace(this)) {
              return dispatch.apply(this, arguments)
            }
            if (eventName === 'message' && msgObj) {
              const ctx = { msgObj, connection: this.connection }
              return startReceiveCh.runStores(ctx, () => {
                if (msgObj.delivery) {
                  contexts.set(msgObj.delivery, ctx)
                  msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery, msgObj.delivery.update)
                  addToInFlightDeliveries(this.connection, msgObj.delivery)
                }
                try {
                  return dispatch.apply(this, arguments)
                } catch (err) {
                  ctx.error = err
                  errorReceiveCh.publish(ctx)
                  throw err
                }
              })
            }
            return dispatch.apply(this, arguments)
          }
      )
      return obj
    })
    addHook({ name: 'rhea', versions: ['>=1'], file: 'lib/connection.js' }, (Connection) => {
      shimmer.wrap(
        Connection.prototype,
        'dispatch',
        (dispatch) =>
          function (eventName, obj) {
            if (eventName === 'disconnected') {
              const error = obj.error || this.saved_error
              if (this[inFlightDeliveries]) {
                this[inFlightDeliveries].forEach((delivery) => {
                  const ctx = contexts.get(delivery)
                  if (!ctx) return
                  ctx.error = error
                  errorReceiveCh.publish(ctx)
                  exports2.beforeFinish(delivery, null)
                  finishReceiveCh.publish(ctx)
                })
              }
            }
            return dispatch.apply(this, arguments)
          }
      )
      return Connection
    })
    addHook({ name: 'rhea', versions: ['>=1'], file: 'lib/session.js' }, (Session) => {
      patchCircularBuffer(Session.prototype, Session)
      return Session
    })
    function canTrace(link) {
      return link.connection && link.session && link.session.outgoing
    }
    function getHostAndPort(connection) {
      let host
      let port
      if (connection && connection.options) {
        host = connection.options.host
        port = connection.options.port
      }
      return { host, port }
    }
    function wrapDeliveryUpdate(obj, update) {
      const ctx = contexts.get(obj)
      if (obj && ctx) {
        const cb = update
        return shimmer.wrapFunction(
          cb,
          (cb2) =>
            function wrappedUpdate(settled, stateData) {
              ctx.state = getStateFromData(stateData)
              dispatchReceiveCh.runStores(ctx, () => {
                return cb2.apply(this, arguments)
              })
            }
        )
      }
      return function wrappedUpdate(settled, stateData) {
        return update.apply(this, arguments)
      }
    }
    function patchCircularBuffer(proto, Session) {
      Object.defineProperty(proto, 'outgoing', {
        configurable: true,
        // eslint-disable-next-line getter-return
        get() {},
        set(outgoing) {
          delete proto.outgoing
          this.outgoing = outgoing
          if (outgoing) {
            let CircularBuffer
            if (outgoing.deliveries) {
              CircularBuffer = outgoing.deliveries.constructor
            }
            if (CircularBuffer && !patched.has(CircularBuffer.prototype)) {
              shimmer.wrap(
                CircularBuffer.prototype,
                'pop_if',
                (popIf) =>
                  function (fn) {
                    arguments[0] = shimmer.wrapFunction(
                      fn,
                      (fn2) =>
                        function (entry) {
                          const ctx = contexts.get(entry)
                          if (!ctx) return fn2(entry)
                          const shouldPop = fn2(entry)
                          if (shouldPop) {
                            const remoteState = entry.remote_state
                            const state =
                              remoteState && remoteState.constructor
                                ? entry.remote_state.constructor.composite_type
                                : void 0
                            ctx.state = state
                            exports2.beforeFinish(entry, state)
                            finishSendCh.publish(ctx)
                          }
                          return shouldPop
                        }
                    )
                    return popIf.apply(this, arguments)
                  }
              )
              patched.add(CircularBuffer.prototype)
              const Session2 = proto.constructor
              if (Session2) {
                Session2[circularBufferConstructor] = CircularBuffer
              }
            }
          }
        },
      })
    }
    function addToInFlightDeliveries(connection, delivery) {
      let deliveries = connection[inFlightDeliveries]
      if (!deliveries) {
        deliveries = /* @__PURE__ */ new Set()
        connection[inFlightDeliveries] = deliveries
      }
      deliveries.add(delivery)
    }
    function beforeFinish(delivery, state) {
      const ctx = contexts.get(delivery)
      if (ctx) {
        if (state) {
          ctx.state = state
          dispatchReceiveCh.publish(ctx)
        }
        if (ctx.connection && ctx.connection[inFlightDeliveries]) {
          ctx.connection[inFlightDeliveries].delete(delivery)
        }
      }
    }
    function getStateFromData(stateData) {
      if (stateData && stateData.descriptor && stateData.descriptor) {
        switch (stateData.descriptor.value) {
          case 36:
            return 'accepted'
          case 37:
            return 'rejected'
          case 38:
            return 'released'
          case 39:
            return 'modified'
        }
      }
    }
    module2.exports.inFlightDeliveries = inFlightDeliveries
    module2.exports.beforeFinish = beforeFinish
    module2.exports.contexts = contexts
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/selenium.js
var require_selenium = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/selenium.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { getEnvironmentVariable } = require_config_helper()
    var ciSeleniumDriverGetStartCh = channel('ci:selenium:driver:get')
    var RUM_STOP_SESSION_SCRIPT = `
if (window.DD_RUM && window.DD_RUM.stopSession) {
  window.DD_RUM.stopSession();
  return true;
} else {
  return false;
}
`
    var IS_RUM_ACTIVE_SCRIPT = 'return !!window.DD_RUM'
    var DD_CIVISIBILITY_RUM_FLUSH_WAIT_MILLIS =
      Number(getEnvironmentVariable('DD_CIVISIBILITY_RUM_FLUSH_WAIT_MILLIS')) || 500
    var DD_CIVISIBILITY_TEST_EXECUTION_ID_COOKIE_NAME = 'datadog-ci-visibility-test-execution-id'
    addHook(
      {
        name: 'selenium-webdriver',
        versions: ['>=4.11.0'],
      },
      (seleniumPackage, seleniumVersion) => {
        shimmer.wrap(
          seleniumPackage.WebDriver.prototype,
          'get',
          (get) =>
            async function () {
              if (!ciSeleniumDriverGetStartCh.hasSubscribers) {
                return get.apply(this, arguments)
              }
              let traceId
              const setTraceId = (inputTraceId) => {
                traceId = inputTraceId
              }
              const getResult = await get.apply(this, arguments)
              const isRumActive = await this.executeScript(IS_RUM_ACTIVE_SCRIPT)
              const capabilities = await this.getCapabilities()
              ciSeleniumDriverGetStartCh.publish({
                setTraceId,
                seleniumVersion,
                browserName: capabilities.getBrowserName(),
                browserVersion: capabilities.getBrowserVersion(),
                isRumActive,
              })
              if (traceId && isRumActive) {
                await this.manage().addCookie({
                  name: DD_CIVISIBILITY_TEST_EXECUTION_ID_COOKIE_NAME,
                  value: traceId,
                })
              }
              return getResult
            }
        )
        shimmer.wrap(
          seleniumPackage.WebDriver.prototype,
          'quit',
          (quit) =>
            async function () {
              if (!ciSeleniumDriverGetStartCh.hasSubscribers) {
                return quit.apply(this, arguments)
              }
              const isRumActive = await this.executeScript(RUM_STOP_SESSION_SCRIPT)
              if (isRumActive) {
                await new Promise((resolve) => {
                  setTimeout(() => {
                    resolve()
                  }, DD_CIVISIBILITY_RUM_FLUSH_WAIT_MILLIS)
                })
                await this.manage().deleteCookie(DD_CIVISIBILITY_TEST_EXECUTION_ID_COOKIE_NAME)
              }
              return quit.apply(this, arguments)
            }
        )
        return seleniumPackage
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/sequelize.js
var require_sequelize = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/sequelize.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: 'sequelize', versions: ['>=4'], file: ['lib/sequelize.js'] }, (Sequelize) => {
      const startCh = channel('datadog:sequelize:query:start')
      const finishCh = channel('datadog:sequelize:query:finish')
      shimmer.wrap(Sequelize.prototype, 'query', (query) => {
        return function (sql, options) {
          if (!startCh.hasSubscribers) {
            return query.apply(this, arguments)
          }
          let dialect
          if (this.options && this.options.dialect) {
            dialect = this.options.dialect
          } else if (this.dialect && this.dialect.name) {
            dialect = this.dialect.name
          }
          function onFinish(result) {
            const type = options?.type || 'RAW'
            if (type === 'RAW' && result?.length > 1) {
              result = result[0]
            }
            finishCh.runStores({ result }, () => {})
          }
          return startCh.runStores({ sql, dialect }, () => {
            const promise = query.apply(this, arguments)
            promise.then(onFinish, () => {
              onFinish()
            })
            return promise
          })
        }
      })
      return Sequelize
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js
var require_sharedb = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var READABLE_ACTION_NAMES = {
      hs: 'handshake',
      qf: 'query-fetch',
      qs: 'query-subscribe',
      qu: 'query-unsubscribe',
      bf: 'bulk-fetch',
      bs: 'bulk-subscribe',
      bu: 'bulk-unsubscribe',
      f: 'fetch',
      s: 'subscribe',
      u: 'unsubscribe',
      op: 'op',
      nf: 'snapshot-fetch',
      nt: 'snapshot-fetch-by-ts',
      p: 'presence-broadcast',
      pr: 'presence-request',
      ps: 'presence-subscribe',
      pu: 'presence-unsubscribe',
    }
    addHook({ name: 'sharedb', versions: ['>=1'], file: 'lib/agent.js' }, (Agent) => {
      const startCh = channel('apm:sharedb:request:start')
      const finishCh = channel('apm:sharedb:request:finish')
      const errorCh = channel('apm:sharedb:request:error')
      shimmer.wrap(
        Agent.prototype,
        '_handleMessage',
        (origHandleMessageFn) =>
          function (request, callback) {
            const action = request.a
            const actionName = getReadableActionName(action)
            const ctx = { actionName, request }
            return startCh.runStores(ctx, () => {
              arguments[1] = shimmer.wrapFunction(
                callback,
                (callback2) =>
                  function (error, res) {
                    if (error) {
                      ctx.error = error
                      errorCh.publish(error)
                    }
                    ctx.res = res
                    return finishCh.runStores(ctx, callback2, this, ...arguments)
                  }
              )
              try {
                return origHandleMessageFn.apply(this, arguments)
              } catch (error) {
                ctx.error = error
                errorCh.publish(ctx)
                throw error
              }
            })
          }
      )
      return Agent
    })
    function getReadableActionName(action) {
      const actionName = READABLE_ACTION_NAMES[action]
      if (actionName === void 0) {
        return action
      }
      return actionName
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js
var require_tedious = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    addHook({ name: 'tedious', versions: ['>=1.0.0'] }, (tedious) => {
      const startCh = channel('apm:tedious:request:start')
      const finishCh = channel('apm:tedious:request:finish')
      const errorCh = channel('apm:tedious:request:error')
      shimmer.wrap(
        tedious.Connection.prototype,
        'makeRequest',
        (makeRequest) =>
          function (request) {
            if (!startCh.hasSubscribers) {
              return makeRequest.apply(this, arguments)
            }
            const [queryOrProcedure, queryParent, queryField] = getQueryOrProcedure(request)
            if (!queryOrProcedure) {
              return makeRequest.apply(this, arguments)
            }
            const connectionConfig = this.config
            const ctx = { queryOrProcedure, connectionConfig }
            return startCh.runStores(ctx, () => {
              queryParent[queryField] = ctx.sql
              const cb = request.callback
              request.callback = function (error, ...args) {
                if (error) {
                  ctx.error = error
                  errorCh.publish(ctx)
                }
                return finishCh.runStores(ctx, cb, this, error, ...args)
              }
              try {
                return makeRequest.apply(this, arguments)
              } catch (error) {
                ctx.error = error
                errorCh.publish(ctx)
                throw error
              }
            })
          }
      )
      return tedious
    })
    function getQueryOrProcedure(request) {
      if (!request.parameters) return [null]
      if (request.parametersByName.statement) {
        return [request.parametersByName.statement.value, request.parametersByName.statement, 'value']
      } else if (request.parametersByName.stmt) {
        return [request.parametersByName.stmt.value, request.parametersByName.stmt, 'value']
      }
      return [request.sqlTextOrProcedure, request, 'sqlTextOrProcedure']
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/fetch.js
var require_fetch = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/fetch.js'(exports2) {
    'use strict'
    exports2.createWrapFetch = function createWrapFetch(Request, ch, onLoad) {
      return function wrapFetch(fetch2) {
        if (typeof fetch2 !== 'function') return fetch2
        return function (input, init) {
          if (onLoad) {
            onLoad()
            onLoad = void 0
          }
          if (!ch.start.hasSubscribers) return fetch2.apply(this, arguments)
          if (input instanceof Request) {
            const ctx2 = { req: input }
            return ch.tracePromise(() => fetch2.call(this, input, init), ctx2)
          }
          const req = new Request(input, init)
          const ctx = { req }
          return ch.tracePromise(() => fetch2.call(this, req), ctx)
        }
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/undici.js
var require_undici = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/undici.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var tracingChannel = require_dc_polyfill().tracingChannel
    var ch = tracingChannel('apm:undici:fetch')
    var { createWrapFetch } = require_fetch()
    addHook(
      {
        name: 'undici',
        versions: ['^4.4.1', '5', '>=6.0.0'],
      },
      (undici) => {
        return shimmer.wrap(undici, 'fetch', createWrapFetch(undici.Request, ch))
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/when.js
var require_when = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/when.js'() {
    'use strict'
    var { addHook } = require_instrument()
    var { wrapThen } = require_promise()
    var shimmer = require_datadog_shimmer()
    addHook(
      {
        name: 'when',
        file: 'lib/Promise.js',
        versions: ['>=3'],
      },
      (Promise2) => {
        shimmer.wrap(Promise2.prototype, 'then', wrapThen)
        return Promise2
      }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js
var require_winston = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js'() {
    'use strict'
    var { channel, addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var patched = /* @__PURE__ */ new WeakSet()
    var configureCh = channel('ci:log-submission:winston:configure')
    var addTransport = channel('ci:log-submission:winston:add-transport')
    addHook({ name: 'winston', file: 'lib/winston/transports/index.js', versions: ['>=3'] }, (transportsPackage) => {
      if (configureCh.hasSubscribers) {
        configureCh.publish(transportsPackage.Http)
      }
      return transportsPackage
    })
    addHook({ name: 'winston', file: 'lib/winston/logger.js', versions: ['>=3'] }, (Logger) => {
      const logCh = channel('apm:winston:log')
      shimmer.wrap(Logger.prototype, 'write', (write) => {
        return function wrappedWrite(chunk, enc, cb) {
          if (logCh.hasSubscribers) {
            const payload = { message: chunk }
            logCh.publish(payload)
            arguments[0] = payload.message
          }
          return write.apply(this, arguments)
        }
      })
      shimmer.wrap(
        Logger.prototype,
        'configure',
        (configure) =>
          function () {
            const configureResponse = configure.apply(this, arguments)
            if (addTransport.hasSubscribers) {
              addTransport.publish(this)
            }
            return configureResponse
          }
      )
      return Logger
    })
    addHook({ name: 'winston', file: 'lib/winston/logger.js', versions: ['1', '2'] }, (logger) => {
      const logCh = channel('apm:winston:log')
      if (logger.Logger.prototype.configure) {
        shimmer.wrap(logger.Logger.prototype, 'configure', (configure) => wrapMethod(configure, logCh))
      }
      shimmer.wrap(logger.Logger.prototype, 'add', (configure) => wrapMethod(configure, logCh))
      return logger
    })
    function wrapMethod(method, logCh) {
      return function methodWithTrace() {
        const result = method.apply(this, arguments)
        if (logCh.hasSubscribers) {
          for (const name in this.transports) {
            const transport = this.transports[name]
            if (patched.has(transport) || typeof transport.log !== 'function') continue
            shimmer.wrap(
              transport,
              'log',
              (log) =>
                function wrappedLog(level, msg, meta, callback) {
                  const payload = { message: meta || {} }
                  logCh.publish(payload)
                  arguments[2] = payload.message
                  log.apply(this, arguments)
                }
            )
            patched.add(transport)
          }
        }
        return result
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/ws.js
var require_ws = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/ws.js'() {
    'use strict'
    var { addHook, channel } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var tracingChannel = require_dc_polyfill().tracingChannel
    var serverCh = tracingChannel('ws:server:connect')
    var producerCh = tracingChannel('ws:send')
    var receiverCh = tracingChannel('ws:receive')
    var closeCh = tracingChannel('ws:close')
    var emitCh = channel('tracing:ws:server:connect:emit')
    var eventHandlerMap = /* @__PURE__ */ new WeakMap()
    function wrapHandleUpgrade(handleUpgrade) {
      return function () {
        const [req, socket, , cb] = arguments
        if (!serverCh.start.hasSubscribers || typeof cb !== 'function') {
          return handleUpgrade.apply(this, arguments)
        }
        const ctx = { req, socket }
        arguments[3] = function () {
          return serverCh.asyncStart.runStores(
            ctx,
            () => {
              try {
                return cb.apply(this, arguments)
              } finally {
                serverCh.asyncEnd.publish(ctx)
              }
            },
            this,
            ...arguments
          )
        }
        return serverCh.traceSync(handleUpgrade, ctx, this, ...arguments)
      }
    }
    function wrapSend(send) {
      return function wrappedSend(...args) {
        if (!producerCh.start.hasSubscribers) return send.apply(this, arguments)
        const [data, options, cb] = arguments
        const ctx = { data, socket: this._sender?._socket }
        return typeof cb === 'function'
          ? producerCh.traceCallback(send, void 0, ctx, this, data, options, cb)
          : producerCh.traceSync(send, ctx, this, data, options, cb)
      }
    }
    function createWrapEmit(emit) {
      return function (title, headers, req) {
        if (!serverCh.start.hasSubscribers || title !== 'headers') return emit.apply(this, arguments)
        const ctx = { req }
        ctx.req.resStatus = headers[0].split(' ')[1]
        emitCh.runStores(ctx, () => {
          try {
            return emit.apply(this, arguments)
          } finally {
            emitCh.publish(ctx)
          }
        })
      }
    }
    function createWrappedHandler(handler) {
      return shimmer.wrapFunction(
        handler,
        (originalHandler) =>
          function (data, binary) {
            const byteLength = dataLength(data)
            const ctx = { data, binary, socket: this._sender?._socket, byteLength }
            return receiverCh.traceSync(originalHandler, ctx, this, data, binary)
          }
      )
    }
    function wrapListener(originalOn) {
      return function (eventName, handler) {
        if (eventName === 'message') {
          const wrappedHandler = eventHandlerMap.get(handler) ?? createWrappedHandler(handler)
          eventHandlerMap.set(handler, wrappedHandler)
          return originalOn.call(this, eventName, wrappedHandler)
        }
        return originalOn.apply(this, arguments)
      }
    }
    function removeListener(originalOff) {
      return function (eventName, handler) {
        if (eventName === 'message') {
          const wrappedHandler = eventHandlerMap.get(handler)
          return originalOff.call(this, eventName, wrappedHandler)
        }
        return originalOff.apply(this, arguments)
      }
    }
    function wrapClose(close) {
      return function (code, data) {
        const isPeerClose = this._closeFrameReceived === true && this._closeFrameSent === false
        const ctx = { code, data, socket: this._sender?._socket, isPeerClose }
        return closeCh.traceSync(close, ctx, this, ...arguments)
      }
    }
    addHook(
      {
        name: 'ws',
        file: 'lib/websocket-server.js',
        versions: ['>=8.0.0'],
      },
      (ws) => {
        shimmer.wrap(ws.prototype, 'handleUpgrade', wrapHandleUpgrade)
        shimmer.wrap(ws.prototype, 'emit', createWrapEmit)
        return ws
      }
    )
    addHook(
      {
        name: 'ws',
        file: 'lib/websocket.js',
        versions: ['>=8.0.0'],
      },
      (ws) => {
        shimmer.wrap(ws.prototype, 'send', wrapSend)
        shimmer.wrap(ws.prototype, 'close', wrapClose)
        shimmer.wrap(ws.prototype, 'on', wrapListener)
        shimmer.wrap(ws.prototype, 'addListener', wrapListener)
        shimmer.wrap(ws.prototype, 'off', removeListener)
        shimmer.wrap(ws.prototype, 'removeListener', removeListener)
        return ws
      }
    )
    function dataLength(data) {
      if (typeof data === 'string') {
        return Buffer.byteLength(data)
      }
      if (data instanceof Blob) {
        return data.size
      }
      return data?.length ?? 0
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hooks.js
var require_hooks = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hooks.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      '@anthropic-ai/sdk': { esmFirst: true, fn: () => require_anthropic() },
      '@apollo/server': () => require_apollo_server(),
      '@apollo/gateway': () => require_apollo(),
      'apollo-server-core': () => require_apollo_server_core(),
      '@aws-sdk/smithy-client': () => require_aws_sdk(),
      '@azure/event-hubs': () => require_azure_event_hubs(),
      '@azure/functions': () => require_azure_functions(),
      '@azure/service-bus': () => require_azure_service_bus(),
      '@cucumber/cucumber': () => require_cucumber(),
      '@playwright/test': () => require_playwright(),
      '@elastic/elasticsearch': () => require_elasticsearch(),
      '@elastic/transport': () => require_elasticsearch(),
      '@google/genai': () => require_google_genai(),
      '@google-cloud/pubsub': () => require_google_cloud_pubsub(),
      '@google-cloud/vertexai': () => require_google_cloud_vertexai(),
      '@graphql-tools/executor': () => require_graphql(),
      '@grpc/grpc-js': () => require_grpc(),
      '@hapi/hapi': () => require_hapi(),
      '@happy-dom/jest-environment': () => require_jest(),
      '@jest/core': () => require_jest(),
      '@jest/reporters': () => require_jest(),
      '@jest/test-sequencer': () => require_jest(),
      '@jest/transform': () => require_jest(),
      '@koa/router': () => require_koa(),
      '@langchain/core': { esmFirst: true, fn: () => require_langchain2() },
      '@node-redis/client': () => require_redis(),
      '@opensearch-project/opensearch': () => require_opensearch(),
      '@opentelemetry/sdk-trace-node': () => require_otel_sdk_trace(),
      '@prisma/client': () => require_prisma(),
      '@redis/client': () => require_redis(),
      '@smithy/smithy-client': () => require_aws_sdk(),
      '@vitest/runner': { esmFirst: true, fn: () => require_vitest() },
      aerospike: () => require_aerospike(),
      ai: () => require_ai(),
      amqp10: () => require_amqp10(),
      amqplib: () => require_amqplib(),
      avsc: () => require_avsc(),
      'aws-sdk': () => require_aws_sdk(),
      bluebird: () => require_bluebird(),
      'body-parser': () => require_body_parser(),
      bunyan: () => require_bunyan(),
      'cassandra-driver': () => require_cassandra_driver(),
      child_process: () => require_child_process(),
      connect: () => require_connect(),
      cookie: () => require_cookie(),
      'cookie-parser': () => require_cookie_parser(),
      couchbase: () => require_couchbase(),
      crypto: () => require_crypto(),
      cypress: () => require_cypress(),
      'dd-trace-api': () => require_dd_trace_api(),
      dns: () => require_dns(),
      elasticsearch: () => require_elasticsearch(),
      express: () => require_express(),
      'express-mongo-sanitize': () => require_express_mongo_sanitize(),
      'express-session': () => require_express_session(),
      fastify: () => require_fastify(),
      'find-my-way': () => require_find_my_way(),
      fs: { serverless: false, fn: () => require_fs() },
      'generic-pool': () => require_generic_pool(),
      graphql: () => require_graphql(),
      grpc: () => require_grpc(),
      handlebars: () => require_handlebars(),
      hapi: () => require_hapi(),
      hono: { esmFirst: true, fn: () => require_hono() },
      http: () => require_http2(),
      http2: () => require_http22(),
      https: () => require_http2(),
      ioredis: () => require_ioredis(),
      iovalkey: () => require_iovalkey(),
      'jest-circus': () => require_jest(),
      'jest-config': () => require_jest(),
      'jest-environment-node': () => require_jest(),
      'jest-environment-jsdom': () => require_jest(),
      'jest-runtime': () => require_jest(),
      'jest-worker': () => require_jest(),
      knex: () => require_knex(),
      koa: () => require_koa(),
      'koa-router': () => require_koa(),
      '@confluentinc/kafka-javascript': () => require_confluentinc_kafka_javascript(),
      kafkajs: () => require_kafkajs(),
      langchain: () => require_langchain2(),
      ldapjs: () => require_ldapjs(),
      'limitd-client': () => require_limitd_client(),
      lodash: () => require_lodash(),
      mariadb: () => require_mariadb(),
      memcached: () => require_memcached(),
      'microgateway-core': () => require_microgateway_core(),
      mocha: () => require_mocha(),
      'mocha-each': () => require_mocha(),
      moleculer: () => require_moleculer(),
      mongodb: () => require_mongodb(),
      'mongodb-core': () => require_mongodb_core(),
      mongoose: () => require_mongoose(),
      mquery: () => require_mquery(),
      multer: () => require_multer(),
      mysql: () => require_mysql(),
      mysql2: () => require_mysql2(),
      net: () => require_net(),
      next: () => require_next(),
      'node-serialize': () => require_node_serialize(),
      'node:child_process': () => require_child_process(),
      'node:crypto': () => require_crypto(),
      'node:dns': () => require_dns(),
      'node:http': () => require_http2(),
      'node:http2': () => require_http22(),
      'node:https': () => require_http2(),
      'node:net': () => require_net(),
      'node:url': () => require_url2(),
      'node:vm': () => require_vm(),
      nyc: () => require_nyc(),
      oracledb: () => require_oracledb(),
      openai: { esmFirst: true, fn: () => require_openai() },
      passport: () => require_passport(),
      'passport-http': () => require_passport_http(),
      'passport-local': () => require_passport_local(),
      pg: () => require_pg(),
      pino: () => require_pino(),
      'pino-pretty': () => require_pino(),
      playwright: () => require_playwright(),
      'playwright-core': () => require_playwright(),
      'promise-js': () => require_promise_js(),
      promise: () => require_promise2(),
      protobufjs: () => require_protobufjs(),
      pug: () => require_pug(),
      q: () => require_q(),
      redis: () => require_redis(),
      restify: () => require_restify(),
      rhea: () => require_rhea(),
      router: () => require_router(),
      'selenium-webdriver': () => require_selenium(),
      sequelize: () => require_sequelize(),
      sharedb: () => require_sharedb(),
      tedious: () => require_tedious(),
      tinypool: { esmFirst: true, fn: () => require_vitest() },
      undici: () => require_undici(),
      url: () => require_url2(),
      vitest: { esmFirst: true, fn: () => require_vitest() },
      vm: () => require_vm(),
      when: () => require_when(),
      winston: () => require_winston(),
      workerpool: () => require_mocha(),
      ws: () => require_ws(),
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/check-require-cache.js
var require_check_require_cache = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/check-require-cache.js'(exports2, module2) {
    'use strict'
    var warnings = []
    var potentialConflicts = /* @__PURE__ */ new Set([
      '@appsignal/javascript',
      '@appsignal/nodejs',
      '@dynatrace/oneagent',
      '@instana/aws-fargate',
      '@instana/aws-lambda',
      '@instana/azure-container-services',
      '@instana/collector',
      '@instana/google-cloud-run',
      '@sentry/node',
      'appoptics-apm',
      'atatus-nodejs',
      'elastic-apm-node',
      'newrelic',
      'stackify-node-apm',
      'sqreen',
    ])
    var extractPackageAndModulePath = require_extract_package_and_module_path()
    module2.exports.checkForRequiredModules = function () {
      const packages = require_hooks()
      const naughties = /* @__PURE__ */ new Set()
      let didWarn = false
      for (const pathToModule of Object.keys(require.cache)) {
        const { pkg } = extractPackageAndModulePath(pathToModule)
        if (naughties.has(pkg)) continue
        if (!(pkg in packages)) continue
        warnings.push(() => `Warning: Package '${pkg}' was loaded before dd-trace! This may break instrumentation.`)
        naughties.add(pkg)
        didWarn = true
      }
      if (didWarn) warnings.push('Warning: Please ensure dd-trace is loaded before other modules.')
    }
    module2.exports.checkForPotentialConflicts = function () {
      const naughties = /* @__PURE__ */ new Set()
      let didWarn = false
      for (const pathToModule of Object.keys(require.cache)) {
        const { pkg } = extractPackageAndModulePath(pathToModule)
        if (naughties.has(pkg)) continue
        if (!potentialConflicts.has(pkg)) continue
        warnings.push(() => `Warning: Package '${pkg}' may cause conflicts with dd-trace.`)
        naughties.add(pkg)
        didWarn = true
      }
      if (didWarn) warnings.push('Warning: Packages were loaded that may conflict with dd-trace.')
    }
    module2.exports.flushStartupLogs = function (log) {
      while (warnings.length) {
        log.warn(warnings.shift())
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/tracer_metadata.js
var require_tracer_metadata = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/tracer_metadata.js'(exports2, module2) {
    'use strict'
    var libdatadog = require('@datadog/libdatadog')
    var tracerVersion = require_version().VERSION
    function storeConfig(config) {
      const processDiscovery = libdatadog.maybeLoad('process-discovery')
      if (processDiscovery === void 0) {
        return
      }
      const metadata = new processDiscovery.TracerMetadata(
        config.tags['runtime-id'],
        tracerVersion,
        config.hostname,
        config.service || null,
        config.env || null,
        config.version || null
      )
      return processDiscovery.storeMetadata(metadata)
    }
    module2.exports = storeConfig
  },
})

// node_modules/dd-trace/packages/dd-trace/src/tracer.js
var require_tracer4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/tracer.js'(exports2, module2) {
    'use strict'
    var Tracer = require_tracer3()
    var tags = require_tags()
    var Scope = require_scope2()
    var { isError } = require_util()
    var { setStartupLogConfig } = require_startup_log()
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants2()
    var { DataStreamsCheckpointer, DataStreamsManager, DataStreamsProcessor } = require_datastreams()
    var { flushStartupLogs } = require_check_require_cache()
    var log = require_writer()
    var SPAN_TYPE = tags.SPAN_TYPE
    var RESOURCE_NAME = tags.RESOURCE_NAME
    var SERVICE_NAME = tags.SERVICE_NAME
    var MEASURED = tags.MEASURED
    var DatadogTracer = class extends Tracer {
      constructor(config, prioritySampler) {
        super(config, prioritySampler)
        this._dataStreamsProcessor = new DataStreamsProcessor(config)
        this._dataStreamsManager = new DataStreamsManager(this._dataStreamsProcessor)
        this.dataStreamsCheckpointer = new DataStreamsCheckpointer(this)
        this._scope = new Scope()
        setStartupLogConfig(config)
        flushStartupLogs(log)
        if (!config._isInServerlessEnvironment()) {
          const storeConfig = require_tracer_metadata()
          const metadata = storeConfig(config)
          if (metadata === void 0) {
            log.warn('Could not store tracer configuration for service discovery')
          }
          this._inmem_cfg = metadata
        }
      }
      configure(config) {
        const { env, sampler } = config
        this._prioritySampler.configure(env, sampler, config)
      }
      // todo[piochelepiotr] These two methods are not related to the tracer, but to data streams monitoring.
      // They should be moved outside of the tracer in the future.
      setCheckpoint(edgeTags, span, payloadSize = 0) {
        return this._dataStreamsManager.setCheckpoint(edgeTags, span, payloadSize)
      }
      decodeDataStreamsContext(carrier) {
        return this._dataStreamsManager.decodeDataStreamsContext(carrier)
      }
      setOffset(offsetData) {
        return this._dataStreamsProcessor.setOffset(offsetData)
      }
      trace(name, options, fn) {
        options = { childOf: this.scope().active(), ...options }
        const span = this.startSpan(name, options)
        addTags(span, options)
        try {
          if (fn.length > 1) {
            return this.scope().activate(span, () =>
              fn(span, (err) => {
                addError(span, err)
                span.finish()
              })
            )
          }
          const result = this.scope().activate(span, () => fn(span))
          if (result && typeof result.then === 'function') {
            return result.then(
              (value) => {
                span.finish()
                return value
              },
              (err) => {
                addError(span, err)
                span.finish()
                throw err
              }
            )
          }
          span.finish()
          return result
        } catch (e) {
          addError(span, e)
          span.finish()
          throw e
        }
      }
      wrap(name, options, fn) {
        const tracer2 = this
        return function () {
          let optionsObj = options
          if (typeof optionsObj === 'function' && typeof fn === 'function') {
            optionsObj = optionsObj.apply(this, arguments)
          }
          const lastArgId = arguments.length - 1
          const cb = arguments[lastArgId]
          if (typeof cb === 'function') {
            const scopeBoundCb = tracer2.scope().bind(cb)
            return tracer2.trace(name, optionsObj, (span, done) => {
              arguments[lastArgId] = function (err) {
                done(err)
                return scopeBoundCb.apply(this, arguments)
              }
              return fn.apply(this, arguments)
            })
          }
          return tracer2.trace(name, optionsObj, () => fn.apply(this, arguments))
        }
      }
      setUrl(url) {
        this._exporter.setUrl(url)
        this._dataStreamsProcessor.setUrl(url)
      }
      scope() {
        return this._scope
      }
      getRumData() {
        if (!this._enableGetRumData) {
          return ''
        }
        const span = this.scope().active().context()
        const traceId = span.toTraceId()
        const traceTime = Date.now()
        return `<meta name="dd-trace-id" content="${traceId}" /><meta name="dd-trace-time" content="${traceTime}" />`
      }
    }
    function addError(span, error) {
      if (isError(error)) {
        span.addTags({
          [ERROR_TYPE]: error.name,
          [ERROR_MESSAGE]: error.message,
          [ERROR_STACK]: error.stack,
        })
      }
    }
    function addTags(span, options) {
      const tags2 = {}
      if (options.type) tags2[SPAN_TYPE] = options.type
      if (options.service) tags2[SERVICE_NAME] = options.service
      if (options.resource) tags2[RESOURCE_NAME] = options.resource
      tags2[MEASURED] = options.measured
      span.addTags(tags2)
    }
    module2.exports = DatadogTracer
  },
})

// node_modules/dd-trace/vendor/dist/crypto-randomuuid/index.js
var require_crypto_randomuuid = __commonJS({
  'node_modules/dd-trace/vendor/dist/crypto-randomuuid/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e = {
          './crypto-randomuuid/index.js': function (e2, t2, o2) {
            let n = o2('crypto')
            e2.exports = 'function' == typeof n.randomUUID ? n.randomUUID : o2('./crypto-randomuuid/polyfill.js')
          },
          './crypto-randomuuid/polyfill.js': function (e2, t2, o2) {
            let n,
              r,
              i,
              s = o2('crypto'),
              {
                validateBoolean: c,
                validateObject: u,
                codes: { ERR_OPERATION_FAILED: l },
              } = o2('./crypto-randomuuid/validators.js'),
              { randomFillSync: a } = s
            function f(e3) {
              return a(Buffer.alloc(e3))
            }
            let p = 0
            function d(e3, t3 = 0) {
              let o3 = (function () {
                if (void 0 === i) {
                  i = Array(256)
                  for (let e4 = 0; e4 < i.length; e4++) {
                    let t4 = e4.toString(16)
                    i[e4] = t4.padStart(2, '0')
                  }
                }
                return i
              })()
              return (
                o3[e3[t3]] +
                o3[e3[t3 + 1]] +
                o3[e3[t3 + 2]] +
                o3[e3[t3 + 3]] +
                '-' +
                o3[e3[t3 + 4]] +
                o3[e3[t3 + 5]] +
                '-' +
                o3[(15 & e3[t3 + 6]) | 64] +
                o3[e3[t3 + 7]] +
                '-' +
                o3[(63 & e3[t3 + 8]) | 128] +
                o3[e3[t3 + 9]] +
                '-' +
                o3[e3[t3 + 10]] +
                o3[e3[t3 + 11]] +
                o3[e3[t3 + 12]] +
                o3[e3[t3 + 13]] +
                o3[e3[t3 + 14]] +
                o3[e3[t3 + 15]]
              )
            }
            e2.exports = function (e3) {
              void 0 !== e3 && u(e3, 'options')
              let { disableEntropyCache: t3 = false } = e3 || {}
              return (
                c(t3, 'options.disableEntropyCache'),
                t3
                  ? (function () {
                      if ((r || (r = f(2048)), void 0 === r)) throw new l('Out of memory')
                      return (a(r), d(r))
                    })()
                  : (function () {
                      if ((n || (n = f(2048)), void 0 === n)) throw new l('Out of memory')
                      return (0 === p && a(n), d(n, 16 * (p = (p + 1) % 128)))
                    })()
              )
            }
          },
          './crypto-randomuuid/validators.js': function (e2, t2, o2) {
            let n = o2('assert'),
              r = o2('util'),
              i = ['string', 'function', 'number', 'object', 'Function', 'Object', 'boolean', 'bigint', 'symbol']
            class s extends TypeError {
              constructor(e3) {
                ;(super(`Operation failed: ${e3}`),
                  (this.code = this.constructor.name),
                  Object.defineProperties(this, {
                    toString: {
                      value() {
                        return `${this.name} [${this.code}]: ${this.message}`
                      },
                      enumerable: false,
                      writable: true,
                      configurable: true,
                    },
                  }))
              }
            }
            class c extends TypeError {
              constructor(e3, t3, o3) {
                ;(super(), n('string' == typeof e3, "'name' must be a string"), Array.isArray(t3) || (t3 = [t3]))
                let s2 = 'The '
                if (e3.endsWith(' argument')) s2 += `${e3} `
                else {
                  const t4 = e3.includes('.') ? 'property' : 'argument'
                  s2 += `"${e3}" ${t4} `
                }
                s2 += 'must be '
                const c2 = [],
                  u = [],
                  l = []
                for (const e4 of t3)
                  (n('string' == typeof e4, 'All expected entries have to be of type string'),
                    i.includes(e4)
                      ? c2.push(e4.toLowerCase())
                      : classRegExp.test(e4)
                        ? u.push(e4)
                        : (n('object' !== e4, 'The value "object" should be written as "Object"'), l.push(e4)))
                if (u.length > 0) {
                  const e4 = c2.indexOf('object')
                  ;-1 !== e4 && (c2.splice(e4, 1), u.push('Object'))
                }
                if (c2.length > 0) {
                  if (c2.length > 2) {
                    const e4 = c2.pop()
                    s2 += `one of type ${c2.join(', ')}, or ${e4}`
                  } else 2 === c2.length ? (s2 += `one of type ${c2[0]} or ${c2[1]}`) : (s2 += `of type ${c2[0]}`)
                  ;(u.length > 0 || l.length > 0) && (s2 += ' or ')
                }
                if (u.length > 0) {
                  if (u.length > 2) {
                    const e4 = u.pop()
                    s2 += `an instance of ${u.join(', ')}, or ${e4}`
                  } else ((s2 += `an instance of ${u[0]}`), 2 === u.length && (s2 += ` or ${u[1]}`))
                  l.length > 0 && (s2 += ' or ')
                }
                if (l.length > 0)
                  if (l.length > 2) {
                    const e4 = l.pop()
                    s2 += `one of ${l.join(', ')}, or ${e4}`
                  } else
                    2 === l.length
                      ? (s2 += `one of ${l[0]} or ${l[1]}`)
                      : (l[0].toLowerCase() !== l[0] && (s2 += 'an '), (s2 += `${l[0]}`))
                if (null == o3) s2 += `. Received ${o3}`
                else if ('function' == typeof o3 && o3.name) s2 += `. Received function ${o3.name}`
                else if ('object' == typeof o3)
                  if (o3.constructor && o3.constructor.name) s2 += `. Received an instance of ${o3.constructor.name}`
                  else {
                    const e4 = r.inspect(o3, { depth: -1 })
                    s2 += `. Received ${e4}`
                  }
                else {
                  let e4 = r.inspect(o3, { colors: false })
                  ;(e4.length > 25 && (e4 = `${e4.slice(0, 25)}...`), (s2 += `. Received type ${typeof o3} (${e4})`))
                }
                ;((this.code = this.constructor.name),
                  Object.defineProperties(this, {
                    message: { value: s2, enumerable: false, writable: true, configurable: true },
                    toString: {
                      value() {
                        return `${this.name} [${this.code}]: ${this.message}`
                      },
                      enumerable: false,
                      writable: true,
                      configurable: true,
                    },
                  }))
              }
            }
            e2.exports = {
              validateBoolean: function (e3, t3) {
                if ('boolean' != typeof e3) throw new c(t3, 'boolean', e3)
              },
              validateObject: function (
                e3,
                t3,
                { nullable: o3 = false, allowArray: n2 = false, allowFunction: r2 = false } = {}
              ) {
                if (
                  (!o3 && null === e3) ||
                  (!n2 && Array.isArray(e3)) ||
                  ('object' != typeof e3 && (!r2 || 'function' != typeof e3))
                )
                  throw new c(t3, 'Object', e3)
              },
              codes: { ERR_OPERATION_FAILED: s },
            }
          },
          assert: function (e2) {
            e2.exports = require('assert')
          },
          crypto: function (e2) {
            e2.exports = require('crypto')
          },
          util: function (e2) {
            e2.exports = require('util')
          },
        },
        t = {},
        o = (function o2(n) {
          var r = t[n]
          if (void 0 !== r) return r.exports
          var i = (t[n] = { exports: {} })
          return (e[n](i, i.exports, o2), i.exports)
        })('./crypto-randomuuid/index.js')
      module2.exports = o
    })()
  },
})

// node_modules/dd-trace/packages/datadog-core/src/utils/src/set.js
var require_set = __commonJS({
  'node_modules/dd-trace/packages/datadog-core/src/utils/src/set.js'(exports2, module2) {
    'use strict'
    module2.exports = function set(object, path, value) {
      let index = -1
      while (true) {
        const nextIndex = path.indexOf('.', index + 1)
        if (nextIndex === -1) {
          if (index === -1) {
            object[path] = value
          } else {
            object[path.slice(index + 1)] = value
          }
          return
        }
        object = object[path.slice(index + 1, nextIndex)] ??= {}
        index = nextIndex
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/git_properties.js
var require_git_properties = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/git_properties.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var path = require('path')
    var gitPropertiesCommitSHARegex = /git\.commit\.sha=([a-f\d]{40})/
    var gitPropertiesRepositoryUrlRegex = /git\.repository_url=([\w\d:@/.-]+)/
    var repositoryUrlRegex = /^([\w\d:@/.-]+)$/
    var remoteOriginRegex = /^\[remote\s+"origin"\]/i
    var gitHeadRefRegex = /ref:\s+(refs\/[A-Za-z0-9._/-]+)/
    var commitSHARegex = /^[0-9a-f]{40}$/
    function removeUserSensitiveInfo(repositoryUrl) {
      try {
        const parsedUrl = new URL(repositoryUrl)
        if (parsedUrl.username || parsedUrl.password) {
          return `${parsedUrl.origin}${parsedUrl.pathname}`
        }
        return repositoryUrl
      } catch {
        return repositoryUrl
      }
    }
    function getGitMetadataFromGitProperties(gitPropertiesString) {
      if (!gitPropertiesString) {
        return {}
      }
      const commitSHAMatch = gitPropertiesString.match(gitPropertiesCommitSHARegex)
      const repositoryUrlMatch = gitPropertiesString.match(gitPropertiesRepositoryUrlRegex)
      const repositoryUrl = repositoryUrlMatch ? repositoryUrlMatch[1] : void 0
      return {
        commitSHA: commitSHAMatch ? commitSHAMatch[1] : void 0,
        repositoryUrl: removeUserSensitiveInfo(repositoryUrl),
      }
    }
    function getRemoteOriginURL(gitConfigContent) {
      if (!gitConfigContent) {
        return
      }
      const lines = gitConfigContent.split('\n')
      let index = 0
      for (; index < lines.length; index++) {
        const line = lines[index]
        if (line[0] !== '[') continue
        if (remoteOriginRegex.test(line)) break
      }
      index++
      for (; index < lines.length; index++) {
        const line = lines[index]
        if (line[0] === '[') return
        const splitAt = line.indexOf('=')
        if (splitAt === -1) continue
        const key = line.slice(0, splitAt).trim().toLowerCase()
        if (key !== 'url') continue
        const repositoryUrlValue = line.slice(splitAt + 1).trim()
        const repositoryUrlMatch = repositoryUrlValue.match(repositoryUrlRegex)
        if (!repositoryUrlMatch) continue
        return removeUserSensitiveInfo(repositoryUrlMatch[0])
      }
    }
    function getGitHeadRef(gitHeadContent) {
      if (!gitHeadContent) {
        return
      }
      const gitRefMatch = gitHeadContent.match(gitHeadRefRegex)
      return gitRefMatch?.[1]
    }
    function resolveGitHeadSHA(DD_GIT_FOLDER_PATH) {
      const gitHeadPath = path.join(DD_GIT_FOLDER_PATH, 'HEAD')
      try {
        const gitHeadContent = fs.readFileSync(gitHeadPath, 'utf8')
        if (!gitHeadContent) {
          return
        }
        const headContent = gitHeadContent.trim()
        if (commitSHARegex.test(headContent)) {
          return headContent
        }
        const gitHeadRef = getGitHeadRef(headContent)
        if (!gitHeadRef) {
          return
        }
        const gitHeadRefPath = path.join(DD_GIT_FOLDER_PATH, gitHeadRef)
        const gitHeadRefContent = fs.readFileSync(gitHeadRefPath, 'utf8')
        if (gitHeadRefContent) {
          const headRefContent = gitHeadRefContent.trim()
          if (commitSHARegex.test(headRefContent)) {
            return headRefContent
          }
        }
      } catch {}
    }
    module2.exports = {
      getGitMetadataFromGitProperties,
      removeUserSensitiveInfo,
      getGitHeadRef,
      getRemoteOriginURL,
      resolveGitHeadSHA,
    }
  },
})

// node_modules/dd-trace/vendor/dist/module-details-from-path/index.js
var require_module_details_from_path = __commonJS({
  'node_modules/dd-trace/vendor/dist/module-details-from-path/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var r = {
          './module-details-from-path/index.js': function (r2, e2, t2) {
            var o = t2('path').sep
            r2.exports = function (r3) {
              var e3 = r3.split(o),
                t3 = e3.lastIndexOf('node_modules')
              if (-1 !== t3 && e3[t3 + 1]) {
                for (
                  var a = '@' === e3[t3 + 1][0],
                    s = a ? e3[t3 + 1] + '/' + e3[t3 + 2] : e3[t3 + 1],
                    n = a ? 3 : 2,
                    i = '',
                    p = t3 + n - 1,
                    u = 0;
                  u <= p;
                  u++
                )
                  u === p ? (i += e3[u]) : (i += e3[u] + o)
                for (var d = '', f = e3.length - 1, x = t3 + n; x <= f; x++) x === f ? (d += e3[x]) : (d += e3[x] + o)
                return { name: s, basedir: i, path: d }
              }
            }
          },
          path: function (r2) {
            r2.exports = require('path')
          },
        },
        e = {},
        t = (function t2(o) {
          var a = e[o]
          if (void 0 !== a) return a.exports
          var s = (e[o] = { exports: {} })
          return (r[o](s, s.exports, t2), s.exports)
        })('./module-details-from-path/index.js')
      module2.exports = t
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/require-package-json.js
var require_require_package_json = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/require-package-json.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var fs = require('fs')
    function requirePackageJson(name, module3) {
      if (path.isAbsolute(name)) {
        const candidate = path.join(name, 'package.json')
        return JSON.parse(fs.readFileSync(candidate, 'utf8'))
      }
      for (const modulePath of module3.paths) {
        const candidate = path.join(modulePath, name, 'package.json')
        try {
          return JSON.parse(fs.readFileSync(candidate, 'utf8'))
        } catch {
          continue
        }
      }
      throw new Error(`could not find ${name}/package.json`)
    }
    module2.exports = requirePackageJson
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/dependencies.js
var require_dependencies = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/dependencies.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var parse = require_module_details_from_path()
    var requirePackageJson = require_require_package_json()
    var { sendData } = require_send_data()
    var dc = require_dc_polyfill()
    var { fileURLToPath } = require('url')
    var { isTrue } = require_util()
    var savedDependenciesToSend = /* @__PURE__ */ new Set()
    var detectedDependencyKeys = /* @__PURE__ */ new Set()
    var detectedDependencyVersions = /* @__PURE__ */ new Set()
    var FILE_URI_START = 'file://'
    var moduleLoadStartChannel = dc.channel('dd-trace:moduleLoadStart')
    var config
    var application
    var host
    var initialLoad
    var isFirstModule = true
    var getRetryData
    var updateRetryData
    function waitAndSend(config2, application2, host2) {
      setImmediate(() => {
        if (savedDependenciesToSend.size === 0) {
          return
        }
        const dependencies = []
        let send = 0
        for (const dependency of savedDependenciesToSend) {
          const [name, version, initialLoadModule] = dependency.split(' ')
          const sendModule = isTrue(initialLoadModule) || config2.telemetry?.dependencyCollection
          savedDependenciesToSend.delete(dependency)
          if (sendModule) {
            dependencies.push({ name, version })
            send++
            if (send === 2e3) {
              break
            }
          }
        }
        let payload = { dependencies }
        let reqType = 'app-dependencies-loaded'
        const retryData = getRetryData()
        if (retryData) {
          payload = [
            {
              request_type: 'app-dependencies-loaded',
              payload,
            },
            {
              request_type: retryData.reqType,
              payload: retryData.payload,
            },
          ]
          reqType = 'message-batch'
        } else if (!dependencies.length) {
          return
        }
        sendData(config2, application2, host2, reqType, payload, updateRetryData)
        if (savedDependenciesToSend.size > 0) {
          waitAndSend(config2, application2, host2)
        }
      }).unref()
    }
    function loadAllTheLoadedModules() {
      if (require.cache) {
        const filenames = Object.keys(require.cache)
        filenames.forEach((filename) => {
          onModuleLoad({ filename })
        })
      }
    }
    function onModuleLoad(data) {
      if (isFirstModule) {
        isFirstModule = false
        loadAllTheLoadedModules()
      }
      if (data) {
        let filename = data.filename
        if (filename?.startsWith(FILE_URI_START)) {
          try {
            filename = fileURLToPath(filename)
          } catch {}
        }
        const parseResult = filename && parse(filename)
        const request = data.request || parseResult?.name
        const dependencyKey = parseResult?.basedir ?? request
        if (filename && request && isDependency(request) && !detectedDependencyKeys.has(dependencyKey)) {
          detectedDependencyKeys.add(dependencyKey)
          if (parseResult) {
            const { name, basedir } = parseResult
            if (basedir) {
              try {
                const { version } = requirePackageJson(basedir, module2)
                const dependencyAndVersion = `${name} ${version}`
                if (!detectedDependencyVersions.has(dependencyAndVersion)) {
                  savedDependenciesToSend.add(`${dependencyAndVersion} ${initialLoad}`)
                  detectedDependencyVersions.add(dependencyAndVersion)
                  waitAndSend(config, application, host)
                }
              } catch {}
            }
          }
        }
      }
    }
    function start(_config = {}, _application, _host, getRetryDataFunction, updateRetryDatafunction) {
      config = _config
      application = _application
      host = _host
      initialLoad = true
      getRetryData = getRetryDataFunction
      updateRetryData = updateRetryDatafunction
      moduleLoadStartChannel.subscribe(onModuleLoad)
      queueMicrotask(() => {
        initialLoad = false
      })
    }
    function isDependency(request) {
      const isDependencyWithSlash = isDependencyWithSeparator(request, '/')
      if (isDependencyWithSlash && process.platform === 'win32') {
        return isDependencyWithSeparator(request, path.sep)
      }
      return isDependencyWithSlash
    }
    function isDependencyWithSeparator(request, sep) {
      return (
        request.indexOf(`..${sep}`) !== 0 &&
        request.indexOf(`.${sep}`) !== 0 &&
        request.indexOf(sep) !== 0 &&
        request.indexOf(`:${sep}`) !== 1
      )
    }
    function stop() {
      config = null
      application = null
      host = null
      detectedDependencyKeys.clear()
      savedDependenciesToSend.clear()
      detectedDependencyVersions.clear()
      if (moduleLoadStartChannel.hasSubscribers) {
        moduleLoadStartChannel.unsubscribe(onModuleLoad)
      }
    }
    module2.exports = { start, stop }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/endpoints.js
var require_endpoints = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/endpoints.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var { sendData } = require_send_data()
    var fastifyRouteCh = dc.channel('apm:fastify:route:added')
    var expressRouteCh = dc.channel('apm:express:route:added')
    var routerRouteCh = dc.channel('apm:router:route:added')
    var config
    var application
    var host
    var getRetryData
    var updateRetryData
    var pendingEndpoints = /* @__PURE__ */ new Map()
    var wildcardEndpoints = /* @__PURE__ */ new Set()
    var flushScheduled = false
    var isFirstPayload = true
    function endpointKey(method, path) {
      return `${method.toUpperCase()} ${path}`
    }
    function scheduleFlush() {
      if (flushScheduled) return
      flushScheduled = true
      setImmediate(flushAndSend).unref()
    }
    function recordEndpoint(method, path) {
      const key = endpointKey(method, path)
      if (pendingEndpoints.has(key)) return
      pendingEndpoints.set(key, { method: method.toUpperCase(), path })
      scheduleFlush()
    }
    function onFastifyRoute(routeData) {
      const routeOptions = routeData?.routeOptions
      if (!routeOptions?.path) return
      const methods = Array.isArray(routeOptions.method) ? routeOptions.method : [routeOptions.method]
      for (const method of methods) {
        recordEndpoint(method, routeOptions.path)
      }
    }
    function onExpressRoute({ method, path }) {
      if (!method || !path) return
      if (wildcardEndpoints.has(path)) return
      recordEndpoint(method, path)
      if (method === '*') {
        wildcardEndpoints.add(path)
        return
      }
      if (method.toUpperCase() === 'GET') {
        recordEndpoint('HEAD', path)
      }
    }
    function buildEndpointObjects(endpoints) {
      return endpoints.map(({ method, path }) => {
        return {
          type: 'REST',
          method,
          path,
          operation_name: 'http.request',
          resource_name: endpointKey(method, path),
        }
      })
    }
    function flushAndSend() {
      flushScheduled = false
      if (pendingEndpoints.size === 0) return
      const batchEndpoints = []
      for (const [key, endpoint] of pendingEndpoints) {
        batchEndpoints.push(endpoint)
        pendingEndpoints.delete(key)
        if (batchEndpoints.length >= config.appsec?.apiSecurity?.endpointCollectionMessageLimit) break
      }
      const payloadObj = {
        is_first: isFirstPayload,
        endpoints: buildEndpointObjects(batchEndpoints),
      }
      let reqType = 'app-endpoints'
      let payload = payloadObj
      const retryData = getRetryData()
      if (retryData) {
        payload = [
          { request_type: 'app-endpoints', payload: payloadObj },
          { request_type: retryData.reqType, payload: retryData.payload },
        ]
        reqType = 'message-batch'
      }
      sendData(config, application, host, reqType, payload, updateRetryData)
      if (isFirstPayload) {
        isFirstPayload = false
      }
      if (pendingEndpoints.size) scheduleFlush()
    }
    function start(_config = {}, _application, _host, getRetryDataFunction, updateRetryDataFunction) {
      if (!_config?.appsec?.apiSecurity?.endpointCollectionEnabled) return
      config = _config
      application = _application
      host = _host
      getRetryData = getRetryDataFunction
      updateRetryData = updateRetryDataFunction
      fastifyRouteCh.subscribe(onFastifyRoute)
      expressRouteCh.subscribe(onExpressRoute)
      routerRouteCh.subscribe(onExpressRoute)
    }
    function stop() {
      fastifyRouteCh.unsubscribe(onFastifyRoute)
      expressRouteCh.unsubscribe(onExpressRoute)
      routerRouteCh.unsubscribe(onExpressRoute)
      pendingEndpoints.clear()
      flushScheduled = false
      config = application = host = getRetryData = updateRetryData = null
    }
    module2.exports = {
      start,
      stop,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/logs/log-collector.js
var require_log_collector = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/logs/log-collector.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var { ddBasePath } = require_util()
    var logs = /* @__PURE__ */ new Map()
    var maxEntries = 1e4
    var overflowedCount = 0
    function hashCode(hashSource) {
      let hash = 0
      const size = hashSource.length
      for (let offset = 0; offset < size; offset++) {
        hash = (((hash * 31) | 0) + hashSource.charCodeAt(offset)) | 0
      }
      return hash
    }
    function createHash(logEntry) {
      const prime = 31
      let result = logEntry.level ? hashCode(logEntry.level) : 0
      result = (((prime * result) | 0) + (logEntry.message ? hashCode(logEntry.message) : 0)) | 0
      result = (((prime * result) | 0) + (logEntry.stack_trace ? hashCode(logEntry.stack_trace) : 0)) | 0
      return result
    }
    function isValid(logEntry) {
      return logEntry?.level && logEntry.message
    }
    var EOL = '\n'
    var STACK_FRAME_LINE_REGEX = /^\s*at\s/gm
    function sanitize(logEntry) {
      const stack = logEntry.stack_trace
      if (!stack) return logEntry
      let stackLines = stack.split(EOL)
      const firstIndex = stackLines.findIndex((l) => l.match(STACK_FRAME_LINE_REGEX))
      stackLines = stackLines
        .filter((line, index) => index >= firstIndex && line.includes(ddBasePath))
        .map((line) => line.replace(ddBasePath, ''))
      if (logEntry.errorType && stackLines.length) {
        stackLines = [`${logEntry.errorType}: redacted`, ...stackLines]
      }
      delete logEntry.errorType
      logEntry.stack_trace = stackLines.join(EOL)
      if (logEntry.stack_trace === '' && (!logEntry.message || logEntry.message === 'Generic Error')) {
        return null
      }
      return logEntry
    }
    var logCollector = {
      add(logEntry) {
        try {
          if (!isValid(logEntry)) return false
          if (logs.size >= maxEntries) {
            overflowedCount++
            return false
          }
          logEntry = sanitize(logEntry)
          if (!logEntry) {
            return false
          }
          const hash = createHash(logEntry)
          if (logs.has(hash)) {
            logs.get(hash).count++
          } else {
            logs.set(hash, logEntry)
            return true
          }
        } catch (e) {
          log.error('Unable to add log to logCollector: %s', e.message)
        }
        return false
      },
      // Used for testing
      hasEntry(logEntry) {
        return logs.has(createHash(logEntry))
      },
      drain() {
        if (logs.size === 0) return
        const drained = [...logs.values()]
        if (overflowedCount > 0) {
          drained.push({
            message: `Omitted ${overflowedCount} entries due to overflowing`,
            level: 'ERROR',
          })
        }
        this.reset()
        return drained
      },
      reset(max) {
        logs.clear()
        overflowedCount = 0
        if (max) {
          maxEntries = max
        }
      },
    }
    logCollector.reset()
    module2.exports = logCollector
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/logs/index.js
var require_logs = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/logs/index.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var logCollector = require_log_collector()
    var { sendData } = require_send_data()
    var telemetryLog = dc.channel('datadog:telemetry:log')
    var errorLog = dc.channel('datadog:log:error')
    var enabled = false
    function isLevelEnabled(level) {
      return isValidLevel(level)
    }
    function isValidLevel(level) {
      switch (level) {
        case 'ERROR':
        case 'WARN':
          return true
        default:
          return false
      }
    }
    function onLog(log) {
      if (isLevelEnabled(log?.level?.toUpperCase())) {
        logCollector.add(log)
      }
    }
    function onErrorLog(msg) {
      const { message, cause, sendViaTelemetry } = msg
      if (!sendViaTelemetry || (!message && !cause)) return
      const telLog = {
        level: 'ERROR',
        count: 1,
        // existing log.error(err) without message will be reported as 'Generic Error'
        message: message ?? 'Generic Error',
      }
      if (cause) {
        telLog.stack_trace = cause.stack
        telLog.errorType = cause.constructor.name
      }
      onLog(telLog)
    }
    function start(config) {
      if (!config.telemetry.logCollection || enabled) return
      enabled = true
      telemetryLog.subscribe(onLog)
      errorLog.subscribe(onErrorLog)
    }
    function stop() {
      enabled = false
      if (telemetryLog.hasSubscribers) {
        telemetryLog.unsubscribe(onLog)
      }
      errorLog.unsubscribe(onErrorLog)
    }
    function send(config, application, host) {
      if (!enabled) return
      const logs = logCollector.drain()
      if (logs) {
        sendData(config, application, host, 'logs', { logs })
      }
    }
    module2.exports = {
      start,
      stop,
      send,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/telemetry.js
var require_telemetry2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/telemetry.js'(exports2, module2) {
    'use strict'
    var tracerVersion = require_package().version
    var dc = require_dc_polyfill()
    var os = require('os')
    var dependencies = require_dependencies()
    var endpoints = require_endpoints()
    var { sendData } = require_send_data()
    var { errors } = require_startup_log()
    var { manager: metricsManager } = require_metrics()
    var telemetryLogger = require_logs()
    var logger = require_log2()
    var telemetryStartChannel = dc.channel('datadog:telemetry:start')
    var telemetryStopChannel = dc.channel('datadog:telemetry:stop')
    var telemetryAppClosingChannel = dc.channel('datadog:telemetry:app-closing')
    var config
    var pluginManager
    var application
    var host
    var heartbeatTimeout
    var heartbeatInterval
    var extendedInterval
    var integrations
    var configWithOrigin = /* @__PURE__ */ new Map()
    var retryData = null
    var extendedHeartbeatPayload = {}
    var sentIntegrations = /* @__PURE__ */ new Set()
    var seqId = 0
    function getRetryData() {
      return retryData
    }
    function updateRetryData(error, retryObj) {
      if (error) {
        if (retryObj.reqType === 'message-batch') {
          const payload = retryObj.payload[0].payload
          const reqType = retryObj.payload[0].request_type
          retryData = { payload, reqType }
          const failedPayload = retryObj.payload[1].payload
          const failedReqType = retryObj.payload[1].request_type
          if (failedReqType === 'app-integrations-change') {
            if (extendedHeartbeatPayload.integrations) {
              extendedHeartbeatPayload.integrations.push(failedPayload)
            } else {
              extendedHeartbeatPayload.integrations = [failedPayload]
            }
          }
          if (failedReqType === 'app-dependencies-loaded') {
            if (extendedHeartbeatPayload.dependencies) {
              extendedHeartbeatPayload.dependencies.push(failedPayload)
            } else {
              extendedHeartbeatPayload.dependencies = [failedPayload]
            }
          }
        } else {
          retryData = retryObj
        }
      } else {
        retryData = null
      }
    }
    function getIntegrations() {
      const newIntegrations = []
      for (const pluginName in pluginManager._pluginsByName) {
        if (sentIntegrations.has(pluginName)) {
          continue
        }
        newIntegrations.push({
          name: pluginName,
          enabled: pluginManager._pluginsByName[pluginName]._enabled,
          auto_enabled: true,
        })
        sentIntegrations.add(pluginName)
      }
      return newIntegrations
    }
    function getProducts(config2) {
      const products = {
        appsec: {
          enabled: config2.appsec.enabled,
        },
        profiler: {
          version: tracerVersion,
          enabled: profilingEnabledToBoolean(config2.profiling.enabled),
        },
      }
      if (errors.profilingError) {
        products.profiler.error = errors.profilingError
        errors.profilingError = {}
      }
      return products
    }
    function getInstallSignature(config2) {
      const { installSignature: sig } = config2
      if (sig && (sig.id || sig.time || sig.type)) {
        return {
          install_id: sig.id,
          install_time: sig.time,
          install_type: sig.type,
        }
      }
    }
    function appStarted(config2) {
      const app = {
        products: getProducts(config2),
        configuration: [...configWithOrigin.values()],
      }
      const installSignature = getInstallSignature(config2)
      if (installSignature) {
        app.install_signature = installSignature
      }
      return app
    }
    function appClosing() {
      if (!config?.telemetry?.enabled) {
        return
      }
      telemetryAppClosingChannel.publish()
      const { reqType, payload } = createPayload('app-closing')
      sendData(config, application, host, reqType, payload)
      metricsManager.send(config, application, host)
      telemetryLogger.send(config, application, host)
    }
    function onBeforeExit() {
      process.removeListener('beforeExit', onBeforeExit)
      appClosing()
    }
    function createAppObject(config2) {
      return {
        service_name: config2.service,
        env: config2.env,
        service_version: config2.version,
        tracer_version: tracerVersion,
        language_name: 'nodejs',
        language_version: process.versions.node,
      }
    }
    function createHostObject() {
      const osName = os.type()
      if (osName === 'Linux' || osName === 'Darwin') {
        return {
          hostname: os.hostname(),
          os: osName,
          architecture: os.arch(),
          kernel_version: os.version(),
          kernel_release: os.release(),
          kernel_name: osName,
        }
      }
      if (osName === 'Windows_NT') {
        return {
          hostname: os.hostname(),
          os: osName,
          architecture: os.arch(),
          os_version: os.version(),
        }
      }
      return {
        hostname: os.hostname(),
        // TODO is this enough?
        os: osName,
      }
    }
    function getTelemetryData() {
      return { config, application, host, heartbeatInterval }
    }
    function createBatchPayload(payload) {
      const batchPayload = payload.map((item) => {
        return {
          request_type: item.reqType,
          payload: item.payload,
        }
      })
      return batchPayload
    }
    function createPayload(currReqType, currPayload = {}) {
      if (getRetryData()) {
        const payload = { reqType: currReqType, payload: currPayload }
        const batchPayload = createBatchPayload([payload, retryData])
        return { reqType: 'message-batch', payload: batchPayload }
      }
      return { reqType: currReqType, payload: currPayload }
    }
    function heartbeat(config2, application2, host2) {
      heartbeatTimeout = setTimeout(() => {
        metricsManager.send(config2, application2, host2)
        telemetryLogger.send(config2, application2, host2)
        const { reqType, payload } = createPayload('app-heartbeat')
        sendData(config2, application2, host2, reqType, payload, updateRetryData)
        heartbeat(config2, application2, host2)
      }, heartbeatInterval).unref()
      return heartbeatTimeout
    }
    function extendedHeartbeat(config2) {
      extendedInterval = setInterval(
        () => {
          const appPayload = appStarted(config2)
          const payload = {
            ...appPayload,
            ...extendedHeartbeatPayload,
          }
          sendData(config2, application, host, 'app-extended-heartbeat', payload)
          Object.keys(extendedHeartbeatPayload).forEach((key) => delete extendedHeartbeatPayload[key])
        },
        1e3 * 60 * 60 * 24
      ).unref()
      return extendedInterval
    }
    function start(aConfig, thePluginManager) {
      if (!aConfig.telemetry.enabled) {
        if (aConfig.sca?.enabled) {
          logger.warn('DD_APPSEC_SCA_ENABLED requires enabling telemetry to work.')
        }
        return
      }
      config = aConfig
      pluginManager = thePluginManager
      application = createAppObject(config)
      host = createHostObject()
      heartbeatInterval = config.telemetry.heartbeatInterval
      integrations = getIntegrations()
      dependencies.start(config, application, host, getRetryData, updateRetryData)
      telemetryLogger.start(config)
      endpoints.start(config, application, host, getRetryData, updateRetryData)
      sendData(config, application, host, 'app-started', appStarted(config))
      if (integrations.length > 0) {
        sendData(config, application, host, 'app-integrations-change', { integrations }, updateRetryData)
      }
      heartbeat(config, application, host)
      extendedHeartbeat(config)
      process.on('beforeExit', onBeforeExit)
      telemetryStartChannel.publish(getTelemetryData())
    }
    function stop() {
      if (!config) {
        return
      }
      clearInterval(extendedInterval)
      clearTimeout(heartbeatTimeout)
      process.removeListener('beforeExit', onBeforeExit)
      telemetryStopChannel.publish(getTelemetryData())
      endpoints.stop()
      config = void 0
    }
    function updateIntegrations() {
      if (!config?.telemetry.enabled) {
        return
      }
      const integrations2 = getIntegrations()
      if (integrations2.length === 0) {
        return
      }
      const { reqType, payload } = createPayload('app-integrations-change', { integrations: integrations2 })
      sendData(config, application, host, reqType, payload, updateRetryData)
    }
    function formatMapForTelemetry(map) {
      return map
        ? Object.entries(map)
            .map(([key, value]) => `${key}:${value}`)
            .join(',')
        : ''
    }
    var nameMapping = {
      sampleRate: 'DD_TRACE_SAMPLE_RATE',
      logInjection: 'DD_LOG_INJECTION',
      headerTags: 'DD_TRACE_HEADER_TAGS',
      tags: 'DD_TAGS',
      'sampler.rules': 'DD_TRACE_SAMPLING_RULES',
      traceEnabled: 'DD_TRACE_ENABLED',
      url: 'DD_TRACE_AGENT_URL',
      'sampler.rateLimit': 'DD_TRACE_RATE_LIMIT',
      queryStringObfuscation: 'DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP',
      version: 'DD_VERSION',
      env: 'DD_ENV',
      service: 'DD_SERVICE',
      clientIpHeader: 'DD_TRACE_CLIENT_IP_HEADER',
      'grpc.client.error.statuses': 'DD_GRPC_CLIENT_ERROR_STATUSES',
      'grpc.server.error.statuses': 'DD_GRPC_SERVER_ERROR_STATUSES',
      traceId128BitLoggingEnabled: 'DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED',
      instrumentationSource: 'instrumentation_source',
      injectionEnabled: 'ssi_injection_enabled',
      injectForce: 'ssi_forced_injection_enabled',
      'runtimeMetrics.enabled': 'runtimeMetrics',
      otelLogsEnabled: 'DD_LOGS_OTEL_ENABLED',
      otelUrl: 'OTEL_EXPORTER_OTLP_ENDPOINT',
      otelEndpoint: 'OTEL_EXPORTER_OTLP_ENDPOINT',
      otelHeaders: 'OTEL_EXPORTER_OTLP_HEADERS',
      otelProtocol: 'OTEL_EXPORTER_OTLP_PROTOCOL',
      otelTimeout: 'OTEL_EXPORTER_OTLP_TIMEOUT',
      otelLogsHeaders: 'OTEL_EXPORTER_OTLP_LOGS_HEADERS',
      otelLogsProtocol: 'OTEL_EXPORTER_OTLP_LOGS_PROTOCOL',
      otelLogsTimeout: 'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT',
      otelLogsUrl: 'OTEL_EXPORTER_OTLP_LOGS_ENDPOINT',
      otelBatchTimeout: 'OTEL_BSP_SCHEDULE_DELAY',
      otelMaxExportBatchSize: 'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
      otelMaxQueueSize: 'OTEL_BSP_MAX_QUEUE_SIZE',
      otelMetricsEnabled: 'DD_METRICS_OTEL_ENABLED',
      otelMetricsHeaders: 'OTEL_EXPORTER_OTLP_METRICS_HEADERS',
      otelMetricsProtocol: 'OTEL_EXPORTER_OTLP_METRICS_PROTOCOL',
      otelMetricsTimeout: 'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
      otelMetricsExportTimeout: 'OTEL_METRIC_EXPORT_TIMEOUT',
      otelMetricsUrl: 'OTEL_EXPORTER_OTLP_METRICS_ENDPOINT',
      otelMetricsExportInterval: 'OTEL_METRIC_EXPORT_INTERVAL',
      otelMetricsTemporalityPreference: 'OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE',
    }
    var namesNeedFormatting = /* @__PURE__ */ new Set(['DD_TAGS', 'peerServiceMapping', 'serviceMapping'])
    function updateConfig(changes, config2) {
      if (!config2.telemetry.enabled) return
      if (changes.length === 0) return
      logger.trace(changes)
      const application2 = createAppObject(config2)
      const host2 = createHostObject()
      const changed = configWithOrigin.size > 0
      for (const change of changes) {
        const name = nameMapping[change.name] || change.name
        const { origin, value } = change
        const entry = { name, value, origin, seq_id: seqId++ }
        if (namesNeedFormatting.has(entry.name)) {
          entry.value = formatMapForTelemetry(entry.value)
        } else if (entry.name === 'url') {
          if (entry.value) {
            entry.value = entry.value.toString()
          }
        } else if (entry.name === 'DD_TRACE_SAMPLING_RULES') {
          entry.value = JSON.stringify(entry.value)
        } else if (Array.isArray(entry.value)) {
          entry.value = value.join(',')
        }
        configWithOrigin.set(`${name}|${origin}`, entry)
      }
      if (changed) {
        const { reqType, payload } = createPayload('app-client-configuration-change', {
          configuration: [...configWithOrigin.values()],
        })
        sendData(config2, application2, host2, reqType, payload, updateRetryData)
      }
    }
    function profilingEnabledToBoolean(profilingEnabled) {
      if (typeof profilingEnabled === 'boolean') {
        return profilingEnabled
      }
      return profilingEnabled === 'true' || profilingEnabled === 'auto'
    }
    module2.exports = {
      start,
      stop,
      updateIntegrations,
      updateConfig,
      appClosing,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/telemetry/index.js
var require_telemetry3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/telemetry/index.js'(exports2, module2) {
    'use strict'
    var telemetry
    module2.exports = {
      start(config, ...args) {
        telemetry ??= require_telemetry2()
        telemetry.start(config, ...args)
      },
      stop() {
        telemetry?.stop()
      },
      // This might be called before `start` so we have to trigger loading the
      // underlying module here as well.
      updateConfig(changes, config, ...args) {
        telemetry ??= require_telemetry2()
        telemetry.updateConfig(changes, config, ...args)
      },
      updateIntegrations() {
        telemetry?.updateIntegrations()
      },
      appClosing() {
        telemetry?.appClosing()
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/serverless.js
var require_serverless = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/serverless.js'(exports2, module2) {
    'use strict'
    var { getEnvironmentVariable } = require_config_helper()
    function getIsGCPFunction() {
      const isDeprecatedGCPFunction =
        getEnvironmentVariable('FUNCTION_NAME') !== void 0 && getEnvironmentVariable('GCP_PROJECT') !== void 0
      const isNewerGCPFunction =
        getEnvironmentVariable('K_SERVICE') !== void 0 && getEnvironmentVariable('FUNCTION_TARGET') !== void 0
      return isDeprecatedGCPFunction || isNewerGCPFunction
    }
    function getIsAzureFunction() {
      const isAzureFunction =
        getEnvironmentVariable('FUNCTIONS_EXTENSION_VERSION') !== void 0 &&
        getEnvironmentVariable('FUNCTIONS_WORKER_RUNTIME') !== void 0
      return isAzureFunction
    }
    function isInServerlessEnvironment() {
      const inAWSLambda = getEnvironmentVariable('AWS_LAMBDA_FUNCTION_NAME') !== void 0
      const isGCPFunction = getIsGCPFunction()
      const isAzureFunction = getIsAzureFunction()
      return inAWSLambda || isGCPFunction || isAzureFunction
    }
    module2.exports = {
      getIsGCPFunction,
      getIsAzureFunction,
      isInServerlessEnvironment,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/payload-tagging/config/aws.json
var require_aws = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/payload-tagging/config/aws.json'(exports2, module2) {
    module2.exports = {
      sns: {
        request: [
          '$.Attributes.KmsMasterKeyId',
          '$.Attributes.PlatformCredential',
          '$.Attributes.PlatformPrincipal',
          '$.Attributes.Token',
          '$.AWSAccountId',
          '$.Endpoint',
          '$.OneTimePassword',
          '$.phoneNumber',
          '$.PhoneNumber',
          '$.Token',
        ],
        response: [
          '$.Attributes.KmsMasterKeyId',
          '$.Attributes.Token',
          '$.Endpoints.*.Token',
          '$.PhoneNumber',
          '$.PlatformApplication.*.PlatformCredential',
          '$.PlatformApplication.*.PlatformPrincipal',
          '$.Subscriptions.*.Endpoint',
          '$.PhoneNumbers[*].PhoneNumber',
          '$.phoneNumbers[*]',
        ],
        expand: ['$.MessageAttributes.*.StringValue'],
      },
      eventbridge: {
        request: [
          '$.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters[*].Value',
          '$.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters[*].Value',
          '$.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters[*].Value',
          '$.AuthParameters.InvocationHttpParameters.HeaderParameters[*].Value',
          '$.AuthParameters.InvocationHttpParameters.QueryStringParameters[*].Value',
          '$.AuthParameters.InvocationHttpParameters.BodyParameters[*].Value',
          '$.Targets[*].RedshiftDataParameters.Sql',
          '$.Targets[*].RedshiftDataParameters.Sqls',
          '$.Targets[*].AppSyncParameters.GraphQLOperation',
          '$.AuthParameters.BasicAuthParameters.Password',
          '$.AuthParameters.OAuthParameters.ClientParameters.ClientSecret',
          '$.AuthParameters.ApiKeyAuthParameters.ApiKeyValue',
        ],
        response: [
          '$.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters[*].Value',
          '$.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters[*].Value',
          '$.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters[*].Value',
          '$.AuthParameters.InvocationHttpParameters.HeaderParameters[*].Value',
          '$.AuthParameters.InvocationHttpParameters.QueryStringParameters[*].Value',
          '$.AuthParameters.InvocationHttpParameters.BodyParameters[*].Value',
          '$.Targets[*].RedshiftDataParameters.Sql',
          '$.Targets[*].RedshiftDataParameters.Sqls',
          '$.Targets[*].AppSyncParameters.GraphQLOperation',
        ],
        expand: [],
      },
      s3: {
        request: [
          '$.SSEKMSKeyId',
          '$.SSEKMSEncryptionContext',
          '$.ServerSideEncryptionConfiguration.Rules[*].ApplyServerSideEncryptionByDefault.KMSMasterKeyID',
          '$.InventoryConfiguration.Destination.S3BucketDestination.Encryption.SSEKMS.KeyId',
          '$.SSECustomerKey',
          '$.CopySourceSSECustomerKey',
          '$.RestoreRequest.OutputLocation.S3.Encryption.KMSKeyId',
        ],
        response: [
          '$.SSEKMSKeyId',
          '$.SSEKMSEncryptionContext',
          '$.ServerSideEncryptionConfiguration.Rules[*].ApplyServerSideEncryptionByDefault.KMSMasterKeyID',
          '$.InventoryConfiguration.Destination.S3BucketDestination.Encryption.SSEKMS.KeyId',
          '$.Credentials.SecretAccessKey',
          '$.Credentials.SessionToken',
          '$.InventoryConfigurationList[*].Destination.S3BucketDestination.Encryption.SSEKMS.KeyId',
        ],
        expand: [],
      },
      sqs: {
        request: [],
        response: [],
        expand: [],
      },
      kinesis: {
        request: [],
        response: [],
        expand: [],
      },
      dynamodb: {
        request: [],
        response: [],
        expand: [],
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/payload-tagging/config/index.js
var require_config = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/payload-tagging/config/index.js'(exports2, module2) {
    'use strict'
    var aws = require_aws()
    var sdks = { aws }
    function getSDKRules(sdk, requestInput, responseInput) {
      const sdkServiceRules = {}
      for (const [service, serviceRules] of Object.entries(sdk)) {
        sdkServiceRules[service] = {
          // Make a copy. Otherwise calling the function multiple times would append
          // the rules to the same object.
          request: [...serviceRules.request, ...requestInput],
          response: [...serviceRules.response, ...responseInput],
          expand: serviceRules.expand,
        }
      }
      return sdkServiceRules
    }
    function appendRules(requestInput = [], responseInput = []) {
      const sdkRules = {}
      for (const [name, sdk] of Object.entries(sdks)) {
        sdkRules[name] = getSDKRules(sdk, requestInput, responseInput)
      }
      return sdkRules
    }
    module2.exports = { appendRules }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/config_stable.js
var require_config_stable = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/config_stable.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var fs = require('fs')
    var { getEnvironmentVariable } = require_config_helper()
    var StableConfig = class {
      constructor() {
        this.warnings = []
        this.localEntries = {}
        this.fleetEntries = {}
        this.wasm_loaded = false
        const { localConfigPath, fleetConfigPath } = this._getStableConfigPaths()
        if (!fs.existsSync(localConfigPath) && !fs.existsSync(fleetConfigPath)) {
          return
        }
        const localConfig = this._readConfigFromPath(localConfigPath)
        const fleetConfig = this._readConfigFromPath(fleetConfigPath)
        if (!localConfig && !fleetConfig) {
          return
        }
        let libdatadog
        try {
          libdatadog = require('@datadog/libdatadog')
          this.wasm_loaded = true
        } catch {
          this.warnings.push("Can't load libdatadog library")
          return
        }
        const libconfig = libdatadog.maybeLoad('library_config')
        if (libconfig === void 0) {
          this.warnings.push("Can't load library_config library")
          return
        }
        try {
          const configurator = new libconfig.JsConfigurator()
          configurator.set_envp(Object.entries(process.env).map(([key, value]) => `${key}=${value}`))
          configurator.set_args(process.argv)
          configurator.get_configuration(localConfig.toString(), fleetConfig.toString()).forEach((entry) => {
            if (entry.source === 'local_stable_config') {
              this.localEntries[entry.name] = entry.value
            } else if (entry.source === 'fleet_stable_config') {
              this.fleetEntries[entry.name] = entry.value
            }
          })
        } catch (e) {
          this.warnings.push(`Error parsing configuration from file: ${e.message}`)
        }
      }
      _readConfigFromPath(path) {
        try {
          return fs.readFileSync(path, 'utf8')
        } catch (err) {
          if (err.code !== 'ENOENT') {
            this.warnings.push(`Error reading config file at ${path}. ${err.code}: ${err.message}`)
          }
          return ''
        }
      }
      _getStableConfigPaths() {
        let localConfigPath = ''
        let fleetConfigPath = ''
        switch (os.type().toLowerCase()) {
          case 'linux':
            localConfigPath = '/etc/datadog-agent/application_monitoring.yaml'
            fleetConfigPath = '/etc/datadog-agent/managed/datadog-agent/stable/application_monitoring.yaml'
            break
          case 'darwin':
            localConfigPath = '/opt/datadog-agent/etc/application_monitoring.yaml'
            fleetConfigPath = '/opt/datadog-agent/etc/managed/datadog-agent/stable/application_monitoring.yaml'
            break
          case 'win32':
            localConfigPath = String.raw`C:\ProgramData\Datadog\application_monitoring.yaml`
            fleetConfigPath = String.raw`C:\ProgramData\Datadog\managed\datadog-agent\stable\application_monitoring.yaml`
            break
          default:
            break
        }
        if (getEnvironmentVariable('DD_TEST_LOCAL_CONFIG_PATH') !== void 0) {
          localConfigPath = getEnvironmentVariable('DD_TEST_LOCAL_CONFIG_PATH')
        }
        if (getEnvironmentVariable('DD_TEST_FLEET_CONFIG_PATH') !== void 0) {
          fleetConfigPath = getEnvironmentVariable('DD_TEST_FLEET_CONFIG_PATH')
        }
        return { localConfigPath, fleetConfigPath }
      }
    }
    module2.exports = StableConfig
  },
})

// node_modules/dd-trace/packages/dd-trace/src/config.js
var require_config2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/config.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var os = require('os')
    var uuid = require_crypto_randomuuid()
    var { URL: URL2 } = require('url')
    var log = require_log2()
    var tagger = require_tagger()
    var set = require_set()
    var { isTrue, isFalse, normalizeProfilingEnabledValue } = require_util()
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2()
    var { getGitMetadataFromGitProperties, removeUserSensitiveInfo, getRemoteOriginURL, resolveGitHeadSHA } =
      require_git_properties()
    var { updateConfig } = require_telemetry3()
    var telemetryMetrics = require_metrics()
    var { isInServerlessEnvironment, getIsGCPFunction, getIsAzureFunction } = require_serverless()
    var { ORIGIN_KEY } = require_constants2()
    var { appendRules } = require_config()
    var { getEnvironmentVariable: getEnv, getEnvironmentVariables } = require_config_helper()
    var defaults = require_config_defaults()
    var path = require('path')
    var { DD_MAJOR } = require_version()
    var tracerMetrics = telemetryMetrics.manager.namespace('tracers')
    var changeTracker = {}
    var telemetryCounters = {
      'otel.env.hiding': {},
      'otel.env.invalid': {},
    }
    function getCounter(event, ddVar, otelVar) {
      const counters = telemetryCounters[event]
      const tags = []
      const ddVarPrefix = 'config_datadog:'
      const otelVarPrefix = 'config_opentelemetry:'
      if (ddVar) {
        ddVar = ddVarPrefix + ddVar.toLowerCase()
        tags.push(ddVar)
      }
      if (otelVar) {
        otelVar = otelVarPrefix + otelVar.toLowerCase()
        tags.push(otelVar)
      }
      if (!(otelVar in counters)) counters[otelVar] = {}
      const counter = tracerMetrics.count(event, tags)
      counters[otelVar][ddVar] = counter
      return counter
    }
    var otelDdEnvMapping = {
      OTEL_LOG_LEVEL: 'DD_TRACE_LOG_LEVEL',
      OTEL_PROPAGATORS: 'DD_TRACE_PROPAGATION_STYLE',
      OTEL_SERVICE_NAME: 'DD_SERVICE',
      OTEL_TRACES_SAMPLER: 'DD_TRACE_SAMPLE_RATE',
      OTEL_TRACES_SAMPLER_ARG: 'DD_TRACE_SAMPLE_RATE',
      OTEL_TRACES_EXPORTER: 'DD_TRACE_ENABLED',
      OTEL_METRICS_EXPORTER: 'DD_RUNTIME_METRICS_ENABLED',
      OTEL_RESOURCE_ATTRIBUTES: 'DD_TAGS',
      OTEL_SDK_DISABLED: 'DD_TRACE_OTEL_ENABLED',
      OTEL_LOGS_EXPORTER: void 0,
    }
    var VALID_PROPAGATION_STYLES = /* @__PURE__ */ new Set([
      'datadog',
      'tracecontext',
      'b3',
      'b3 single header',
      'none',
    ])
    var VALID_PROPAGATION_BEHAVIOR_EXTRACT = /* @__PURE__ */ new Set(['continue', 'restart', 'ignore'])
    var VALID_LOG_LEVELS = /* @__PURE__ */ new Set(['debug', 'info', 'warn', 'error'])
    var DEFAULT_OTLP_PORT = 4318
    function getFromOtelSamplerMap(otelTracesSampler, otelTracesSamplerArg) {
      const OTEL_TRACES_SAMPLER_MAPPING = {
        always_on: '1.0',
        always_off: '0.0',
        traceidratio: otelTracesSamplerArg,
        parentbased_always_on: '1.0',
        parentbased_always_off: '0.0',
        parentbased_traceidratio: otelTracesSamplerArg,
      }
      return OTEL_TRACES_SAMPLER_MAPPING[otelTracesSampler]
    }
    function isInvalidOtelEnvironmentVariable(envVar, value) {
      if (value === void 0) return false
      switch (envVar) {
        case 'OTEL_LOG_LEVEL':
          return !VALID_LOG_LEVELS.has(value)
        case 'OTEL_PROPAGATORS':
        case 'OTEL_RESOURCE_ATTRIBUTES':
        case 'OTEL_SERVICE_NAME':
          return typeof value !== 'string'
        case 'OTEL_TRACES_SAMPLER':
          return getFromOtelSamplerMap(value, getEnv('OTEL_TRACES_SAMPLER_ARG')) === void 0
        case 'OTEL_TRACES_SAMPLER_ARG':
          return Number.isNaN(Number.parseFloat(value))
        case 'OTEL_SDK_DISABLED':
          return value.toLowerCase() !== 'true' && value.toLowerCase() !== 'false'
        case 'OTEL_TRACES_EXPORTER':
        case 'OTEL_METRICS_EXPORTER':
        case 'OTEL_LOGS_EXPORTER':
          return value.toLowerCase() !== 'none'
        default:
          return true
      }
    }
    function checkIfBothOtelAndDdEnvVarSet() {
      for (const [otelEnvVar, ddEnvVar] of Object.entries(otelDdEnvMapping)) {
        const otelValue = getEnv(otelEnvVar)
        if (ddEnvVar && getEnv(ddEnvVar) && otelValue) {
          log.warn('both %s and %s environment variables are set', ddEnvVar, otelEnvVar)
          getCounter('otel.env.hiding', ddEnvVar, otelEnvVar).inc()
        }
        if (isInvalidOtelEnvironmentVariable(otelEnvVar, otelValue)) {
          log.warn('unexpected value %s for %s environment variable', otelValue, otelEnvVar)
          getCounter('otel.env.invalid', ddEnvVar, otelEnvVar).inc()
        }
      }
    }
    var runtimeId = uuid()
    function maybeFile(filepath) {
      if (!filepath) return
      try {
        return fs.readFileSync(filepath, 'utf8')
      } catch (e) {
        log.error('Error reading file %s', filepath, e)
      }
    }
    function maybeJsonFile(filepath) {
      const file = maybeFile(filepath)
      if (!file) return
      try {
        return JSON.parse(file)
      } catch (e) {
        log.error('Error parsing JSON file %s', filepath, e)
      }
    }
    function safeJsonParse(input) {
      try {
        return JSON.parse(input)
      } catch {}
    }
    var namingVersions = /* @__PURE__ */ new Set(['v0', 'v1'])
    var defaultNamingVersion = 'v0'
    function validateNamingVersion(versionString) {
      if (!versionString) {
        return defaultNamingVersion
      }
      if (!namingVersions.has(versionString)) {
        log.warn('Unexpected input for config.spanAttributeSchema, picked default', defaultNamingVersion)
        return defaultNamingVersion
      }
      return versionString
    }
    function splitJSONPathRules(input) {
      if (!input) return
      if (Array.isArray(input)) return input
      if (input === 'all') return []
      return input.split(',')
    }
    function remapify(input, mappings) {
      if (!input) return
      const output = {}
      for (const [key, value] of Object.entries(input)) {
        output[key in mappings ? mappings[key] : key] = value
      }
      return output
    }
    function normalizePropagationStyle(value) {
      if (Array.isArray(value)) {
        return value.map((v) => v.toLowerCase())
      }
      if (typeof value === 'string') {
        return value
          .split(',')
          .filter((v) => v !== '')
          .map((v) => v.trim().toLowerCase())
      }
      if (value !== void 0) {
        log.warn('Unexpected input for config.tracePropagationStyle')
      }
    }
    function warnIfPropagationStyleConflict(general, inject, extract) {
      if (general && (inject || extract)) {
        log.warn(
          // eslint-disable-next-line @stylistic/max-len
          'Use either the DD_TRACE_PROPAGATION_STYLE environment variable or separate DD_TRACE_PROPAGATION_STYLE_INJECT and DD_TRACE_PROPAGATION_STYLE_EXTRACT environment variables'
        )
      }
    }
    function reformatSpanSamplingRules(rules) {
      if (!rules) return rules
      return rules.map((rule) => {
        return remapify(rule, {
          sample_rate: 'sampleRate',
          max_per_second: 'maxPerSecond',
        })
      })
    }
    var Config = class {
      /**
       * parsed DD_TAGS, usable as a standalone tag set across products
       * @type {Record<string, string> | undefined}
       */
      #parsedDdTags = {}
      #envUnprocessed = {}
      #optsUnprocessed = {}
      #remoteUnprocessed = {}
      #env = {}
      #options = {}
      #remote = {}
      #defaults = {}
      #optionsArg = {}
      #localStableConfig = {}
      #fleetStableConfig = {}
      #calculated = {}
      #getSourcesInOrder() {
        return [
          { container: this.#remote, origin: 'remote_config', unprocessed: this.#remoteUnprocessed },
          { container: this.#options, origin: 'code', unprocessed: this.#optsUnprocessed },
          { container: this.#fleetStableConfig, origin: 'fleet_stable_config' },
          { container: this.#env, origin: 'env_var', unprocessed: this.#envUnprocessed },
          { container: this.#localStableConfig, origin: 'local_stable_config' },
          { container: this.#calculated, origin: 'calculated' },
          { container: this.#defaults, origin: 'default' },
        ]
      }
      constructor(options = {}) {
        if (!isInServerlessEnvironment()) {
          const StableConfig = require_config_stable()
          this.stableConfig = new StableConfig()
        }
        const envs = getEnvironmentVariables()
        options = {
          ...options,
          appsec: options.appsec == null ? options.experimental?.appsec : options.appsec,
          iast: options.iast == null ? options.experimental?.iast : options.iast,
        }
        const logConfig = log.getConfig()
        this.debug = log.isEnabled(
          this.stableConfig?.fleetEntries?.DD_TRACE_DEBUG,
          this.stableConfig?.localEntries?.DD_TRACE_DEBUG
        )
        this.logger = options.logger ?? logConfig.logger
        this.logLevel = log.getLogLevel(
          options.logLevel,
          this.stableConfig?.fleetEntries?.DD_TRACE_LOG_LEVEL,
          this.stableConfig?.localEntries?.DD_TRACE_LOG_LEVEL
        )
        log.use(this.logger)
        log.toggle(this.debug, this.logLevel)
        for (const warning of this.stableConfig?.warnings ?? []) {
          log.warn(warning)
        }
        checkIfBothOtelAndDdEnvVarSet()
        if (typeof options.appsec === 'boolean') {
          options.appsec = {
            enabled: options.appsec,
          }
        }
        if (typeof options.runtimeMetrics === 'boolean') {
          options.runtimeMetrics = {
            enabled: options.runtimeMetrics,
          }
        }
        this.#defaults = defaults
        this.#applyDefaults()
        this.#applyStableConfig(this.stableConfig?.localEntries ?? {}, this.#localStableConfig)
        this.#applyEnvironment(envs)
        this.#applyStableConfig(this.stableConfig?.fleetEntries ?? {}, this.#fleetStableConfig)
        this.#applyOptions(options)
        this.#applyCalculated()
        this.#applyRemote({})
        this.#merge()
        tagger.add(this.tags, {
          service: this.service,
          env: this.env,
          version: this.version,
          'runtime-id': runtimeId,
        })
        if (this.isCiVisibility) {
          tagger.add(this.tags, {
            [ORIGIN_KEY]: 'ciapp-test',
          })
        }
        if (this.gitMetadataEnabled) {
          this.#loadGitMetadata(envs)
        }
      }
      get parsedDdTags() {
        return this.#parsedDdTags
      }
      // Supports only a subset of options for now.
      configure(options, remote) {
        if (remote) {
          this.#applyRemote(options)
        } else {
          this.#applyOptions(options)
        }
        this.#applyCalculated()
        this.#merge()
      }
      #getDefaultPropagationStyle(options) {
        const DD_TRACE_B3_ENABLED = options.experimental?.b3 ?? getEnv('DD_TRACE_EXPERIMENTAL_B3_ENABLED')
        const defaultPropagationStyle = ['datadog', 'tracecontext']
        if (isTrue(DD_TRACE_B3_ENABLED)) {
          defaultPropagationStyle.push('b3', 'b3 single header')
        }
        return defaultPropagationStyle
      }
      _isInServerlessEnvironment() {
        return isInServerlessEnvironment()
      }
      #applyStableConfig(config, obj) {
        this.#applyConfigValues(config, obj, {})
      }
      // Set environment-dependent defaults that can be overridden by users
      #applyDefaults() {
        const defaults2 = this.#defaults
        if (isInServerlessEnvironment()) {
          this.#setBoolean(defaults2, 'crashtracking.enabled', false)
          this.#setString(defaults2, 'profiling.enabled', 'false')
          this.#setBoolean(defaults2, 'telemetry.enabled', false)
          this.#setBoolean(defaults2, 'remoteConfig.enabled', false)
        } else {
          this.#setBoolean(defaults2, 'crashtracking.enabled', true)
        }
        if (getEnv('JEST_WORKER_ID')) {
          this.#setBoolean(defaults2, 'telemetry.enabled', false)
        }
      }
      #applyEnvironment() {
        this.#applyConfigValues(getEnvironmentVariables(), this.#env, this.#envUnprocessed)
      }
      #applyConfigValues(source, target, unprocessedTarget) {
        const {
          AWS_LAMBDA_FUNCTION_NAME,
          DD_AGENT_HOST,
          DD_AI_GUARD_ENABLED,
          DD_AI_GUARD_ENDPOINT,
          DD_AI_GUARD_MAX_CONTENT_SIZE,
          DD_AI_GUARD_MAX_MESSAGES_LENGTH,
          DD_AI_GUARD_TIMEOUT,
          DD_API_KEY,
          DD_API_SECURITY_ENABLED,
          DD_API_SECURITY_SAMPLE_DELAY,
          DD_API_SECURITY_ENDPOINT_COLLECTION_ENABLED,
          DD_API_SECURITY_ENDPOINT_COLLECTION_MESSAGE_LIMIT,
          DD_APM_TRACING_ENABLED,
          DD_APP_KEY,
          DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE,
          DD_APPSEC_COLLECT_ALL_HEADERS,
          DD_APPSEC_ENABLED,
          DD_APPSEC_GRAPHQL_BLOCKED_TEMPLATE_JSON,
          DD_APPSEC_HEADER_COLLECTION_REDACTION_ENABLED,
          DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML,
          DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON,
          DD_APPSEC_MAX_COLLECTED_HEADERS,
          DD_APPSEC_MAX_STACK_TRACES,
          DD_APPSEC_MAX_STACK_TRACE_DEPTH,
          DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP,
          DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP,
          DD_APPSEC_RULES,
          DD_APPSEC_SCA_ENABLED,
          DD_APPSEC_STACK_TRACE_ENABLED,
          DD_APPSEC_RASP_ENABLED,
          DD_APPSEC_RASP_COLLECT_REQUEST_BODY,
          DD_APPSEC_TRACE_RATE_LIMIT,
          DD_APPSEC_WAF_TIMEOUT,
          DD_CRASHTRACKING_ENABLED,
          DD_CODE_ORIGIN_FOR_SPANS_ENABLED,
          DD_CODE_ORIGIN_FOR_SPANS_EXPERIMENTAL_EXIT_SPANS_ENABLED,
          DD_DATA_STREAMS_ENABLED,
          DD_DBM_PROPAGATION_MODE,
          DD_DOGSTATSD_HOST,
          DD_DOGSTATSD_PORT,
          DD_DYNAMIC_INSTRUMENTATION_CAPTURE_TIMEOUT_MS,
          DD_DYNAMIC_INSTRUMENTATION_ENABLED,
          DD_DYNAMIC_INSTRUMENTATION_PROBE_FILE,
          DD_DYNAMIC_INSTRUMENTATION_REDACTED_IDENTIFIERS,
          DD_DYNAMIC_INSTRUMENTATION_REDACTION_EXCLUDED_IDENTIFIERS,
          DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS,
          DD_ENV,
          DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED,
          DD_EXPERIMENTAL_PROPAGATE_PROCESS_TAGS_ENABLED,
          DD_PROFILING_ENABLED,
          DD_GRPC_CLIENT_ERROR_STATUSES,
          DD_GRPC_SERVER_ERROR_STATUSES,
          DD_HEAP_SNAPSHOT_COUNT,
          DD_HEAP_SNAPSHOT_DESTINATION,
          DD_HEAP_SNAPSHOT_INTERVAL,
          DD_IAST_DB_ROWS_TO_TAINT,
          DD_IAST_DEDUPLICATION_ENABLED,
          DD_IAST_ENABLED,
          DD_IAST_MAX_CONCURRENT_REQUESTS,
          DD_IAST_MAX_CONTEXT_OPERATIONS,
          DD_IAST_REDACTION_ENABLED,
          DD_IAST_REDACTION_NAME_PATTERN,
          DD_IAST_REDACTION_VALUE_PATTERN,
          DD_IAST_REQUEST_SAMPLING,
          DD_IAST_SECURITY_CONTROLS_CONFIGURATION,
          DD_IAST_TELEMETRY_VERBOSITY,
          DD_IAST_STACK_TRACE_ENABLED,
          DD_INJECTION_ENABLED,
          DD_INJECT_FORCE,
          DD_INSTRUMENTATION_TELEMETRY_ENABLED,
          DD_INSTRUMENTATION_CONFIG_ID,
          DD_LOGS_INJECTION,
          DD_LOGS_OTEL_ENABLED,
          DD_METRICS_OTEL_ENABLED,
          DD_LANGCHAIN_SPAN_CHAR_LIMIT,
          DD_LANGCHAIN_SPAN_PROMPT_COMPLETION_SAMPLE_RATE,
          DD_LLMOBS_AGENTLESS_ENABLED,
          DD_LLMOBS_ENABLED,
          DD_LLMOBS_ML_APP,
          DD_OPENAI_LOGS_ENABLED,
          DD_OPENAI_SPAN_CHAR_LIMIT,
          DD_PROFILING_EXPORTERS,
          DD_PROFILING_SOURCE_MAP,
          DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD,
          DD_INSTRUMENTATION_INSTALL_ID,
          DD_INSTRUMENTATION_INSTALL_TIME,
          DD_INSTRUMENTATION_INSTALL_TYPE,
          DD_REMOTE_CONFIGURATION_ENABLED,
          DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS,
          DD_RUNTIME_METRICS_ENABLED,
          DD_RUNTIME_METRICS_EVENT_LOOP_ENABLED,
          DD_RUNTIME_METRICS_GC_ENABLED,
          DD_SERVICE,
          DD_SERVICE_MAPPING,
          DD_SITE,
          DD_SPAN_SAMPLING_RULES,
          DD_SPAN_SAMPLING_RULES_FILE,
          DD_TAGS,
          DD_TELEMETRY_DEBUG,
          DD_TELEMETRY_DEPENDENCY_COLLECTION_ENABLED,
          DD_TELEMETRY_HEARTBEAT_INTERVAL,
          DD_TELEMETRY_LOG_COLLECTION_ENABLED,
          DD_TELEMETRY_METRICS_ENABLED,
          DD_TRACE_128_BIT_TRACEID_GENERATION_ENABLED,
          DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED,
          DD_TRACE_AGENT_PORT,
          DD_TRACE_AGENT_PROTOCOL_VERSION,
          DD_TRACE_AWS_ADD_SPAN_POINTERS,
          DD_TRACE_BAGGAGE_MAX_BYTES,
          DD_TRACE_BAGGAGE_MAX_ITEMS,
          DD_TRACE_BAGGAGE_TAG_KEYS,
          DD_TRACE_CLIENT_IP_ENABLED,
          DD_TRACE_CLIENT_IP_HEADER,
          DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING,
          DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING,
          DD_TRACE_CLOUD_PAYLOAD_TAGGING_MAX_DEPTH,
          DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS,
          DD_TRACE_ENABLED,
          DD_TRACE_EXPERIMENTAL_EXPORTER,
          DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED,
          DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED,
          DD_TRACE_GIT_METADATA_ENABLED,
          DD_TRACE_GLOBAL_TAGS,
          DD_TRACE_GRAPHQL_ERROR_EXTENSIONS,
          DD_TRACE_HEADER_TAGS,
          DD_TRACE_LEGACY_BAGGAGE_ENABLED,
          DD_TRACE_MEMCACHED_COMMAND_ENABLED,
          DD_TRACE_MIDDLEWARE_TRACING_ENABLED,
          DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP,
          DD_TRACE_PARTIAL_FLUSH_MIN_SPANS,
          DD_TRACE_FLUSH_INTERVAL,
          DD_TRACE_PEER_SERVICE_MAPPING,
          DD_TRACE_PROPAGATION_EXTRACT_FIRST,
          DD_TRACE_PROPAGATION_BEHAVIOR_EXTRACT,
          DD_TRACE_PROPAGATION_STYLE,
          DD_TRACE_PROPAGATION_STYLE_INJECT,
          DD_TRACE_PROPAGATION_STYLE_EXTRACT,
          DD_TRACE_RATE_LIMIT,
          DD_TRACE_REMOVE_INTEGRATION_SERVICE_NAMES_ENABLED,
          DD_TRACE_REPORT_HOSTNAME,
          DD_TRACE_RESOURCE_RENAMING_ENABLED,
          DD_TRACE_SAMPLE_RATE,
          DD_TRACE_SAMPLING_RULES,
          DD_TRACE_SCOPE,
          DD_TRACE_SPAN_ATTRIBUTE_SCHEMA,
          DD_TRACE_SPAN_LEAK_DEBUG,
          DD_TRACE_STARTUP_LOGS,
          DD_TRACE_TAGS,
          DD_TRACE_WEBSOCKET_MESSAGES_ENABLED,
          DD_TRACE_WEBSOCKET_MESSAGES_INHERIT_SAMPLING,
          DD_TRACE_WEBSOCKET_MESSAGES_SEPARATE_TRACES,
          DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH,
          DD_TRACING_ENABLED,
          DD_VERSION,
          DD_VERTEXAI_SPAN_PROMPT_COMPLETION_SAMPLE_RATE,
          DD_VERTEXAI_SPAN_CHAR_LIMIT,
          DD_TRACE_INFERRED_PROXY_SERVICES_ENABLED,
          DD_TRACE_NATIVE_SPAN_EVENTS,
          OTEL_METRICS_EXPORTER,
          OTEL_PROPAGATORS,
          OTEL_RESOURCE_ATTRIBUTES,
          OTEL_SERVICE_NAME,
          OTEL_TRACES_SAMPLER,
          OTEL_TRACES_SAMPLER_ARG,
          DD_EXPERIMENTAL_FLAGGING_PROVIDER_ENABLED,
          OTEL_EXPORTER_OTLP_LOGS_ENDPOINT,
          OTEL_EXPORTER_OTLP_LOGS_HEADERS,
          OTEL_EXPORTER_OTLP_LOGS_PROTOCOL,
          OTEL_EXPORTER_OTLP_LOGS_TIMEOUT,
          OTEL_EXPORTER_OTLP_METRICS_ENDPOINT,
          OTEL_EXPORTER_OTLP_METRICS_HEADERS,
          OTEL_EXPORTER_OTLP_METRICS_PROTOCOL,
          OTEL_EXPORTER_OTLP_METRICS_TIMEOUT,
          OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE,
          OTEL_METRIC_EXPORT_TIMEOUT,
          OTEL_EXPORTER_OTLP_PROTOCOL,
          OTEL_EXPORTER_OTLP_ENDPOINT,
          OTEL_EXPORTER_OTLP_HEADERS,
          OTEL_EXPORTER_OTLP_TIMEOUT,
          OTEL_BSP_SCHEDULE_DELAY,
          OTEL_BSP_MAX_EXPORT_BATCH_SIZE,
          OTEL_BSP_MAX_QUEUE_SIZE,
          OTEL_METRIC_EXPORT_INTERVAL,
        } = source
        const tags = {}
        const parsedDdTags = parseSpaceSeparatedTags(DD_TAGS)
        tagger.add(this.#parsedDdTags, parsedDdTags)
        tagger.add(tags, parseSpaceSeparatedTags(handleOtel(OTEL_RESOURCE_ATTRIBUTES)))
        tagger.add(tags, parsedDdTags)
        tagger.add(tags, DD_TRACE_TAGS)
        tagger.add(tags, DD_TRACE_GLOBAL_TAGS)
        this.#setString(target, 'apiKey', DD_API_KEY)
        this.#setBoolean(target, 'otelLogsEnabled', DD_LOGS_OTEL_ENABLED)
        if (OTEL_EXPORTER_OTLP_ENDPOINT) {
          this.#setString(target, 'otelUrl', OTEL_EXPORTER_OTLP_ENDPOINT)
        }
        if (OTEL_EXPORTER_OTLP_ENDPOINT || OTEL_EXPORTER_OTLP_LOGS_ENDPOINT) {
          this.#setString(target, 'otelLogsUrl', OTEL_EXPORTER_OTLP_LOGS_ENDPOINT || target.otelUrl)
        }
        this.#setString(target, 'otelHeaders', OTEL_EXPORTER_OTLP_HEADERS)
        this.#setString(target, 'otelLogsHeaders', OTEL_EXPORTER_OTLP_LOGS_HEADERS || target.otelHeaders)
        this.#setString(target, 'otelProtocol', OTEL_EXPORTER_OTLP_PROTOCOL)
        this.#setString(target, 'otelLogsProtocol', OTEL_EXPORTER_OTLP_LOGS_PROTOCOL || target.otelProtocol)
        const otelTimeout = nonNegInt(OTEL_EXPORTER_OTLP_TIMEOUT, 'OTEL_EXPORTER_OTLP_TIMEOUT')
        if (otelTimeout !== void 0) {
          target.otelTimeout = otelTimeout
        }
        const otelLogsTimeout = nonNegInt(OTEL_EXPORTER_OTLP_LOGS_TIMEOUT, 'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT')
        target.otelLogsTimeout = otelLogsTimeout === void 0 ? target.otelTimeout : otelLogsTimeout
        const otelBatchTimeout = nonNegInt(OTEL_BSP_SCHEDULE_DELAY, 'OTEL_BSP_SCHEDULE_DELAY', false)
        if (otelBatchTimeout !== void 0) {
          target.otelBatchTimeout = otelBatchTimeout
        }
        target.otelMaxExportBatchSize = nonNegInt(
          OTEL_BSP_MAX_EXPORT_BATCH_SIZE,
          'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
          false
        )
        target.otelMaxQueueSize = nonNegInt(OTEL_BSP_MAX_QUEUE_SIZE, 'OTEL_BSP_MAX_QUEUE_SIZE', false)
        const otelMetricsExporterEnabled = OTEL_METRICS_EXPORTER?.toLowerCase() !== 'none'
        this.#setBoolean(
          target,
          'otelMetricsEnabled',
          DD_METRICS_OTEL_ENABLED && isTrue(DD_METRICS_OTEL_ENABLED) && otelMetricsExporterEnabled
        )
        if (OTEL_EXPORTER_OTLP_ENDPOINT || OTEL_EXPORTER_OTLP_METRICS_ENDPOINT) {
          this.#setString(target, 'otelMetricsUrl', OTEL_EXPORTER_OTLP_METRICS_ENDPOINT || target.otelUrl)
        }
        this.#setString(target, 'otelMetricsHeaders', OTEL_EXPORTER_OTLP_METRICS_HEADERS || target.otelHeaders)
        this.#setString(target, 'otelMetricsProtocol', OTEL_EXPORTER_OTLP_METRICS_PROTOCOL || target.otelProtocol)
        const otelMetricsTimeout = nonNegInt(OTEL_EXPORTER_OTLP_METRICS_TIMEOUT, 'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT')
        target.otelMetricsTimeout = otelMetricsTimeout === void 0 ? target.otelTimeout : otelMetricsTimeout
        target.otelMetricsExportTimeout = nonNegInt(OTEL_METRIC_EXPORT_TIMEOUT, 'OTEL_METRIC_EXPORT_TIMEOUT')
        target.otelMetricsExportInterval = nonNegInt(OTEL_METRIC_EXPORT_INTERVAL, 'OTEL_METRIC_EXPORT_INTERVAL', false)
        if (OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE) {
          const temporalityPref = OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE.toUpperCase()
          if (['DELTA', 'CUMULATIVE', 'LOWMEMORY'].includes(temporalityPref)) {
            this.#setString(target, 'otelMetricsTemporalityPreference', temporalityPref)
          }
        }
        this.#setBoolean(
          target,
          'apmTracingEnabled',
          DD_APM_TRACING_ENABLED ??
            (DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED && isFalse(DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED))
        )
        this.#setBoolean(target, 'propagateProcessTags.enabled', DD_EXPERIMENTAL_PROPAGATE_PROCESS_TAGS_ENABLED)
        this.#setString(target, 'appKey', DD_APP_KEY)
        this.#setBoolean(
          target,
          'appsec.apiSecurity.enabled',
          DD_API_SECURITY_ENABLED && isTrue(DD_API_SECURITY_ENABLED)
        )
        target['appsec.apiSecurity.sampleDelay'] = maybeFloat(DD_API_SECURITY_SAMPLE_DELAY)
        this.#setBoolean(
          target,
          'appsec.apiSecurity.endpointCollectionEnabled',
          DD_API_SECURITY_ENDPOINT_COLLECTION_ENABLED
        )
        target['appsec.apiSecurity.endpointCollectionMessageLimit'] = maybeInt(
          DD_API_SECURITY_ENDPOINT_COLLECTION_MESSAGE_LIMIT
        )
        target['appsec.blockedTemplateGraphql'] = maybeFile(DD_APPSEC_GRAPHQL_BLOCKED_TEMPLATE_JSON)
        target['appsec.blockedTemplateHtml'] = maybeFile(DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML)
        unprocessedTarget['appsec.blockedTemplateHtml'] = DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML
        target['appsec.blockedTemplateJson'] = maybeFile(DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON)
        unprocessedTarget['appsec.blockedTemplateJson'] = DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON
        this.#setBoolean(target, 'appsec.enabled', DD_APPSEC_ENABLED)
        this.#setString(target, 'appsec.eventTracking.mode', DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE)
        this.#setBoolean(target, 'appsec.extendedHeadersCollection.enabled', DD_APPSEC_COLLECT_ALL_HEADERS)
        this.#setBoolean(
          target,
          'appsec.extendedHeadersCollection.redaction',
          DD_APPSEC_HEADER_COLLECTION_REDACTION_ENABLED
        )
        target['appsec.extendedHeadersCollection.maxHeaders'] = maybeInt(DD_APPSEC_MAX_COLLECTED_HEADERS)
        unprocessedTarget['appsec.extendedHeadersCollection.maxHeaders'] = DD_APPSEC_MAX_COLLECTED_HEADERS
        this.#setString(target, 'appsec.obfuscatorKeyRegex', DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP)
        this.#setString(target, 'appsec.obfuscatorValueRegex', DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP)
        this.#setBoolean(target, 'appsec.rasp.enabled', DD_APPSEC_RASP_ENABLED)
        this.#setBoolean(target, 'appsec.rasp.bodyCollection', DD_APPSEC_RASP_COLLECT_REQUEST_BODY)
        target['appsec.rateLimit'] = maybeInt(DD_APPSEC_TRACE_RATE_LIMIT)
        unprocessedTarget['appsec.rateLimit'] = DD_APPSEC_TRACE_RATE_LIMIT
        this.#setString(target, 'appsec.rules', DD_APPSEC_RULES)
        this.#setBoolean(target, 'appsec.sca.enabled', DD_APPSEC_SCA_ENABLED)
        this.#setBoolean(target, 'appsec.stackTrace.enabled', DD_APPSEC_STACK_TRACE_ENABLED)
        target['appsec.stackTrace.maxDepth'] = maybeInt(DD_APPSEC_MAX_STACK_TRACE_DEPTH)
        unprocessedTarget['appsec.stackTrace.maxDepth'] = DD_APPSEC_MAX_STACK_TRACE_DEPTH
        target['appsec.stackTrace.maxStackTraces'] = maybeInt(DD_APPSEC_MAX_STACK_TRACES)
        unprocessedTarget['appsec.stackTrace.maxStackTraces'] = DD_APPSEC_MAX_STACK_TRACES
        target['appsec.wafTimeout'] = maybeInt(DD_APPSEC_WAF_TIMEOUT)
        unprocessedTarget['appsec.wafTimeout'] = DD_APPSEC_WAF_TIMEOUT
        target.baggageMaxBytes = DD_TRACE_BAGGAGE_MAX_BYTES
        target.baggageMaxItems = DD_TRACE_BAGGAGE_MAX_ITEMS
        target.baggageTagKeys = DD_TRACE_BAGGAGE_TAG_KEYS
        this.#setBoolean(target, 'clientIpEnabled', DD_TRACE_CLIENT_IP_ENABLED)
        this.#setString(target, 'clientIpHeader', DD_TRACE_CLIENT_IP_HEADER?.toLowerCase())
        if (DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING || DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING) {
          if (DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING) {
            this.#setBoolean(target, 'cloudPayloadTagging.requestsEnabled', true)
          }
          if (DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING) {
            this.#setBoolean(target, 'cloudPayloadTagging.responsesEnabled', true)
          }
          target['cloudPayloadTagging.rules'] = appendRules(
            splitJSONPathRules(DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING),
            splitJSONPathRules(DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING)
          )
        }
        if (DD_TRACE_CLOUD_PAYLOAD_TAGGING_MAX_DEPTH) {
          target['cloudPayloadTagging.maxDepth'] = maybeInt(DD_TRACE_CLOUD_PAYLOAD_TAGGING_MAX_DEPTH)
        }
        this.#setBoolean(target, 'crashtracking.enabled', DD_CRASHTRACKING_ENABLED)
        this.#setBoolean(target, 'codeOriginForSpans.enabled', DD_CODE_ORIGIN_FOR_SPANS_ENABLED)
        this.#setBoolean(
          target,
          'codeOriginForSpans.experimental.exit_spans.enabled',
          DD_CODE_ORIGIN_FOR_SPANS_EXPERIMENTAL_EXIT_SPANS_ENABLED
        )
        this.#setString(target, 'dbmPropagationMode', DD_DBM_PROPAGATION_MODE)
        this.#setString(target, 'dogstatsd.hostname', DD_DOGSTATSD_HOST)
        this.#setString(target, 'dogstatsd.port', DD_DOGSTATSD_PORT)
        this.#setBoolean(target, 'dsmEnabled', DD_DATA_STREAMS_ENABLED)
        target['dynamicInstrumentation.captureTimeoutMs'] = maybeInt(DD_DYNAMIC_INSTRUMENTATION_CAPTURE_TIMEOUT_MS)
        unprocessedTarget['dynamicInstrumentation.captureTimeoutMs'] = DD_DYNAMIC_INSTRUMENTATION_CAPTURE_TIMEOUT_MS
        this.#setBoolean(target, 'dynamicInstrumentation.enabled', DD_DYNAMIC_INSTRUMENTATION_ENABLED)
        this.#setString(target, 'dynamicInstrumentation.probeFile', DD_DYNAMIC_INSTRUMENTATION_PROBE_FILE)
        this.#setArray(
          target,
          'dynamicInstrumentation.redactedIdentifiers',
          DD_DYNAMIC_INSTRUMENTATION_REDACTED_IDENTIFIERS
        )
        this.#setArray(
          target,
          'dynamicInstrumentation.redactionExcludedIdentifiers',
          DD_DYNAMIC_INSTRUMENTATION_REDACTION_EXCLUDED_IDENTIFIERS
        )
        target['dynamicInstrumentation.uploadIntervalSeconds'] = maybeFloat(
          DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS
        )
        unprocessedTarget['dynamicInstrumentation.uploadInterval'] = DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS
        this.#setString(target, 'env', DD_ENV || tags.env)
        this.#setBoolean(target, 'experimental.flaggingProvider.enabled', DD_EXPERIMENTAL_FLAGGING_PROVIDER_ENABLED)
        this.#setBoolean(target, 'traceEnabled', DD_TRACE_ENABLED)
        this.#setBoolean(target, 'experimental.aiguard.enabled', DD_AI_GUARD_ENABLED)
        this.#setString(target, 'experimental.aiguard.endpoint', DD_AI_GUARD_ENDPOINT)
        target['experimental.aiguard.maxContentSize'] = maybeInt(DD_AI_GUARD_MAX_CONTENT_SIZE)
        unprocessedTarget['experimental.aiguard.maxContentSize'] = DD_AI_GUARD_MAX_CONTENT_SIZE
        target['experimental.aiguard.maxMessagesLength'] = maybeInt(DD_AI_GUARD_MAX_MESSAGES_LENGTH)
        unprocessedTarget['experimental.aiguard.maxMessagesLength'] = DD_AI_GUARD_MAX_MESSAGES_LENGTH
        target['experimental.aiguard.timeout'] = maybeInt(DD_AI_GUARD_TIMEOUT)
        unprocessedTarget['experimental.aiguard.timeout'] = DD_AI_GUARD_TIMEOUT
        this.#setBoolean(target, 'experimental.enableGetRumData', DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED)
        this.#setString(target, 'experimental.exporter', DD_TRACE_EXPERIMENTAL_EXPORTER)
        if (AWS_LAMBDA_FUNCTION_NAME) {
          target.flushInterval = 0
        } else if (DD_TRACE_FLUSH_INTERVAL) {
          target.flushInterval = maybeInt(DD_TRACE_FLUSH_INTERVAL)
        }
        target.flushMinSpans = maybeInt(DD_TRACE_PARTIAL_FLUSH_MIN_SPANS)
        unprocessedTarget.flushMinSpans = DD_TRACE_PARTIAL_FLUSH_MIN_SPANS
        this.#setBoolean(target, 'gitMetadataEnabled', DD_TRACE_GIT_METADATA_ENABLED)
        this.#setIntegerRangeSet(target, 'grpc.client.error.statuses', DD_GRPC_CLIENT_ERROR_STATUSES)
        this.#setIntegerRangeSet(target, 'grpc.server.error.statuses', DD_GRPC_SERVER_ERROR_STATUSES)
        this.#setArray(target, 'headerTags', DD_TRACE_HEADER_TAGS)
        target['heapSnapshot.count'] = maybeInt(DD_HEAP_SNAPSHOT_COUNT)
        this.#setString(target, 'heapSnapshot.destination', DD_HEAP_SNAPSHOT_DESTINATION)
        target['heapSnapshot.interval'] = maybeInt(DD_HEAP_SNAPSHOT_INTERVAL)
        this.#setString(target, 'hostname', DD_AGENT_HOST)
        target['iast.dbRowsToTaint'] = maybeInt(DD_IAST_DB_ROWS_TO_TAINT)
        this.#setBoolean(target, 'iast.deduplicationEnabled', DD_IAST_DEDUPLICATION_ENABLED)
        this.#setBoolean(target, 'iast.enabled', DD_IAST_ENABLED)
        target['iast.maxConcurrentRequests'] = maybeInt(DD_IAST_MAX_CONCURRENT_REQUESTS)
        unprocessedTarget['iast.maxConcurrentRequests'] = DD_IAST_MAX_CONCURRENT_REQUESTS
        target['iast.maxContextOperations'] = maybeInt(DD_IAST_MAX_CONTEXT_OPERATIONS)
        unprocessedTarget['iast.maxContextOperations'] = DD_IAST_MAX_CONTEXT_OPERATIONS
        this.#setBoolean(
          target,
          'iast.redactionEnabled',
          DD_IAST_REDACTION_ENABLED && !isFalse(DD_IAST_REDACTION_ENABLED)
        )
        this.#setString(target, 'iast.redactionNamePattern', DD_IAST_REDACTION_NAME_PATTERN)
        this.#setString(target, 'iast.redactionValuePattern', DD_IAST_REDACTION_VALUE_PATTERN)
        const iastRequestSampling = maybeInt(DD_IAST_REQUEST_SAMPLING)
        if (iastRequestSampling !== void 0 && iastRequestSampling > -1 && iastRequestSampling < 101) {
          target['iast.requestSampling'] = iastRequestSampling
        }
        unprocessedTarget['iast.requestSampling'] = DD_IAST_REQUEST_SAMPLING
        this.#setString(target, 'iast.securityControlsConfiguration', DD_IAST_SECURITY_CONTROLS_CONFIGURATION)
        this.#setString(target, 'iast.telemetryVerbosity', DD_IAST_TELEMETRY_VERBOSITY)
        this.#setBoolean(target, 'iast.stackTrace.enabled', DD_IAST_STACK_TRACE_ENABLED)
        this.#setString(target, 'installSignature.id', DD_INSTRUMENTATION_INSTALL_ID)
        this.#setString(target, 'installSignature.time', DD_INSTRUMENTATION_INSTALL_TIME)
        this.#setString(target, 'installSignature.type', DD_INSTRUMENTATION_INSTALL_TYPE)
        this.#setArray(target, 'injectionEnabled', DD_INJECTION_ENABLED)
        if (DD_INJECTION_ENABLED !== void 0) {
          this.#setString(target, 'instrumentationSource', DD_INJECTION_ENABLED ? 'ssi' : 'manual')
        }
        this.#setBoolean(target, 'injectForce', DD_INJECT_FORCE)
        this.#setBoolean(target, 'isAzureFunction', getIsAzureFunction())
        this.#setBoolean(target, 'isGCPFunction', getIsGCPFunction())
        target['langchain.spanCharLimit'] = maybeInt(DD_LANGCHAIN_SPAN_CHAR_LIMIT)
        target['langchain.spanPromptCompletionSampleRate'] = maybeFloat(DD_LANGCHAIN_SPAN_PROMPT_COMPLETION_SAMPLE_RATE)
        this.#setBoolean(target, 'legacyBaggageEnabled', DD_TRACE_LEGACY_BAGGAGE_ENABLED)
        this.#setBoolean(target, 'llmobs.agentlessEnabled', DD_LLMOBS_AGENTLESS_ENABLED)
        this.#setBoolean(target, 'llmobs.enabled', DD_LLMOBS_ENABLED)
        this.#setString(target, 'llmobs.mlApp', DD_LLMOBS_ML_APP)
        this.#setBoolean(target, 'logInjection', DD_LOGS_INJECTION)
        this.#setBoolean(target, 'memcachedCommandEnabled', DD_TRACE_MEMCACHED_COMMAND_ENABLED)
        this.#setBoolean(target, 'middlewareTracingEnabled', DD_TRACE_MIDDLEWARE_TRACING_ENABLED)
        this.#setBoolean(target, 'openAiLogsEnabled', DD_OPENAI_LOGS_ENABLED)
        target['openai.spanCharLimit'] = maybeInt(DD_OPENAI_SPAN_CHAR_LIMIT)
        unprocessedTarget.openaiSpanCharLimit = DD_OPENAI_SPAN_CHAR_LIMIT
        if (DD_TRACE_PEER_SERVICE_MAPPING) {
          target.peerServiceMapping = Object.fromEntries(
            DD_TRACE_PEER_SERVICE_MAPPING.split(',').map((x) => x.trim().split(':'))
          )
          unprocessedTarget.peerServiceMapping = DD_TRACE_PEER_SERVICE_MAPPING
        }
        this.#setString(target, 'port', DD_TRACE_AGENT_PORT)
        const profilingEnabled = normalizeProfilingEnabledValue(DD_PROFILING_ENABLED)
        this.#setString(target, 'profiling.enabled', profilingEnabled)
        this.#setString(target, 'profiling.exporters', DD_PROFILING_EXPORTERS)
        this.#setBoolean(target, 'profiling.sourceMap', DD_PROFILING_SOURCE_MAP && !isFalse(DD_PROFILING_SOURCE_MAP))
        if (DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD) {
          target['profiling.longLivedThreshold'] = Number(DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD)
        }
        this.#setString(target, 'protocolVersion', DD_TRACE_AGENT_PROTOCOL_VERSION)
        this.#setString(target, 'queryStringObfuscation', DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP)
        this.#setBoolean(target, 'remoteConfig.enabled', DD_REMOTE_CONFIGURATION_ENABLED)
        target['remoteConfig.pollInterval'] = maybeFloat(DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS)
        unprocessedTarget['remoteConfig.pollInterval'] = DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS
        this.#setBoolean(target, 'reportHostname', DD_TRACE_REPORT_HOSTNAME)
        if (DD_TRACE_RESOURCE_RENAMING_ENABLED !== void 0) {
          this.#setBoolean(target, 'resourceRenamingEnabled', DD_TRACE_RESOURCE_RENAMING_ENABLED)
        }
        const otelSetRuntimeMetrics = String(OTEL_METRICS_EXPORTER).toLowerCase() === 'none' ? false : void 0
        this.#setBoolean(target, 'runtimeMetrics.enabled', DD_RUNTIME_METRICS_ENABLED || otelSetRuntimeMetrics)
        this.#setBoolean(target, 'runtimeMetrics.eventLoop', DD_RUNTIME_METRICS_EVENT_LOOP_ENABLED)
        this.#setBoolean(target, 'runtimeMetrics.gc', DD_RUNTIME_METRICS_GC_ENABLED)
        this.#setBoolean(target, 'runtimeMetricsRuntimeId', DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED)
        this.#setArray(
          target,
          'sampler.spanSamplingRules',
          reformatSpanSamplingRules(maybeJsonFile(DD_SPAN_SAMPLING_RULES_FILE) ?? safeJsonParse(DD_SPAN_SAMPLING_RULES))
        )
        this.#setUnit(
          target,
          'sampleRate',
          DD_TRACE_SAMPLE_RATE || getFromOtelSamplerMap(OTEL_TRACES_SAMPLER, OTEL_TRACES_SAMPLER_ARG)
        )
        target['sampler.rateLimit'] = DD_TRACE_RATE_LIMIT
        this.#setSamplingRule(target, 'sampler.rules', safeJsonParse(DD_TRACE_SAMPLING_RULES))
        unprocessedTarget['sampler.rules'] = DD_TRACE_SAMPLING_RULES
        this.#setString(target, 'scope', DD_TRACE_SCOPE)
        this.#setString(target, 'service', DD_SERVICE || tags.service || OTEL_SERVICE_NAME)
        if (DD_SERVICE_MAPPING) {
          target.serviceMapping = Object.fromEntries(DD_SERVICE_MAPPING.split(',').map((x) => x.trim().split(':')))
        }
        this.#setString(target, 'site', DD_SITE)
        if (DD_TRACE_SPAN_ATTRIBUTE_SCHEMA) {
          this.#setString(target, 'spanAttributeSchema', validateNamingVersion(DD_TRACE_SPAN_ATTRIBUTE_SCHEMA))
          unprocessedTarget.spanAttributeSchema = DD_TRACE_SPAN_ATTRIBUTE_SCHEMA
        }
        target.spanLeakDebug = maybeInt(DD_TRACE_SPAN_LEAK_DEBUG)
        this.#setBoolean(target, 'spanRemoveIntegrationFromService', DD_TRACE_REMOVE_INTEGRATION_SERVICE_NAMES_ENABLED)
        this.#setBoolean(target, 'startupLogs', DD_TRACE_STARTUP_LOGS)
        this.#setTags(target, 'tags', tags)
        target.tagsHeaderMaxLength = DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH
        this.#setBoolean(target, 'telemetry.enabled', DD_INSTRUMENTATION_TELEMETRY_ENABLED)
        this.#setString(target, 'instrumentation_config_id', DD_INSTRUMENTATION_CONFIG_ID)
        this.#setBoolean(target, 'telemetry.debug', DD_TELEMETRY_DEBUG)
        this.#setBoolean(target, 'telemetry.dependencyCollection', DD_TELEMETRY_DEPENDENCY_COLLECTION_ENABLED)
        target['telemetry.heartbeatInterval'] = maybeInt(Math.floor(DD_TELEMETRY_HEARTBEAT_INTERVAL * 1e3))
        unprocessedTarget['telemetry.heartbeatInterval'] = DD_TELEMETRY_HEARTBEAT_INTERVAL * 1e3
        this.#setBoolean(target, 'telemetry.logCollection', DD_TELEMETRY_LOG_COLLECTION_ENABLED)
        this.#setBoolean(target, 'telemetry.metrics', DD_TELEMETRY_METRICS_ENABLED)
        this.#setBoolean(target, 'traceId128BitGenerationEnabled', DD_TRACE_128_BIT_TRACEID_GENERATION_ENABLED)
        this.#setBoolean(target, 'traceId128BitLoggingEnabled', DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED)
        warnIfPropagationStyleConflict(
          DD_TRACE_PROPAGATION_STYLE,
          DD_TRACE_PROPAGATION_STYLE_INJECT,
          DD_TRACE_PROPAGATION_STYLE_EXTRACT
        )
        if (DD_TRACE_PROPAGATION_STYLE !== void 0) {
          this.#setArray(target, 'tracePropagationStyle.inject', normalizePropagationStyle(DD_TRACE_PROPAGATION_STYLE))
          this.#setArray(target, 'tracePropagationStyle.extract', normalizePropagationStyle(DD_TRACE_PROPAGATION_STYLE))
        }
        if (DD_TRACE_PROPAGATION_STYLE_INJECT !== void 0) {
          this.#setArray(
            target,
            'tracePropagationStyle.inject',
            normalizePropagationStyle(DD_TRACE_PROPAGATION_STYLE_INJECT)
          )
        }
        if (DD_TRACE_PROPAGATION_STYLE_EXTRACT !== void 0) {
          this.#setArray(
            target,
            'tracePropagationStyle.extract',
            normalizePropagationStyle(DD_TRACE_PROPAGATION_STYLE_EXTRACT)
          )
        }
        this.#setBoolean(target, 'tracePropagationExtractFirst', DD_TRACE_PROPAGATION_EXTRACT_FIRST)
        if (DD_TRACE_PROPAGATION_BEHAVIOR_EXTRACT !== void 0) {
          const stringPropagationBehaviorExtract = String(DD_TRACE_PROPAGATION_BEHAVIOR_EXTRACT)
          target.tracePropagationBehaviorExtract = VALID_PROPAGATION_BEHAVIOR_EXTRACT.has(
            stringPropagationBehaviorExtract
          )
            ? stringPropagationBehaviorExtract
            : 'continue'
        }
        if (
          DD_TRACE_PROPAGATION_STYLE !== void 0 ||
          DD_TRACE_PROPAGATION_STYLE_INJECT !== void 0 ||
          DD_TRACE_PROPAGATION_STYLE_EXTRACT !== void 0 ||
          OTEL_PROPAGATORS !== void 0
        ) {
          const useDdStyle =
            DD_TRACE_PROPAGATION_STYLE || DD_TRACE_PROPAGATION_STYLE_INJECT || DD_TRACE_PROPAGATION_STYLE_EXTRACT
          this.#setBoolean(target, 'tracePropagationStyle.otelPropagators', useDdStyle ? false : !!OTEL_PROPAGATORS)
          if (!useDdStyle && OTEL_PROPAGATORS) {
            const otelStyles = normalizePropagationStyle(OTEL_PROPAGATORS)
            for (const style of otelStyles || []) {
              if (!VALID_PROPAGATION_STYLES.has(style)) {
                log.warn('unexpected value %s for OTEL_PROPAGATORS environment variable', style)
                getCounter('otel.env.invalid', 'DD_TRACE_PROPAGATION_STYLE', 'OTEL_PROPAGATORS').inc()
              }
            }
            if (otelStyles) {
              this.#setArray(target, 'tracePropagationStyle.inject', otelStyles)
              this.#setArray(target, 'tracePropagationStyle.extract', otelStyles)
            }
          }
        }
        this.#setBoolean(target, 'traceWebsocketMessagesEnabled', DD_TRACE_WEBSOCKET_MESSAGES_ENABLED)
        this.#setBoolean(target, 'traceWebsocketMessagesInheritSampling', DD_TRACE_WEBSOCKET_MESSAGES_INHERIT_SAMPLING)
        this.#setBoolean(target, 'traceWebsocketMessagesSeparateTraces', DD_TRACE_WEBSOCKET_MESSAGES_SEPARATE_TRACES)
        this.#setBoolean(target, 'tracing', DD_TRACING_ENABLED)
        this.#setString(target, 'version', DD_VERSION || tags.version)
        this.#setBoolean(target, 'inferredProxyServicesEnabled', DD_TRACE_INFERRED_PROXY_SERVICES_ENABLED)
        this.#setBoolean(target, 'trace.aws.addSpanPointers', DD_TRACE_AWS_ADD_SPAN_POINTERS)
        this.#setString(target, 'trace.dynamoDb.tablePrimaryKeys', DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS)
        this.#setArray(target, 'graphqlErrorExtensions', DD_TRACE_GRAPHQL_ERROR_EXTENSIONS)
        this.#setBoolean(target, 'trace.nativeSpanEvents', DD_TRACE_NATIVE_SPAN_EVENTS)
        target['vertexai.spanPromptCompletionSampleRate'] = maybeFloat(DD_VERTEXAI_SPAN_PROMPT_COMPLETION_SAMPLE_RATE)
        target['vertexai.spanCharLimit'] = maybeInt(DD_VERTEXAI_SPAN_CHAR_LIMIT)
      }
      #applyOptions(options) {
        const opts = this.#options
        const tags = {}
        options = this.#optionsArg = { ingestion: {}, ...options, ...opts }
        tagger.add(tags, options.tags)
        this.#setBoolean(
          opts,
          'apmTracingEnabled',
          options.apmTracingEnabled ??
            (options.experimental?.appsec?.standalone && !options.experimental.appsec.standalone.enabled)
        )
        this.#setBoolean(opts, 'appsec.apiSecurity.enabled', options.appsec?.apiSecurity?.enabled)
        this.#setBoolean(
          opts,
          'appsec.apiSecurity.endpointCollectionEnabled',
          options.appsec?.apiSecurity?.endpointCollectionEnabled
        )
        opts['appsec.apiSecurity.endpointCollectionMessageLimit'] = maybeInt(
          options.appsec?.apiSecurity?.endpointCollectionMessageLimit
        )
        opts['appsec.blockedTemplateGraphql'] = maybeFile(options.appsec?.blockedTemplateGraphql)
        opts['appsec.blockedTemplateHtml'] = maybeFile(options.appsec?.blockedTemplateHtml)
        this.#optsUnprocessed['appsec.blockedTemplateHtml'] = options.appsec?.blockedTemplateHtml
        opts['appsec.blockedTemplateJson'] = maybeFile(options.appsec?.blockedTemplateJson)
        this.#optsUnprocessed['appsec.blockedTemplateJson'] = options.appsec?.blockedTemplateJson
        this.#setBoolean(opts, 'appsec.enabled', options.appsec?.enabled)
        this.#setString(opts, 'appsec.eventTracking.mode', options.appsec?.eventTracking?.mode)
        this.#setBoolean(
          opts,
          'appsec.extendedHeadersCollection.enabled',
          options.appsec?.extendedHeadersCollection?.enabled
        )
        this.#setBoolean(
          opts,
          'appsec.extendedHeadersCollection.redaction',
          options.appsec?.extendedHeadersCollection?.redaction
        )
        opts['appsec.extendedHeadersCollection.maxHeaders'] = options.appsec?.extendedHeadersCollection?.maxHeaders
        this.#setString(opts, 'appsec.obfuscatorKeyRegex', options.appsec?.obfuscatorKeyRegex)
        this.#setString(opts, 'appsec.obfuscatorValueRegex', options.appsec?.obfuscatorValueRegex)
        this.#setBoolean(opts, 'appsec.rasp.enabled', options.appsec?.rasp?.enabled)
        this.#setBoolean(opts, 'appsec.rasp.bodyCollection', options.appsec?.rasp?.bodyCollection)
        opts['appsec.rateLimit'] = maybeInt(options.appsec?.rateLimit)
        this.#optsUnprocessed['appsec.rateLimit'] = options.appsec?.rateLimit
        this.#setString(opts, 'appsec.rules', options.appsec?.rules)
        this.#setBoolean(opts, 'appsec.stackTrace.enabled', options.appsec?.stackTrace?.enabled)
        opts['appsec.stackTrace.maxDepth'] = maybeInt(options.appsec?.stackTrace?.maxDepth)
        this.#optsUnprocessed['appsec.stackTrace.maxDepth'] = options.appsec?.stackTrace?.maxDepth
        opts['appsec.stackTrace.maxStackTraces'] = maybeInt(options.appsec?.stackTrace?.maxStackTraces)
        this.#optsUnprocessed['appsec.stackTrace.maxStackTraces'] = options.appsec?.stackTrace?.maxStackTraces
        opts['appsec.wafTimeout'] = maybeInt(options.appsec?.wafTimeout)
        this.#optsUnprocessed['appsec.wafTimeout'] = options.appsec?.wafTimeout
        this.#setBoolean(opts, 'clientIpEnabled', options.clientIpEnabled)
        this.#setString(opts, 'clientIpHeader', options.clientIpHeader?.toLowerCase())
        if (options.cloudPayloadTagging?.request || options.cloudPayloadTagging?.response) {
          if (options.cloudPayloadTagging.request) {
            this.#setBoolean(opts, 'cloudPayloadTagging.requestsEnabled', true)
          }
          if (options.cloudPayloadTagging.response) {
            this.#setBoolean(opts, 'cloudPayloadTagging.responsesEnabled', true)
          }
          opts['cloudPayloadTagging.rules'] = appendRules(
            splitJSONPathRules(options.cloudPayloadTagging.request),
            splitJSONPathRules(options.cloudPayloadTagging.response)
          )
        }
        if (options.cloudPayloadTagging?.requestsEnabled !== void 0) {
          this.#setBoolean(opts, 'cloudPayloadTagging.requestsEnabled', options.cloudPayloadTagging.requestsEnabled)
        }
        if (options.cloudPayloadTagging?.responsesEnabled !== void 0) {
          this.#setBoolean(opts, 'cloudPayloadTagging.responsesEnabled', options.cloudPayloadTagging.responsesEnabled)
        }
        opts['cloudPayloadTagging.maxDepth'] = maybeInt(options.cloudPayloadTagging?.maxDepth)
        opts.baggageMaxBytes = options.baggageMaxBytes
        opts.baggageMaxItems = options.baggageMaxItems
        opts.baggageTagKeys = options.baggageTagKeys
        this.#setBoolean(opts, 'codeOriginForSpans.enabled', options.codeOriginForSpans?.enabled)
        this.#setBoolean(
          opts,
          'codeOriginForSpans.experimental.exit_spans.enabled',
          options.codeOriginForSpans?.experimental?.exit_spans?.enabled
        )
        this.#setString(opts, 'dbmPropagationMode', options.dbmPropagationMode)
        if (options.dogstatsd) {
          this.#setString(opts, 'dogstatsd.hostname', options.dogstatsd.hostname)
          this.#setString(opts, 'dogstatsd.port', options.dogstatsd.port)
        }
        this.#setBoolean(opts, 'dsmEnabled', options.dsmEnabled)
        opts['dynamicInstrumentation.captureTimeoutMs'] = maybeInt(options.dynamicInstrumentation?.captureTimeoutMs)
        this.#optsUnprocessed['dynamicInstrumentation.captureTimeoutMs'] =
          options.dynamicInstrumentation?.captureTimeoutMs
        this.#setBoolean(opts, 'dynamicInstrumentation.enabled', options.dynamicInstrumentation?.enabled)
        this.#setString(opts, 'dynamicInstrumentation.probeFile', options.dynamicInstrumentation?.probeFile)
        this.#setArray(
          opts,
          'dynamicInstrumentation.redactedIdentifiers',
          options.dynamicInstrumentation?.redactedIdentifiers
        )
        this.#setArray(
          opts,
          'dynamicInstrumentation.redactionExcludedIdentifiers',
          options.dynamicInstrumentation?.redactionExcludedIdentifiers
        )
        opts['dynamicInstrumentation.uploadIntervalSeconds'] = maybeFloat(
          options.dynamicInstrumentation?.uploadIntervalSeconds
        )
        this.#optsUnprocessed['dynamicInstrumentation.uploadIntervalSeconds'] =
          options.dynamicInstrumentation?.uploadIntervalSeconds
        this.#setString(opts, 'env', options.env || tags.env)
        this.#setBoolean(opts, 'experimental.aiguard.enabled', options.experimental?.aiguard?.enabled)
        this.#setString(opts, 'experimental.aiguard.endpoint', options.experimental?.aiguard?.endpoint)
        opts['experimental.aiguard.maxMessagesLength'] = maybeInt(options.experimental?.aiguard?.maxMessagesLength)
        this.#optsUnprocessed['experimental.aiguard.maxMessagesLength'] =
          options.experimental?.aiguard?.maxMessagesLength
        opts['experimental.aiguard.maxContentSize'] = maybeInt(options.experimental?.aiguard?.maxContentSize)
        this.#optsUnprocessed['experimental.aiguard.maxContentSize'] = options.experimental?.aiguard?.maxContentSize
        opts['experimental.aiguard.timeout'] = maybeInt(options.experimental?.aiguard?.timeout)
        this.#optsUnprocessed['experimental.aiguard.timeout'] = options.experimental?.aiguard?.timeout
        this.#setBoolean(opts, 'experimental.enableGetRumData', options.experimental?.enableGetRumData)
        this.#setString(opts, 'experimental.exporter', options.experimental?.exporter)
        this.#setBoolean(opts, 'experimental.flaggingProvider.enabled', options.experimental?.flaggingProvider?.enabled)
        opts.flushInterval = maybeInt(options.flushInterval)
        this.#optsUnprocessed.flushInterval = options.flushInterval
        opts.flushMinSpans = maybeInt(options.flushMinSpans)
        this.#optsUnprocessed.flushMinSpans = options.flushMinSpans
        this.#setArray(opts, 'headerTags', options.headerTags)
        this.#setString(opts, 'hostname', options.hostname)
        opts['iast.dbRowsToTaint'] = maybeInt(options.iast?.dbRowsToTaint)
        this.#setBoolean(opts, 'iast.deduplicationEnabled', options.iast && options.iast.deduplicationEnabled)
        this.#setBoolean(opts, 'iast.enabled', options.iast && (options.iast === true || options.iast.enabled === true))
        opts['iast.maxConcurrentRequests'] = maybeInt(options.iast?.maxConcurrentRequests)
        this.#optsUnprocessed['iast.maxConcurrentRequests'] = options.iast?.maxConcurrentRequests
        opts['iast.maxContextOperations'] = maybeInt(options.iast?.maxContextOperations)
        this.#optsUnprocessed['iast.maxContextOperations'] = options.iast?.maxContextOperations
        this.#setBoolean(opts, 'iast.redactionEnabled', options.iast?.redactionEnabled)
        this.#setString(opts, 'iast.redactionNamePattern', options.iast?.redactionNamePattern)
        this.#setString(opts, 'iast.redactionValuePattern', options.iast?.redactionValuePattern)
        const iastRequestSampling = maybeInt(options.iast?.requestSampling)
        if (iastRequestSampling !== void 0 && iastRequestSampling > -1 && iastRequestSampling < 101) {
          opts['iast.requestSampling'] = iastRequestSampling
          this.#optsUnprocessed['iast.requestSampling'] = options.iast?.requestSampling
        }
        if (DD_MAJOR < 6) {
          opts['iast.securityControlsConfiguration'] = options.iast?.securityControlsConfiguration
        }
        this.#setBoolean(opts, 'iast.stackTrace.enabled', options.iast?.stackTrace?.enabled)
        this.#setString(opts, 'iast.telemetryVerbosity', options.iast && options.iast.telemetryVerbosity)
        this.#setBoolean(opts, 'isCiVisibility', options.isCiVisibility)
        this.#setBoolean(opts, 'legacyBaggageEnabled', options.legacyBaggageEnabled)
        this.#setBoolean(opts, 'llmobs.agentlessEnabled', options.llmobs?.agentlessEnabled)
        this.#setString(opts, 'llmobs.mlApp', options.llmobs?.mlApp)
        this.#setBoolean(opts, 'logInjection', options.logInjection)
        opts.lookup = options.lookup
        this.#setBoolean(opts, 'middlewareTracingEnabled', options.middlewareTracingEnabled)
        this.#setBoolean(opts, 'openAiLogsEnabled', options.openAiLogsEnabled)
        opts.peerServiceMapping = options.peerServiceMapping
        this.#setBoolean(opts, 'plugins', options.plugins)
        this.#setString(opts, 'port', options.port)
        const strProfiling = String(options.profiling)
        if (['true', 'false', 'auto'].includes(strProfiling)) {
          this.#setString(opts, 'profiling.enabled', strProfiling)
        }
        this.#setString(opts, 'protocolVersion', options.protocolVersion)
        if (options.remoteConfig) {
          opts['remoteConfig.pollInterval'] = maybeFloat(options.remoteConfig.pollInterval)
          this.#optsUnprocessed['remoteConfig.pollInterval'] = options.remoteConfig.pollInterval
        }
        this.#setBoolean(opts, 'reportHostname', options.reportHostname)
        this.#setBoolean(opts, 'runtimeMetrics.enabled', options.runtimeMetrics?.enabled)
        this.#setBoolean(opts, 'runtimeMetrics.eventLoop', options.runtimeMetrics?.eventLoop)
        this.#setBoolean(opts, 'runtimeMetrics.gc', options.runtimeMetrics?.gc)
        this.#setBoolean(opts, 'runtimeMetricsRuntimeId', options.runtimeMetricsRuntimeId)
        this.#setArray(opts, 'sampler.spanSamplingRules', reformatSpanSamplingRules(options.spanSamplingRules))
        this.#setUnit(opts, 'sampleRate', options.sampleRate ?? options.ingestion.sampleRate)
        opts['sampler.rateLimit'] = maybeInt(options.rateLimit ?? options.ingestion.rateLimit)
        this.#setSamplingRule(opts, 'sampler.rules', options.samplingRules)
        this.#setString(opts, 'service', options.service || tags.service)
        opts.serviceMapping = options.serviceMapping
        this.#setString(opts, 'site', options.site)
        if (options.spanAttributeSchema) {
          this.#setString(opts, 'spanAttributeSchema', validateNamingVersion(options.spanAttributeSchema))
          this.#optsUnprocessed.spanAttributeSchema = options.spanAttributeSchema
        }
        this.#setBoolean(opts, 'spanRemoveIntegrationFromService', options.spanRemoveIntegrationFromService)
        this.#setBoolean(opts, 'startupLogs', options.startupLogs)
        this.#setTags(opts, 'tags', tags)
        this.#setBoolean(opts, 'traceId128BitGenerationEnabled', options.traceId128BitGenerationEnabled)
        this.#setBoolean(opts, 'traceId128BitLoggingEnabled', options.traceId128BitLoggingEnabled)
        this.#setBoolean(opts, 'traceWebsocketMessagesEnabled', options.traceWebsocketMessagesEnabled)
        this.#setBoolean(opts, 'traceWebsocketMessagesInheritSampling', options.traceWebsocketMessagesInheritSampling)
        this.#setBoolean(opts, 'traceWebsocketMessagesSeparateTraces', options.traceWebsocketMessagesSeparateTraces)
        this.#setString(opts, 'version', options.version || tags.version)
        this.#setBoolean(opts, 'inferredProxyServicesEnabled', options.inferredProxyServicesEnabled)
        this.#setBoolean(opts, 'graphqlErrorExtensions', options.graphqlErrorExtensions)
        this.#setBoolean(opts, 'trace.nativeSpanEvents', options.trace?.nativeSpanEvents)
        if (options.tracePropagationStyle) {
          this.#setArray(
            opts,
            'tracePropagationStyle.inject',
            normalizePropagationStyle(options.tracePropagationStyle.inject ?? options.tracePropagationStyle)
          )
          this.#setArray(
            opts,
            'tracePropagationStyle.extract',
            normalizePropagationStyle(options.tracePropagationStyle.extract ?? options.tracePropagationStyle)
          )
        }
        const llmobsEnabledEnv = this.#env['llmobs.enabled']
        if (llmobsEnabledEnv == null && options.llmobs) {
          this.#setBoolean(opts, 'llmobs.enabled', !!options.llmobs)
        }
      }
      #isCiVisibility() {
        return this.#optionsArg.isCiVisibility ?? this.#defaults.isCiVisibility
      }
      #isCiVisibilityItrEnabled() {
        return getEnv('DD_CIVISIBILITY_ITR_ENABLED') ?? true
      }
      #getHostname() {
        const DD_CIVISIBILITY_AGENTLESS_URL = getEnv('DD_CIVISIBILITY_AGENTLESS_URL')
        const url = DD_CIVISIBILITY_AGENTLESS_URL
          ? new URL2(DD_CIVISIBILITY_AGENTLESS_URL)
          : getAgentUrl(this._getTraceAgentUrl(), this.#optionsArg)
        const DD_AGENT_HOST = this.#optionsArg.hostname ?? getEnv('DD_AGENT_HOST') ?? defaults.hostname
        return DD_AGENT_HOST || url?.hostname
      }
      #getSpanComputePeerService() {
        const DD_TRACE_SPAN_ATTRIBUTE_SCHEMA = validateNamingVersion(
          this.#optionsArg.spanAttributeSchema ?? getEnv('DD_TRACE_SPAN_ATTRIBUTE_SCHEMA')
        )
        const peerServiceSet =
          this.#optionsArg.hasOwnProperty('spanComputePeerService') ||
          getEnv('DD_TRACE_PEER_SERVICE_DEFAULTS_ENABLED') !== void 0
        const peerServiceValue =
          this.#optionsArg.spanComputePeerService ?? getEnv('DD_TRACE_PEER_SERVICE_DEFAULTS_ENABLED')
        const spanComputePeerService =
          DD_TRACE_SPAN_ATTRIBUTE_SCHEMA === 'v0'
            ? peerServiceSet && isTrue(peerServiceValue)
            : peerServiceSet
              ? !isFalse(peerServiceValue)
              : true
        return spanComputePeerService
      }
      #isTraceStatsComputationEnabled() {
        const apmTracingEnabled = this.#options.apmTracingEnabled !== false && this.#env.apmTracingEnabled !== false
        return (
          apmTracingEnabled &&
          (this.#optionsArg.stats ??
            getEnv('DD_TRACE_STATS_COMPUTATION_ENABLED') ??
            (getIsGCPFunction() || getIsAzureFunction()))
        )
      }
      _getTraceAgentUrl() {
        return this.#optionsArg.url ?? getEnv('DD_TRACE_AGENT_URL') ?? null
      }
      // handles values calculated from a mixture of options and env vars
      #applyCalculated() {
        const calc = this.#calculated
        const DD_CIVISIBILITY_AGENTLESS_URL = getEnv('DD_CIVISIBILITY_AGENTLESS_URL')
        calc.url = DD_CIVISIBILITY_AGENTLESS_URL
          ? new URL2(DD_CIVISIBILITY_AGENTLESS_URL)
          : getAgentUrl(this._getTraceAgentUrl(), this.#optionsArg)
        if (this.#isCiVisibility()) {
          this.#setBoolean(
            calc,
            'isEarlyFlakeDetectionEnabled',
            getEnv('DD_CIVISIBILITY_EARLY_FLAKE_DETECTION_ENABLED') ?? true
          )
          this.#setBoolean(calc, 'isFlakyTestRetriesEnabled', getEnv('DD_CIVISIBILITY_FLAKY_RETRY_ENABLED') ?? true)
          calc.flakyTestRetriesCount = maybeInt(getEnv('DD_CIVISIBILITY_FLAKY_RETRY_COUNT')) ?? 5
          this.#setBoolean(calc, 'isIntelligentTestRunnerEnabled', isTrue(this.#isCiVisibilityItrEnabled()))
          this.#setBoolean(calc, 'isManualApiEnabled', !isFalse(getEnv('DD_CIVISIBILITY_MANUAL_API_ENABLED')))
          this.#setString(calc, 'ciVisibilityTestSessionName', getEnv('DD_TEST_SESSION_NAME'))
          this.#setBoolean(
            calc,
            'ciVisAgentlessLogSubmissionEnabled',
            isTrue(getEnv('DD_AGENTLESS_LOG_SUBMISSION_ENABLED'))
          )
          this.#setBoolean(
            calc,
            'isTestDynamicInstrumentationEnabled',
            !isFalse(getEnv('DD_TEST_FAILED_TEST_REPLAY_ENABLED'))
          )
          this.#setBoolean(calc, 'isServiceUserProvided', !!this.#env.service)
          this.#setBoolean(calc, 'isTestManagementEnabled', !isFalse(getEnv('DD_TEST_MANAGEMENT_ENABLED')))
          calc.testManagementAttemptToFixRetries = maybeInt(getEnv('DD_TEST_MANAGEMENT_ATTEMPT_TO_FIX_RETRIES')) ?? 20
          this.#setBoolean(
            calc,
            'isImpactedTestsEnabled',
            !isFalse(getEnv('DD_CIVISIBILITY_IMPACTED_TESTS_DETECTION_ENABLED'))
          )
        }
        if (this.#env.otelLogsEnabled) {
          this.#setBoolean(calc, 'logInjection', false)
        }
        calc['dogstatsd.hostname'] = this.#getHostname()
        const agentHostname = this.#getHostname()
        calc.otelLogsUrl = `http://${agentHostname}:${DEFAULT_OTLP_PORT}`
        calc.otelMetricsUrl = `http://${agentHostname}:${DEFAULT_OTLP_PORT}/v1/metrics`
        calc.otelUrl = `http://${agentHostname}:${DEFAULT_OTLP_PORT}`
        this.#setBoolean(
          calc,
          'isGitUploadEnabled',
          calc.isIntelligentTestRunnerEnabled && !isFalse(getEnv('DD_CIVISIBILITY_GIT_UPLOAD_ENABLED'))
        )
        if (this.#env.resourceRenamingEnabled === void 0) {
          const appsecEnabled = this.#options['appsec.enabled'] ?? this.#env['appsec.enabled']
          if (appsecEnabled) {
            this.#setBoolean(calc, 'resourceRenamingEnabled', true)
          }
        }
        this.#setBoolean(calc, 'spanComputePeerService', this.#getSpanComputePeerService())
        this.#setBoolean(calc, 'stats.enabled', this.#isTraceStatsComputationEnabled())
        const defaultPropagationStyle = this.#getDefaultPropagationStyle(this.#optionsArg)
        if (defaultPropagationStyle.length > 2) {
          calc['tracePropagationStyle.inject'] = defaultPropagationStyle
          calc['tracePropagationStyle.extract'] = defaultPropagationStyle
        }
      }
      #applyRemote(options) {
        const opts = this.#remote
        const tags = {}
        const headerTags = options.tracing_header_tags
          ? options.tracing_header_tags.map((tag) => {
              return tag.tag_name ? `${tag.header}:${tag.tag_name}` : tag.header
            })
          : void 0
        tagger.add(tags, options.tracing_tags)
        if (Object.keys(tags).length) tags['runtime-id'] = runtimeId
        this.#setUnit(opts, 'sampleRate', options.tracing_sampling_rate)
        this.#setBoolean(opts, 'logInjection', options.log_injection_enabled)
        opts.headerTags = headerTags
        this.#setTags(opts, 'tags', tags)
        this.#setBoolean(opts, 'tracing', options.tracing_enabled)
        this.#remoteUnprocessed['sampler.rules'] = options.tracing_sampling_rules
        this.#setSamplingRule(opts, 'sampler.rules', this.#reformatTags(options.tracing_sampling_rules))
      }
      #reformatTags(samplingRules) {
        for (const rule of samplingRules || []) {
          const reformattedTags = {}
          if (rule.tags) {
            for (const tag of rule.tags) {
              reformattedTags[tag.key] = tag.value_glob
            }
            rule.tags = reformattedTags
          }
        }
        return samplingRules
      }
      #setBoolean(obj, name, value) {
        if (value === void 0 || value === null) {
          obj[name] = value
        } else if (isTrue(value)) {
          obj[name] = true
        } else if (isFalse(value)) {
          obj[name] = false
        }
      }
      #setUnit(obj, name, value) {
        if (value === null || value === void 0) {
          obj[name] = value
          return
        }
        value = Number.parseFloat(value)
        if (!Number.isNaN(value)) {
          obj[name] = Math.min(Math.max(value, 0), 1)
        }
      }
      #setArray(obj, name, value) {
        if (value == null) {
          obj[name] = null
          return
        }
        if (typeof value === 'string') {
          value = value.split(',').map((item) => {
            const [key, val] = item.split(':').map((part) => part.trim())
            return val === void 0 ? key : `${key}:${val}`
          })
        }
        if (Array.isArray(value)) {
          obj[name] = value
        }
      }
      #setIntegerRangeSet(obj, name, value) {
        if (value == null) {
          obj[name] = null
          return
        }
        value = value.split(',')
        const result = []
        value.forEach((val) => {
          if (val.includes('-')) {
            const [start, end] = val.split('-').map(Number)
            for (let i = start; i <= end; i++) {
              result.push(i)
            }
          } else {
            result.push(Number(val))
          }
        })
        obj[name] = result
      }
      #setSamplingRule(obj, name, value) {
        if (value == null) {
          obj[name] = null
          return
        }
        if (typeof value === 'string') {
          value = value.split(',')
        }
        if (Array.isArray(value)) {
          value = value.map((rule) => {
            return remapify(rule, {
              sample_rate: 'sampleRate',
            })
          })
          obj[name] = value
        }
      }
      #setString(obj, name, value) {
        obj[name] = value ? String(value) : void 0
      }
      #setTags(obj, name, value) {
        if (!value || Object.keys(value).length === 0) {
          obj[name] = null
          return
        }
        obj[name] = value
      }
      #setAndTrackChange({ name, value, origin, unprocessedValue, changes }) {
        set(this, name, value)
        if (!changeTracker[name]) {
          changeTracker[name] = {}
        }
        const originExists = origin in changeTracker[name]
        const oldValue = changeTracker[name][origin]
        if (!originExists || oldValue !== value) {
          changeTracker[name][origin] = value
          changes.push({
            name,
            value: unprocessedValue || value,
            origin,
          })
        }
      }
      // TODO: Report origin changes and errors to telemetry.
      // TODO: Deeply merge configurations.
      // TODO: Move change tracking to telemetry.
      // for telemetry reporting, `name`s in `containers` need to be keys from:
      // https://github.com/DataDog/dd-go/blob/prod/trace/apps/tracer-telemetry-intake/telemetry-payload/static/config_norm_rules.json
      #merge() {
        const changes = []
        const sources = this.#getSourcesInOrder()
        for (const name of Object.keys(this.#defaults)) {
          for (let i = sources.length - 1; i >= 0; i--) {
            const { container, origin, unprocessed } = sources[i]
            const value = container[name]
            if (value != null || container === this.#defaults) {
              this.#setAndTrackChange({
                name,
                value,
                origin,
                unprocessedValue: unprocessed?.[name],
                changes,
              })
            }
          }
        }
        this.sampler.sampleRate = this.sampleRate
        updateConfig(changes, this)
      }
      getOrigin(name) {
        for (const { container, origin } of this.#getSourcesInOrder()) {
          const value = container[name]
          if (value != null || container === this.#defaults) {
            return origin
          }
        }
      }
      #loadGitMetadata(envs) {
        this.repositoryUrl = removeUserSensitiveInfo(envs.DD_GIT_REPOSITORY_URL ?? this.tags[GIT_REPOSITORY_URL])
        this.commitSHA = envs.DD_GIT_COMMIT_SHA ?? this.tags[GIT_COMMIT_SHA]
        if (!this.repositoryUrl || !this.commitSHA) {
          const DD_GIT_PROPERTIES_FILE = envs.DD_GIT_PROPERTIES_FILE ?? `${process.cwd()}/git.properties`
          let gitPropertiesString
          try {
            gitPropertiesString = fs.readFileSync(DD_GIT_PROPERTIES_FILE, 'utf8')
          } catch (e) {
            if (envs.DD_GIT_PROPERTIES_FILE) {
              log.error('Error reading DD_GIT_PROPERTIES_FILE: %s', DD_GIT_PROPERTIES_FILE, e)
            }
          }
          if (gitPropertiesString) {
            const { commitSHA, repositoryUrl } = getGitMetadataFromGitProperties(gitPropertiesString)
            this.commitSHA = this.commitSHA || commitSHA
            this.repositoryUrl = this.repositoryUrl || repositoryUrl
          }
        }
        if (!this.repositoryUrl || !this.commitSHA) {
          const DD_GIT_FOLDER_PATH = envs.DD_GIT_FOLDER_PATH ?? path.join(process.cwd(), '.git')
          if (!this.repositoryUrl) {
            const gitConfigPath = path.join(DD_GIT_FOLDER_PATH, 'config')
            try {
              const gitConfigContent = fs.readFileSync(gitConfigPath, 'utf8')
              if (gitConfigContent) {
                this.repositoryUrl = getRemoteOriginURL(gitConfigContent)
              }
            } catch (e) {
              if (envs.DD_GIT_FOLDER_PATH) {
                log.error('Error reading git config: %s', gitConfigPath, e)
              }
            }
          }
          if (!this.commitSHA) {
            const gitHeadSha = resolveGitHeadSHA(DD_GIT_FOLDER_PATH)
            if (gitHeadSha) {
              this.commitSHA = gitHeadSha
            }
          }
        }
      }
    }
    function handleOtel(tagString) {
      return tagString
        ?.replace(/(^|,)deployment\.environment=/, '$1env:')
        .replace(/(^|,)service\.name=/, '$1service:')
        .replace(/(^|,)service\.version=/, '$1version:')
        .replaceAll('=', ':')
    }
    function parseSpaceSeparatedTags(tagString) {
      if (tagString && !tagString.includes(',')) {
        tagString = tagString.replaceAll(/\s+/g, ',')
      }
      return tagString
    }
    function maybeInt(number) {
      const parsed = Number.parseInt(number)
      return Number.isNaN(parsed) ? void 0 : parsed
    }
    function maybeFloat(number) {
      const parsed = Number.parseFloat(number)
      return Number.isNaN(parsed) ? void 0 : parsed
    }
    function nonNegInt(value, envVarName, allowZero = true) {
      if (value === void 0) return
      const parsed = Number.parseInt(value)
      if (Number.isNaN(parsed) || parsed < 0 || (parsed === 0 && !allowZero)) {
        log.warn(`Invalid value ${parsed} for ${envVarName}. Using default value.`)
        return
      }
      return parsed
    }
    function getAgentUrl(url, options) {
      if (url) return new URL2(url)
      if (os.type() === 'Windows_NT') return
      if (
        !options.hostname &&
        !options.port &&
        !getEnv('DD_AGENT_HOST') &&
        !getEnv('DD_TRACE_AGENT_PORT') &&
        fs.existsSync('/var/run/datadog/apm.socket')
      ) {
        return new URL2('unix:///var/run/datadog/apm.socket')
      }
    }
    var configInstance = null
    function getConfig(options) {
      if (!configInstance) {
        configInstance = new Config(options)
      }
      return configInstance
    }
    module2.exports = getConfig
  },
})

// node_modules/dd-trace/packages/dd-trace/src/debugger/config.js
var require_config3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/debugger/config.js'(exports2, module2) {
    'use strict'
    module2.exports = function getDebuggerConfig(config) {
      return {
        commitSHA: config.commitSHA,
        debug: config.debug,
        dynamicInstrumentation: config.dynamicInstrumentation,
        hostname: config.hostname,
        logLevel: config.logLevel,
        port: config.port,
        repositoryUrl: config.repositoryUrl,
        runtimeId: config.tags['runtime-id'],
        service: config.service,
        url: config.url?.toString(),
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/debugger/index.js
var require_debugger = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/debugger/index.js'(exports2, module2) {
    'use strict'
    var { readFile } = require('fs')
    var { types } = require('util')
    var { join } = require('path')
    var { Worker, MessageChannel: MessageChannel2, threadId: parentThreadId } = require('worker_threads')
    var getDebuggerConfig = require_config3()
    var log = require_log2()
    var worker = null
    var configChannel = null
    var ackId = 0
    var { NODE_OPTIONS, ...env } = process.env
    module2.exports = {
      start,
      configure,
    }
    function start(config, rc) {
      if (worker !== null) return
      log.debug('[debugger] Starting Dynamic Instrumentation client...')
      const rcAckCallbacks = /* @__PURE__ */ new Map()
      const probeChannel = new MessageChannel2()
      const logChannel = new MessageChannel2()
      configChannel = new MessageChannel2()
      process[/* @__PURE__ */ Symbol.for('datadog:node:util:types')] = types
      readProbeFile(config.dynamicInstrumentation.probeFile, (probes) => {
        const action = 'apply'
        for (const probe of probes) {
          probeChannel.port2.postMessage({ action, probe })
        }
      })
      rc.setProductHandler('LIVE_DEBUGGING', (action, probe, id, ack) => {
        rcAckCallbacks.set(++ackId, ack)
        probeChannel.port2.postMessage({ action, probe, ackId })
      })
      probeChannel.port2.on('message', ({ ackId: ackId2, error }) => {
        const ack = rcAckCallbacks.get(ackId2)
        if (ack === void 0) {
          log.error('[debugger] Received an unknown ackId: %s', ackId2)
          if (error) log.error('[debugger] Error starting Dynamic Instrumentation client', error)
          return
        }
        ack(error)
        rcAckCallbacks.delete(ackId2)
      })
      probeChannel.port2.on('messageerror', (err) => log.error('[debugger] received "messageerror" on probe port', err))
      logChannel.port2.on('message', ({ level, args }) => {
        log[level](...args)
      })
      logChannel.port2.on('messageerror', (err) => log.error('[debugger] received "messageerror" on log port', err))
      worker = new Worker(join(__dirname, 'devtools_client', 'index.js'), {
        execArgv: [],
        // Avoid worker thread inheriting the `-r` command line argument
        env,
        // Avoid worker thread inheriting the `NODE_OPTIONS` environment variable (in case it contains `-r`)
        workerData: {
          config: getDebuggerConfig(config),
          parentThreadId,
          probePort: probeChannel.port1,
          logPort: logChannel.port1,
          configPort: configChannel.port1,
        },
        transferList: [probeChannel.port1, logChannel.port1, configChannel.port1],
      })
      worker.on('online', () => {
        log.debug(
          '[debugger] Dynamic Instrumentation worker thread started successfully (thread id: %d)',
          worker.threadId
        )
      })
      worker.on('error', (err) => log.error('[debugger] worker thread error', err))
      worker.on('messageerror', (err) => log.error('[debugger] received "messageerror" from worker', err))
      worker.on('exit', (code) => {
        const error = new Error(`Dynamic Instrumentation worker thread exited unexpectedly with code ${code}`)
        log.error('[debugger] worker thread exited unexpectedly', error)
        rc.removeProductHandler('LIVE_DEBUGGING')
        worker.removeAllListeners()
        configChannel = null
        for (const ackId2 of rcAckCallbacks.keys()) {
          rcAckCallbacks.get(ackId2)(error)
          rcAckCallbacks.delete(ackId2)
        }
      })
      worker.unref()
      probeChannel.port1.unref()
      probeChannel.port2.unref()
      logChannel.port1.unref()
      logChannel.port2.unref()
      configChannel.port1.unref()
      configChannel.port2.unref()
    }
    function configure(config) {
      if (configChannel === null) return
      configChannel.port2.postMessage(getDebuggerConfig(config))
    }
    function readProbeFile(path, cb) {
      if (!path) return
      log.debug('[debugger] Reading probe file: %s', path)
      readFile(path, 'utf8', (err, data) => {
        if (err) {
          log.error('[debugger] Failed to read probe file: %s', path, err)
          return
        }
        try {
          const parsedData = JSON.parse(data)
          log.debug('[debugger] Successfully parsed probe file: %s', path)
          cb(parsedData)
        } catch (err2) {
          log.error('[debugger] Probe file (%s) is not valid JSON', path, err2)
        }
      })
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/definition.js
var require_definition = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/definition.js'(exports2, module2) {
    'use strict'
    var SchemaDefinition = class {
      constructor(schema) {
        this.schema = schema
      }
      getOpName(type, kind, plugin, opts) {
        const item = this.schema[type][kind][plugin]
        return item.opName(opts)
      }
      getServiceName(type, kind, plugin, opts) {
        const item = this.schema[type][kind][plugin]
        return item.serviceName(opts)
      }
    }
    module2.exports = SchemaDefinition
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/util.js
var require_util4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/util.js'(exports2, module2) {
    'use strict'
    function identityService({ tracerService }) {
      return tracerService
    }
    function getFormattedHostString({ host, port }) {
      return [host, port].filter(Boolean).join(':')
    }
    function httpPluginClientService({ tracerService, pluginConfig, sessionDetails }) {
      if (pluginConfig.splitByDomain) {
        return getFormattedHostString(sessionDetails)
      } else if (pluginConfig.service) {
        return pluginConfig.service
      }
      return tracerService
    }
    function awsServiceV0({ tracerService, awsService }) {
      return `${tracerService}-aws-${awsService}`
    }
    module2.exports = { identityService, httpPluginClientService, awsServiceV0 }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/messaging.js
var require_messaging = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/messaging.js'(exports2, module2) {
    'use strict'
    var { identityService, awsServiceV0 } = require_util4()
    function amqpServiceName({ tracerService }) {
      return `${tracerService}-amqp`
    }
    var messaging = {
      producer: {
        amqplib: {
          opName: () => 'amqp.command',
          serviceName: amqpServiceName,
        },
        amqp10: {
          opName: () => 'amqp.send',
          serviceName: amqpServiceName,
        },
        'azure-event-hubs': {
          opName: () => 'azure.eventhubs.send',
          serviceName: ({ tracerService }) => `${tracerService}-azure-event-hubs`,
        },
        'azure-service-bus': {
          opName: () => 'azure.servicebus.send',
          serviceName: ({ tracerService }) => `${tracerService}-azure-service-bus`,
        },
        'google-cloud-pubsub': {
          opName: () => 'pubsub.request',
          serviceName: ({ tracerService }) => `${tracerService}-pubsub`,
        },
        kafkajs: {
          opName: () => 'kafka.produce',
          serviceName: ({ tracerService }) => `${tracerService}-kafka`,
        },
        'confluentinc-kafka-javascript': {
          opName: () => 'kafka.produce',
          serviceName: ({ tracerService }) => `${tracerService}-kafka`,
        },
        rhea: {
          opName: () => 'amqp.send',
          serviceName: ({ tracerService }) => `${tracerService}-amqp-producer`,
        },
        sqs: {
          opName: () => 'aws.request',
          serviceName: awsServiceV0,
        },
        sns: {
          opName: () => 'aws.request',
          serviceName: awsServiceV0,
        },
      },
      consumer: {
        amqplib: {
          opName: () => 'amqp.command',
          serviceName: amqpServiceName,
        },
        amqp10: {
          opName: () => 'amqp.receive',
          serviceName: amqpServiceName,
        },
        'google-cloud-pubsub': {
          opName: () => 'pubsub.receive',
          serviceName: identityService,
        },
        kafkajs: {
          opName: () => 'kafka.consume',
          serviceName: ({ tracerService }) => `${tracerService}-kafka`,
        },
        'confluentinc-kafka-javascript': {
          opName: () => 'kafka.consume',
          serviceName: ({ tracerService }) => `${tracerService}-kafka`,
        },
        rhea: {
          opName: () => 'amqp.receive',
          serviceName: identityService,
        },
        sqs: {
          opName: () => 'aws.request',
          serviceName: awsServiceV0,
        },
      },
      client: {
        amqplib: {
          opName: () => 'amqp.command',
          serviceName: amqpServiceName,
        },
        'google-cloud-pubsub': {
          opName: () => 'pubsub.request',
          serviceName: ({ tracerService }) => `${tracerService}-pubsub`,
        },
      },
    }
    module2.exports = messaging
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/storage.js
var require_storage2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/storage.js'(exports2, module2) {
    'use strict'
    function getRedisService(pluginConfig, connectionName) {
      if (pluginConfig.splitByInstance && connectionName) {
        return pluginConfig.service ? `${pluginConfig.service}-${connectionName}` : connectionName
      }
      return pluginConfig.service
    }
    function fromSystem(tracerService, system) {
      return system ? `${tracerService}-${system}` : void 0
    }
    function mysqlServiceName({ tracerService, pluginConfig, dbConfig, system }) {
      if (typeof pluginConfig.service === 'function') {
        return pluginConfig.service(dbConfig)
      }
      return pluginConfig.service || fromSystem(tracerService, system)
    }
    function withSuffixFunction(suffix) {
      return ({ tracerService, pluginConfig, params }) => {
        if (typeof pluginConfig.service === 'function') {
          return pluginConfig.service(params)
        }
        return pluginConfig.service || `${tracerService}-${suffix}`
      }
    }
    var redisConfig = {
      opName: () => 'redis.command',
      serviceName: ({ tracerService, pluginConfig, system, connectionName }) => {
        return getRedisService(pluginConfig, connectionName) || fromSystem(tracerService, system)
      },
    }
    var valkeyConfig = {
      opName: () => 'valkey.command',
      serviceName: ({ tracerService, pluginConfig, system, connectionName }) => {
        return getRedisService(pluginConfig, connectionName) || fromSystem(tracerService, system)
      },
    }
    var storage = {
      client: {
        aerospike: {
          opName: () => 'aerospike.command',
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-aerospike`,
        },
        'cassandra-driver': {
          opName: () => 'cassandra.query',
          serviceName: ({ tracerService, pluginConfig, system }) =>
            pluginConfig.service || fromSystem(tracerService, system),
        },
        couchbase: {
          opName: ({ operation }) => `couchbase.${operation}`,
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-couchbase`,
        },
        elasticsearch: {
          opName: () => 'elasticsearch.query',
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-elasticsearch`,
        },
        ioredis: redisConfig,
        iovalkey: valkeyConfig,
        mariadb: {
          opName: () => 'mariadb.query',
          serviceName: mysqlServiceName,
        },
        memcached: {
          opName: () => 'memcached.command',
          serviceName: ({ tracerService, pluginConfig, system }) =>
            pluginConfig.service || fromSystem(tracerService, system),
        },
        'mongodb-core': {
          opName: () => 'mongodb.query',
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-mongodb`,
        },
        mysql: {
          opName: () => 'mysql.query',
          serviceName: mysqlServiceName,
        },
        mysql2: {
          opName: () => 'mysql.query',
          serviceName: mysqlServiceName,
        },
        opensearch: {
          opName: () => 'opensearch.query',
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-opensearch`,
        },
        oracledb: {
          opName: () => 'oracle.query',
          serviceName: withSuffixFunction('oracle'),
        },
        pg: {
          opName: () => 'pg.query',
          serviceName: withSuffixFunction('postgres'),
        },
        prisma: {
          opName: ({ operation }) => `prisma.${operation}`,
          serviceName: withSuffixFunction('prisma'),
        },
        redis: redisConfig,
        tedious: {
          opName: () => 'tedious.request',
          serviceName: ({ tracerService, pluginConfig, system }) =>
            pluginConfig.service || fromSystem(tracerService, system),
        },
      },
    }
    module2.exports = storage
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/graphql.js
var require_graphql2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/graphql.js'(exports2, module2) {
    'use strict'
    var { identityService } = require_util4()
    var graphql = {
      server: {
        graphql: {
          opName: () => 'graphql.execute',
          serviceName: identityService,
        },
      },
    }
    module2.exports = graphql
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/web.js
var require_web = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/web.js'(exports2, module2) {
    'use strict'
    var { identityService, httpPluginClientService, awsServiceV0 } = require_util4()
    var web = {
      client: {
        grpc: {
          opName: () => 'grpc.client',
          serviceName: identityService,
        },
        moleculer: {
          opName: () => 'moleculer.call',
          serviceName: identityService,
        },
        http: {
          opName: () => 'http.request',
          serviceName: httpPluginClientService,
        },
        fetch: {
          opName: () => 'http.request',
          serviceName: httpPluginClientService,
        },
        http2: {
          opName: () => 'http.request',
          serviceName: httpPluginClientService,
        },
        genai: {
          opName: () => 'google_genai.request',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        aws: {
          opName: () => 'aws.request',
          serviceName: awsServiceV0,
        },
        lambda: {
          opName: () => 'aws.request',
          serviceName: awsServiceV0,
        },
        undici: {
          opName: () => 'undici.request',
          serviceName: httpPluginClientService,
        },
      },
      server: {
        'apollo.gateway.request': {
          opName: () => 'apollo.gateway.request',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.plan': {
          opName: () => 'apollo.gateway.plan',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.validate': {
          opName: () => 'apollo.gateway.validate',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.execute': {
          opName: () => 'apollo.gateway.execute',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.fetch': {
          opName: () => 'apollo.gateway.fetch',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.postprocessing': {
          opName: () => 'apollo.gateway.postprocessing',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        grpc: {
          opName: () => 'grpc.server',
          serviceName: identityService,
        },
        moleculer: {
          opName: () => 'moleculer.action',
          serviceName: identityService,
        },
        http: {
          opName: () => 'web.request',
          serviceName: identityService,
        },
        http2: {
          opName: () => 'web.request',
          serviceName: identityService,
        },
        next: {
          opName: () => 'next.request',
          serviceName: identityService,
        },
      },
    }
    module2.exports = web
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/serverless.js
var require_serverless2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/serverless.js'(exports2, module2) {
    'use strict'
    var { identityService } = require_util4()
    var serverless = {
      server: {
        'azure-functions': {
          opName: () => 'azure.functions.invoke',
          serviceName: identityService,
        },
      },
    }
    module2.exports = serverless
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/websocket.js
var require_websocket = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/websocket.js'(exports2, module2) {
    'use strict'
    var websocket = {
      request: {
        ws: {
          opName: () => 'web.request',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
      producer: {
        ws: {
          opName: () => 'websocket.send',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
      consumer: {
        ws: {
          opName: () => 'websocket.receive',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
      close: {
        ws: {
          opName: () => 'websocket.close',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
    }
    module2.exports = websocket
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/index.js
var require_v0 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v0/index.js'(exports2, module2) {
    'use strict'
    var SchemaDefinition = require_definition()
    var messaging = require_messaging()
    var storage = require_storage2()
    var graphql = require_graphql2()
    var web = require_web()
    var serverless = require_serverless2()
    var websocket = require_websocket()
    module2.exports = new SchemaDefinition({ messaging, storage, web, graphql, serverless, websocket })
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/messaging.js
var require_messaging2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/messaging.js'(exports2, module2) {
    'use strict'
    var { identityService } = require_util4()
    var amqpInbound = {
      opName: () => 'amqp.process',
      serviceName: identityService,
    }
    var amqpOutbound = {
      opName: () => 'amqp.send',
      serviceName: identityService,
    }
    var messaging = {
      producer: {
        amqplib: amqpOutbound,
        amqp10: amqpOutbound,
        'azure-service-bus': {
          opName: () => 'azure.servicebus.send',
          serviceName: identityService,
        },
        'azure-event-hubs': {
          opName: () => 'azure.eventhubs.send',
          serviceName: identityService,
        },
        'google-cloud-pubsub': {
          opName: () => 'gcp.pubsub.send',
          serviceName: identityService,
        },
        kafkajs: {
          opName: () => 'kafka.send',
          serviceName: identityService,
        },
        'confluentinc-kafka-javascript': {
          opName: () => 'kafka.send',
          serviceName: identityService,
        },
        rhea: amqpOutbound,
        sqs: {
          opName: () => 'aws.sqs.send',
          serviceName: identityService,
        },
        sns: {
          opName: () => 'aws.sns.send',
          serviceName: identityService,
        },
      },
      consumer: {
        amqplib: amqpInbound,
        amqp10: amqpInbound,
        'google-cloud-pubsub': {
          opName: () => 'gcp.pubsub.process',
          serviceName: identityService,
        },
        kafkajs: {
          opName: () => 'kafka.process',
          serviceName: identityService,
        },
        'confluentinc-kafka-javascript': {
          opName: () => 'kafka.process',
          serviceName: identityService,
        },
        rhea: amqpInbound,
        sqs: {
          opName: () => 'aws.sqs.process',
          serviceName: identityService,
        },
      },
      client: {
        amqplib: {
          opName: () => 'amqp.command',
          serviceName: identityService,
        },
        'google-cloud-pubsub': {
          opName: () => 'gcp.pubsub.request',
          serviceName: identityService,
        },
      },
    }
    module2.exports = messaging
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/storage.js
var require_storage3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/storage.js'(exports2, module2) {
    'use strict'
    function configWithFallback({ tracerService, pluginConfig }) {
      return pluginConfig.service || tracerService
    }
    var redisNaming = {
      opName: () => 'redis.command',
      serviceName: configWithFallback,
    }
    var mySQLNaming = {
      opName: () => 'mysql.query',
      serviceName: withFunction,
    }
    function withFunction({ tracerService, pluginConfig, params }) {
      if (typeof pluginConfig.service === 'function') {
        const result = pluginConfig.service(params)
        return typeof result === 'string' && result.length > 0 ? result : tracerService
      }
      return configWithFallback({ tracerService, pluginConfig })
    }
    var storage = {
      client: {
        aerospike: {
          opName: () => 'aerospike.command',
          serviceName: configWithFallback,
        },
        'cassandra-driver': {
          opName: () => 'cassandra.query',
          serviceName: configWithFallback,
        },
        couchbase: {
          opName: () => 'couchbase.query',
          serviceName: configWithFallback,
        },
        elasticsearch: {
          opName: () => 'elasticsearch.query',
          serviceName: configWithFallback,
        },
        ioredis: redisNaming,
        iovalkey: {
          opName: () => 'valkey.command',
          serviceName: configWithFallback,
        },
        mariadb: {
          opName: () => 'mariadb.query',
          serviceName: withFunction,
        },
        memcached: {
          opName: () => 'memcached.command',
          serviceName: configWithFallback,
        },
        'mongodb-core': {
          opName: () => 'mongodb.query',
          serviceName: configWithFallback,
        },
        mysql: mySQLNaming,
        mysql2: mySQLNaming,
        opensearch: {
          opName: () => 'opensearch.query',
          serviceName: configWithFallback,
        },
        oracledb: {
          opName: () => 'oracle.query',
          serviceName: withFunction,
        },
        pg: {
          opName: () => 'postgresql.query',
          serviceName: withFunction,
        },
        prisma: {
          opName: ({ operation }) => `prisma.${operation}`,
          serviceName: configWithFallback,
        },
        redis: redisNaming,
        tedious: {
          opName: () => 'mssql.query',
          serviceName: configWithFallback,
        },
      },
    }
    module2.exports = storage
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/graphql.js
var require_graphql3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/graphql.js'(exports2, module2) {
    'use strict'
    var { identityService } = require_util4()
    var graphql = {
      server: {
        graphql: {
          opName: () => 'graphql.server.request',
          serviceName: identityService,
        },
      },
    }
    module2.exports = graphql
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/web.js
var require_web2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/web.js'(exports2, module2) {
    'use strict'
    var { identityService, httpPluginClientService } = require_util4()
    var web = {
      client: {
        grpc: {
          opName: () => 'grpc.client.request',
          serviceName: identityService,
        },
        moleculer: {
          opName: () => 'moleculer.client.request',
          serviceName: identityService,
        },
        http: {
          opName: () => 'http.client.request',
          serviceName: httpPluginClientService,
        },
        genai: {
          opName: () => 'google_genai.request',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        fetch: {
          opName: () => 'http.client.request',
          serviceName: httpPluginClientService,
        },
        http2: {
          opName: () => 'http.client.request',
          serviceName: httpPluginClientService,
        },
        aws: {
          opName: ({ awsService }) => `aws.${awsService}.request`,
          serviceName: identityService,
        },
        lambda: {
          opName: () => 'aws.lambda.invoke',
          serviceName: identityService,
        },
        undici: {
          opName: () => 'undici.request',
          serviceName: httpPluginClientService,
        },
      },
      server: {
        'apollo.gateway.request': {
          opName: () => 'apollo.gateway.request',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.plan': {
          opName: () => 'apollo.gateway.plan',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.validate': {
          opName: () => 'apollo.gateway.validate',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.execute': {
          opName: () => 'apollo.gateway.execute',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.fetch': {
          opName: () => 'apollo.gateway.fetch',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        'apollo.gateway.postprocessing': {
          opName: () => 'apollo.gateway.postprocessing',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
        grpc: {
          opName: () => 'grpc.server.request',
          serviceName: identityService,
        },
        moleculer: {
          opName: () => 'moleculer.server.request',
          serviceName: identityService,
        },
        http: {
          opName: () => 'http.server.request',
          serviceName: identityService,
        },
        http2: {
          opName: () => 'http.server.request',
          serviceName: identityService,
        },
        next: {
          opName: () => 'http.server.request',
          serviceName: identityService,
        },
      },
    }
    module2.exports = web
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/serverless.js
var require_serverless3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/serverless.js'(exports2, module2) {
    'use strict'
    var { identityService } = require_util4()
    var serverless = {
      server: {
        'azure-functions': {
          opName: () => 'azure.functions.invoke',
          serviceName: identityService,
        },
      },
    }
    module2.exports = serverless
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/websocket.js
var require_websocket2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/websocket.js'(exports2, module2) {
    'use strict'
    var websocket = {
      request: {
        ws: {
          opName: () => 'web.request',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
      producer: {
        ws: {
          opName: () => 'websocket.send',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
      consumer: {
        ws: {
          opName: () => 'websocket.receive',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
      close: {
        ws: {
          opName: () => 'websocket.close',
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService,
        },
      },
    }
    module2.exports = websocket
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/index.js
var require_v1 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/schemas/v1/index.js'(exports2, module2) {
    'use strict'
    var SchemaDefinition = require_definition()
    var messaging = require_messaging2()
    var storage = require_storage3()
    var graphql = require_graphql3()
    var web = require_web2()
    var serverless = require_serverless3()
    var websocket = require_websocket2()
    module2.exports = new SchemaDefinition({ messaging, storage, web, graphql, serverless, websocket })
  },
})

// node_modules/dd-trace/packages/dd-trace/src/service-naming/index.js
var require_service_naming = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/service-naming/index.js'(exports2, module2) {
    'use strict'
    var SchemaManager = class {
      /**
       * @type {object}
       */
      config = {
        spanAttributeSchema: 'v0',
        spanRemoveIntegrationFromService: false,
      }
      schemas = {
        v0: require_v0(),
      }
      get schema() {
        return this.schemas[this.version]
      }
      get version() {
        return this.config.spanAttributeSchema
      }
      get shouldUseConsistentServiceNaming() {
        return this.config.spanRemoveIntegrationFromService && this.version === 'v0'
      }
      /**
       * @param {string} type
       * @param {string} kind
       * @param {string} plugin
       * @param {object} opts
       * @returns {string}
       */
      opName(type, kind, plugin, opts) {
        return this.schema.getOpName(type, kind, plugin, opts)
      }
      /**
       * @param {string} type
       * @param {string} kind
       * @param {string} plugin
       * @param {object} opts
       * @returns {string}
       */
      serviceName(type, kind, plugin, opts) {
        const schema = this.shouldUseConsistentServiceNaming ? this.schemas.v1 : this.schema
        return schema.getServiceName(type, kind, plugin, { ...opts, tracerService: this.config.service })
      }
      /**
       * @param {object} config
       * @param {string} config.spanAttributeSchema
       * @param {boolean} config.spanRemoveIntegrationFromService
       * @param {string} [config.service]
       */
      configure(config) {
        const { spanAttributeSchema, spanRemoveIntegrationFromService } = config
        if (!this.schemas.v0 && spanAttributeSchema === 'v0') {
          this.schemas.v0 = require_v0()
        }
        if (!this.schemas.v1 && (spanAttributeSchema === 'v1' || spanRemoveIntegrationFromService)) {
          this.schemas.v1 = require_v1()
        }
        this.config = config
      }
    }
    module2.exports = new SchemaManager()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js
var require_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var logger = require_log2()
    var { storage } = require_datadog_core()
    var Subscription = class {
      constructor(event, handler) {
        this._channel = dc.channel(event)
        this._handler = (message, name) => {
          const store = storage('legacy').getStore()
          if (!store || !store.noop) {
            handler(message, name)
          }
        }
      }
      enable() {
        this._channel.subscribe(this._handler)
      }
      disable() {
        this._channel.unsubscribe(this._handler)
      }
    }
    var StoreBinding = class {
      constructor(event, transform) {
        this._channel = dc.channel(event)
        this._transform = (data) => {
          const store = storage('legacy').getStore()
          return !store || !store.noop || (data && Object.hasOwn(data, 'currentStore')) ? transform(data) : store
        }
      }
      enable() {
        this._channel.bindStore(storage('legacy'), this._transform)
      }
      disable() {
        this._channel.unbindStore(storage('legacy'))
      }
    }
    module2.exports = class Plugin {
      /**
       * Create a new plugin instance.
       *
       * @param {object} tracer Tracer instance or wrapper containing it under `_tracer`.
       * @param {object} tracerConfig Global tracer configuration object.
       */
      constructor(tracer2, tracerConfig) {
        this._subscriptions = []
        this._bindings = []
        this._enabled = false
        this._tracer = tracer2
        this.config = {}
        this._tracerConfig = tracerConfig
      }
      /**
       * Normalized tracer access. Returns the underlying tracer even if wrapped.
       *
       * @returns {object}
       */
      get tracer() {
        return this._tracer?._tracer || this._tracer
      }
      /**
       * Enter a context with the provided span bound in storage.
       *
       * @param {object} span The span to bind as current.
       * @param {object=} store Optional existing store to extend; if omitted, uses current store.
       * @returns {void}
       */
      enter(span, store) {
        store = store || storage('legacy').getStore()
        storage('legacy').enterWith({ ...store, span })
      }
      // TODO: Implement filters on resource name for all plugins.
      /** Prevents creation of spans here and for all async descendants. */
      skip() {
        storage('legacy').enterWith({ noop: true })
      }
      /**
       * Subscribe to a diagnostic channel with automatic error handling and enable/disable lifecycle.
       *
       * @param {string} channelName Diagnostic channel name.
       * @param {(...args: unknown[]) => unknown} handler Handler invoked on messages.
       * @returns {void}
       */
      addSub(channelName, handler) {
        const wrappedHandler = (...args) => {
          try {
            return handler.apply(this, args)
          } catch (error) {
            logger.error('Error in plugin handler:', error)
            logger.info('Disabling plugin: %s', this.constructor.name)
            this.configure(false)
          }
        }
        this._subscriptions.push(new Subscription(channelName, wrappedHandler))
      }
      /**
       * Bind the tracer store to a diagnostic channel with a transform function.
       *
       * @param {string} channelName Diagnostic channel name.
       * @param {(data: unknown) => object} transform Transform to compute the bound store.
       * @returns {void}
       */
      addBind(channelName, transform) {
        this._bindings.push(new StoreBinding(channelName, transform))
      }
      /**
       * Attach an error to the current active span (if any).
       *
       * @param {unknown} error Error object or sentinel value.
       * @returns {void}
       */
      addError(error) {
        const store = storage('legacy').getStore()
        if (!store || !store.span) return
        if (!store.span._spanContext._tags.error) {
          store.span.setTag('error', error || 1)
        }
      }
      /**
       * Enable or disable the plugin and (re)apply its configuration.
       *
       * @param {boolean|object} config Either a boolean to enable/disable or a configuration object
       *                                containing at least `{ enabled: boolean }`.
       * @returns {void}
       */
      configure(config) {
        if (typeof config === 'boolean') {
          config = { enabled: config }
        }
        this.config = config
        if (config.enabled && !this._enabled) {
          this._enabled = true
          this._subscriptions.forEach((sub) => sub.enable())
          this._bindings.forEach((sub) => sub.enable())
        } else if (!config.enabled && this._enabled) {
          this._enabled = false
          this._subscriptions.forEach((sub) => sub.disable())
          this._bindings.forEach((sub) => sub.disable())
        }
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/composite.js
var require_composite = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/composite.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var CompositePlugin = class extends Plugin {
      constructor(...args) {
        super(...args)
        for (const [name, PluginClass] of Object.entries(this.constructor.plugins)) {
          this[name] = new PluginClass(...args)
        }
      }
      /**
       * @override
       */
      configure(config) {
        super.configure(config)
        for (const name in this.constructor.plugins) {
          const pluginConfig = config[name] === false ? false : { ...config, ...config[name] }
          this[name].configure(pluginConfig)
        }
      }
    }
    module2.exports = CompositePlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js
var require_analytics_sampler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js'(exports2, module2) {
    'use strict'
    var { MEASURED } = require_tags()
    module2.exports = {
      sample(span, measured, measuredByDefault) {
        if (measured !== null && typeof measured === 'object') {
          this.sample(span, measured[span.context()._name], measuredByDefault)
        } else if (measured !== void 0) {
          span.setTag(MEASURED, !!measured)
        } else if (measuredByDefault) {
          span.setTag(MEASURED, true)
        }
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/tracing.js
var require_tracing = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/tracing.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var { storage } = require_datadog_core()
    var analyticsSampler = require_analytics_sampler()
    var { COMPONENT } = require_constants2()
    var TracingPlugin = class extends Plugin {
      constructor(...args) {
        super(...args)
        this.component = this.constructor.component || this.constructor.id
        this.operation = this.constructor.operation
        this.addTraceSubs()
      }
      get activeSpan() {
        const store = storage('legacy').getStore()
        return store && store.span
      }
      serviceName(opts = {}) {
        const { type = this.constructor.type, id = this.constructor.id, kind = this.constructor.kind } = opts
        return this._tracer._nomenclature.serviceName(type, kind, id, opts)
      }
      operationName(opts = {}) {
        const { type = this.constructor.type, id = this.constructor.id, kind = this.constructor.kind } = opts
        return this._tracer._nomenclature.opName(type, kind, id, opts)
      }
      configure(config) {
        return super.configure({
          ...config,
          hooks: {
            [this.operation]: () => {},
            ...config.hooks,
          },
        })
      }
      start() {}
      // implemented by individual plugins
      finish(ctx) {
        const span = ctx?.currentStore?.span || this.activeSpan
        span?.finish()
      }
      error(ctxOrError) {
        if (ctxOrError?.currentStore) {
          ctxOrError.currentStore?.span.setTag('error', ctxOrError?.error)
          return
        }
        this.addError(ctxOrError)
      }
      addTraceSubs() {
        const events = ['start', 'end', 'asyncStart', 'asyncEnd', 'error', 'finish']
        for (const event of events) {
          const bindName = `bind${event.charAt(0).toUpperCase()}${event.slice(1)}`
          if (this[event]) {
            this.addTraceSub(event, (message) => {
              this[event](message)
            })
          }
          if (this[bindName]) {
            this.addTraceBind(event, (message) => this[bindName](message))
          }
        }
      }
      addTraceSub(eventName, handler) {
        const prefix = this.constructor.prefix || `apm:${this.component}:${this.operation}`
        this.addSub(`${prefix}:${eventName}`, handler)
      }
      addTraceBind(eventName, transform) {
        const prefix = this.constructor.prefix || `apm:${this.component}:${this.operation}`
        this.addBind(`${prefix}:${eventName}`, transform)
      }
      addError(error, span = this.activeSpan) {
        if (span && !span._spanContext._tags.error) {
          error = (error && error.error) || error
          span.setTag('error', error || 1)
        }
      }
      startSpan(name, options = {}, enterOrCtx = true) {
        let {
          component = this.component,
          childOf,
          integrationName,
          kind,
          meta,
          metrics,
          service,
          startTime,
          resource,
          type,
        } = options
        const tracer2 = options.tracer || this.tracer
        const config = options.config || this.config
        const store = storage('legacy').getStore()
        if (store && childOf === void 0) {
          childOf = store.span
        }
        const span = tracer2.startSpan(name, {
          startTime,
          childOf,
          tags: {
            [COMPONENT]: component,
            'service.name': service || meta?.service || tracer2._service,
            'resource.name': resource,
            'span.kind': kind,
            'span.type': type,
            ...meta,
            ...metrics,
          },
          integrationName: integrationName || component,
          links: childOf?._links,
        })
        analyticsSampler.sample(span, config.measured)
        if (enterOrCtx === true) {
          storage('legacy').enterWith({ ...store, span })
        } else if (enterOrCtx) {
          enterOrCtx.parentStore = store
          enterOrCtx.currentStore = { ...store, span }
        }
        return span
      }
    }
    module2.exports = TracingPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-anthropic/src/tracing.js
var require_tracing2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-anthropic/src/tracing.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var AnthropicTracingPlugin = class extends TracingPlugin {
      static id = 'anthropic'
      static operation = 'request'
      static system = 'anthropic'
      static prefix = 'tracing:apm:anthropic:request'
      bindStart(ctx) {
        const { resource, options } = ctx
        this.startSpan(
          'anthropic.request',
          {
            meta: {
              'resource.name': `Messages.${resource}`,
              'anthropic.request.model': options.model,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore?.span
        span?.finish()
      }
    }
    module2.exports = AnthropicTracingPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/storage.js
var require_storage4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/storage.js'(exports2, module2) {
    'use strict'
    var { storage: createStorage } = require_datadog_core()
    var storage = createStorage('llmobs')
    module2.exports = { storage }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/constants/tags.js
var require_tags3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/constants/tags.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      SPAN_KINDS: ['llm', 'agent', 'workflow', 'task', 'tool', 'embedding', 'retrieval'],
      SPAN_KIND: '_ml_obs.meta.span.kind',
      SESSION_ID: '_ml_obs.session_id',
      DECORATOR: '_ml_obs.decorator',
      INTEGRATION: '_ml_obs.integration',
      METADATA: '_ml_obs.meta.metadata',
      METRICS: '_ml_obs.metrics',
      ML_APP: '_ml_obs.meta.ml_app',
      PROPAGATED_PARENT_ID_KEY: '_dd.p.llmobs_parent_id',
      PROPAGATED_ML_APP_KEY: '_dd.p.llmobs_ml_app',
      PARENT_ID_KEY: '_ml_obs.llmobs_parent_id',
      TAGS: '_ml_obs.tags',
      NAME: '_ml_obs.name',
      TRACE_ID: '_ml_obs.trace_id',
      PROPAGATED_TRACE_ID_KEY: '_dd.p.llmobs_trace_id',
      ROOT_PARENT_ID: 'undefined',
      MODEL_NAME: '_ml_obs.meta.model_name',
      MODEL_PROVIDER: '_ml_obs.meta.model_provider',
      INPUT_DOCUMENTS: '_ml_obs.meta.input.documents',
      INPUT_MESSAGES: '_ml_obs.meta.input.messages',
      INPUT_VALUE: '_ml_obs.meta.input.value',
      OUTPUT_DOCUMENTS: '_ml_obs.meta.output.documents',
      OUTPUT_MESSAGES: '_ml_obs.meta.output.messages',
      OUTPUT_VALUE: '_ml_obs.meta.output.value',
      INPUT_TOKENS_METRIC_KEY: 'input_tokens',
      OUTPUT_TOKENS_METRIC_KEY: 'output_tokens',
      TOTAL_TOKENS_METRIC_KEY: 'total_tokens',
      CACHE_READ_INPUT_TOKENS_METRIC_KEY: 'cache_read_input_tokens',
      CACHE_WRITE_INPUT_TOKENS_METRIC_KEY: 'cache_write_input_tokens',
      REASONING_OUTPUT_TOKENS_METRIC_KEY: 'reasoning_output_tokens',
      DROPPED_IO_COLLECTION_ERROR: 'dropped_io',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/tagger.js
var require_tagger2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/tagger.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var {
      MODEL_NAME,
      MODEL_PROVIDER,
      SESSION_ID,
      ML_APP,
      SPAN_KIND,
      INPUT_VALUE,
      OUTPUT_DOCUMENTS,
      INPUT_DOCUMENTS,
      OUTPUT_VALUE,
      METADATA,
      METRICS,
      PARENT_ID_KEY,
      INPUT_MESSAGES,
      OUTPUT_MESSAGES,
      TAGS,
      NAME,
      PROPAGATED_PARENT_ID_KEY,
      ROOT_PARENT_ID,
      CACHE_READ_INPUT_TOKENS_METRIC_KEY,
      CACHE_WRITE_INPUT_TOKENS_METRIC_KEY,
      INPUT_TOKENS_METRIC_KEY,
      OUTPUT_TOKENS_METRIC_KEY,
      TOTAL_TOKENS_METRIC_KEY,
      REASONING_OUTPUT_TOKENS_METRIC_KEY,
      INTEGRATION,
      DECORATOR,
      PROPAGATED_ML_APP_KEY,
    } = require_tags3()
    var { storage } = require_storage4()
    var registry = /* @__PURE__ */ new WeakMap()
    var LLMObsTagger = class {
      constructor(config, softFail = false) {
        this._config = config
        this.softFail = softFail
      }
      static get tagMap() {
        return registry
      }
      static getSpanKind(span) {
        return registry.get(span)?.[SPAN_KIND]
      }
      registerLLMObsSpan(
        span,
        { modelName, modelProvider, sessionId, mlApp, parent, kind, name, integration, _decorator } = {}
      ) {
        if (!this._config.llmobs.enabled) return
        if (!kind) return
        const spanMlApp =
          mlApp ||
          registry.get(parent)?.[ML_APP] ||
          span.context()._trace.tags[PROPAGATED_ML_APP_KEY] ||
          this._config.llmobs.mlApp ||
          this._config.service
        if (!spanMlApp) {
          throw new Error(
            '[LLMObs] Cannot start an LLMObs span without an mlApp configured.Ensure this configuration is set before running your application.'
          )
        }
        this._register(span)
        this._setTag(span, ML_APP, spanMlApp)
        if (name) this._setTag(span, NAME, name)
        this._setTag(span, SPAN_KIND, kind)
        if (modelName) this.tagModelName(span, modelName)
        if (modelProvider) this._setTag(span, MODEL_PROVIDER, modelProvider)
        sessionId = sessionId || registry.get(parent)?.[SESSION_ID]
        if (sessionId) this._setTag(span, SESSION_ID, sessionId)
        if (integration) this._setTag(span, INTEGRATION, integration)
        if (_decorator) this._setTag(span, DECORATOR, _decorator)
        const parentId =
          parent?.context().toSpanId() ?? span.context()._trace.tags[PROPAGATED_PARENT_ID_KEY] ?? ROOT_PARENT_ID
        this._setTag(span, PARENT_ID_KEY, parentId)
        const annotationContext = storage.getStore()?.annotationContext
        const tags = annotationContext?.tags
        if (tags) this.tagSpanTags(span, tags)
        const annotationContextName = annotationContext?.name
        if (annotationContextName) this._setTag(span, NAME, annotationContextName)
      }
      // TODO: similarly for the following `tag` methods,
      // how can we transition from a span weakmap to core API functionality
      tagLLMIO(span, inputData, outputData) {
        this.#tagMessages(span, inputData, INPUT_MESSAGES)
        this.#tagMessages(span, outputData, OUTPUT_MESSAGES)
      }
      tagEmbeddingIO(span, inputData, outputData) {
        this.#tagDocuments(span, inputData, INPUT_DOCUMENTS)
        this.#tagText(span, outputData, OUTPUT_VALUE)
      }
      tagRetrievalIO(span, inputData, outputData) {
        this.#tagText(span, inputData, INPUT_VALUE)
        this.#tagDocuments(span, outputData, OUTPUT_DOCUMENTS)
      }
      tagTextIO(span, inputData, outputData) {
        this.#tagText(span, inputData, INPUT_VALUE)
        this.#tagText(span, outputData, OUTPUT_VALUE)
      }
      tagMetadata(span, metadata) {
        const existingMetadata = registry.get(span)?.[METADATA]
        if (existingMetadata) {
          Object.assign(existingMetadata, metadata)
        } else {
          this._setTag(span, METADATA, metadata)
        }
      }
      tagMetrics(span, metrics) {
        const filterdMetrics = {}
        for (const [key, value] of Object.entries(metrics)) {
          let processedKey = key
          switch (key) {
            case 'inputTokens':
              processedKey = INPUT_TOKENS_METRIC_KEY
              break
            case 'outputTokens':
              processedKey = OUTPUT_TOKENS_METRIC_KEY
              break
            case 'totalTokens':
              processedKey = TOTAL_TOKENS_METRIC_KEY
              break
            case 'cacheReadTokens':
              processedKey = CACHE_READ_INPUT_TOKENS_METRIC_KEY
              break
            case 'cacheWriteTokens':
              processedKey = CACHE_WRITE_INPUT_TOKENS_METRIC_KEY
              break
            case 'reasoningOutputTokens':
              processedKey = REASONING_OUTPUT_TOKENS_METRIC_KEY
              break
          }
          if (typeof value === 'number') {
            filterdMetrics[processedKey] = value
          } else {
            this.#handleFailure(`Value for metric '${key}' must be a number, instead got ${value}`, 'invalid_metrics')
          }
        }
        const existingMetrics = registry.get(span)?.[METRICS]
        if (existingMetrics) {
          Object.assign(existingMetrics, filterdMetrics)
        } else {
          this._setTag(span, METRICS, filterdMetrics)
        }
      }
      tagSpanTags(span, tags) {
        const currentTags = registry.get(span)?.[TAGS]
        if (currentTags) {
          Object.assign(currentTags, tags)
        } else {
          this._setTag(span, TAGS, tags)
        }
      }
      changeKind(span, newKind) {
        this._setTag(span, SPAN_KIND, newKind)
      }
      tagModelName(span, modelName) {
        this._setTag(span, MODEL_NAME, modelName)
      }
      #tagText(span, data, key) {
        if (data) {
          if (typeof data === 'string') {
            this._setTag(span, key, data)
          } else {
            try {
              this._setTag(span, key, JSON.stringify(data))
            } catch {
              const type = key === INPUT_VALUE ? 'input' : 'output'
              this.#handleFailure(`Failed to parse ${type} value, must be JSON serializable.`, 'invalid_io_text')
            }
          }
        }
      }
      #tagDocuments(span, data, key) {
        if (!data) {
          return
        }
        if (!Array.isArray(data)) {
          data = [data]
        }
        const documents = []
        for (const document of data) {
          if (typeof document === 'string') {
            documents.push({ text: document })
            continue
          }
          if (document == null || typeof document !== 'object') {
            this.#handleFailure('Documents must be a string, object, or list of objects.', 'invalid_embedding_io')
            continue
          }
          const { text, name, id, score } = document
          const valid = typeof text === 'string'
          if (!valid) {
            this.#handleFailure('Document text must be a string.', 'invalid_embedding_io')
          }
          const documentObj = { text }
          const condition1 = this.#tagConditionalString(name, 'Document name', documentObj, 'name')
          const condition2 = this.#tagConditionalString(id, 'Document ID', documentObj, 'id')
          const condition3 = this.#tagConditionalNumber(score, 'Document score', documentObj, 'score')
          if (valid && condition1 && condition2 && condition3) {
            documents.push(documentObj)
          }
        }
        if (documents.length) {
          this._setTag(span, key, documents)
        }
      }
      #filterToolCalls(toolCalls) {
        if (!Array.isArray(toolCalls)) {
          toolCalls = [toolCalls]
        }
        const filteredToolCalls = []
        for (const toolCall of toolCalls) {
          if (typeof toolCall !== 'object') {
            this.#handleFailure('Tool call must be an object.', 'invalid_io_messages')
            continue
          }
          const { name, arguments: args, toolId, type } = toolCall
          const toolCallObj = {}
          const condition1 = this.#tagConditionalString(name, 'Tool name', toolCallObj, 'name')
          const condition2 = this.#tagConditionalObject(args, 'Tool arguments', toolCallObj, 'arguments')
          const condition3 = this.#tagConditionalString(toolId, 'Tool ID', toolCallObj, 'tool_id')
          const condition4 = this.#tagConditionalString(type, 'Tool type', toolCallObj, 'type')
          if (condition1 && condition2 && condition3 && condition4) {
            filteredToolCalls.push(toolCallObj)
          }
        }
        return filteredToolCalls
      }
      #filterToolResults(toolResults) {
        if (!Array.isArray(toolResults)) {
          toolResults = [toolResults]
        }
        const filteredToolResults = []
        for (const toolResult of toolResults) {
          if (typeof toolResult !== 'object') {
            this.#handleFailure('Tool result must be an object.', 'invalid_io_messages')
            continue
          }
          const { result, toolId, name = '', type } = toolResult
          const toolResultObj = {}
          const condition1 = this.#tagConditionalString(result, 'Tool result', toolResultObj, 'result')
          const condition2 = this.#tagConditionalString(toolId, 'Tool ID', toolResultObj, 'tool_id')
          if (typeof name === 'string') {
            toolResultObj.name = name
          } else {
            this.#handleFailure(`[LLMObs] Expected tool result name to be a string, instead got "${typeof name}"`)
          }
          const condition3 = this.#tagConditionalString(type, 'Tool type', toolResultObj, 'type')
          if (condition1 && condition2 && condition3) {
            filteredToolResults.push(toolResultObj)
          }
        }
        return filteredToolResults
      }
      #tagMessages(span, data, key) {
        if (!data) {
          return
        }
        if (!Array.isArray(data)) {
          data = [data]
        }
        const messages = []
        for (const message of data) {
          if (typeof message === 'string') {
            messages.push({ content: message, role: '' })
            continue
          }
          if (message == null || typeof message !== 'object') {
            this.#handleFailure('Messages must be a string, object, or list of objects', 'invalid_io_messages')
            continue
          }
          const { role = '', content, toolCalls, toolResults, toolId } = message
          const messageObj = {}
          let condition = this.#tagConditionalString(role, 'Message role', messageObj, 'role')
          if (content == null && toolCalls == null && toolResults == null) {
            messageObj.content = ''
          }
          if (content != null) {
            condition = this.#tagConditionalString(content, 'Message content', messageObj, 'content') && condition
          }
          if (toolCalls != null) {
            const filteredToolCalls = this.#filterToolCalls(toolCalls)
            if (filteredToolCalls.length) {
              messageObj.tool_calls = filteredToolCalls
            }
          }
          if (toolResults != null) {
            const filteredToolResults = this.#filterToolResults(toolResults)
            if (filteredToolResults.length) {
              messageObj.tool_results = filteredToolResults
            }
          }
          if (toolId) {
            if (role === 'tool') {
              condition = this.#tagConditionalString(toolId, 'Tool ID', messageObj, 'tool_id') && condition
            } else {
              log.warn(`Tool ID for tool message not associated with a "tool" role, instead got "${role}"`)
            }
          }
          if (condition) {
            messages.push(messageObj)
          }
        }
        if (messages.length) {
          this._setTag(span, key, messages)
        }
      }
      #tagConditionalString(data, type, carrier, key) {
        if (data == null) return true
        if (typeof data !== 'string') {
          this.#handleFailure(`"${type}" must be a string.`)
          return false
        }
        carrier[key] = data
        return true
      }
      #tagConditionalNumber(data, type, carrier, key) {
        if (data == null) return true
        if (typeof data !== 'number') {
          this.#handleFailure(`"${type}" must be a number.`)
          return false
        }
        carrier[key] = data
        return true
      }
      #tagConditionalObject(data, type, carrier, key) {
        if (data == null) return true
        if (typeof data !== 'object') {
          this.#handleFailure(`"${type}" must be an object.`)
          return false
        }
        carrier[key] = data
        return true
      }
      // any public-facing LLMObs APIs using this tagger should not soft fail
      // auto-instrumentation should soft fail
      #handleFailure(msg, errorTag) {
        if (this.softFail) {
          log.warn(msg)
        } else {
          const err = new Error(msg)
          if (errorTag) {
            Object.defineProperty(err, 'ddErrorTag', {
              get() {
                return errorTag
              },
            })
          }
          throw err
        }
      }
      _register(span) {
        if (!this._config.llmobs.enabled) return
        if (registry.has(span)) {
          this.#handleFailure(`LLMObs Span "${span._name}" already registered.`)
          return
        }
        registry.set(span, {})
      }
      _setTag(span, key, value) {
        if (!this._config.llmobs.enabled) return
        if (!registry.has(span)) {
          this.#handleFailure(`Span "${span._name}" must be an LLMObs generated span.`)
          return
        }
        const tagsCarrier = registry.get(span)
        tagsCarrier[key] = value
      }
    }
    module2.exports = LLMObsTagger
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/telemetry.js
var require_telemetry4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/telemetry.js'(exports2, module2) {
    'use strict'
    var { SPAN_KIND, MODEL_PROVIDER, PARENT_ID_KEY, SESSION_ID, ROOT_PARENT_ID, INTEGRATION, DECORATOR } =
      require_tags3()
    var ERROR_TYPE = require_constants2()
    var telemetryMetrics = require_metrics()
    var LLMObsTagger = require_tagger2()
    var llmobsMetrics = telemetryMetrics.manager.namespace('mlobs')
    function extractIntegrationFromTags(tags) {
      if (!Array.isArray(tags)) return null
      const integrationTag = tags.find((tag) => tag.startsWith('integration:'))
      if (!integrationTag) return null
      return integrationTag.split(':')[1] || null
    }
    function extractTagsFromSpanEvent(event) {
      const spanKind = event.meta?.['span.kind'] || ''
      const integration = extractIntegrationFromTags(event.tags)
      const error = event.status === 'error'
      const autoinstrumented = integration != null
      return {
        span_kind: spanKind,
        autoinstrumented: Number(autoinstrumented),
        error: error ? 1 : 0,
        integration: integration || 'N/A',
      }
    }
    function incrementLLMObsSpanStartCount(tags, value = 1) {
      llmobsMetrics.count('span.start', tags).inc(value)
    }
    function incrementLLMObsSpanFinishedCount(span, value = 1) {
      const mlObsTags = LLMObsTagger.tagMap.get(span)
      const spanTags = span.context()._tags
      const isRootSpan = mlObsTags[PARENT_ID_KEY] === ROOT_PARENT_ID
      const hasSessionId = mlObsTags[SESSION_ID] != null
      const integration = mlObsTags[INTEGRATION]
      const autoInstrumented = integration != null
      const decorator = !!mlObsTags[DECORATOR]
      const spanKind = mlObsTags[SPAN_KIND]
      const modelProvider = mlObsTags[MODEL_PROVIDER]
      const error = spanTags.error || spanTags[ERROR_TYPE]
      const tags = {
        autoinstrumented: Number(autoInstrumented),
        has_session_id: Number(hasSessionId),
        is_root_span: Number(isRootSpan),
        span_kind: spanKind,
        integration: integration || 'N/A',
        error: error ? 1 : 0,
      }
      if (!autoInstrumented) {
        tags.decorator = Number(decorator)
      }
      if (modelProvider) {
        tags.model_provider = modelProvider
      }
      llmobsMetrics.count('span.finished', tags).inc(value)
    }
    function recordLLMObsEnabled(startTime, config, value = 1) {
      const initTimeMs = performance.now() - startTime
      const autoEnabled = !!config._env?.['llmobs.enabled']
      const tags = {
        error: 0,
        agentless: Number(config.llmobs.agentlessEnabled),
        site: config.site,
        auto: Number(autoEnabled),
        ml_app: config.llmobs.mlApp,
      }
      llmobsMetrics.count('product_enabled', tags).inc(value)
      llmobsMetrics.distribution('init_time', tags).track(initTimeMs)
    }
    function recordLLMObsRawSpanSize(event, rawEventSize) {
      const tags = extractTagsFromSpanEvent(event)
      llmobsMetrics.distribution('span.raw_size', tags).track(rawEventSize)
    }
    function recordLLMObsSpanSize(event, eventSize, shouldTruncate) {
      const tags = extractTagsFromSpanEvent(event)
      tags.truncated = Number(shouldTruncate)
      llmobsMetrics.distribution('span.size', tags).track(eventSize)
    }
    function recordDroppedPayload(numEvents, eventType, error) {
      if (eventType !== 'span' && eventType !== 'evaluation_metric') return
      const metricName = eventType === 'span' ? 'dropped_span_event' : 'dropped_eval_event'
      const tags = { error }
      llmobsMetrics.count(metricName, tags).inc(numEvents)
    }
    function recordLLMObsAnnotate(span, err, value = 1) {
      const mlObsTags = LLMObsTagger.tagMap.get(span) || {}
      const spanKind = mlObsTags[SPAN_KIND] || 'N/A'
      const isRootSpan = mlObsTags[PARENT_ID_KEY] === ROOT_PARENT_ID
      const tags = {
        error: Number(!!err),
        span_kind: spanKind,
        is_root_span: Number(isRootSpan),
      }
      if (err) tags.error_type = err
      llmobsMetrics.count('annotations', tags).inc(value)
    }
    function recordUserFlush(err, value = 1) {
      const tags = { error: Number(!!err) }
      if (err) tags.error_type = err
      llmobsMetrics.count('user_flush', tags).inc(value)
    }
    function recordExportSpan(span, err, value = 1) {
      const mlObsTags = LLMObsTagger.tagMap.get(span) || {}
      const spanKind = mlObsTags[SPAN_KIND] || 'N/A'
      const isRootSpan = mlObsTags[PARENT_ID_KEY] === ROOT_PARENT_ID
      const tags = {
        error: Number(!!err),
        span_kind: spanKind,
        is_root_span: Number(isRootSpan),
      }
      if (err) tags.error_type = err
      llmobsMetrics.count('spans_exported', tags).inc(value)
    }
    function recordSubmitEvaluation(options, err, value = 1) {
      const tags = {
        error: Number(!!err),
        custom_joining_key: 0,
      }
      const metricType = options?.metricType?.toLowerCase()
      if (metricType !== 'categorical' && metricType !== 'score') tags.metric_type = 'other'
      if (err) tags.error_type = err
      llmobsMetrics.count('evals_submitted', tags).inc(value)
    }
    function recordLLMObsUserProcessorCalled(error, value = 1) {
      const tags = { error: error ? 1 : 0 }
      llmobsMetrics.count('user_processor_called', tags).inc(value)
    }
    module2.exports = {
      recordLLMObsEnabled,
      incrementLLMObsSpanStartCount,
      incrementLLMObsSpanFinishedCount,
      recordLLMObsRawSpanSize,
      recordLLMObsSpanSize,
      recordDroppedPayload,
      recordLLMObsAnnotate,
      recordUserFlush,
      recordExportSpan,
      recordSubmitEvaluation,
      recordLLMObsUserProcessorCalled,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/base.js
var require_base = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/base.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var { storage: llmobsStorage } = require_storage4()
    var telemetry = require_telemetry4()
    var TracingPlugin = require_tracing()
    var LLMObsTagger = require_tagger2()
    var LLMObsPlugin = class extends TracingPlugin {
      constructor(...args) {
        super(...args)
        this._tagger = new LLMObsTagger(this._tracerConfig, true)
      }
      setLLMObsTags(ctx) {
        throw new Error('setLLMObsTags must be implemented by the subclass')
      }
      getLLMObsSpanRegisterOptions(ctx) {
        throw new Error('getLLMObsSPanRegisterOptions must be implemented by the subclass')
      }
      start(ctx) {
        const enabled = this._tracerConfig.llmobs.enabled
        if (!enabled) return
        const parentStore = llmobsStorage.getStore()
        const apmStore = ctx.currentStore
        const span = apmStore?.span
        const registerOptions = this.getLLMObsSpanRegisterOptions(ctx)
        if (registerOptions) {
          telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: true, integration: this.constructor.integration })
          ctx.llmobs = {}
          llmobsStorage.enterWith({ ...parentStore, span })
          ctx.llmobs.parent = parentStore
          this._tagger.registerLLMObsSpan(span, {
            parent: parentStore?.span,
            integration: this.constructor.integration,
            ...registerOptions,
          })
        }
      }
      end(ctx) {
        const enabled = this._tracerConfig.llmobs.enabled
        if (!enabled) return
        const apmStore = ctx.currentStore
        const span = apmStore?.span
        if (!LLMObsTagger.tagMap.has(span)) return
        const parentStore = ctx.llmobs.parent
        llmobsStorage.enterWith(parentStore)
      }
      asyncEnd(ctx) {
        const enabled = this._tracerConfig.llmobs.enabled
        if (!enabled) return
        const apmStore = ctx.currentStore
        const span = apmStore?.span
        if (!span) {
          log.debug(
            'Tried to start an LLMObs span for %s without an active APM span. Not starting LLMObs span.',
            this.constructor.name
          )
          return
        }
        this.setLLMObsTags(ctx)
      }
      configure(config) {
        const llmobsEnabled = this._tracerConfig.llmobs.enabled
        if (llmobsEnabled === false) {
          config = typeof config === 'boolean' ? false : { ...config, enabled: false }
        }
        super.configure(config)
      }
    }
    module2.exports = LLMObsPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/anthropic.js
var require_anthropic2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/anthropic.js'(exports2, module2) {
    'use strict'
    var LLMObsPlugin = require_base()
    var ALLOWED_METADATA_KEYS = /* @__PURE__ */ new Set([
      'max_tokens',
      'stop_sequences',
      'temperature',
      'top_k',
      'top_p',
    ])
    var AnthropicLLMObsPlugin = class extends LLMObsPlugin {
      static integration = 'anthropic'
      // used for llmobs telemetry
      static id = 'anthropic'
      static prefix = 'tracing:apm:anthropic:request'
      constructor() {
        super(...arguments)
        this.addSub('apm:anthropic:request:chunk', ({ ctx, chunk, done }) => {
          ctx.chunks ??= []
          const chunks = ctx.chunks
          if (chunk) chunks.push(chunk)
          if (!done) return
          const response = { content: [] }
          for (const chunk2 of chunks) {
            switch (chunk2.type) {
              case 'message_start': {
                const { message } = chunk2
                if (!message) continue
                const { role, usage } = message
                if (role) response.role = role
                if (usage) response.usage = usage
                break
              }
              case 'content_block_start': {
                const contentBlock = chunk2.content_block
                if (!contentBlock) continue
                const { type } = contentBlock
                if (type === 'text') {
                  response.content.push({ type, text: contentBlock.text })
                } else if (type === 'tool_use') {
                  response.content.push({ type, name: contentBlock.name, input: '', id: contentBlock.id })
                }
                break
              }
              case 'content_block_delta': {
                const { delta } = chunk2
                if (!delta) continue
                const { text } = delta
                if (text) response.content[response.content.length - 1].text += text
                const partialJson = delta.partial_json
                if (partialJson && delta.type === 'input_json_delta') {
                  response.content[response.content.length - 1].input += partialJson
                }
                break
              }
              case 'content_block_stop': {
                const type = response.content[response.content.length - 1].type
                if (type === 'tool_use') {
                  const input = response.content[response.content.length - 1].input ?? '{}'
                  response.content[response.content.length - 1].input = JSON.parse(input)
                }
                break
              }
              case 'message_delta': {
                const { delta } = chunk2
                const finishReason = delta?.stop_reason
                if (finishReason) response.finish_reason = finishReason
                const { usage } = chunk2
                if (usage) {
                  const responseUsage = response.usage ?? (response.usage = { input_tokens: 0, output_tokens: 0 })
                  responseUsage.output_tokens = usage.output_tokens
                  const cacheCreationTokens = usage.cache_creation_input_tokens
                  const cacheReadTokens = usage.cache_read_input_tokens
                  if (cacheCreationTokens) responseUsage.cache_creation_input_tokens = cacheCreationTokens
                  if (cacheReadTokens) responseUsage.cache_read_input_tokens = cacheReadTokens
                }
                break
              }
              case 'error': {
                const { error } = chunk2
                if (!error) continue
                response.error = {}
                if (error.type) response.error.type = error.type
                if (error.message) response.error.message = error.message
                break
              }
            }
            ctx.result = response
          }
        })
      }
      getLLMObsSpanRegisterOptions(ctx) {
        const { options } = ctx
        const { model } = options
        return {
          kind: 'llm',
          modelName: model,
          modelProvider: 'anthropic',
        }
      }
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span
        if (!span) return
        const { options, result } = ctx
        this.#tagAnthropicInputMessages(span, options)
        this.#tagAnthropicOutputMessages(span, result)
        this.#tagAnthropicMetadata(span, options)
        this.#tagAnthropicUsage(span, result)
      }
      #tagAnthropicInputMessages(span, options) {
        const { system, messages } = options
        const inputMessages = []
        if (system) {
          messages.unshift({ content: system, role: 'system' })
        }
        for (const message of messages) {
          const { content, role } = message
          if (typeof content === 'string') {
            inputMessages.push({ content, role })
            continue
          }
          for (const block of content) {
            if (block.type === 'text') {
              inputMessages.push({ content: block.text, role })
            } else if (block.type === 'image') {
              inputMessages.push({ content: '([IMAGE DETECTED])', role })
            } else if (block.type === 'tool_use') {
              const { text, name, id, type } = block
              let input = block.input
              if (typeof input === 'string') {
                input = JSON.parse(input)
              }
              const toolCall = {
                name,
                arguments: input,
                toolId: id,
                type,
              }
              inputMessages.push({ content: text ?? '', role, toolCalls: [toolCall] })
            } else if (block.type === 'tool_result') {
              const { content: content2 } = block
              const formattedContent = this.#formatAnthropicToolResultContent(content2)
              const toolResult = {
                result: formattedContent,
                toolId: block.tool_use_id,
                type: 'tool_result',
              }
              inputMessages.push({ content: '', role, toolResults: [toolResult] })
            } else {
              inputMessages.push({ content: JSON.stringify(block), role })
            }
          }
        }
        this._tagger.tagLLMIO(span, inputMessages)
      }
      #tagAnthropicOutputMessages(span, result) {
        if (!result) return
        const { content, role } = result
        if (typeof content === 'string') {
          this._tagger.tagLLMIO(span, null, [{ content, role }])
          return
        }
        const outputMessages = []
        for (const block of content) {
          const { text } = block
          if (typeof text === 'string') {
            outputMessages.push({ content: text, role })
          } else if (block.type === 'tool_use') {
            let input = block.input
            if (typeof input === 'string') {
              input = JSON.parse(input)
            }
            const toolCall = {
              name: block.name,
              arguments: input,
              toolId: block.id,
              type: block.type,
            }
            outputMessages.push({ content: text ?? '', role, toolCalls: [toolCall] })
          }
        }
        this._tagger.tagLLMIO(span, null, outputMessages)
      }
      #tagAnthropicMetadata(span, options) {
        const metadata = {}
        for (const [key, value] of Object.entries(options)) {
          if (ALLOWED_METADATA_KEYS.has(key)) {
            metadata[key] = value
          }
        }
        this._tagger.tagMetadata(span, metadata)
      }
      #tagAnthropicUsage(span, result) {
        if (!result) return
        const { usage } = result
        if (!usage) return
        const inputTokens = usage.input_tokens
        const outputTokens = usage.output_tokens
        const cacheWriteTokens = usage.cache_creation_input_tokens
        const cacheReadTokens = usage.cache_read_input_tokens
        const metrics = {
          inputTokens: (inputTokens ?? 0) + (cacheWriteTokens ?? 0) + (cacheReadTokens ?? 0),
        }
        if (outputTokens) metrics.outputTokens = outputTokens
        const totalTokens = metrics.inputTokens + (outputTokens ?? 0)
        if (totalTokens) metrics.totalTokens = totalTokens
        if (cacheWriteTokens != null) metrics.cacheWriteTokens = cacheWriteTokens
        if (cacheReadTokens != null) metrics.cacheReadTokens = cacheReadTokens
        this._tagger.tagMetrics(span, metrics)
      }
      // maybe can make into a util file
      #formatAnthropicToolResultContent(content) {
        if (typeof content === 'string') {
          return content
        } else if (Array.isArray(content)) {
          const formattedContent = []
          for (const toolResultBlock of content) {
            if (toolResultBlock.text) {
              formattedContent.push(toolResultBlock.text)
            } else if (toolResultBlock.type === 'image') {
              formattedContent.push('([IMAGE DETECTED])')
            }
          }
          return formattedContent.join(',')
        }
        return JSON.stringify(content)
      }
    }
    module2.exports = AnthropicLLMObsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-anthropic/src/index.js
var require_src = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-anthropic/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var AnthropicTracingPlugin = require_tracing2()
    var AnthropicLLMObsPlugin = require_anthropic2()
    var AnthropicPlugin = class extends CompositePlugin {
      static id = 'anthropic'
      static get plugins() {
        return {
          llmobs: AnthropicLLMObsPlugin,
          tracing: AnthropicTracingPlugin,
        }
      }
    }
    module2.exports = AnthropicPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/apollo.js
var require_apollo2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/apollo.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var { storage } = require_datadog_core()
    var ApolloBasePlugin = class extends TracingPlugin {
      static id = 'apollo.gateway'
      static type = 'web'
      static kind = 'server'
      bindStart(ctx) {
        const store = storage('legacy').getStore()
        const childOf = store ? store.span : null
        const span = this.startSpan(
          this.getOperationName(),
          {
            childOf,
            service: this.getServiceName(),
            type: this.constructor.type,
            kind: this.constructor.kind,
            meta: {},
          },
          false
        )
        ctx.parentStore = store
        ctx.currentStore = { ...store, span }
        return ctx.currentStore
      }
      end(ctx) {
        if (!ctx.hasOwnProperty('result') && !ctx.hasOwnProperty('error')) return
        ctx?.currentStore?.span?.finish()
      }
      asyncStart(ctx) {
        ctx?.currentStore?.span.finish()
        return ctx.parentStore
      }
      getServiceName() {
        return this.serviceName({
          id: `${this.constructor.id}.${this.constructor.operation}`,
          pluginConfig: this.config,
        })
      }
      getOperationName() {
        return this.operationName({
          id: `${this.constructor.id}.${this.constructor.operation}`,
        })
      }
    }
    module2.exports = ApolloBasePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/execute.js
var require_execute = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/execute.js'(exports2, module2) {
    'use strict'
    var ApolloBasePlugin = require_apollo2()
    var ApolloGatewayExecutePlugin = class extends ApolloBasePlugin {
      static operation = 'execute'
      static prefix = 'tracing:apm:apollo:gateway:execute'
    }
    module2.exports = ApolloGatewayExecutePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/postprocessing.js
var require_postprocessing = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/postprocessing.js'(exports2, module2) {
    'use strict'
    var ApolloBasePlugin = require_apollo2()
    var ApolloGatewayPostProcessingPlugin = class extends ApolloBasePlugin {
      static operation = 'postprocessing'
      static prefix = 'tracing:apm:apollo:gateway:postprocessing'
    }
    module2.exports = ApolloGatewayPostProcessingPlugin
  },
})

// node_modules/dd-trace/vendor/dist/lodash.sortby/index.js
var require_lodash2 = __commonJS({
  'node_modules/dd-trace/vendor/dist/lodash.sortby/index.js'(exports2, module2) {
    ;(() => {
      var t = {
          './lodash.sortby/index.js': function (t2, r2, n2) {
            t2 = n2.nmd(t2)
            var e2,
              o,
              a,
              u,
              i,
              c,
              f = '__lodash_hash_undefined__',
              l = 1 / 0,
              s = '[object Arguments]',
              h = '[object Array]',
              v = '[object Boolean]',
              p = '[object Date]',
              _ = '[object Error]',
              d = '[object Function]',
              y = '[object Map]',
              b = '[object Number]',
              g = '[object Object]',
              j = '[object Promise]',
              w = '[object RegExp]',
              m = '[object Set]',
              A = '[object String]',
              O = '[object Symbol]',
              x = '[object WeakMap]',
              k = '[object ArrayBuffer]',
              S = '[object DataView]',
              $ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              E = /^\w*$/,
              F = /^\./,
              C = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
              I = /\\(\\)?/g,
              M = /^\[object .+?Constructor\]$/,
              P = /^(?:0|[1-9]\d*)$/,
              T = {}
            ;((T['[object Float32Array]'] =
              T['[object Float64Array]'] =
              T['[object Int8Array]'] =
              T['[object Int16Array]'] =
              T['[object Int32Array]'] =
              T['[object Uint8Array]'] =
              T['[object Uint8ClampedArray]'] =
              T['[object Uint16Array]'] =
              T['[object Uint32Array]'] =
                true),
              (T[s] =
                T[h] =
                T[k] =
                T[v] =
                T[S] =
                T[p] =
                T[_] =
                T[d] =
                T[y] =
                T[b] =
                T[g] =
                T[w] =
                T[m] =
                T[A] =
                T[x] =
                  false))
            var U = 'object' == typeof global && global && global.Object === Object && global,
              z = 'object' == typeof self && self && self.Object === Object && self,
              L = U || z || Function('return this')(),
              B = r2 && !r2.nodeType && r2,
              D = B && t2 && !t2.nodeType && t2,
              R = D && D.exports === B && U.process,
              V = (function () {
                try {
                  return R && R.binding('util')
                } catch (t7) {}
              })(),
              W = V && V.isTypedArray
            function G(t7, r3) {
              for (var n3 = -1, e3 = t7 ? t7.length : 0, o2 = Array(e3); ++n3 < e3; ) o2[n3] = r3(t7[n3], n3, t7)
              return o2
            }
            function N(t7) {
              return function (r3) {
                return t7(r3)
              }
            }
            function q(t7) {
              var r3 = false
              if (null != t7 && 'function' != typeof t7.toString)
                try {
                  r3 = !!(t7 + '')
                } catch (t10) {}
              return r3
            }
            function H(t7) {
              var r3 = -1,
                n3 = Array(t7.size)
              return (
                t7.forEach(function (t10, e3) {
                  n3[++r3] = [e3, t10]
                }),
                n3
              )
            }
            function J(t7) {
              var r3 = -1,
                n3 = Array(t7.size)
              return (
                t7.forEach(function (t10) {
                  n3[++r3] = t10
                }),
                n3
              )
            }
            var K = Array.prototype,
              Q = Function.prototype,
              X = Object.prototype,
              Y = L['__core-js_shared__'],
              Z = (o = /[^.]+$/.exec((Y && Y.keys && Y.keys.IE_PROTO) || '')) ? 'Symbol(src)_1.' + o : '',
              tt = Q.toString,
              tr = X.hasOwnProperty,
              tn = X.toString,
              te = RegExp(
                '^' +
                  tt
                    .call(tr)
                    .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
                  '$'
              ),
              to = L.Symbol,
              ta = L.Uint8Array,
              tu = X.propertyIsEnumerable,
              ti = K.splice,
              tc = to ? to.isConcatSpreadable : void 0,
              tf =
                ((a = Object.keys),
                (u = Object),
                function (t7) {
                  return a(u(t7))
                }),
              tl = Math.max,
              ts = tB(L, 'DataView'),
              th = tB(L, 'Map'),
              tv = tB(L, 'Promise'),
              tp = tB(L, 'Set'),
              t_ = tB(L, 'WeakMap'),
              td = tB(Object, 'create'),
              ty = tJ(ts),
              tb = tJ(th),
              tg = tJ(tv),
              tj = tJ(tp),
              tw = tJ(t_),
              tm = to ? to.prototype : void 0,
              tA = tm ? tm.valueOf : void 0,
              tO = tm ? tm.toString : void 0
            function tx(t7) {
              var r3 = -1,
                n3 = t7 ? t7.length : 0
              for (this.clear(); ++r3 < n3; ) {
                var e3 = t7[r3]
                this.set(e3[0], e3[1])
              }
            }
            function tk(t7) {
              var r3 = -1,
                n3 = t7 ? t7.length : 0
              for (this.clear(); ++r3 < n3; ) {
                var e3 = t7[r3]
                this.set(e3[0], e3[1])
              }
            }
            function tS(t7) {
              var r3 = -1,
                n3 = t7 ? t7.length : 0
              for (this.clear(); ++r3 < n3; ) {
                var e3 = t7[r3]
                this.set(e3[0], e3[1])
              }
            }
            function t$(t7) {
              var r3 = -1,
                n3 = t7 ? t7.length : 0
              for (this.__data__ = new tS(); ++r3 < n3; ) this.add(t7[r3])
            }
            function tE(t7) {
              this.__data__ = new tk(t7)
            }
            function tF(t7, r3) {
              for (var n3 = t7.length; n3--; ) if (tX(t7[n3][0], r3)) return n3
              return -1
            }
            ;((tx.prototype.clear = function () {
              this.__data__ = td ? td(null) : {}
            }),
              (tx.prototype.delete = function (t7) {
                return this.has(t7) && delete this.__data__[t7]
              }),
              (tx.prototype.get = function (t7) {
                var r3 = this.__data__
                if (td) {
                  var n3 = r3[t7]
                  return n3 === f ? void 0 : n3
                }
                return tr.call(r3, t7) ? r3[t7] : void 0
              }),
              (tx.prototype.has = function (t7) {
                var r3 = this.__data__
                return td ? void 0 !== r3[t7] : tr.call(r3, t7)
              }),
              (tx.prototype.set = function (t7, r3) {
                return ((this.__data__[t7] = td && void 0 === r3 ? f : r3), this)
              }),
              (tk.prototype.clear = function () {
                this.__data__ = []
              }),
              (tk.prototype.delete = function (t7) {
                var r3 = this.__data__,
                  n3 = tF(r3, t7)
                return !(n3 < 0) && (n3 == r3.length - 1 ? r3.pop() : ti.call(r3, n3, 1), true)
              }),
              (tk.prototype.get = function (t7) {
                var r3 = this.__data__,
                  n3 = tF(r3, t7)
                return n3 < 0 ? void 0 : r3[n3][1]
              }),
              (tk.prototype.has = function (t7) {
                return tF(this.__data__, t7) > -1
              }),
              (tk.prototype.set = function (t7, r3) {
                var n3 = this.__data__,
                  e3 = tF(n3, t7)
                return (e3 < 0 ? n3.push([t7, r3]) : (n3[e3][1] = r3), this)
              }),
              (tS.prototype.clear = function () {
                this.__data__ = { hash: new tx(), map: new (th || tk)(), string: new tx() }
              }),
              (tS.prototype.delete = function (t7) {
                return tL(this, t7).delete(t7)
              }),
              (tS.prototype.get = function (t7) {
                return tL(this, t7).get(t7)
              }),
              (tS.prototype.has = function (t7) {
                return tL(this, t7).has(t7)
              }),
              (tS.prototype.set = function (t7, r3) {
                return (tL(this, t7).set(t7, r3), this)
              }),
              (t$.prototype.add = t$.prototype.push =
                function (t7) {
                  return (this.__data__.set(t7, f), this)
                }),
              (t$.prototype.has = function (t7) {
                return this.__data__.has(t7)
              }),
              (tE.prototype.clear = function () {
                this.__data__ = new tk()
              }),
              (tE.prototype.delete = function (t7) {
                return this.__data__.delete(t7)
              }),
              (tE.prototype.get = function (t7) {
                return this.__data__.get(t7)
              }),
              (tE.prototype.has = function (t7) {
                return this.__data__.has(t7)
              }),
              (tE.prototype.set = function (t7, r3) {
                var n3 = this.__data__
                if (n3 instanceof tk) {
                  var e3 = n3.__data__
                  if (!th || e3.length < 199) return (e3.push([t7, r3]), this)
                  n3 = this.__data__ = new tS(e3)
                }
                return (n3.set(t7, r3), this)
              }))
            var tC =
                ((e2 = function (t7, r3) {
                  return t7 && tI(t7, r3, t4)
                }),
                function (t7, r3) {
                  if (null == t7) return t7
                  if (!t1(t7)) return e2(t7, r3)
                  for (var n3 = t7.length, o2 = -1, a2 = Object(t7); ++o2 < n3 && false !== r3(a2[o2], o2, a2); );
                  return t7
                }),
              tI = function (t7, r3, n3) {
                for (var e3 = -1, o2 = Object(t7), a2 = n3(t7), u2 = a2.length; u2--; ) {
                  var i2 = a2[++e3]
                  if (false === r3(o2[i2], i2, o2)) break
                }
                return t7
              }
            function tM(t7, r3) {
              var n3
              r3 = tG(r3, t7) ? [r3] : tZ((n3 = r3)) ? n3 : tq(n3)
              for (var e3 = 0, o2 = r3.length; null != t7 && e3 < o2; ) t7 = t7[tH(r3[e3++])]
              return e3 && e3 == o2 ? t7 : void 0
            }
            function tP(t7, r3) {
              return null != t7 && r3 in Object(t7)
            }
            function tT(t7, r3, n3, e3, o2) {
              return (
                t7 === r3 ||
                (null != t7 && null != r3 && (t3(t7) || t8(r3))
                  ? (function (t10, r4, n4, e4, o3, a2) {
                      var u2 = tZ(t10),
                        i2 = tZ(r4),
                        c2 = h,
                        f2 = h
                      ;(u2 || (c2 = (c2 = tD(t10)) == s ? g : c2), i2 || (f2 = (f2 = tD(r4)) == s ? g : f2))
                      var l2 = c2 == g && !q(t10),
                        d2 = f2 == g && !q(r4),
                        j2 = c2 == f2
                      if (j2 && !l2)
                        return (
                          a2 || (a2 = new tE()),
                          u2 || t9(t10)
                            ? tz(t10, r4, n4, e4, o3, a2)
                            : (function (t11, r5, n5, e5, o4, a3, u3) {
                                switch (n5) {
                                  case S:
                                    if (t11.byteLength != r5.byteLength || t11.byteOffset != r5.byteOffset) break
                                    ;((t11 = t11.buffer), (r5 = r5.buffer))
                                  case k:
                                    if (t11.byteLength != r5.byteLength || !e5(new ta(t11), new ta(r5))) break
                                    return true
                                  case v:
                                  case p:
                                  case b:
                                    return tX(+t11, +r5)
                                  case _:
                                    return t11.name == r5.name && t11.message == r5.message
                                  case w:
                                  case A:
                                    return t11 == r5 + ''
                                  case y:
                                    var i3 = H
                                  case m:
                                    var c3 = 2 & a3
                                    if ((i3 || (i3 = J), t11.size != r5.size && !c3)) break
                                    var f3 = u3.get(t11)
                                    if (f3) return f3 == r5
                                    ;((a3 |= 1), u3.set(t11, r5))
                                    var l3 = tz(i3(t11), i3(r5), e5, o4, a3, u3)
                                    return (u3.delete(t11), l3)
                                  case O:
                                    if (tA) return tA.call(t11) == tA.call(r5)
                                }
                                return false
                              })(t10, r4, c2, n4, e4, o3, a2)
                        )
                      if (!(2 & o3)) {
                        var x2 = l2 && tr.call(t10, '__wrapped__'),
                          $2 = d2 && tr.call(r4, '__wrapped__')
                        if (x2 || $2) {
                          var E2 = x2 ? t10.value() : t10,
                            F2 = $2 ? r4.value() : r4
                          return (a2 || (a2 = new tE()), n4(E2, F2, e4, o3, a2))
                        }
                      }
                      return (
                        !!j2 &&
                        (a2 || (a2 = new tE()),
                        (function (t11, r5, n5, e5, o4, a3) {
                          var u3 = 2 & o4,
                            i3 = t4(t11),
                            c3 = i3.length
                          if (c3 != t4(r5).length && !u3) return false
                          for (var f3 = c3; f3--; ) {
                            var l3 = i3[f3]
                            if (!(u3 ? l3 in r5 : tr.call(r5, l3))) return false
                          }
                          var s2 = a3.get(t11)
                          if (s2 && a3.get(r5)) return s2 == r5
                          var h2 = true
                          ;(a3.set(t11, r5), a3.set(r5, t11))
                          for (var v2 = u3; ++f3 < c3; ) {
                            var p2 = t11[(l3 = i3[f3])],
                              _2 = r5[l3]
                            if (e5) var d3 = u3 ? e5(_2, p2, l3, r5, t11, a3) : e5(p2, _2, l3, t11, r5, a3)
                            if (!(void 0 === d3 ? p2 === _2 || n5(p2, _2, e5, o4, a3) : d3)) {
                              h2 = false
                              break
                            }
                            v2 || (v2 = 'constructor' == l3)
                          }
                          if (h2 && !v2) {
                            var y2 = t11.constructor,
                              b2 = r5.constructor
                            y2 != b2 &&
                              'constructor' in t11 &&
                              'constructor' in r5 &&
                              !(
                                'function' == typeof y2 &&
                                y2 instanceof y2 &&
                                'function' == typeof b2 &&
                                b2 instanceof b2
                              ) &&
                              (h2 = false)
                          }
                          return (a3.delete(t11), a3.delete(r5), h2)
                        })(t10, r4, n4, e4, o3, a2))
                      )
                    })(t7, r3, tT, n3, e3, o2)
                  : t7 != t7 && r3 != r3)
              )
            }
            function tU(t7) {
              var r3, n3, e3, o2
              return 'function' == typeof t7
                ? t7
                : null == t7
                  ? t5
                  : 'object' == typeof t7
                    ? tZ(t7)
                      ? ((r3 = t7[0]),
                        (n3 = t7[1]),
                        tG(r3) &&
                        (function (t10) {
                          return t10 == t10 && !t3(t10)
                        })(n3)
                          ? tN(tH(r3), n3)
                          : function (t10) {
                              var e4,
                                o3,
                                a2,
                                u2,
                                i2,
                                c2 =
                                  ((e4 = t10),
                                  (o3 = r3),
                                  void 0 === (a2 = null == e4 ? void 0 : tM(e4, o3)) ? void 0 : a2)
                              return void 0 === c2 && c2 === n3
                                ? ((u2 = t10),
                                  (i2 = r3),
                                  null != u2 &&
                                    (function (t11, r4, n4) {
                                      r4 = tG(r4, t11) ? [r4] : tZ((e5 = r4)) ? e5 : tq(e5)
                                      for (var e5, o4, a3 = -1, u3 = r4.length; ++a3 < u3; ) {
                                        var i3 = tH(r4[a3])
                                        if (!(o4 = null != t11 && n4(t11, i3))) break
                                        t11 = t11[i3]
                                      }
                                      if (o4) return o4
                                      var u3 = t11 ? t11.length : 0
                                      return !!u3 && t22(u3) && tV(i3, u3) && (tZ(t11) || tY(t11))
                                    })(u2, i2, tP))
                                : tT(n3, c2, void 0, 3)
                            })
                      : 1 ==
                            (o2 = (function (t10) {
                              for (var r4 = t4(t10), n4 = r4.length; n4--; ) {
                                var e4 = r4[n4],
                                  o3 = t10[e4]
                                r4[n4] = [
                                  e4,
                                  o3,
                                  (function (t11) {
                                    return t11 == t11 && !t3(t11)
                                  })(o3),
                                ]
                              }
                              return r4
                            })((e3 = t7))).length && o2[0][2]
                        ? tN(o2[0][0], o2[0][1])
                        : function (t10) {
                            return (
                              t10 === e3 ||
                              (function (t11, r4, n4, e4) {
                                var o3 = n4.length,
                                  a2 = o3
                                if (null == t11) return !a2
                                for (t11 = Object(t11); o3--; ) {
                                  var u2 = n4[o3]
                                  if ((0, u2[2]) ? u2[1] !== t11[u2[0]] : !(u2[0] in t11)) return false
                                }
                                for (; ++o3 < a2; ) {
                                  var i2 = (u2 = n4[o3])[0],
                                    c2 = t11[i2],
                                    f2 = u2[1]
                                  if ((0, u2[2])) {
                                    if (void 0 === c2 && !(i2 in t11)) return false
                                  } else {
                                    var l2,
                                      s2 = new tE()
                                    if (!(void 0 === l2 ? tT(f2, c2, void 0, 3, s2) : l2)) return false
                                  }
                                }
                                return true
                              })(t10, 0, o2)
                            )
                          }
                    : (function (t10) {
                        var r4
                        return tG(t10)
                          ? ((r4 = tH(t10)),
                            function (t11) {
                              return null == t11 ? void 0 : t11[r4]
                            })
                          : function (r5) {
                              return tM(r5, t10)
                            }
                      })(t7)
            }
            function tz(t7, r3, n3, e3, o2, a2) {
              var u2 = 2 & o2,
                i2 = t7.length,
                c2 = r3.length
              if (i2 != c2 && !(u2 && c2 > i2)) return false
              var f2 = a2.get(t7)
              if (f2 && a2.get(r3)) return f2 == r3
              var l2 = -1,
                s2 = true,
                h2 = 1 & o2 ? new t$() : void 0
              for (a2.set(t7, r3), a2.set(r3, t7); ++l2 < i2; ) {
                var v2 = t7[l2],
                  p2 = r3[l2]
                if (e3) var _2 = u2 ? e3(p2, v2, l2, r3, t7, a2) : e3(v2, p2, l2, t7, r3, a2)
                if (void 0 !== _2) {
                  if (_2) continue
                  s2 = false
                  break
                }
                if (h2) {
                  if (
                    !(function (t10, r4) {
                      for (var n4 = -1, e4 = t10 ? t10.length : 0; ++n4 < e4; ) if (r4(t10[n4], n4, t10)) return true
                      return false
                    })(r3, function (t10, r4) {
                      if (!h2.has(r4) && (v2 === t10 || n3(v2, t10, e3, o2, a2))) return h2.add(r4)
                    })
                  ) {
                    s2 = false
                    break
                  }
                } else if (!(v2 === p2 || n3(v2, p2, e3, o2, a2))) {
                  s2 = false
                  break
                }
              }
              return (a2.delete(t7), a2.delete(r3), s2)
            }
            function tL(t7, r3) {
              var n3,
                e3,
                o2 = t7.__data__
              return (
                'string' == (e3 = typeof (n3 = r3)) || 'number' == e3 || 'symbol' == e3 || 'boolean' == e3
                  ? '__proto__' !== n3
                  : null === n3
              )
                ? o2['string' == typeof r3 ? 'string' : 'hash']
                : o2.map
            }
            function tB(t7, r3) {
              var n3,
                e3 = null == t7 ? void 0 : t7[r3]
              return !(!t3(e3) || ((n3 = e3), Z && Z in n3)) && (t0(e3) || q(e3) ? te : M).test(tJ(e3)) ? e3 : void 0
            }
            var tD = function (t7) {
              return tn.call(t7)
            }
            function tR(t7) {
              return tZ(t7) || tY(t7) || !!(tc && t7 && t7[tc])
            }
            function tV(t7, r3) {
              return (
                !!(r3 = null == r3 ? 9007199254740991 : r3) &&
                ('number' == typeof t7 || P.test(t7)) &&
                t7 > -1 &&
                t7 % 1 == 0 &&
                t7 < r3
              )
            }
            function tW(t7, r3, n3) {
              if (!t3(n3)) return false
              var e3 = typeof r3
              return ('number' == e3 ? !!(t1(n3) && tV(r3, n3.length)) : 'string' == e3 && r3 in n3) && tX(n3[r3], t7)
            }
            function tG(t7, r3) {
              if (tZ(t7)) return false
              var n3 = typeof t7
              return (
                !!('number' == n3 || 'symbol' == n3 || 'boolean' == n3 || null == t7 || t6(t7)) ||
                E.test(t7) ||
                !$.test(t7) ||
                (null != r3 && t7 in Object(r3))
              )
            }
            function tN(t7, r3) {
              return function (n3) {
                return null != n3 && n3[t7] === r3 && (void 0 !== r3 || t7 in Object(n3))
              }
            }
            ;((ts && tD(new ts(new ArrayBuffer(1))) != S) ||
              (th && tD(new th()) != y) ||
              (tv && tD(tv.resolve()) != j) ||
              (tp && tD(new tp()) != m) ||
              (t_ && tD(new t_()) != x)) &&
              (tD = function (t7) {
                var r3 = tn.call(t7),
                  n3 = r3 == g ? t7.constructor : void 0,
                  e3 = n3 ? tJ(n3) : void 0
                if (e3)
                  switch (e3) {
                    case ty:
                      return S
                    case tb:
                      return y
                    case tg:
                      return j
                    case tj:
                      return m
                    case tw:
                      return x
                  }
                return r3
              })
            var tq = tQ(function (t7) {
              t7 =
                null == (r3 = t7)
                  ? ''
                  : (function (t10) {
                      if ('string' == typeof t10) return t10
                      if (t6(t10)) return tO ? tO.call(t10) : ''
                      var r4 = t10 + ''
                      return '0' == r4 && 1 / t10 == -l ? '-0' : r4
                    })(r3)
              var r3,
                n3 = []
              return (
                F.test(t7) && n3.push(''),
                t7.replace(C, function (t10, r4, e3, o2) {
                  n3.push(e3 ? o2.replace(I, '$1') : r4 || t10)
                }),
                n3
              )
            })
            function tH(t7) {
              if ('string' == typeof t7 || t6(t7)) return t7
              var r3 = t7 + ''
              return '0' == r3 && 1 / t7 == -l ? '-0' : r3
            }
            function tJ(t7) {
              if (null != t7) {
                try {
                  return tt.call(t7)
                } catch (t10) {}
                try {
                  return t7 + ''
                } catch (t10) {}
              }
              return ''
            }
            var tK =
              ((i = function (t7, r3) {
                if (null == t7) return []
                var n3 = r3.length
                return (
                  n3 > 1 && tW(t7, r3[0], r3[1]) ? (r3 = []) : n3 > 2 && tW(r3[0], r3[1], r3[2]) && (r3 = [r3[0]]),
                  (function (t10, r4, n4) {
                    var e3,
                      o2,
                      a2,
                      u2 = -1
                    r4 = G(r4.length ? r4 : [t5], N(tU))
                    var i2 =
                        ((e3 = function (t11, n5, e4) {
                          return {
                            criteria: G(r4, function (r5) {
                              return r5(t11)
                            }),
                            index: ++u2,
                            value: t11,
                          }
                        }),
                        (o2 = -1),
                        (a2 = t1(t10) ? Array(t10.length) : []),
                        tC(t10, function (t11, r5, n5) {
                          a2[++o2] = e3(t11, r5, n5)
                        }),
                        a2),
                      c2 = i2.length
                    for (
                      i2.sort(function (t11, r5) {
                        return (function (t12, r6, n5) {
                          for (
                            var e4 = -1, o3 = t12.criteria, a3 = r6.criteria, u3 = o3.length, i3 = n5.length;
                            ++e4 < u3;
                          ) {
                            var c3 = (function (t13, r7) {
                              if (t13 !== r7) {
                                var n6 = void 0 !== t13,
                                  e5 = null === t13,
                                  o4 = t13 == t13,
                                  a4 = t6(t13),
                                  u4 = void 0 !== r7,
                                  i4 = null === r7,
                                  c4 = r7 == r7,
                                  f2 = t6(r7)
                                if (
                                  (!i4 && !f2 && !a4 && t13 > r7) ||
                                  (a4 && u4 && c4 && !i4 && !f2) ||
                                  (e5 && u4 && c4) ||
                                  (!n6 && c4) ||
                                  !o4
                                )
                                  return 1
                                if (
                                  (!e5 && !a4 && !f2 && t13 < r7) ||
                                  (f2 && n6 && o4 && !e5 && !a4) ||
                                  (i4 && n6 && o4) ||
                                  (!u4 && o4) ||
                                  !c4
                                )
                                  return -1
                              }
                              return 0
                            })(o3[e4], a3[e4])
                            if (c3) {
                              if (e4 >= i3) return c3
                              return c3 * ('desc' == n5[e4] ? -1 : 1)
                            }
                          }
                          return t12.index - r6.index
                        })(t11, r5, n4)
                      });
                      c2--;
                    )
                      i2[c2] = i2[c2].value
                    return i2
                  })(
                    t7,
                    (function t10(r4, n4, e3, o2, a2) {
                      var u2 = -1,
                        i2 = r4.length
                      for (e3 || (e3 = tR), a2 || (a2 = []); ++u2 < i2; ) {
                        var c2 = r4[u2]
                        n4 > 0 && e3(c2)
                          ? n4 > 1
                            ? t10(c2, n4 - 1, e3, o2, a2)
                            : (function (t11, r5) {
                                for (var n5 = -1, e4 = r5.length, o3 = t11.length; ++n5 < e4; ) t11[o3 + n5] = r5[n5]
                              })(a2, c2)
                          : o2 || (a2[a2.length] = c2)
                      }
                      return a2
                    })(r3, 1),
                    []
                  )
                )
              }),
              (c = tl(void 0 === c ? i.length - 1 : c, 0)),
              function () {
                for (var t7 = arguments, r3 = -1, n3 = tl(t7.length - c, 0), e3 = Array(n3); ++r3 < n3; )
                  e3[r3] = t7[c + r3]
                r3 = -1
                for (var o2 = Array(c + 1); ++r3 < c; ) o2[r3] = t7[r3]
                o2[c] = e3
                switch (o2.length) {
                  case 0:
                    return i.call(this)
                  case 1:
                    return i.call(this, o2[0])
                  case 2:
                    return i.call(this, o2[0], o2[1])
                  case 3:
                    return i.call(this, o2[0], o2[1], o2[2])
                }
                return i.apply(this, o2)
              })
            function tQ(t7, r3) {
              if ('function' != typeof t7 || (r3 && 'function' != typeof r3)) throw TypeError('Expected a function')
              var n3 = function () {
                var e3 = arguments,
                  o2 = r3 ? r3.apply(this, e3) : e3[0],
                  a2 = n3.cache
                if (a2.has(o2)) return a2.get(o2)
                var u2 = t7.apply(this, e3)
                return ((n3.cache = a2.set(o2, u2)), u2)
              }
              return ((n3.cache = new (tQ.Cache || tS)()), n3)
            }
            function tX(t7, r3) {
              return t7 === r3 || (t7 != t7 && r3 != r3)
            }
            function tY(t7) {
              var r3
              return t8((r3 = t7)) && t1(r3) && tr.call(t7, 'callee') && (!tu.call(t7, 'callee') || tn.call(t7) == s)
            }
            tQ.Cache = tS
            var tZ = Array.isArray
            function t1(t7) {
              return null != t7 && t22(t7.length) && !t0(t7)
            }
            function t0(t7) {
              var r3 = t3(t7) ? tn.call(t7) : ''
              return r3 == d || '[object GeneratorFunction]' == r3
            }
            function t22(t7) {
              return 'number' == typeof t7 && t7 > -1 && t7 % 1 == 0 && t7 <= 9007199254740991
            }
            function t3(t7) {
              var r3 = typeof t7
              return !!t7 && ('object' == r3 || 'function' == r3)
            }
            function t8(t7) {
              return !!t7 && 'object' == typeof t7
            }
            function t6(t7) {
              return 'symbol' == typeof t7 || (t8(t7) && tn.call(t7) == O)
            }
            var t9 = W
              ? N(W)
              : function (t7) {
                  return t8(t7) && t22(t7.length) && !!T[tn.call(t7)]
                }
            function t4(t7) {
              return t1(t7)
                ? (function (t10, r3) {
                    var n3 =
                        tZ(t10) || tY(t10)
                          ? (function (t11, r4) {
                              for (var n4 = -1, e4 = Array(t11); ++n4 < t11; ) e4[n4] = r4(n4)
                              return e4
                            })(t10.length, String)
                          : [],
                      e3 = n3.length,
                      o2 = !!e3
                    for (var a2 in t10) tr.call(t10, a2) && !(o2 && ('length' == a2 || tV(a2, e3))) && n3.push(a2)
                    return n3
                  })(t7)
                : (function (t10) {
                    if (((n3 = (r3 = t10) && r3.constructor), r3 !== (('function' == typeof n3 && n3.prototype) || X)))
                      return tf(t10)
                    var r3,
                      n3,
                      e3 = []
                    for (var o2 in Object(t10)) tr.call(t10, o2) && 'constructor' != o2 && e3.push(o2)
                    return e3
                  })(t7)
            }
            function t5(t7) {
              return t7
            }
            t2.exports = tK
          },
        },
        r = {}
      function n(e2) {
        var o = r[e2]
        if (void 0 !== o) return o.exports
        var a = (r[e2] = { id: e2, loaded: false, exports: {} })
        return (t[e2](a, a.exports, n), (a.loaded = true), a.exports)
      }
      n.nmd = (t2) => ((t2.paths = []), t2.children || (t2.children = []), t2)
      var e = n('./lodash.sortby/index.js')
      module2.exports = e
    })()
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js
var require_transforms = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js'(exports2) {
    'use strict'
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod2) {
        return mod2 && mod2.__esModule ? mod2 : { default: mod2 }
      }
    Object.defineProperty(exports2, '__esModule', { value: true })
    var ddGlobal = globalThis[/* @__PURE__ */ Symbol.for('dd-trace')]
    var visitor_1 = ddGlobal.graphql_visitor
    var printer_1 = ddGlobal.graphql_printer
    var utilities_1 = ddGlobal.graphql_utilities
    var lodash_sortby_1 = __importDefault(require_lodash2())
    function hideLiterals(ast) {
      return visitor_1.visit(ast, {
        IntValue(node) {
          return Object.assign({}, node, { value: '0' })
        },
        FloatValue(node) {
          return Object.assign({}, node, { value: '0' })
        },
        StringValue(node) {
          return Object.assign({}, node, { value: '', block: false })
        },
        ListValue(node) {
          return Object.assign({}, node, { values: [] })
        },
        ObjectValue(node) {
          return Object.assign({}, node, { fields: [] })
        },
      })
    }
    exports2.hideLiterals = hideLiterals
    function hideStringAndNumericLiterals(ast) {
      return visitor_1.visit(ast, {
        IntValue(node) {
          return Object.assign({}, node, { value: '0' })
        },
        FloatValue(node) {
          return Object.assign({}, node, { value: '0' })
        },
        StringValue(node) {
          return Object.assign({}, node, { value: '', block: false })
        },
      })
    }
    exports2.hideStringAndNumericLiterals = hideStringAndNumericLiterals
    function dropUnusedDefinitions(ast, operationName) {
      const separated = utilities_1.separateOperations(ast)[operationName]
      if (!separated) {
        return ast
      }
      return separated
    }
    exports2.dropUnusedDefinitions = dropUnusedDefinitions
    function sorted(items) {
      if (items) {
        return lodash_sortby_1.default.apply(null, arguments)
      }
      return void 0
    }
    function sortAST(ast) {
      return visitor_1.visit(ast, {
        OperationDefinition(node) {
          return Object.assign({}, node, {
            variableDefinitions: sorted(node.variableDefinitions, 'variable.name.value'),
          })
        },
        SelectionSet(node) {
          return Object.assign({}, node, { selections: lodash_sortby_1.default(node.selections, 'kind', 'name.value') })
        },
        Field(node) {
          return Object.assign({}, node, { arguments: sorted(node.arguments, 'name.value') })
        },
        FragmentSpread(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, 'name.value') })
        },
        InlineFragment(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, 'name.value') })
        },
        FragmentDefinition(node) {
          return Object.assign({}, node, {
            directives: sorted(node.directives, 'name.value'),
            variableDefinitions: sorted(node.variableDefinitions, 'variable.name.value'),
          })
        },
        Directive(node) {
          return Object.assign({}, node, { arguments: sorted(node.arguments, 'name.value') })
        },
      })
    }
    exports2.sortAST = sortAST
    function removeAliases(ast) {
      return visitor_1.visit(ast, {
        Field(node) {
          return Object.assign({}, node, { alias: void 0 })
        },
      })
    }
    exports2.removeAliases = removeAliases
    function printWithReducedWhitespace(ast) {
      const sanitizedAST = visitor_1.visit(ast, {
        StringValue(node) {
          return Object.assign({}, node, { value: Buffer.from(node.value, 'utf8').toString('hex'), block: false })
        },
      })
      const withWhitespace = printer_1.print(sanitizedAST)
      const minimizedButStillHex = withWhitespace
        .replace(/\s+/g, ' ')
        .replace(/([^_a-zA-Z0-9]) /g, (_, c) => c)
        .replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c)
      return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) =>
        JSON.stringify(Buffer.from(hex, 'hex').toString('utf8'))
      )
    }
    exports2.printWithReducedWhitespace = printWithReducedWhitespace
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js
var require_signature = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js'(exports2) {
    'use strict'
    Object.defineProperty(exports2, '__esModule', { value: true })
    var transforms_1 = require_transforms()
    function defaultEngineReportingSignature(ast, operationName) {
      return transforms_1.printWithReducedWhitespace(
        transforms_1.sortAST(
          transforms_1.removeAliases(transforms_1.hideLiterals(transforms_1.dropUnusedDefinitions(ast, operationName)))
        )
      )
    }
    exports2.defaultEngineReportingSignature = defaultEngineReportingSignature
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js
var require_tools = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js'(exports2) {
    'use strict'
    Object.defineProperty(exports2, '__esModule', { value: true })
    var signature_1 = require_signature()
    exports2.defaultEngineReportingSignature = signature_1.defaultEngineReportingSignature
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/request.js
var require_request2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/request.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var ApolloBasePlugin = require_apollo2()
    var tools
    var OPERATION_DEFINITION = 'OperationDefinition'
    var FRAGMENT_DEFINITION = 'FragmentDefinition'
    var ApolloGatewayRequestPlugin = class extends ApolloBasePlugin {
      static operation = 'request'
      static prefix = 'tracing:apm:apollo:gateway:request'
      bindStart(ctx) {
        const store = storage('legacy').getStore()
        const childOf = store ? store.span : null
        const spanData = {
          childOf,
          service: this.serviceName({
            id: `${this.constructor.id}.${this.constructor.operation}`,
            pluginConfig: this.config,
          }),
          type: this.constructor.type,
          kind: this.constructor.kind,
          meta: {},
        }
        const { requestContext, gateway } = ctx
        if (requestContext?.operationName) {
          spanData.meta['graphql.operation.name'] = requestContext.operationName
        }
        if ((this.config.source || gateway?.config?.telemetry?.includeDocument) && requestContext?.source) {
          spanData.meta['graphql.source'] = requestContext.source
        }
        const operationContext = buildOperationContext(
          gateway.schema,
          requestContext.document,
          requestContext.request.operationName
        )
        if (operationContext?.operation?.operation) {
          const document = requestContext?.document
          const type = operationContext?.operation?.operation
          const name = operationContext?.operation?.name && operationContext?.operation?.name?.value
          spanData.resource = getSignature(document, name, type, this?.config?.signature)
          spanData.meta['graphql.operation.type'] = type
        }
        const span = this.startSpan(
          this.operationName({ id: `${this.constructor.id}.${this.constructor.operation}` }),
          spanData,
          false
        )
        ctx.parentStore = store
        ctx.currentStore = { ...store, span }
        return ctx.currentStore
      }
      asyncStart(ctx) {
        const errors = ctx?.result?.errors
        if (Array.isArray(errors) && errors.at(-1)?.stack && errors.at(-1).message) {
          ctx.currentStore.span.setTag('error', errors.at(-1))
        }
        ctx.currentStore.span.finish()
        return ctx.parentStore
      }
    }
    function buildOperationContext(schema, operationDocument, operationName) {
      let operation
      let operationCount = 0
      const fragments = /* @__PURE__ */ Object.create(null)
      try {
        operationDocument.definitions.forEach((definition) => {
          switch (definition.kind) {
            case OPERATION_DEFINITION:
              operationCount++
              if (!operationName && operationCount > 1) {
                return
              }
              if (!operationName || (definition.name && definition.name.value === operationName)) {
                operation = definition
              }
              break
            case FRAGMENT_DEFINITION:
              fragments[definition.name.value] = definition
              break
          }
        })
      } catch {}
      return {
        schema,
        operation,
        fragments,
      }
    }
    function getSignature(document, operationName, operationType, calculate) {
      if (calculate !== false && tools !== false) {
        try {
          try {
            tools = tools || require_tools()
          } catch (e) {
            tools = false
            throw e
          }
          return tools.defaultEngineReportingSignature(document, operationName)
        } catch {}
      }
      return [operationType, operationName].filter(Boolean).join(' ')
    }
    module2.exports = ApolloGatewayRequestPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/plan.js
var require_plan = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/plan.js'(exports2, module2) {
    'use strict'
    var ApolloBasePlugin = require_apollo2()
    var ApolloGatewayPlanPlugin = class extends ApolloBasePlugin {
      static operation = 'plan'
      static prefix = 'tracing:apm:apollo:gateway:plan'
    }
    module2.exports = ApolloGatewayPlanPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/validate.js
var require_validate = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/validate.js'(exports2, module2) {
    'use strict'
    var ApolloBasePlugin = require_apollo2()
    var ApolloGatewayValidatePlugin = class extends ApolloBasePlugin {
      static operation = 'validate'
      static prefix = 'tracing:apm:apollo:gateway:validate'
      end(ctx) {
        const result = ctx.result
        const span = ctx.currentStore?.span
        if (!span) return
        if (Array.isArray(result) && result.at(-1)?.stack && result.at(-1).message) {
          span.setTag('error', result.at(-1))
        }
        span.finish()
      }
    }
    module2.exports = ApolloGatewayValidatePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/fetch.js
var require_fetch2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/fetch.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var ApolloBasePlugin = require_apollo2()
    var ApolloGatewayFetchPlugin = class extends ApolloBasePlugin {
      static operation = 'fetch'
      static prefix = 'tracing:apm:apollo:gateway:fetch'
      bindStart(ctx) {
        const store = storage('legacy').getStore()
        const childOf = store ? store.span : null
        const spanData = {
          childOf,
          service: this.getServiceName(),
          type: this.constructor.type,
          meta: {},
        }
        const serviceName = ctx?.attributes?.service
        if (serviceName) {
          spanData.meta.serviceName = serviceName
        }
        const span = this.startSpan(this.getOperationName(), spanData, false)
        ctx.parentStore = store
        ctx.currentStore = { ...store, span }
        return ctx.currentStore
      }
    }
    module2.exports = ApolloGatewayFetchPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/index.js
var require_gateway = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/gateway/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var CompositePlugin = require_composite()
    var ApolloGatewayExecutePlugin = require_execute()
    var ApolloGatewayPostProcessingPlugin = require_postprocessing()
    var ApolloGatewayRequestPlugin = require_request2()
    var ApolloGatewayPlanPlugin = require_plan()
    var ApolloGatewayValidatePlugin = require_validate()
    var ApolloGatewayFetchPlugin = require_fetch2()
    var ApolloGatewayPlugin = class extends CompositePlugin {
      static id = 'gateway'
      static get plugins() {
        return {
          execute: ApolloGatewayExecutePlugin,
          postprocessing: ApolloGatewayPostProcessingPlugin,
          request: ApolloGatewayRequestPlugin,
          plan: ApolloGatewayPlanPlugin,
          fetch: ApolloGatewayFetchPlugin,
          validate: ApolloGatewayValidatePlugin,
        }
      }
      constructor(...args) {
        super(...args)
        this.addSub('apm:apollo:gateway:general:error', (ctx) => {
          const store = storage('legacy').getStore()
          const span = store?.span
          if (!span) return
          span.setTag('error', ctx.error)
        })
      }
    }
    module2.exports = ApolloGatewayPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-apollo/src/index.js
var require_src2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-apollo/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var ApolloGatewayPlugin = require_gateway()
    var ApolloPlugin = class extends CompositePlugin {
      static id = 'apollo'
      static get plugins() {
        return {
          gateway: ApolloGatewayPlugin,
        }
      }
    }
    module2.exports = ApolloPlugin
  },
})

// node_modules/dd-trace/packages/datadog-code-origin/index.js
var require_datadog_code_origin = __commonJS({
  'node_modules/dd-trace/packages/datadog-code-origin/index.js'(exports2, module2) {
    'use strict'
    var { parseUserLandFrames } = require_stacktrace()
    var ENTRY_SPAN_STACK_FRAMES_LIMIT = 1
    var EXIT_SPAN_STACK_FRAMES_LIMIT = Number(process.env._DD_CODE_ORIGIN_FOR_SPANS_EXIT_SPAN_MAX_USER_FRAMES) || 8
    module2.exports = {
      entryTags,
      exitTags,
    }
    function entryTags(topOfStackFunc) {
      return tag('entry', topOfStackFunc, ENTRY_SPAN_STACK_FRAMES_LIMIT)
    }
    function exitTags(topOfStackFunc) {
      return tag('exit', topOfStackFunc, EXIT_SPAN_STACK_FRAMES_LIMIT)
    }
    function tag(type, topOfStackFunc, limit) {
      const originalLimit = Error.stackTraceLimit
      Error.stackTraceLimit = Infinity
      const dummy = {}
      Error.captureStackTrace(dummy, topOfStackFunc)
      const frames = parseUserLandFrames(dummy.stack, limit)
      Error.stackTraceLimit = originalLimit
      const tags = {
        '_dd.code_origin.type': type,
      }
      for (let i = 0; i < frames.length; i++) {
        const frame = frames[i]
        tags[`_dd.code_origin.frames.${i}.file`] = frame.fileName
        tags[`_dd.code_origin.frames.${i}.line`] = frame.lineNumber
        tags[`_dd.code_origin.frames.${i}.column`] = frame.columnNumber
        if (frame.methodName || frame.functionName) {
          tags[`_dd.code_origin.frames.${i}.method`] = frame.methodName || frame.functionName
        }
        if (frame.typeName) {
          tags[`_dd.code_origin.frames.${i}.type`] = frame.typeName
        }
      }
      return tags
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/outbound.js
var require_outbound = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/outbound.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY, PEER_SERVICE_KEY, PEER_SERVICE_SOURCE_KEY, PEER_SERVICE_REMAP_KEY } = require_constants2()
    var TracingPlugin = require_tracing()
    var { exitTags } = require_datadog_code_origin()
    var { storage } = require_datadog_core()
    var COMMON_PEER_SVC_SOURCE_TAGS = ['net.peer.name', 'out.host']
    var OutboundPlugin = class extends TracingPlugin {
      static peerServicePrecursors = []
      constructor(...args) {
        super(...args)
        this.addTraceSub('connect', (ctx) => {
          this.connect(ctx)
        })
      }
      bindFinish(ctx) {
        return ctx.parentStore
      }
      startSpan(...args) {
        const span = super.startSpan(...args)
        if (
          this._tracerConfig.codeOriginForSpans.enabled &&
          this._tracerConfig.codeOriginForSpans.experimental.exit_spans.enabled
        ) {
          span.addTags(exitTags(this.startSpan))
        }
        return span
      }
      getPeerService(tags) {
        if (tags[PEER_SERVICE_KEY] !== void 0) {
          return {
            [PEER_SERVICE_KEY]: tags[PEER_SERVICE_KEY],
            [PEER_SERVICE_SOURCE_KEY]: PEER_SERVICE_KEY,
          }
        }
        const sourceTags = [...this.constructor.peerServicePrecursors, ...COMMON_PEER_SVC_SOURCE_TAGS]
        for (const sourceTag of sourceTags) {
          if (tags[sourceTag]) {
            return {
              [PEER_SERVICE_KEY]: tags[sourceTag],
              [PEER_SERVICE_SOURCE_KEY]: sourceTag,
            }
          }
        }
      }
      getPeerServiceRemap(peerData) {
        const peerService = peerData[PEER_SERVICE_KEY]
        const mappedService = this._tracerConfig.peerServiceMapping?.[peerService]
        if (peerService && mappedService) {
          return {
            ...peerData,
            [PEER_SERVICE_KEY]: mappedService,
            [PEER_SERVICE_REMAP_KEY]: peerService,
          }
        }
        return peerData
      }
      finish(ctx) {
        const span = ctx?.currentStore?.span || this.activeSpan
        this.tagPeerService(span)
        if (this._tracerConfig?._isInServerlessEnvironment()) {
          const peerHostname = storage('peerServerless').getStore()?.peerHostname
          if (peerHostname) span.setTag('peer.service', peerHostname)
        }
        super.finish(...arguments)
      }
      tagPeerService(span) {
        if (this._tracerConfig.spanComputePeerService) {
          const peerData = this.getPeerService(span.context()._tags)
          if (peerData !== void 0) {
            span.addTags(this.getPeerServiceRemap(peerData))
          }
        }
      }
      connect(ctx) {
        this.addHost(ctx)
      }
      addHost(ctx) {
        const { hostname, port } = ctx
        const span = ctx?.currentStore?.span || this.activeSpan
        if (!span) return
        span.addTags({
          'out.host': hostname,
          [CLIENT_PORT_KEY]: port,
        })
      }
    }
    module2.exports = OutboundPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/client.js
var require_client5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/client.js'(exports2, module2) {
    'use strict'
    var OutboundPlugin = require_outbound()
    var ClientPlugin = class extends OutboundPlugin {
      static operation = 'request'
      static kind = 'client'
      static type = 'web'
      // overridden by storage and other client type plugins
    }
    module2.exports = ClientPlugin
  },
})

// node_modules/dd-trace/vendor/dist/rfdc/index.js
var require_rfdc = __commonJS({
  'node_modules/dd-trace/vendor/dist/rfdc/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var t = {
          './rfdc/index.js': function (t2) {
            function e2(t3) {
              return t3 instanceof Buffer
                ? Buffer.from(t3)
                : new t3.constructor(t3.buffer.slice(), t3.byteOffset, t3.length)
            }
            t2.exports = function (t3) {
              if ((t3 = t3 || {}).circles)
                return (function (t4) {
                  let r3 = [],
                    n2 = [],
                    o2 = /* @__PURE__ */ new Map()
                  if (
                    (o2.set(Date, (t5) => new Date(t5)),
                    o2.set(Map, (t5, e3) => new Map(f(Array.from(t5), e3))),
                    o2.set(Set, (t5, e3) => new Set(f(Array.from(t5), e3))),
                    t4.constructorHandlers)
                  )
                    for (let e3 of t4.constructorHandlers) o2.set(e3[0], e3[1])
                  let c = null
                  return t4.proto
                    ? function t5(u) {
                        if ('object' != typeof u || null === u) return u
                        if (Array.isArray(u)) return f(u, t5)
                        if (u.constructor !== Object && (c = o2.get(u.constructor))) return c(u, t5)
                        let s = {}
                        for (let f2 in (r3.push(u), n2.push(s), u)) {
                          let l = u[f2]
                          if ('object' != typeof l || null === l) s[f2] = l
                          else if (l.constructor !== Object && (c = o2.get(l.constructor))) s[f2] = c(l, t5)
                          else if (ArrayBuffer.isView(l)) s[f2] = e2(l)
                          else {
                            let e3 = r3.indexOf(l)
                            ;-1 !== e3 ? (s[f2] = n2[e3]) : (s[f2] = t5(l))
                          }
                        }
                        return (r3.pop(), n2.pop(), s)
                      }
                    : function t5(u) {
                        if ('object' != typeof u || null === u) return u
                        if (Array.isArray(u)) return f(u, t5)
                        if (u.constructor !== Object && (c = o2.get(u.constructor))) return c(u, t5)
                        let s = {}
                        for (let f2 in (r3.push(u), n2.push(s), u)) {
                          if (false === Object.hasOwnProperty.call(u, f2)) continue
                          let l = u[f2]
                          if ('object' != typeof l || null === l) s[f2] = l
                          else if (l.constructor !== Object && (c = o2.get(l.constructor))) s[f2] = c(l, t5)
                          else if (ArrayBuffer.isView(l)) s[f2] = e2(l)
                          else {
                            let e3 = r3.indexOf(l)
                            ;-1 !== e3 ? (s[f2] = n2[e3]) : (s[f2] = t5(l))
                          }
                        }
                        return (r3.pop(), n2.pop(), s)
                      }
                  function f(t5, f2) {
                    let u = Object.keys(t5),
                      s = Array(u.length)
                    for (let l = 0; l < u.length; l++) {
                      let i = u[l],
                        a = t5[i]
                      if ('object' != typeof a || null === a) s[i] = a
                      else if (a.constructor !== Object && (c = o2.get(a.constructor))) s[i] = c(a, f2)
                      else if (ArrayBuffer.isView(a)) s[i] = e2(a)
                      else {
                        let t6 = r3.indexOf(a)
                        ;-1 !== t6 ? (s[i] = n2[t6]) : (s[i] = f2(a))
                      }
                    }
                    return s
                  }
                })(t3)
              let r2 = /* @__PURE__ */ new Map()
              if (
                (r2.set(Date, (t4) => new Date(t4)),
                r2.set(Map, (t4, e3) => new Map(o(Array.from(t4), e3))),
                r2.set(Set, (t4, e3) => new Set(o(Array.from(t4), e3))),
                t3.constructorHandlers)
              )
                for (let e3 of t3.constructorHandlers) r2.set(e3[0], e3[1])
              let n = null
              return t3.proto
                ? function t4(c) {
                    if ('object' != typeof c || null === c) return c
                    if (Array.isArray(c)) return o(c, t4)
                    if (c.constructor !== Object && (n = r2.get(c.constructor))) return n(c, t4)
                    let f = {}
                    for (let o2 in c) {
                      let u = c[o2]
                      'object' != typeof u || null === u
                        ? (f[o2] = u)
                        : u.constructor !== Object && (n = r2.get(u.constructor))
                          ? (f[o2] = n(u, t4))
                          : ArrayBuffer.isView(u)
                            ? (f[o2] = e2(u))
                            : (f[o2] = t4(u))
                    }
                    return f
                  }
                : function t4(c) {
                    if ('object' != typeof c || null === c) return c
                    if (Array.isArray(c)) return o(c, t4)
                    if (c.constructor !== Object && (n = r2.get(c.constructor))) return n(c, t4)
                    let f = {}
                    for (let o2 in c) {
                      if (false === Object.hasOwnProperty.call(c, o2)) continue
                      let u = c[o2]
                      'object' != typeof u || null === u
                        ? (f[o2] = u)
                        : u.constructor !== Object && (n = r2.get(u.constructor))
                          ? (f[o2] = n(u, t4))
                          : ArrayBuffer.isView(u)
                            ? (f[o2] = e2(u))
                            : (f[o2] = t4(u))
                    }
                    return f
                  }
              function o(t4, o2) {
                let c = Object.keys(t4),
                  f = Array(c.length)
                for (let u = 0; u < c.length; u++) {
                  let s = c[u],
                    l = t4[s]
                  'object' != typeof l || null === l
                    ? (f[s] = l)
                    : l.constructor !== Object && (n = r2.get(l.constructor))
                      ? (f[s] = n(l, o2))
                      : ArrayBuffer.isView(l)
                        ? (f[s] = e2(l))
                        : (f[s] = o2(l))
                }
                return f
              }
            }
          },
        },
        e = {},
        r = (function r2(n) {
          var o = e[n]
          if (void 0 !== o) return o.exports
          var c = (e[n] = { exports: {} })
          return (t[n](c, c.exports, r2), c.exports)
        })('./rfdc/index.js')
      module2.exports = r
    })()
  },
})

// node_modules/dd-trace/vendor/dist/jsonpath-plus/index.js
var require_jsonpath_plus = __commonJS({
  'node_modules/dd-trace/vendor/dist/jsonpath-plus/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e = {}
      ;((e.d = (t2, r2) => {
        for (var i2 in r2)
          e.o(r2, i2) && !e.o(t2, i2) && Object.defineProperty(t2, i2, { enumerable: true, get: r2[i2] })
      }),
        (e.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2)),
        (e.r = (e2) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e2, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(e2, '__esModule', { value: true }))
        }))
      var t = {}
      ;(e.r(t), e.d(t, { JSONPath: () => u }))
      let r = require('vm')
      class i {
        static get version() {
          return '1.4.0'
        }
        static toString() {
          return 'JavaScript Expression Parser (JSEP) v' + i.version
        }
        static addUnaryOp(e2) {
          return ((i.max_unop_len = Math.max(e2.length, i.max_unop_len)), (i.unary_ops[e2] = 1), i)
        }
        static addBinaryOp(e2, t2, r2) {
          return (
            (i.max_binop_len = Math.max(e2.length, i.max_binop_len)),
            (i.binary_ops[e2] = t2),
            r2 ? i.right_associative.add(e2) : i.right_associative.delete(e2),
            i
          )
        }
        static addIdentifierChar(e2) {
          return (i.additional_identifier_chars.add(e2), i)
        }
        static addLiteral(e2, t2) {
          return ((i.literals[e2] = t2), i)
        }
        static removeUnaryOp(e2) {
          return (
            delete i.unary_ops[e2],
            e2.length === i.max_unop_len && (i.max_unop_len = i.getMaxKeyLen(i.unary_ops)),
            i
          )
        }
        static removeAllUnaryOps() {
          return ((i.unary_ops = {}), (i.max_unop_len = 0), i)
        }
        static removeIdentifierChar(e2) {
          return (i.additional_identifier_chars.delete(e2), i)
        }
        static removeBinaryOp(e2) {
          return (
            delete i.binary_ops[e2],
            e2.length === i.max_binop_len && (i.max_binop_len = i.getMaxKeyLen(i.binary_ops)),
            i.right_associative.delete(e2),
            i
          )
        }
        static removeAllBinaryOps() {
          return ((i.binary_ops = {}), (i.max_binop_len = 0), i)
        }
        static removeLiteral(e2) {
          return (delete i.literals[e2], i)
        }
        static removeAllLiterals() {
          return ((i.literals = {}), i)
        }
        get char() {
          return this.expr.charAt(this.index)
        }
        get code() {
          return this.expr.charCodeAt(this.index)
        }
        constructor(e2) {
          ;((this.expr = e2), (this.index = 0))
        }
        static parse(e2) {
          return new i(e2).parse()
        }
        static getMaxKeyLen(e2) {
          return Math.max(0, ...Object.keys(e2).map((e3) => e3.length))
        }
        static isDecimalDigit(e2) {
          return e2 >= 48 && e2 <= 57
        }
        static binaryPrecedence(e2) {
          return i.binary_ops[e2] || 0
        }
        static isIdentifierStart(e2) {
          return (
            (e2 >= 65 && e2 <= 90) ||
            (e2 >= 97 && e2 <= 122) ||
            (e2 >= 128 && !i.binary_ops[String.fromCharCode(e2)]) ||
            i.additional_identifier_chars.has(String.fromCharCode(e2))
          )
        }
        static isIdentifierPart(e2) {
          return i.isIdentifierStart(e2) || i.isDecimalDigit(e2)
        }
        throwError(e2) {
          let t2 = Error(e2 + ' at character ' + this.index)
          throw ((t2.index = this.index), (t2.description = e2), t2)
        }
        runHook(e2, t2) {
          if (i.hooks[e2]) {
            let r2 = { context: this, node: t2 }
            return (i.hooks.run(e2, r2), r2.node)
          }
          return t2
        }
        searchHook(e2) {
          if (i.hooks[e2]) {
            let t2 = { context: this }
            return (
              i.hooks[e2].find(function (e3) {
                return (e3.call(t2.context, t2), t2.node)
              }),
              t2.node
            )
          }
        }
        gobbleSpaces() {
          let e2 = this.code
          for (; e2 === i.SPACE_CODE || e2 === i.TAB_CODE || e2 === i.LF_CODE || e2 === i.CR_CODE; )
            e2 = this.expr.charCodeAt(++this.index)
          this.runHook('gobble-spaces')
        }
        parse() {
          this.runHook('before-all')
          let e2 = this.gobbleExpressions(),
            t2 = 1 === e2.length ? e2[0] : { type: i.COMPOUND, body: e2 }
          return this.runHook('after-all', t2)
        }
        gobbleExpressions(e2) {
          let t2 = [],
            r2,
            s2
          for (; this.index < this.expr.length; )
            if ((r2 = this.code) === i.SEMCOL_CODE || r2 === i.COMMA_CODE) this.index++
            else if ((s2 = this.gobbleExpression())) t2.push(s2)
            else if (this.index < this.expr.length) {
              if (r2 === e2) break
              this.throwError('Unexpected "' + this.char + '"')
            }
          return t2
        }
        gobbleExpression() {
          let e2 = this.searchHook('gobble-expression') || this.gobbleBinaryExpression()
          return (this.gobbleSpaces(), this.runHook('after-expression', e2))
        }
        gobbleBinaryOp() {
          this.gobbleSpaces()
          let e2 = this.expr.substr(this.index, i.max_binop_len),
            t2 = e2.length
          for (; t2 > 0; ) {
            if (
              i.binary_ops.hasOwnProperty(e2) &&
              (!i.isIdentifierStart(this.code) ||
                (this.index + e2.length < this.expr.length &&
                  !i.isIdentifierPart(this.expr.charCodeAt(this.index + e2.length))))
            )
              return ((this.index += t2), e2)
            e2 = e2.substr(0, --t2)
          }
          return false
        }
        gobbleBinaryExpression() {
          let e2, t2, r2, s2, n2, a2, o2, l2, h2
          if (!(a2 = this.gobbleToken()) || !(t2 = this.gobbleBinaryOp())) return a2
          for (
            n2 = { value: t2, prec: i.binaryPrecedence(t2), right_a: i.right_associative.has(t2) },
              (o2 = this.gobbleToken()) || this.throwError('Expected expression after ' + t2),
              s2 = [a2, n2, o2];
            (t2 = this.gobbleBinaryOp());
          ) {
            if (0 === (r2 = i.binaryPrecedence(t2))) {
              this.index -= t2.length
              break
            }
            ;((n2 = { value: t2, prec: r2, right_a: i.right_associative.has(t2) }), (h2 = t2))
            let l3 = (e3) => (n2.right_a && e3.right_a ? r2 > e3.prec : r2 <= e3.prec)
            for (; s2.length > 2 && l3(s2[s2.length - 2]); )
              ((o2 = s2.pop()),
                (t2 = s2.pop().value),
                (a2 = s2.pop()),
                (e2 = { type: i.BINARY_EXP, operator: t2, left: a2, right: o2 }),
                s2.push(e2))
            ;((e2 = this.gobbleToken()) || this.throwError('Expected expression after ' + h2), s2.push(n2, e2))
          }
          for (l2 = s2.length - 1, e2 = s2[l2]; l2 > 1; )
            ((e2 = { type: i.BINARY_EXP, operator: s2[l2 - 1].value, left: s2[l2 - 2], right: e2 }), (l2 -= 2))
          return e2
        }
        gobbleToken() {
          let e2, t2, r2, s2
          if ((this.gobbleSpaces(), (s2 = this.searchHook('gobble-token')))) return this.runHook('after-token', s2)
          if (((e2 = this.code), i.isDecimalDigit(e2) || e2 === i.PERIOD_CODE)) return this.gobbleNumericLiteral()
          if (e2 === i.SQUOTE_CODE || e2 === i.DQUOTE_CODE) s2 = this.gobbleStringLiteral()
          else if (e2 === i.OBRACK_CODE) s2 = this.gobbleArray()
          else {
            for (r2 = (t2 = this.expr.substr(this.index, i.max_unop_len)).length; r2 > 0; ) {
              if (
                i.unary_ops.hasOwnProperty(t2) &&
                (!i.isIdentifierStart(this.code) ||
                  (this.index + t2.length < this.expr.length &&
                    !i.isIdentifierPart(this.expr.charCodeAt(this.index + t2.length))))
              ) {
                this.index += r2
                let e3 = this.gobbleToken()
                return (
                  e3 || this.throwError('missing unaryOp argument'),
                  this.runHook('after-token', { type: i.UNARY_EXP, operator: t2, argument: e3, prefix: true })
                )
              }
              t2 = t2.substr(0, --r2)
            }
            i.isIdentifierStart(e2)
              ? ((s2 = this.gobbleIdentifier()),
                i.literals.hasOwnProperty(s2.name)
                  ? (s2 = { type: i.LITERAL, value: i.literals[s2.name], raw: s2.name })
                  : s2.name === i.this_str && (s2 = { type: i.THIS_EXP }))
              : e2 === i.OPAREN_CODE && (s2 = this.gobbleGroup())
          }
          return s2
            ? ((s2 = this.gobbleTokenProperty(s2)), this.runHook('after-token', s2))
            : this.runHook('after-token', false)
        }
        gobbleTokenProperty(e2) {
          this.gobbleSpaces()
          let t2 = this.code
          for (; t2 === i.PERIOD_CODE || t2 === i.OBRACK_CODE || t2 === i.OPAREN_CODE || t2 === i.QUMARK_CODE; ) {
            let r2
            if (t2 === i.QUMARK_CODE) {
              if (this.expr.charCodeAt(this.index + 1) !== i.PERIOD_CODE) break
              ;((r2 = true), (this.index += 2), this.gobbleSpaces(), (t2 = this.code))
            }
            ;(this.index++,
              t2 === i.OBRACK_CODE
                ? ((e2 = { type: i.MEMBER_EXP, computed: true, object: e2, property: this.gobbleExpression() })
                    .property || this.throwError('Unexpected "' + this.char + '"'),
                  this.gobbleSpaces(),
                  (t2 = this.code) !== i.CBRACK_CODE && this.throwError('Unclosed ['),
                  this.index++)
                : t2 === i.OPAREN_CODE
                  ? (e2 = { type: i.CALL_EXP, arguments: this.gobbleArguments(i.CPAREN_CODE), callee: e2 })
                  : (t2 === i.PERIOD_CODE || r2) &&
                    (r2 && this.index--,
                    this.gobbleSpaces(),
                    (e2 = { type: i.MEMBER_EXP, computed: false, object: e2, property: this.gobbleIdentifier() })),
              r2 && (e2.optional = true),
              this.gobbleSpaces(),
              (t2 = this.code))
          }
          return e2
        }
        gobbleNumericLiteral() {
          let e2 = '',
            t2,
            r2
          for (; i.isDecimalDigit(this.code); ) e2 += this.expr.charAt(this.index++)
          if (this.code === i.PERIOD_CODE)
            for (e2 += this.expr.charAt(this.index++); i.isDecimalDigit(this.code); )
              e2 += this.expr.charAt(this.index++)
          if ('e' === (t2 = this.char) || 'E' === t2) {
            for (
              e2 += this.expr.charAt(this.index++),
                ('+' === (t2 = this.char) || '-' === t2) && (e2 += this.expr.charAt(this.index++));
              i.isDecimalDigit(this.code);
            )
              e2 += this.expr.charAt(this.index++)
            i.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ||
              this.throwError('Expected exponent (' + e2 + this.char + ')')
          }
          return (
            (r2 = this.code),
            i.isIdentifierStart(r2)
              ? this.throwError('Variable names cannot start with a number (' + e2 + this.char + ')')
              : (r2 === i.PERIOD_CODE || (1 === e2.length && e2.charCodeAt(0) === i.PERIOD_CODE)) &&
                this.throwError('Unexpected period'),
            { type: i.LITERAL, value: parseFloat(e2), raw: e2 }
          )
        }
        gobbleStringLiteral() {
          let e2 = '',
            t2 = this.index,
            r2 = this.expr.charAt(this.index++),
            s2 = false
          for (; this.index < this.expr.length; ) {
            let t3 = this.expr.charAt(this.index++)
            if (t3 === r2) {
              s2 = true
              break
            }
            if ('\\' === t3)
              switch ((t3 = this.expr.charAt(this.index++))) {
                case 'n':
                  e2 += '\n'
                  break
                case 'r':
                  e2 += '\r'
                  break
                case 't':
                  e2 += '	'
                  break
                case 'b':
                  e2 += '\b'
                  break
                case 'f':
                  e2 += '\f'
                  break
                case 'v':
                  e2 += '\v'
                  break
                default:
                  e2 += t3
              }
            else e2 += t3
          }
          return (
            s2 || this.throwError('Unclosed quote after "' + e2 + '"'),
            { type: i.LITERAL, value: e2, raw: this.expr.substring(t2, this.index) }
          )
        }
        gobbleIdentifier() {
          let e2 = this.code,
            t2 = this.index
          for (
            i.isIdentifierStart(e2) ? this.index++ : this.throwError('Unexpected ' + this.char);
            this.index < this.expr.length;
          )
            if (((e2 = this.code), i.isIdentifierPart(e2))) this.index++
            else break
          return { type: i.IDENTIFIER, name: this.expr.slice(t2, this.index) }
        }
        gobbleArguments(e2) {
          let t2 = [],
            r2 = false,
            s2 = 0
          for (; this.index < this.expr.length; ) {
            this.gobbleSpaces()
            let n2 = this.code
            if (n2 === e2) {
              ;((r2 = true),
                this.index++,
                e2 === i.CPAREN_CODE &&
                  s2 &&
                  s2 >= t2.length &&
                  this.throwError('Unexpected token ' + String.fromCharCode(e2)))
              break
            }
            if (n2 === i.COMMA_CODE) {
              if ((this.index++, ++s2 !== t2.length)) {
                if (e2 === i.CPAREN_CODE) this.throwError('Unexpected token ,')
                else if (e2 === i.CBRACK_CODE) for (let e3 = t2.length; e3 < s2; e3++) t2.push(null)
              }
            } else if (t2.length !== s2 && 0 !== s2) this.throwError('Expected comma')
            else {
              let e3 = this.gobbleExpression()
              ;((e3 && e3.type !== i.COMPOUND) || this.throwError('Expected comma'), t2.push(e3))
            }
          }
          return (r2 || this.throwError('Expected ' + String.fromCharCode(e2)), t2)
        }
        gobbleGroup() {
          this.index++
          let e2 = this.gobbleExpressions(i.CPAREN_CODE)
          if (this.code === i.CPAREN_CODE)
            return (this.index++, 1 === e2.length) ? e2[0] : !!e2.length && { type: i.SEQUENCE_EXP, expressions: e2 }
          this.throwError('Unclosed (')
        }
        gobbleArray() {
          return (this.index++, { type: i.ARRAY_EXP, elements: this.gobbleArguments(i.CBRACK_CODE) })
        }
      }
      ;(Object.assign(i, {
        hooks: new (class {
          add(e2, t2, r2) {
            if ('string' != typeof arguments[0])
              for (let e3 in arguments[0]) this.add(e3, arguments[0][e3], arguments[1])
            else
              (Array.isArray(e2) ? e2 : [e2]).forEach(function (e3) {
                ;((this[e3] = this[e3] || []), t2 && this[e3][r2 ? 'unshift' : 'push'](t2))
              }, this)
          }
          run(e2, t2) {
            ;((this[e2] = this[e2] || []),
              this[e2].forEach(function (e3) {
                e3.call(t2 && t2.context ? t2.context : t2, t2)
              }))
          }
        })(),
        plugins: new (class {
          constructor(e2) {
            ;((this.jsep = e2), (this.registered = {}))
          }
          register(...e2) {
            e2.forEach((e3) => {
              if ('object' != typeof e3 || !e3.name || !e3.init) throw Error('Invalid JSEP plugin format')
              this.registered[e3.name] || (e3.init(this.jsep), (this.registered[e3.name] = e3))
            })
          }
        })(i),
        COMPOUND: 'Compound',
        SEQUENCE_EXP: 'SequenceExpression',
        IDENTIFIER: 'Identifier',
        MEMBER_EXP: 'MemberExpression',
        LITERAL: 'Literal',
        THIS_EXP: 'ThisExpression',
        CALL_EXP: 'CallExpression',
        UNARY_EXP: 'UnaryExpression',
        BINARY_EXP: 'BinaryExpression',
        ARRAY_EXP: 'ArrayExpression',
        TAB_CODE: 9,
        LF_CODE: 10,
        CR_CODE: 13,
        SPACE_CODE: 32,
        PERIOD_CODE: 46,
        COMMA_CODE: 44,
        SQUOTE_CODE: 39,
        DQUOTE_CODE: 34,
        OPAREN_CODE: 40,
        CPAREN_CODE: 41,
        OBRACK_CODE: 91,
        CBRACK_CODE: 93,
        QUMARK_CODE: 63,
        SEMCOL_CODE: 59,
        COLON_CODE: 58,
        unary_ops: { '-': 1, '!': 1, '~': 1, '+': 1 },
        binary_ops: {
          '||': 1,
          '??': 1,
          '&&': 2,
          '|': 3,
          '^': 4,
          '&': 5,
          '==': 6,
          '!=': 6,
          '===': 6,
          '!==': 6,
          '<': 7,
          '>': 7,
          '<=': 7,
          '>=': 7,
          '<<': 8,
          '>>': 8,
          '>>>': 8,
          '+': 9,
          '-': 9,
          '*': 10,
          '/': 10,
          '%': 10,
          '**': 11,
        },
        right_associative: /* @__PURE__ */ new Set(['**']),
        additional_identifier_chars: /* @__PURE__ */ new Set(['$', '_']),
        literals: { true: true, false: false, null: null },
        this_str: 'this',
      }),
        (i.max_unop_len = i.getMaxKeyLen(i.unary_ops)),
        (i.max_binop_len = i.getMaxKeyLen(i.binary_ops)))
      let s = (e2) => new i(e2).parse(),
        n = Object.getOwnPropertyNames(class {})
      ;(Object.getOwnPropertyNames(i)
        .filter((e2) => !n.includes(e2) && void 0 === s[e2])
        .forEach((e2) => {
          s[e2] = i[e2]
        }),
        (s.Jsep = i),
        s.plugins.register({
          name: 'ternary',
          init(e2) {
            e2.hooks.add('after-expression', function (t2) {
              if (t2.node && this.code === e2.QUMARK_CODE) {
                this.index++
                let r2 = t2.node,
                  i2 = this.gobbleExpression()
                if ((i2 || this.throwError('Expected expression'), this.gobbleSpaces(), this.code === e2.COLON_CODE)) {
                  this.index++
                  let s2 = this.gobbleExpression()
                  if (
                    (s2 || this.throwError('Expected expression'),
                    (t2.node = { type: 'ConditionalExpression', test: r2, consequent: i2, alternate: s2 }),
                    r2.operator && e2.binary_ops[r2.operator] <= 0.9)
                  ) {
                    let i3 = r2
                    for (; i3.right.operator && e2.binary_ops[i3.right.operator] <= 0.9; ) i3 = i3.right
                    ;((t2.node.test = i3.right), (i3.right = t2.node), (t2.node = r2))
                  }
                } else this.throwError('Expected :')
              }
            })
          },
        }))
      let a = {
        name: 'assignment',
        assignmentOperators: /* @__PURE__ */ new Set([
          '=',
          '*=',
          '**=',
          '/=',
          '%=',
          '+=',
          '-=',
          '<<=',
          '>>=',
          '>>>=',
          '&=',
          '^=',
          '|=',
          '||=',
          '&&=',
          '??=',
        ]),
        updateOperators: [43, 45],
        assignmentPrecedence: 0.9,
        init(e2) {
          let t2 = [e2.IDENTIFIER, e2.MEMBER_EXP]
          ;(a.assignmentOperators.forEach((t3) => e2.addBinaryOp(t3, a.assignmentPrecedence, true)),
            e2.hooks.add('gobble-token', function (e3) {
              let r2 = this.code
              a.updateOperators.some((e4) => e4 === r2 && e4 === this.expr.charCodeAt(this.index + 1)) &&
                ((this.index += 2),
                (e3.node = {
                  type: 'UpdateExpression',
                  operator: 43 === r2 ? '++' : '--',
                  argument: this.gobbleTokenProperty(this.gobbleIdentifier()),
                  prefix: true,
                }),
                (e3.node.argument && t2.includes(e3.node.argument.type)) ||
                  this.throwError(`Unexpected ${e3.node.operator}`))
            }),
            e2.hooks.add('after-token', function (e3) {
              if (e3.node) {
                let r2 = this.code
                a.updateOperators.some((e4) => e4 === r2 && e4 === this.expr.charCodeAt(this.index + 1)) &&
                  (t2.includes(e3.node.type) || this.throwError(`Unexpected ${e3.node.operator}`),
                  (this.index += 2),
                  (e3.node = {
                    type: 'UpdateExpression',
                    operator: 43 === r2 ? '++' : '--',
                    argument: e3.node,
                    prefix: false,
                  }))
              }
            }),
            e2.hooks.add('after-expression', function (e3) {
              e3.node &&
                (function e4(t3) {
                  a.assignmentOperators.has(t3.operator)
                    ? ((t3.type = 'AssignmentExpression'), e4(t3.left), e4(t3.right))
                    : t3.operator ||
                      Object.values(t3).forEach((t4) => {
                        t4 && 'object' == typeof t4 && e4(t4)
                      })
                })(e3.node)
            }))
        },
      }
      ;(s.plugins.register(
        {
          name: 'regex',
          init(e2) {
            e2.hooks.add('gobble-token', function (t2) {
              if (47 === this.code) {
                let r2 = ++this.index,
                  i2 = false
                for (; this.index < this.expr.length; ) {
                  if (47 === this.code && !i2) {
                    let i3,
                      s2 = this.expr.slice(r2, this.index),
                      n2 = ''
                    for (; ++this.index < this.expr.length; ) {
                      let e3 = this.code
                      if ((e3 >= 97 && e3 <= 122) || (e3 >= 65 && e3 <= 90) || (e3 >= 48 && e3 <= 57)) n2 += this.char
                      else break
                    }
                    try {
                      i3 = new RegExp(s2, n2)
                    } catch (e3) {
                      this.throwError(e3.message)
                    }
                    return (
                      (t2.node = { type: e2.LITERAL, value: i3, raw: this.expr.slice(r2 - 1, this.index) }),
                      (t2.node = this.gobbleTokenProperty(t2.node)),
                      t2.node
                    )
                  }
                  ;(this.code === e2.OBRACK_CODE ? (i2 = true) : i2 && this.code === e2.CBRACK_CODE && (i2 = false),
                    (this.index += 92 === this.code ? 2 : 1))
                }
                this.throwError('Unclosed Regex')
              }
            })
          },
        },
        a
      ),
        s.addUnaryOp('typeof'),
        s.addLiteral('null', null),
        s.addLiteral('undefined', void 0))
      let o = /* @__PURE__ */ new Set(['constructor', '__proto__', '__defineGetter__', '__defineSetter__']),
        l = {
          evalAst(e2, t2) {
            switch (e2.type) {
              case 'BinaryExpression':
              case 'LogicalExpression':
                return l.evalBinaryExpression(e2, t2)
              case 'Compound':
                return l.evalCompound(e2, t2)
              case 'ConditionalExpression':
                return l.evalConditionalExpression(e2, t2)
              case 'Identifier':
                return l.evalIdentifier(e2, t2)
              case 'Literal':
                return l.evalLiteral(e2, t2)
              case 'MemberExpression':
                return l.evalMemberExpression(e2, t2)
              case 'UnaryExpression':
                return l.evalUnaryExpression(e2, t2)
              case 'ArrayExpression':
                return l.evalArrayExpression(e2, t2)
              case 'CallExpression':
                return l.evalCallExpression(e2, t2)
              case 'AssignmentExpression':
                return l.evalAssignmentExpression(e2, t2)
              default:
                throw SyntaxError('Unexpected expression', e2)
            }
          },
          evalBinaryExpression: (e2, t2) =>
            ({
              '||': (e3, t3) => e3 || t3(),
              '&&': (e3, t3) => e3 && t3(),
              '|': (e3, t3) => e3 | t3(),
              '^': (e3, t3) => e3 ^ t3(),
              '&': (e3, t3) => e3 & t3(),
              '==': (e3, t3) => e3 == t3(),
              '!=': (e3, t3) => e3 != t3(),
              '===': (e3, t3) => e3 === t3(),
              '!==': (e3, t3) => e3 !== t3(),
              '<': (e3, t3) => e3 < t3(),
              '>': (e3, t3) => e3 > t3(),
              '<=': (e3, t3) => e3 <= t3(),
              '>=': (e3, t3) => e3 >= t3(),
              '<<': (e3, t3) => e3 << t3(),
              '>>': (e3, t3) => e3 >> t3(),
              '>>>': (e3, t3) => e3 >>> t3(),
              '+': (e3, t3) => e3 + t3(),
              '-': (e3, t3) => e3 - t3(),
              '*': (e3, t3) => e3 * t3(),
              '/': (e3, t3) => e3 / t3(),
              '%': (e3, t3) => e3 % t3(),
            })[e2.operator](l.evalAst(e2.left, t2), () => l.evalAst(e2.right, t2)),
          evalCompound(e2, t2) {
            let r2
            for (let i2 = 0; i2 < e2.body.length; i2++) {
              'Identifier' === e2.body[i2].type &&
                ['var', 'let', 'const'].includes(e2.body[i2].name) &&
                e2.body[i2 + 1] &&
                'AssignmentExpression' === e2.body[i2 + 1].type &&
                (i2 += 1)
              let s2 = e2.body[i2]
              r2 = l.evalAst(s2, t2)
            }
            return r2
          },
          evalConditionalExpression: (e2, t2) =>
            l.evalAst(e2.test, t2) ? l.evalAst(e2.consequent, t2) : l.evalAst(e2.alternate, t2),
          evalIdentifier(e2, t2) {
            if (Object.hasOwn(t2, e2.name)) return t2[e2.name]
            throw ReferenceError(`${e2.name} is not defined`)
          },
          evalLiteral: (e2) => e2.value,
          evalMemberExpression(e2, t2) {
            let r2 = String(e2.computed ? l.evalAst(e2.property) : e2.property.name),
              i2 = l.evalAst(e2.object, t2)
            if (null == i2 || (!Object.hasOwn(i2, r2) && o.has(r2)))
              throw TypeError(`Cannot read properties of ${i2} (reading '${r2}')`)
            let s2 = i2[r2]
            return 'function' == typeof s2 ? s2.bind(i2) : s2
          },
          evalUnaryExpression: (e2, t2) =>
            ({
              '-': (e3) => -l.evalAst(e3, t2),
              '!': (e3) => !l.evalAst(e3, t2),
              '~': (e3) => ~l.evalAst(e3, t2),
              '+': (e3) => +l.evalAst(e3, t2),
              typeof: (e3) => typeof l.evalAst(e3, t2),
            })[e2.operator](e2.argument),
          evalArrayExpression: (e2, t2) => e2.elements.map((e3) => l.evalAst(e3, t2)),
          evalCallExpression(e2, t2) {
            let r2 = e2.arguments.map((e3) => l.evalAst(e3, t2))
            return l.evalAst(e2.callee, t2)(...r2)
          },
          evalAssignmentExpression(e2, t2) {
            if ('Identifier' !== e2.left.type) throw SyntaxError('Invalid left-hand side in assignment')
            let r2 = e2.left.name,
              i2 = l.evalAst(e2.right, t2)
            return ((t2[r2] = i2), t2[r2])
          },
        }
      function h(e2, t2) {
        return ((e2 = e2.slice()).push(t2), e2)
      }
      function p(e2, t2) {
        return ((t2 = t2.slice()).unshift(e2), t2)
      }
      class c extends Error {
        constructor(e2) {
          ;(super('JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)'),
            (this.avoidNew = true),
            (this.value = e2),
            (this.name = 'NewError'))
        }
      }
      function u(e2, t2, r2, i2, s2) {
        if (!(this instanceof u))
          try {
            return new u(e2, t2, r2, i2, s2)
          } catch (e3) {
            if (!e3.avoidNew) throw e3
            return e3.value
          }
        'string' == typeof e2 && ((s2 = i2), (i2 = r2), (r2 = t2), (t2 = e2), (e2 = null))
        let n2 = e2 && 'object' == typeof e2
        if (
          ((e2 = e2 || {}),
          (this.json = e2.json || r2),
          (this.path = e2.path || t2),
          (this.resultType = e2.resultType || 'value'),
          (this.flatten = e2.flatten || false),
          (this.wrap = !Object.hasOwn(e2, 'wrap') || e2.wrap),
          (this.sandbox = e2.sandbox || {}),
          (this.eval = void 0 === e2.eval ? 'safe' : e2.eval),
          (this.ignoreEvalErrors = void 0 !== e2.ignoreEvalErrors && e2.ignoreEvalErrors),
          (this.parent = e2.parent || null),
          (this.parentProperty = e2.parentProperty || null),
          (this.callback = e2.callback || i2 || null),
          (this.otherTypeCallback =
            e2.otherTypeCallback ||
            s2 ||
            function () {
              throw TypeError('You must supply an otherTypeCallback callback option with the @other() operator.')
            }),
          false !== e2.autostart)
        ) {
          let i3 = { path: n2 ? e2.path : t2 }
          n2 ? 'json' in e2 && (i3.json = e2.json) : (i3.json = r2)
          let s3 = this.evaluate(i3)
          if (!s3 || 'object' != typeof s3) throw new c(s3)
          return s3
        }
      }
      ;((u.prototype.evaluate = function (e2, t2, r2, i2) {
        let s2 = this.parent,
          n2 = this.parentProperty,
          { flatten: a2, wrap: o2 } = this
        if (
          ((this.currResultType = this.resultType),
          (this.currEval = this.eval),
          (this.currSandbox = this.sandbox),
          (r2 = r2 || this.callback),
          (this.currOtherTypeCallback = i2 || this.otherTypeCallback),
          (t2 = t2 || this.json),
          (e2 = e2 || this.path) && 'object' == typeof e2 && !Array.isArray(e2))
        ) {
          if (!e2.path && '' !== e2.path)
            throw TypeError(
              'You must supply a "path" property when providing an object argument to JSONPath.evaluate().'
            )
          if (!Object.hasOwn(e2, 'json'))
            throw TypeError(
              'You must supply a "json" property when providing an object argument to JSONPath.evaluate().'
            )
          ;(({ json: t2 } = e2),
            (a2 = Object.hasOwn(e2, 'flatten') ? e2.flatten : a2),
            (this.currResultType = Object.hasOwn(e2, 'resultType') ? e2.resultType : this.currResultType),
            (this.currSandbox = Object.hasOwn(e2, 'sandbox') ? e2.sandbox : this.currSandbox),
            (o2 = Object.hasOwn(e2, 'wrap') ? e2.wrap : o2),
            (this.currEval = Object.hasOwn(e2, 'eval') ? e2.eval : this.currEval),
            (r2 = Object.hasOwn(e2, 'callback') ? e2.callback : r2),
            (this.currOtherTypeCallback = Object.hasOwn(e2, 'otherTypeCallback')
              ? e2.otherTypeCallback
              : this.currOtherTypeCallback),
            (s2 = Object.hasOwn(e2, 'parent') ? e2.parent : s2),
            (n2 = Object.hasOwn(e2, 'parentProperty') ? e2.parentProperty : n2),
            (e2 = e2.path))
        }
        if (
          ((s2 = s2 || null),
          (n2 = n2 || null),
          Array.isArray(e2) && (e2 = u.toPathString(e2)),
          (!e2 && '' !== e2) || !t2)
        )
          return
        let l2 = u.toPathArray(e2)
        ;('$' === l2[0] && l2.length > 1 && l2.shift(), (this._hasParentSelector = null))
        let h2 = this._trace(l2, t2, ['$'], s2, n2, r2).filter(function (e3) {
          return e3 && !e3.isParentSelector
        })
        return h2.length
          ? o2 || 1 !== h2.length || h2[0].hasArrExpr
            ? h2.reduce((e3, t3) => {
                let r3 = this._getPreferredOutput(t3)
                return (a2 && Array.isArray(r3) ? (e3 = e3.concat(r3)) : e3.push(r3), e3)
              }, [])
            : this._getPreferredOutput(h2[0])
          : o2
            ? []
            : void 0
      }),
        (u.prototype._getPreferredOutput = function (e2) {
          let t2 = this.currResultType
          switch (t2) {
            case 'all': {
              let t3 = Array.isArray(e2.path) ? e2.path : u.toPathArray(e2.path)
              return (
                (e2.pointer = u.toPointer(t3)),
                (e2.path = 'string' == typeof e2.path ? e2.path : u.toPathString(e2.path)),
                e2
              )
            }
            case 'value':
            case 'parent':
            case 'parentProperty':
              return e2[t2]
            case 'path':
              return u.toPathString(e2[t2])
            case 'pointer':
              return u.toPointer(e2.path)
            default:
              throw TypeError('Unknown result type')
          }
        }),
        (u.prototype._handleCallback = function (e2, t2, r2) {
          if (t2) {
            let i2 = this._getPreferredOutput(e2)
            ;((e2.path = 'string' == typeof e2.path ? e2.path : u.toPathString(e2.path)), t2(i2, r2, e2))
          }
        }),
        (u.prototype._trace = function (e2, t2, r2, i2, s2, n2, a2, o2) {
          let l2
          if (!e2.length)
            return (
              (l2 = { path: r2, value: t2, parent: i2, parentProperty: s2, hasArrExpr: a2 }),
              this._handleCallback(l2, n2, 'value'),
              l2
            )
          let c2 = e2[0],
            u2 = e2.slice(1),
            d = []
          function b(e3) {
            Array.isArray(e3)
              ? e3.forEach((e4) => {
                  d.push(e4)
                })
              : d.push(e3)
          }
          if (('string' != typeof c2 || o2) && t2 && Object.hasOwn(t2, c2))
            b(this._trace(u2, t2[c2], h(r2, c2), t2, c2, n2, a2))
          else if ('*' === c2)
            this._walk(t2, (e3) => {
              b(this._trace(u2, t2[e3], h(r2, e3), t2, e3, n2, true, true))
            })
          else if ('..' === c2)
            (b(this._trace(u2, t2, r2, i2, s2, n2, a2)),
              this._walk(t2, (i3) => {
                'object' == typeof t2[i3] && b(this._trace(e2.slice(), t2[i3], h(r2, i3), t2, i3, n2, true))
              }))
          else if ('^' === c2)
            return ((this._hasParentSelector = true), { path: r2.slice(0, -1), expr: u2, isParentSelector: true })
          else if ('~' === c2)
            return (
              (l2 = { path: h(r2, c2), value: s2, parent: i2, parentProperty: null }),
              this._handleCallback(l2, n2, 'property'),
              l2
            )
          else if ('$' === c2) b(this._trace(u2, t2, r2, null, null, n2, a2))
          else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(c2)) b(this._slice(c2, u2, t2, r2, i2, s2, n2))
          else if (0 === c2.indexOf('?(')) {
            if (false === this.currEval) throw Error('Eval [?(expr)] prevented in JSONPath expression.')
            let e3 = c2.replace(/^\?\((.*?)\)$/u, '$1'),
              a3 = /@.?([^?]*)[['](\??\(.*?\))(?!.\)\])[\]']/gu.exec(e3)
            a3
              ? this._walk(t2, (e4) => {
                  let o3 = [a3[2]],
                    l3 = a3[1] ? t2[e4][a3[1]] : t2[e4]
                  this._trace(o3, l3, r2, i2, s2, n2, true).length > 0 &&
                    b(this._trace(u2, t2[e4], h(r2, e4), t2, e4, n2, true))
                })
              : this._walk(t2, (a4) => {
                  this._eval(e3, t2[a4], a4, r2, i2, s2) && b(this._trace(u2, t2[a4], h(r2, a4), t2, a4, n2, true))
                })
          } else if ('(' === c2[0]) {
            if (false === this.currEval) throw Error('Eval [(expr)] prevented in JSONPath expression.')
            b(this._trace(p(this._eval(c2, t2, r2.at(-1), r2.slice(0, -1), i2, s2), u2), t2, r2, i2, s2, n2, a2))
          } else if ('@' === c2[0]) {
            let e3 = false,
              a3 = c2.slice(1, -2)
            switch (a3) {
              case 'scalar':
                ;(t2 && ['object', 'function'].includes(typeof t2)) || (e3 = true)
                break
              case 'boolean':
              case 'string':
              case 'undefined':
              case 'function':
                typeof t2 === a3 && (e3 = true)
                break
              case 'integer':
                Number.isFinite(t2) && !(t2 % 1) && (e3 = true)
                break
              case 'number':
                Number.isFinite(t2) && (e3 = true)
                break
              case 'nonFinite':
                'number' != typeof t2 || Number.isFinite(t2) || (e3 = true)
                break
              case 'object':
                t2 && typeof t2 === a3 && (e3 = true)
                break
              case 'array':
                Array.isArray(t2) && (e3 = true)
                break
              case 'other':
                e3 = this.currOtherTypeCallback(t2, r2, i2, s2)
                break
              case 'null':
                null === t2 && (e3 = true)
                break
              default:
                throw TypeError('Unknown value type ' + a3)
            }
            if (e3)
              return (
                (l2 = { path: r2, value: t2, parent: i2, parentProperty: s2 }),
                this._handleCallback(l2, n2, 'value'),
                l2
              )
          } else if ('`' === c2[0] && t2 && Object.hasOwn(t2, c2.slice(1))) {
            let e3 = c2.slice(1)
            b(this._trace(u2, t2[e3], h(r2, e3), t2, e3, n2, a2, true))
          } else if (c2.includes(',')) for (let e3 of c2.split(',')) b(this._trace(p(e3, u2), t2, r2, i2, s2, n2, true))
          else !o2 && t2 && Object.hasOwn(t2, c2) && b(this._trace(u2, t2[c2], h(r2, c2), t2, c2, n2, a2, true))
          if (this._hasParentSelector)
            for (let e3 = 0; e3 < d.length; e3++) {
              let r3 = d[e3]
              if (r3 && r3.isParentSelector) {
                let o3 = this._trace(r3.expr, t2, r3.path, i2, s2, n2, a2)
                if (Array.isArray(o3)) {
                  d[e3] = o3[0]
                  let t3 = o3.length
                  for (let r4 = 1; r4 < t3; r4++) (e3++, d.splice(e3, 0, o3[r4]))
                } else d[e3] = o3
              }
            }
          return d
        }),
        (u.prototype._walk = function (e2, t2) {
          if (Array.isArray(e2)) {
            let r2 = e2.length
            for (let e3 = 0; e3 < r2; e3++) t2(e3)
          } else
            e2 &&
              'object' == typeof e2 &&
              Object.keys(e2).forEach((e3) => {
                t2(e3)
              })
        }),
        (u.prototype._slice = function (e2, t2, r2, i2, s2, n2, a2) {
          if (!Array.isArray(r2)) return
          let o2 = r2.length,
            l2 = e2.split(':'),
            h2 = (l2[2] && Number.parseInt(l2[2])) || 1,
            c2 = (l2[0] && Number.parseInt(l2[0])) || 0,
            u2 = (l2[1] && Number.parseInt(l2[1])) || o2
          ;((c2 = c2 < 0 ? Math.max(0, c2 + o2) : Math.min(o2, c2)),
            (u2 = u2 < 0 ? Math.max(0, u2 + o2) : Math.min(o2, u2)))
          let d = []
          for (let e3 = c2; e3 < u2; e3 += h2)
            this._trace(p(e3, t2), r2, i2, s2, n2, a2, true).forEach((e4) => {
              d.push(e4)
            })
          return d
        }),
        (u.prototype._eval = function (e2, t2, r2, i2, s2, n2) {
          ;((this.currSandbox._$_parentProperty = n2),
            (this.currSandbox._$_parent = s2),
            (this.currSandbox._$_property = r2),
            (this.currSandbox._$_root = this.json),
            (this.currSandbox._$_v = t2))
          let a2 = e2.includes('@path')
          a2 && (this.currSandbox._$_path = u.toPathString(i2.concat([r2])))
          let o2 = this.currEval + 'Script:' + e2
          if (!u.cache[o2]) {
            let t3 = e2
              .replaceAll('@parentProperty', '_$_parentProperty')
              .replaceAll('@parent', '_$_parent')
              .replaceAll('@property', '_$_property')
              .replaceAll('@root', '_$_root')
              .replaceAll(/@([.\s)[])/gu, '_$_v$1')
            if (
              (a2 && (t3 = t3.replaceAll('@path', '_$_path')),
              'safe' === this.currEval || true === this.currEval || void 0 === this.currEval)
            )
              u.cache[o2] = new this.safeVm.Script(t3)
            else if ('native' === this.currEval) u.cache[o2] = new this.vm.Script(t3)
            else if (
              'function' == typeof this.currEval &&
              this.currEval.prototype &&
              Object.hasOwn(this.currEval.prototype, 'runInNewContext')
            ) {
              let e3 = this.currEval
              u.cache[o2] = new e3(t3)
            } else if ('function' == typeof this.currEval)
              u.cache[o2] = { runInNewContext: (e3) => this.currEval(t3, e3) }
            else throw TypeError(`Unknown "eval" property "${this.currEval}"`)
          }
          try {
            return u.cache[o2].runInNewContext(this.currSandbox)
          } catch (t3) {
            if (this.ignoreEvalErrors) return false
            throw Error('jsonPath: ' + t3.message + ': ' + e2)
          }
        }),
        (u.cache = {}),
        (u.toPathString = function (e2) {
          let t2 = e2.length,
            r2 = '$'
          for (let i2 = 1; i2 < t2; i2++)
            /^(~|\^|@.*?\(\))$/u.test(e2[i2]) ||
              (r2 += /^[0-9*]+$/u.test(e2[i2]) ? '[' + e2[i2] + ']' : "['" + e2[i2] + "']")
          return r2
        }),
        (u.toPointer = function (e2) {
          let t2 = e2.length,
            r2 = ''
          for (let i2 = 1; i2 < t2; i2++)
            /^(~|\^|@.*?\(\))$/u.test(e2[i2]) ||
              (r2 += '/' + e2[i2].toString().replaceAll('~', '~0').replaceAll('/', '~1'))
          return r2
        }),
        (u.toPathArray = function (e2) {
          let { cache: t2 } = u
          if (t2[e2]) return t2[e2].concat()
          let r2 = [],
            i2 = e2
              .replaceAll(
                /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu,
                ';$&;'
              )
              .replaceAll(/[['](\??\(.*?\))[\]'](?!.\])/gu, function (e3, t3) {
                return '[#' + (r2.push(t3) - 1) + ']'
              })
              .replaceAll(/\[['"]([^'\]]*)['"]\]/gu, function (e3, t3) {
                return "['" + t3.replaceAll('.', '%@%').replaceAll('~', '%%@@%%') + "']"
              })
              .replaceAll('~', ';~;')
              .replaceAll(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ';')
              .replaceAll('%@%', '.')
              .replaceAll('%%@@%%', '~')
              .replaceAll(/(?:;)?(\^+)(?:;)?/gu, function (e3, t3) {
                return ';' + t3.split('').join(';') + ';'
              })
              .replaceAll(/;;;|;;/gu, ';..;')
              .replaceAll(/;$|'?\]|'$/gu, '')
              .split(';')
              .map(function (e3) {
                let t3 = e3.match(/#(\d+)/u)
                return t3 && t3[1] ? r2[t3[1]] : e3
              })
          return ((t2[e2] = i2), t2[e2].concat())
        }),
        (u.prototype.safeVm = {
          Script: class {
            constructor(e2) {
              ;((this.code = e2), (this.ast = s(this.code)))
            }
            runInNewContext(e2) {
              let t2 = Object.assign(/* @__PURE__ */ Object.create(null), e2)
              return l.evalAst(this.ast, t2)
            }
          },
        }),
        (u.prototype.vm = r),
        (module2.exports = t))
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/payload-tagging/tagging.js
var require_tagging = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/payload-tagging/tagging.js'(exports2, module2) {
    'use strict'
    var { PAYLOAD_TAGGING_MAX_TAGS } = require_constants2()
    var redactedKeys = /* @__PURE__ */ new Set(['authorization', 'x-authorization', 'password', 'token'])
    var truncated = 'truncated'
    var redacted = 'redacted'
    function escapeKey(key) {
      return key.replaceAll('.', String.raw`\.`)
    }
    function tagsFromObject(object, opts) {
      const { maxDepth, prefix } = opts
      let tagCount = 0
      let abort = false
      const result = {}
      function tagRec(prefix2, object2, depth = 0) {
        if (abort) {
          return
        }
        if (tagCount >= PAYLOAD_TAGGING_MAX_TAGS - 1) {
          abort = true
          result['_dd.payload_tags_incomplete'] = true
          return
        }
        if (depth >= maxDepth && object2 !== null && typeof object2 === 'object') {
          tagCount += 1
          result[prefix2] = truncated
          return
        }
        if (object2 === void 0) {
          tagCount += 1
          result[prefix2] = 'undefined'
          return
        }
        if (object2 === null) {
          tagCount += 1
          result[prefix2] = 'null'
          return
        }
        if (['number', 'boolean'].includes(typeof object2) || Buffer.isBuffer(object2)) {
          tagCount += 1
          result[prefix2] = object2.toString().slice(0, 5e3)
          return
        }
        if (typeof object2 === 'string') {
          tagCount += 1
          result[prefix2] = object2.slice(0, 5e3)
        }
        if (typeof object2 === 'object') {
          for (const [key, value] of Object.entries(object2)) {
            if (redactedKeys.has(key.toLowerCase())) {
              tagCount += 1
              result[`${prefix2}.${escapeKey(key)}`] = redacted
            } else {
              tagRec(`${prefix2}.${escapeKey(key)}`, value, depth + 1)
            }
          }
        }
      }
      tagRec(prefix, object)
      return result
    }
    module2.exports = { tagsFromObject }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/payload-tagging/index.js
var require_payload_tagging = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/payload-tagging/index.js'(exports2, module2) {
    'use strict'
    var rfdc = require_rfdc()({ proto: false, circles: false })
    var { PAYLOAD_TAG_REQUEST_PREFIX, PAYLOAD_TAG_RESPONSE_PREFIX } = require_constants2()
    var jsonpath = require_jsonpath_plus().JSONPath
    var { tagsFromObject } = require_tagging()
    function maybeJSONParseValue(value) {
      if (typeof value !== 'string' || value[0] !== '{') {
        return value
      }
      try {
        return JSON.parse(value)
      } catch {
        return value
      }
    }
    function expand(object, expansionRules) {
      for (const rule of expansionRules) {
        jsonpath(rule, object, (value, _type, desc) => {
          desc.parent[desc.parentProperty] = maybeJSONParseValue(value)
        })
      }
    }
    function redact(object, redactionRules) {
      for (const rule of redactionRules) {
        jsonpath(rule, object, (_value, _type, desc) => {
          desc.parent[desc.parentProperty] = 'redacted'
        })
      }
    }
    function computeTags(config, object, opts) {
      const payload = rfdc(object)
      const redactionRules = opts.prefix === PAYLOAD_TAG_REQUEST_PREFIX ? config.request : config.response
      const expansionRules = config.expand
      expand(payload, expansionRules)
      redact(payload, redactionRules)
      return tagsFromObject(payload, opts)
    }
    function tagsFromRequest(config, object, opts) {
      return computeTags(config, object, { ...opts, prefix: PAYLOAD_TAG_REQUEST_PREFIX })
    }
    function tagsFromResponse(config, object, opts) {
      return computeTags(config, object, { ...opts, prefix: PAYLOAD_TAG_RESPONSE_PREFIX })
    }
    module2.exports = { computeTags, tagsFromRequest, tagsFromResponse }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/base.js
var require_base2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/base.js'(exports2, module2) {
    'use strict'
    var analyticsSampler = require_analytics_sampler()
    var ClientPlugin = require_client5()
    var { storage } = require_datadog_core()
    var { isTrue } = require_util()
    var { tagsFromRequest, tagsFromResponse } = require_payload_tagging()
    var { getEnvironmentVariable } = require_config_helper()
    var BaseAwsSdkPlugin = class extends ClientPlugin {
      static id = 'aws'
      static isPayloadReporter = false
      get serviceIdentifier() {
        const id = this.constructor.id.toLowerCase()
        Object.defineProperty(this, 'serviceIdentifier', {
          configurable: true,
          writable: true,
          enumerable: true,
          value: id,
        })
        return id
      }
      get cloudTaggingConfig() {
        return this._tracerConfig.cloudPayloadTagging
      }
      get payloadTaggingRules() {
        return this.cloudTaggingConfig.rules.aws?.[this.constructor.id]
      }
      constructor(...args) {
        super(...args)
        this._parentMap = /* @__PURE__ */ new WeakMap()
        this.addBind(`apm:aws:request:start:${this.serviceIdentifier}`, (ctx) => {
          const { request, operation, awsRegion, awsService } = ctx
          const parentStore = (ctx.parentStore = storage('legacy').getStore())
          const childOf = parentStore?.span
          this._parentMap.set(request, parentStore)
          if (!this.isEnabled(request)) {
            return parentStore
          }
          const meta = {
            'span.kind': 'client',
            'service.name': this.serviceName(),
            'aws.operation': operation,
            'aws.region': awsRegion,
            region: awsRegion,
            'aws.partition': getPartition(awsRegion),
            aws_service: awsService,
            'aws.service': awsService,
            component: 'aws-sdk',
          }
          if (this.requestTags) this.requestTags.set(request, meta)
          const span = this.startSpan(
            this.operationFromRequest(request),
            {
              childOf,
              meta,
              integrationName: 'aws-sdk',
            },
            ctx
          )
          analyticsSampler.sample(span, this.config.measured)
          storage('legacy').run(ctx.currentStore, () => {
            this.requestInject(span, request)
          })
          if (this.constructor.isPayloadReporter && this.cloudTaggingConfig.requestsEnabled) {
            const maxDepth = this.cloudTaggingConfig.maxDepth
            const requestTags = tagsFromRequest(this.payloadTaggingRules, request.params, { maxDepth })
            span.addTags(requestTags)
          }
          return ctx.currentStore
        })
        this.addSub(`apm:aws:request:start:${this.serviceIdentifier}`, (ctx) => {
          if (!this._tracerConfig?._isInServerlessEnvironment()) return
          const { awsRegion, awsService, currentStore, request } = ctx
          const peerServerlessStorage = storage('peerServerless')
          const hostname = getHostname({ awsParams: request.params, awsService }, awsRegion)
          const peerServerlessStore = {}
          peerServerlessStorage.enterWith(peerServerlessStore)
          if (hostname) {
            currentStore.span.setTag('peer.service', hostname)
            peerServerlessStore.peerHostname = hostname
          } else {
            currentStore.awsParams = request.params
            currentStore.awsService = awsService
          }
        })
        this.addSub(`apm:aws:request:region:${this.serviceIdentifier}`, ({ region }) => {
          const store = storage('legacy').getStore()
          if (!store) return
          const { span } = store
          if (!span) return
          span.setTag('aws.region', region)
          span.setTag('region', region)
          const partition = getPartition(region)
          if (partition) {
            span.setTag('aws.partition', partition)
          }
          if (!this._tracerConfig?._isInServerlessEnvironment()) return
          const hostname = getHostname(store, region)
          if (!hostname) return
          span.setTag('peer.service', hostname)
          const peerServerlessStore = storage('peerServerless').getStore()
          if (peerServerlessStore) {
            peerServerlessStore.peerHostname = hostname
          }
        })
        this.addSub(`apm:aws:request:complete:${this.serviceIdentifier}`, (ctx) => {
          const { response, cbExists = false, currentStore } = ctx
          if (!currentStore) return
          const { span } = currentStore
          if (!span) return
          storage('legacy').run(currentStore, () => {
            if (!cbExists && this.serviceIdentifier === 'sqs') {
              const params = response.request.params
              const operation = response.request.operation
              this.responseExtractDSMContext(operation, params, response.data ?? response, span)
            }
            this.addResponseTags(span, response)
            if (this._tracerConfig?.trace?.aws?.addSpanPointers) {
              this.addSpanPointers(span, response)
            }
          })
          this.finish(ctx)
        })
        this.addBind(`apm:aws:response:start:${this.serviceIdentifier}`, (ctx) => {
          return this._parentMap.get(ctx.request)
        })
      }
      requestInject(span, request) {}
      addSpanPointers(span, response) {}
      operationFromRequest(request) {
        return this.operationName({
          id: 'aws',
          type: 'web',
          kind: 'client',
          awsService: this.serviceIdentifier,
        })
      }
      serviceName() {
        return (
          this.config.service ||
          super.serviceName({
            id: 'aws',
            type: 'web',
            kind: 'client',
            awsService: this.serviceIdentifier,
          })
        )
      }
      isEnabled(request) {
        const serviceId = this.serviceIdentifier.toUpperCase()
        const envVarValue = getEnvironmentVariable(`DD_TRACE_AWS_SDK_${serviceId}_ENABLED`)
        return envVarValue ? isTrue(envVarValue) : true
      }
      addResponseTags(span, response) {
        if (!span || !response.request) return
        const params = response.request.params
        const operation = response.request.operation
        const extraTags = this.generateTags(params, operation, response) || {}
        const tags = {
          'aws.response.request_id': response.requestId,
          'resource.name': operation,
          'span.kind': 'client',
          ...extraTags,
        }
        span.addTags(tags)
        if (this.constructor.isPayloadReporter && this.cloudTaggingConfig.responsesEnabled) {
          const maxDepth = this.cloudTaggingConfig.maxDepth
          const responseBody = this.extractResponseBody(response)
          const responseTags = tagsFromResponse(this.payloadTaggingRules, responseBody, { maxDepth })
          span.addTags(responseTags)
        }
      }
      extractResponseBody(response) {
        if (response.hasOwnProperty('data')) {
          return response.data
        }
        return Object.fromEntries(
          Object.entries(response).filter(([key]) => !['request', 'requestId', 'error', '$metadata'].includes(key))
        )
      }
      generateTags() {}
      finish(ctx) {
        const { currentStore, response } = ctx
        const { span } = currentStore
        const error = response?.error || ctx.error
        if (error) {
          span.setTag('error', error)
          const requestId = error.RequestId || error.requestId
          if (requestId) {
            span.addTags({ 'aws.response.request_id': requestId })
          }
        }
        if (response) {
          this.config.hooks.request(span, response)
        }
        super.finish(ctx)
      }
      configure(config) {
        super.configure(normalizeConfig(config, this.serviceIdentifier))
      }
    }
    function normalizeConfig(config, serviceIdentifier) {
      const hooks = getHooks(config)
      let specificConfig = config[serviceIdentifier]
      switch (typeof specificConfig) {
        case 'undefined':
          specificConfig = {}
          break
        case 'boolean':
          specificConfig = { enabled: specificConfig }
          break
      }
      const serviceId = serviceIdentifier.toUpperCase()
      const batchPropagationEnabled = isTrue(
        specificConfig.batchPropagationEnabled ??
          getEnvironmentVariable(`DD_TRACE_AWS_SDK_${serviceId}_BATCH_PROPAGATION_ENABLED`) ??
          config.batchPropagationEnabled ??
          getEnvironmentVariable('DD_TRACE_AWS_SDK_BATCH_PROPAGATION_ENABLED')
      )
      return {
        ...config,
        ...specificConfig,
        batchPropagationEnabled,
        hooks,
      }
    }
    var noop = () => {}
    function getHooks(config) {
      const request = config.hooks?.request || noop
      return { request }
    }
    function getHostname(store, region) {
      if (!store) return
      if (!region) return
      const { awsParams, awsService } = store
      switch (awsService) {
        case 'EventBridge':
          return `events.${region}.amazonaws.com`
        case 'SQS':
          return `sqs.${region}.amazonaws.com`
        case 'SNS':
          return `sns.${region}.amazonaws.com`
        case 'Kinesis':
          return `kinesis.${region}.amazonaws.com`
        case 'DynamoDBDocument':
        case 'DynamoDB':
          return `dynamodb.${region}.amazonaws.com`
        case 'S3':
          return awsParams?.Bucket ? `${awsParams.Bucket}.s3.${region}.amazonaws.com` : `s3.${region}.amazonaws.com`
      }
    }
    function getPartition(region) {
      if (!region) return
      let partition = 'aws'
      if (region.startsWith('cn-')) {
        partition = 'aws-cn'
      } else if (region.startsWith('us-gov-')) {
        partition = 'aws-us-gov'
      }
      return partition
    }
    module2.exports = BaseAwsSdkPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js
var require_cloudwatchlogs = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js'(exports2, module2) {
    'use strict'
    var BaseAwsSdkPlugin = require_base2()
    var CloudwatchLogs = class extends BaseAwsSdkPlugin {
      static id = 'cloudwatchlogs'
      generateTags(params, operation) {
        if (!params?.logGroupName) return {}
        return {
          'resource.name': `${operation} ${params.logGroupName}`,
          'aws.cloudwatch.logs.log_group_name': params.logGroupName,
          loggroupname: params.logGroupName,
        }
      }
    }
    module2.exports = CloudwatchLogs
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/util.js
var require_util5 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/util.js'(exports2, module2) {
    'use strict'
    var crypto = require('crypto')
    var log = require_log2()
    function generatePointerHash(components) {
      const dataToHash = components.join('|')
      const hash = crypto.createHash('sha256').update(dataToHash).digest('hex')
      return hash.slice(0, 32)
    }
    function encodeValue(valueObject) {
      if (!valueObject) {
        return
      }
      try {
        const type = Object.keys(valueObject)[0]
        const value = valueObject[type]
        switch (type) {
          case 'S':
            return Buffer.from(value)
          case 'N':
            return Buffer.from(value.toString())
          case 'B':
            return Buffer.isBuffer(value) ? value : Buffer.from(value)
          default:
            log.debug('Found unknown type while trying to create DynamoDB span pointer:', type)
        }
      } catch (err) {
        log.debug('Failed to encode value while trying to create DynamoDB span pointer:', err.message)
      }
    }
    var extractPrimaryKeys = (keyNames, keyValuePairs) => {
      if (keyNames.length === 0) {
        return
      }
      if (keyNames.length === 1) {
        const value = encodeValue(keyValuePairs[keyNames[0]])
        if (value) {
          return [keyNames[0], value, '', '']
        }
      } else {
        const [key1, key2] = keyNames.sort()
        const value1 = encodeValue(keyValuePairs[key1])
        const value2 = encodeValue(keyValuePairs[key2])
        if (value1 && value2) {
          return [key1, value1, key2, value2]
        }
      }
    }
    var extractQueueMetadata = (queueURL) => {
      if (!queueURL) {
        return null
      }
      const parts = queueURL.split('/').filter(Boolean)
      const hasScheme = Boolean(parts[0]?.startsWith('http'))
      const minParts = hasScheme ? 4 : 3
      if (parts.length < minParts) return null
      const accountId = parts[parts.length - 2]
      const queueName = parts[parts.length - 1]
      const host = hasScheme ? parts[1] : parts[0]
      let region = 'us-east-1'
      if (host.includes('.amazonaws.com') && !host.startsWith('queue')) {
        const startFrom = host.startsWith('sqs.') ? 4 : 0
        const nextDot = host.indexOf('.', startFrom)
        region = host.slice(startFrom, nextDot)
      }
      let partition = 'aws'
      if (region.startsWith('cn-')) {
        partition = 'aws-cn'
      } else if (region.startsWith('us-gov-')) {
        partition = 'aws-us-gov'
      }
      const arn = `arn:${partition}:sqs:${region}:${accountId}:${queueName}`
      return { queueName, arn }
    }
    module2.exports = {
      generatePointerHash,
      encodeValue,
      extractPrimaryKeys,
      extractQueueMetadata,
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js
var require_dynamodb = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js'(exports2, module2) {
    'use strict'
    var BaseAwsSdkPlugin = require_base2()
    var log = require_log2()
    var { DYNAMODB_PTR_KIND, SPAN_POINTER_DIRECTION } = require_constants2()
    var { extractPrimaryKeys, generatePointerHash } = require_util5()
    var DynamoDb = class _DynamoDb extends BaseAwsSdkPlugin {
      static id = 'dynamodb'
      static peerServicePrecursors = ['tablename']
      static isPayloadReporter = true
      generateTags(params, operation, response) {
        const tags = {}
        if (params) {
          let tableName = params.TableName
          if (params.RequestItems !== null && typeof params.RequestItems === 'object') {
            const requestItemsKeys = Object.keys(params.RequestItems)
            if (requestItemsKeys.length === 1) {
              tableName = requestItemsKeys[0]
            }
          }
          if (tableName) {
            tags['resource.name'] = `${operation} ${tableName}`
            tags['aws.dynamodb.table_name'] = tableName
            tags.tablename = tableName
          }
        }
        tags['span.type'] = 'dynamodb'
        return tags
      }
      addSpanPointers(span, response) {
        const request = response?.request
        const operationName = request?.operation
        const hashes = []
        switch (operationName) {
          case 'putItem': {
            const hash = _DynamoDb.calculatePutItemHash(
              request?.params?.TableName,
              request?.params?.Item,
              this.getPrimaryKeyConfig()
            )
            if (hash) hashes.push(hash)
            break
          }
          case 'updateItem':
          case 'deleteItem': {
            const hash = _DynamoDb.calculateHashWithKnownKeys(request?.params?.TableName, request?.params?.Key)
            if (hash) hashes.push(hash)
            break
          }
          case 'transactWriteItems': {
            const transactItems = request?.params?.TransactItems || []
            for (const item of transactItems) {
              if (item.Put) {
                const hash = _DynamoDb.calculatePutItemHash(
                  item.Put.TableName,
                  item.Put.Item,
                  this.getPrimaryKeyConfig()
                )
                if (hash) hashes.push(hash)
              } else {
                const operation = item.Update || item.Delete
                if (operation) {
                  const hash = _DynamoDb.calculateHashWithKnownKeys(operation.TableName, operation.Key)
                  if (hash) hashes.push(hash)
                }
              }
            }
            break
          }
          case 'batchWriteItem': {
            const requestItems = request?.params.RequestItems || {}
            for (const [tableName, operations] of Object.entries(requestItems)) {
              if (!Array.isArray(operations)) continue
              for (const operation of operations) {
                if (operation?.PutRequest) {
                  const hash = _DynamoDb.calculatePutItemHash(
                    tableName,
                    operation.PutRequest.Item,
                    this.getPrimaryKeyConfig()
                  )
                  if (hash) hashes.push(hash)
                } else if (operation?.DeleteRequest) {
                  const hash = _DynamoDb.calculateHashWithKnownKeys(tableName, operation.DeleteRequest.Key)
                  if (hash) hashes.push(hash)
                }
              }
            }
            break
          }
        }
        for (const hash of hashes) {
          span.addSpanPointer(DYNAMODB_PTR_KIND, SPAN_POINTER_DIRECTION.DOWNSTREAM, hash)
        }
      }
      /**
       * Parses primary key config from the `DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS` env var.
       * Only runs when needed, and warns when missing or invalid config.
       * @returns {Object|undefined} Parsed config from env var or undefined if empty/missing/invalid config.
       */
      getPrimaryKeyConfig() {
        if (this.dynamoPrimaryKeyConfig) {
          return this.dynamoPrimaryKeyConfig
        }
        const configStr = this._tracerConfig?.trace?.dynamoDb?.tablePrimaryKeys
        if (!configStr) {
          log.warn(
            // eslint-disable-next-line @stylistic/max-len
            "Missing DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS env variable. Please add your table's primary keys under this env variable."
          )
          return
        }
        try {
          const parsedConfig = JSON.parse(configStr)
          const config = {}
          for (const [tableName, primaryKeys] of Object.entries(parsedConfig)) {
            if (Array.isArray(primaryKeys) && primaryKeys.length > 0 && primaryKeys.length <= 2) {
              config[tableName] = primaryKeys
            } else {
              log.warn(
                // eslint-disable-next-line @stylistic/max-len
                'Invalid primary key configuration for table: %s. Please fix the DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS env var.',
                tableName
              )
            }
          }
          this.dynamoPrimaryKeyConfig = config
          return config
        } catch (err) {
          log.warn('Failed to parse DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS:', err.message)
        }
      }
      /**
       * Calculates a hash for DynamoDB PutItem operations using table's configured primary keys.
       * @param {string} tableName - Name of the DynamoDB table.
       * @param {Object} item - Complete PutItem item parameter to be put.
       * @param {Object.<string, Array<string>>} primaryKeyConfig - Mapping of table names to an Array of primary key names
       *                                                         loaded from DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS.
       * @returns {string|undefined} Hash combining table name and primary key/value pairs, or undefined if unable.
       */
      static calculatePutItemHash(tableName, item, primaryKeyConfig) {
        if (!tableName || !item) {
          log.debug('Unable to calculate hash because missing required parameters')
          return
        }
        const keyNames = primaryKeyConfig?.[tableName]
        if (!keyNames) {
          return
        }
        const keyValues = extractPrimaryKeys(keyNames, item)
        if (keyValues) {
          return generatePointerHash([tableName, ...keyValues])
        }
      }
      /**
       * Calculates a hash for DynamoDB operations that have keys provided (UpdateItem, DeleteItem).
       * @param {string} tableName - Name of the DynamoDB table.
       * @param {Object} keysObject - Object containing primary key/value attributes in DynamoDB format.
       *                       (e.g., { userId: { S: "123" }, sortKey: { N: "456" } })
       * @returns {string|undefined} Hash value combining table name and primary key/value pairs, or undefined if unable.
       *
       * @example
       * calculateHashWithKnownKeys('UserTable', { userId: { S: "user123" }, timestamp: { N: "1234567" } })
       */
      static calculateHashWithKnownKeys(tableName, keysObject) {
        if (!tableName || !keysObject) {
          log.debug('Unable to calculate hash because missing parameters')
          return
        }
        const keyNames = Object.keys(keysObject)
        const keyValues = extractPrimaryKeys(keyNames, keysObject)
        if (keyValues) {
          return generatePointerHash([tableName, ...keyValues])
        }
      }
    }
    module2.exports = DynamoDb
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js
var require_eventbridge = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var BaseAwsSdkPlugin = require_base2()
    var EventBridge = class extends BaseAwsSdkPlugin {
      static id = 'eventbridge'
      static isPayloadReporter = true
      generateTags(params, operation, response) {
        if (!params?.source) return {}
        const rulename = params.Name ?? ''
        return {
          'resource.name': operation ? `${operation} ${params.source}` : params.source,
          'aws.eventbridge.source': `${params.source}`,
          rulename: `${rulename}`,
        }
      }
      /**
       * requestInject
       * @param {*} span
       * @param {*} request
       *
       * Docs: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html
       * We cannot use the traceHeader field as that's reserved for X-Ray.
       * Detail must be a valid JSON string
       * Max size per event is 256kb (https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-putevent-size.html)
       */
      requestInject(span, request) {
        const operation = request.operation
        if (
          operation === 'putEvents' &&
          request.params &&
          request.params.Entries &&
          request.params.Entries.length > 0 &&
          request.params.Entries[0].Detail
        ) {
          try {
            const details = JSON.parse(request.params.Entries[0].Detail)
            details._datadog = {}
            this.tracer.inject(span, 'text_map', details._datadog)
            const finalData = JSON.stringify(details)
            const byteSize = Buffer.byteLength(finalData)
            if (byteSize >= 1024 * 256) {
              log.info('Payload size too large to pass context')
              return
            }
            request.params.Entries[0].Detail = finalData
          } catch (e) {
            log.error('EventBridge error injecting request', e)
          }
        }
      }
    }
    module2.exports = EventBridge
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js
var require_kinesis = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js'(exports2, module2) {
    'use strict'
    var { DsmPathwayCodec, getSizeOrZero } = require_datastreams()
    var log = require_log2()
    var BaseAwsSdkPlugin = require_base2()
    var Kinesis = class extends BaseAwsSdkPlugin {
      static id = 'kinesis'
      static peerServicePrecursors = ['streamname']
      static isPayloadReporter = true
      constructor(...args) {
        super(...args)
        this.requestTags = /* @__PURE__ */ new WeakMap()
        this.addBind('apm:aws:response:start:kinesis', (ctx) => {
          const { request, response } = ctx
          const plugin = this
          let store = this._parentMap.get(request)
          if (request.operation === 'getShardIterator' || request.operation === 'listShards') {
            return this.storeStreamName(request.params, request.operation, store)
          }
          if (request.operation === 'getRecords') {
            let span
            const responseExtraction = this.responseExtract(request.params, request.operation, response)
            if (responseExtraction && responseExtraction.maybeChildOf) {
              ctx.needsFinish = true
              const options = {
                childOf: responseExtraction.maybeChildOf,
                meta: {
                  ...this.requestTags.get(request),
                  'span.kind': 'server',
                },
                integrationName: 'aws-sdk',
              }
              span = plugin.startSpan('aws.response', options, ctx)
              store = ctx.currentStore
            }
            const { streamName } = store
            this.responseExtractDSMContext(request.operation, request.params, response, span || null, { streamName })
          }
          return store
        })
        this.addSub('apm:aws:response:finish:kinesis', (ctx) => {
          if (!ctx.needsFinish) return
          this.finish(ctx)
        })
      }
      generateTags(params, operation, response) {
        if (!params || !params.StreamName) return {}
        return {
          'resource.name': `${operation} ${params.StreamName}`,
          'aws.kinesis.stream_name': params.StreamName,
          streamname: params.StreamName,
        }
      }
      storeStreamName(params, operation, store) {
        if (!operation) return store
        if (operation !== 'getShardIterator' && operation !== 'listShards') return store
        if (!params || !params.StreamName) return store
        const streamName = params.StreamName
        return { ...store, streamName }
      }
      responseExtract(params, operation, response) {
        if (operation !== 'getRecords') return
        if (params.Limit && params.Limit !== 1) return
        if (!response || !response.Records || !response.Records[0]) return
        const record = response.Records[0]
        try {
          const decodedData = JSON.parse(Buffer.from(record.Data).toString())
          return {
            maybeChildOf: this.tracer.extract('text_map', decodedData._datadog),
            parsedAttributes: decodedData._datadog,
          }
        } catch (e) {
          log.error('Kinesis error extracting response', e)
        }
      }
      responseExtractDSMContext(operation, params, response, span, kwargs = {}) {
        const { streamName } = kwargs
        if (!this.config.dsmEnabled) return
        if (operation !== 'getRecords') return
        if (!response || !response.Records || !response.Records[0]) return
        span = response.Records.length > 1 ? null : span
        response.Records.forEach((record) => {
          const parsedAttributes = JSON.parse(Buffer.from(record.Data).toString())
          const payloadSize = getSizeOrZero(record.Data)
          if (parsedAttributes?._datadog) {
            this.tracer.decodeDataStreamsContext(parsedAttributes._datadog)
          }
          const tags = streamName
            ? ['direction:in', `topic:${streamName}`, 'type:kinesis']
            : ['direction:in', 'type:kinesis']
          this.tracer.setCheckpoint(tags, span, payloadSize)
        })
      }
      // AWS-SDK will b64 kinesis payloads
      // or will accept an already b64 encoded payload
      // This method handles both
      _tryParse(body) {
        try {
          return JSON.parse(body)
        } catch {
          log.info('Not JSON string. Trying Base64 encoded JSON string')
        }
        try {
          return JSON.parse(Buffer.from(body, 'base64').toString('ascii'), true)
        } catch {
          return null
        }
      }
      requestInject(span, request) {
        const { operation, params } = request
        if (!params) return
        let stream
        switch (operation) {
          case 'putRecord':
            stream = params.StreamArn ?? params.StreamName ?? ''
            this.injectToMessage(span, params, stream, true)
            break
          case 'putRecords':
            stream = params.StreamArn ?? params.StreamName ?? ''
            for (let i = 0; i < params.Records.length; i++) {
              this.injectToMessage(span, params.Records[i], stream, i === 0 || this.config.batchPropagationEnabled)
            }
        }
      }
      injectToMessage(span, params, stream, injectTraceContext) {
        if (!params) {
          return
        }
        let parsedData
        if (injectTraceContext || this.config.dsmEnabled) {
          parsedData = this._tryParse(params.Data)
          if (!parsedData) {
            log.error('Unable to parse payload, unable to pass trace context or set DSM checkpoint (if enabled)')
            return
          }
        }
        const ddInfo = {}
        if (injectTraceContext) {
          this.tracer.inject(span, 'text_map', ddInfo)
        }
        if (this.config.dsmEnabled) {
          parsedData._datadog = ddInfo
          const dataStreamsContext = this.setDSMCheckpoint(span, parsedData, stream)
          DsmPathwayCodec.encode(dataStreamsContext, ddInfo)
        }
        if (Object.keys(ddInfo).length !== 0) {
          parsedData._datadog = ddInfo
          const finalData = Buffer.from(JSON.stringify(parsedData))
          const byteSize = finalData.length
          if (byteSize >= 1048576) {
            log.info('Payload size too large to pass context')
            return
          }
          params.Data = finalData
        }
      }
      setDSMCheckpoint(span, parsedData, stream) {
        const payloadSize = Buffer.byteLength(JSON.stringify(parsedData))
        const dataStreamsContext = this.tracer.setCheckpoint(
          ['direction:out', `topic:${stream}`, 'type:kinesis'],
          span,
          payloadSize
        )
        return dataStreamsContext
      }
    }
    module2.exports = Kinesis
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js
var require_lambda = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var BaseAwsSdkPlugin = require_base2()
    var Lambda = class extends BaseAwsSdkPlugin {
      static id = 'lambda'
      generateTags(params, operation, response) {
        if (!params?.FunctionName) return {}
        return {
          'resource.name': `${operation} ${params.FunctionName}`,
          functionname: params.FunctionName,
          'aws.lambda': params.FunctionName,
        }
      }
      requestInject(span, request) {
        const operation = request.operation
        if (operation === 'invoke') {
          if (!request.params) {
            request.params = {}
          }
          const isSyncInvocation = !request.params.InvocationType || request.params.InvocationType === 'RequestResponse'
          if (isSyncInvocation) {
            try {
              let clientContext = {}
              if (request.params.ClientContext) {
                const clientContextJson = Buffer.from(request.params.ClientContext, 'base64').toString('utf8')
                clientContext = JSON.parse(clientContextJson)
              }
              if (!clientContext.custom) {
                clientContext.custom = {}
              }
              this.tracer.inject(span, 'text_map', clientContext.custom)
              const newContextBase64 = Buffer.from(JSON.stringify(clientContext)).toString('base64')
              request.params.ClientContext = newContextBase64
            } catch (err) {
              log.error('Lambda error injecting request', err)
            }
          }
        }
      }
      operationFromRequest(request) {
        if (request.operation === 'invoke') {
          return this.operationName({
            type: 'web',
            kind: 'client',
          })
        }
        return this.operationName({
          id: 'aws',
          type: 'web',
          kind: 'client',
          awsService: 'lambda',
        })
      }
    }
    module2.exports = Lambda
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js
var require_redshift = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js'(exports2, module2) {
    'use strict'
    var BaseAwsSdkPlugin = require_base2()
    var Redshift = class extends BaseAwsSdkPlugin {
      static id = 'redshift'
      generateTags(params, operation, response) {
        if (!params?.ClusterIdentifier) return {}
        return {
          'resource.name': `${operation} ${params.ClusterIdentifier}`,
          'aws.redshift.cluster_identifier': params.ClusterIdentifier,
          clusteridentifier: params.ClusterIdentifier,
        }
      }
    }
    module2.exports = Redshift
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js
var require_s3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js'(exports2, module2) {
    'use strict'
    var BaseAwsSdkPlugin = require_base2()
    var log = require_log2()
    var { generatePointerHash } = require_util5()
    var { S3_PTR_KIND, SPAN_POINTER_DIRECTION } = require_constants2()
    var S3 = class extends BaseAwsSdkPlugin {
      static id = 's3'
      static peerServicePrecursors = ['bucketname']
      static isPayloadReporter = true
      generateTags(params, operation, response) {
        if (!params?.Bucket) return {}
        return {
          'resource.name': `${operation} ${params.Bucket}`,
          'aws.s3.bucket_name': params.Bucket,
          bucketname: params.Bucket,
        }
      }
      addSpanPointers(span, response) {
        const request = response?.request
        const operationName = request?.operation
        if (!['putObject', 'copyObject', 'completeMultipartUpload'].includes(operationName)) {
          return
        }
        const bucketName = request?.params?.Bucket
        const objectKey = request?.params?.Key
        let eTag =
          response?.ETag || // v3 PutObject & CompleteMultipartUpload
          response?.CopyObjectResult?.ETag || // v3 CopyObject
          response?.data?.ETag || // v2 PutObject & CompleteMultipartUpload
          response?.data?.CopyObjectResult?.ETag
        if (!bucketName || !objectKey || !eTag) {
          log.debug('Unable to calculate span pointer hash because of missing parameters.')
          return
        }
        if (eTag.startsWith('"') && eTag.endsWith('"')) {
          eTag = eTag.slice(1, -1)
        }
        const pointerHash = generatePointerHash([bucketName, objectKey, eTag])
        span.addSpanPointer(S3_PTR_KIND, SPAN_POINTER_DIRECTION.DOWNSTREAM, pointerHash)
      }
    }
    module2.exports = S3
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/stepfunctions.js
var require_stepfunctions = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/stepfunctions.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var BaseAwsSdkPlugin = require_base2()
    var Stepfunctions = class extends BaseAwsSdkPlugin {
      static id = 'stepfunctions'
      // This is the shape of StartExecutionInput, as defined in
      // https://github.com/aws/aws-sdk-js/blob/master/apis/states-2016-11-23.normal.json
      // "StartExecutionInput": {
      //   "type": "structure",
      //   "required": [
      //     "stateMachineArn"
      //   ],
      //   "members": {
      //     "stateMachineArn": {
      //       "shape": "Arn",
      //     },
      //     "name": {
      //       "shape": "Name",
      //     },
      //     "input": {
      //       "shape": "SensitiveData",
      //     },
      //     "traceHeader": {
      //       "shape": "TraceHeader",
      //     }
      //   }
      generateTags(params, operation, response) {
        if (!params) return {}
        const tags = { 'resource.name': params.name ? `${operation} ${params.name}` : `${operation}` }
        if (operation === 'startExecution' || operation === 'startSyncExecution') {
          tags.statemachinearn = `${params.stateMachineArn}`
        }
        return tags
      }
      requestInject(span, request) {
        const operation = request.operation
        if (operation === 'startExecution' || operation === 'startSyncExecution') {
          if (!request.params || !request.params.input) {
            return
          }
          const input = request.params.input
          try {
            const inputObj = JSON.parse(input)
            if (inputObj !== null && typeof inputObj === 'object') {
              inputObj._datadog = {}
              this.tracer.inject(span, 'text_map', inputObj._datadog)
              const newInput = JSON.stringify(inputObj)
              request.params.input = newInput
            }
          } catch {
            log.info('Unable to treat input as JSON')
          }
        }
      }
    }
    module2.exports = Stepfunctions
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sfn.js
var require_sfn = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sfn.js'(exports2, module2) {
    'use strict'
    var Stepfunctions = require_stepfunctions()
    var Sfn = class extends Stepfunctions {
      static id = 'sfn'
    }
    module2.exports = Sfn
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js
var require_sns = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js'(exports2, module2) {
    'use strict'
    var { DsmPathwayCodec, getHeadersSize } = require_datastreams()
    var log = require_log2()
    var BaseAwsSdkPlugin = require_base2()
    var Sns = class extends BaseAwsSdkPlugin {
      static id = 'sns'
      static peerServicePrecursors = ['topicname']
      static isPayloadReporter = true
      generateTags(params, operation, response) {
        if (!params) return {}
        if (!params.TopicArn && !(response.data && response.data.TopicArn)) return {}
        const TopicArn = params.TopicArn || response.data.TopicArn
        const arnParts = TopicArn.split(':')
        const topicName = arnParts.at(-1)
        return {
          'resource.name': `${operation} ${params.TopicArn || response.data.TopicArn}`,
          'aws.sns.topic_arn': TopicArn,
          topicname: topicName,
        }
      }
      operationFromRequest(request) {
        switch (request.operation) {
          case 'publish':
          case 'publishBatch':
            return this.operationName({
              type: 'messaging',
              kind: 'producer',
            })
        }
        return this.operationName({
          id: 'aws',
          type: 'web',
          kind: 'client',
          awsService: 'sns',
        })
      }
      requestInject(span, request) {
        const { operation, params } = request
        if (!params) return
        switch (operation) {
          case 'publish':
            this.injectToMessage(span, params, params.TopicArn, true)
            break
          case 'publishBatch':
            for (let i = 0; i < params.PublishBatchRequestEntries.length; i++) {
              this.injectToMessage(
                span,
                params.PublishBatchRequestEntries[i],
                params.TopicArn,
                i === 0 || this.config.batchPropagationEnabled
              )
            }
            break
        }
      }
      injectToMessage(span, params, topicArn, injectTraceContext) {
        if (!params.MessageAttributes) {
          params.MessageAttributes = {}
        } else if (Object.keys(params.MessageAttributes).length >= 10) {
          log.info('Message attributes full, skipping trace context injection')
          return
        }
        const ddInfo = {}
        if (injectTraceContext) {
          this.tracer.inject(span, 'text_map', ddInfo)
          params.MessageAttributes._datadog = {
            DataType: 'Binary',
            BinaryValue: ddInfo,
          }
        }
        if (this.config.dsmEnabled) {
          if (!params.MessageAttributes._datadog) {
            params.MessageAttributes._datadog = {
              DataType: 'Binary',
              BinaryValue: ddInfo,
            }
          }
          const dataStreamsContext = this.setDSMCheckpoint(span, params, topicArn)
          DsmPathwayCodec.encode(dataStreamsContext, ddInfo)
        }
        if (Object.keys(ddInfo).length !== 0) {
          params.MessageAttributes._datadog.BinaryValue = Buffer.from(JSON.stringify(ddInfo))
        } else if (params.MessageAttributes._datadog) {
          delete params.MessageAttributes._datadog
        }
      }
      setDSMCheckpoint(span, params, topicArn) {
        if (topicArn) {
          const payloadSize = getHeadersSize(params)
          const dataStreamsContext = this.tracer.setCheckpoint(
            ['direction:out', `topic:${topicArn}`, 'type:sns'],
            span,
            payloadSize
          )
          return dataStreamsContext
        }
      }
    }
    module2.exports = Sns
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js
var require_sqs = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var BaseAwsSdkPlugin = require_base2()
    var { DsmPathwayCodec, getHeadersSize } = require_datastreams()
    var { extractQueueMetadata } = require_util5()
    var Sqs = class extends BaseAwsSdkPlugin {
      static id = 'sqs'
      static peerServicePrecursors = ['queuename']
      static isPayloadReporter = true
      constructor(...args) {
        super(...args)
        this.requestTags = /* @__PURE__ */ new WeakMap()
        this.addBind('apm:aws:response:start:sqs', (ctx) => {
          const { request, response } = ctx
          const contextExtraction = this.responseExtract(request.params, request.operation, response)
          let store = this._parentMap.get(request)
          let span
          let parsedMessageAttributes = null
          if (contextExtraction && contextExtraction.datadogContext) {
            ctx.needsFinish = true
            const options = {
              childOf: contextExtraction.datadogContext,
              meta: {
                ...this.requestTags.get(request),
                'span.kind': 'server',
              },
              integrationName: 'aws-sdk',
            }
            parsedMessageAttributes = contextExtraction.parsedAttributes
            span = this.startSpan('aws.response', options, ctx)
            store = ctx.currentStore
          }
          this.responseExtractDSMContext(request.operation, request.params, response, span || null, {
            parsedAttributes: parsedMessageAttributes,
          })
          return store
        })
        this.addSub('apm:aws:response:finish:sqs', (ctx) => {
          if (!ctx.needsFinish) return
          this.finish(ctx)
        })
      }
      operationFromRequest(request) {
        switch (request.operation) {
          case 'receiveMessage':
            return this.operationName({
              type: 'messaging',
              kind: 'consumer',
            })
          case 'sendMessage':
          case 'sendMessageBatch':
            return this.operationName({
              type: 'messaging',
              kind: 'producer',
            })
        }
        return this.operationName({
          id: 'aws',
          type: 'web',
          kind: 'client',
          awsService: 'sqs',
        })
      }
      isEnabled(request) {
        const config = this.config
        switch (request.operation) {
          case 'receiveMessage':
            return config.consumer !== false
          case 'sendMessage':
          case 'sendMessageBatch':
            return config.producer !== false
          default:
            return true
        }
      }
      generateTags(params, operation, response) {
        if (!params || (!params.QueueName && !params.QueueUrl)) return {}
        const queueMetadata = extractQueueMetadata(params.QueueUrl)
        const queueName = queueMetadata?.queueName || params.QueueName
        const tags = {
          'resource.name': `${operation} ${params.QueueName || params.QueueUrl}`,
          'aws.sqs.queue_name': params.QueueName || params.QueueUrl,
          queuename: queueName,
        }
        if (queueMetadata?.arn) {
          tags['cloud.resource_id'] = queueMetadata.arn
        }
        switch (operation) {
          case 'receiveMessage':
            tags['span.type'] = 'worker'
            tags['span.kind'] = 'consumer'
            break
          case 'sendMessage':
          case 'sendMessageBatch':
            tags['span.kind'] = 'producer'
            break
        }
        return tags
      }
      responseExtract(params, operation, response) {
        if (operation !== 'receiveMessage') return
        if (params.MaxNumberOfMessages && params.MaxNumberOfMessages !== 1) return
        if (!response || !response.Messages || !response.Messages[0]) return
        let message = response.Messages[0]
        if (message.Body) {
          try {
            const body = JSON.parse(message.Body)
            if (body.Type === 'Notification') {
              message = body
            }
          } catch {}
        }
        if (!message.MessageAttributes || !message.MessageAttributes._datadog) return
        const datadogAttribute = message.MessageAttributes._datadog
        const parsedAttributes = this.parseDatadogAttributes(datadogAttribute)
        if (parsedAttributes) {
          return {
            datadogContext: this.tracer.extract('text_map', parsedAttributes),
            parsedAttributes,
          }
        }
      }
      parseDatadogAttributes(attributes) {
        try {
          if (attributes.StringValue) {
            const textMap = attributes.StringValue
            return JSON.parse(textMap)
          } else if (attributes.Type === 'Binary' || attributes.DataType === 'Binary') {
            const buffer = Buffer.from(attributes.Value ?? attributes.BinaryValue, 'base64')
            return JSON.parse(buffer)
          }
        } catch (e) {
          log.error('Sqs error parsing DD attributes', e)
        }
      }
      responseExtractDSMContext(operation, params, response, span, kwargs = {}) {
        let { parsedAttributes } = kwargs
        if (!this.config.dsmEnabled) return
        if (operation !== 'receiveMessage') return
        if (!response || !response.Messages || !response.Messages[0]) return
        span = response.Messages.length > 1 ? null : span
        response.Messages.forEach((message) => {
          if (!parsedAttributes) {
            if (message.Body) {
              try {
                const body = JSON.parse(message.Body)
                if (body.Type === 'Notification') {
                  message = body
                }
              } catch {}
            }
            if (!parsedAttributes && message.MessageAttributes && message.MessageAttributes._datadog) {
              parsedAttributes = this.parseDatadogAttributes(message.MessageAttributes._datadog)
            }
          }
          const payloadSize = getHeadersSize({
            Body: message.Body,
            MessageAttributes: message.MessageAttributes,
          })
          const queue = params.QueueUrl.split('/').pop()
          if (parsedAttributes) {
            this.tracer.decodeDataStreamsContext(parsedAttributes)
          }
          this.tracer.setCheckpoint(['direction:in', `topic:${queue}`, 'type:sqs'], span, payloadSize)
        })
      }
      requestInject(span, request) {
        const { operation, params } = request
        if (!params) return
        switch (operation) {
          case 'sendMessage':
            this.injectToMessage(span, params, params.QueueUrl, true)
            break
          case 'sendMessageBatch':
            for (let i = 0; i < params.Entries.length; i++) {
              this.injectToMessage(
                span,
                params.Entries[i],
                params.QueueUrl,
                i === 0 || this.config.batchPropagationEnabled
              )
            }
            break
          case 'receiveMessage':
            if (!params.MessageAttributeNames) {
              params.MessageAttributeNames = ['_datadog']
            } else if (
              !params.MessageAttributeNames.includes('_datadog') &&
              !params.MessageAttributeNames.includes('.*') &&
              !params.MessageAttributeNames.includes('All')
            ) {
              params.MessageAttributeNames.push('_datadog')
            }
            break
        }
      }
      injectToMessage(span, params, queueUrl, injectTraceContext) {
        if (!params) {
          params = {}
        }
        if (!params.MessageAttributes) {
          params.MessageAttributes = {}
        } else if (Object.keys(params.MessageAttributes).length >= 10) {
          return
        }
        const ddInfo = {}
        if (injectTraceContext) {
          this.tracer.inject(span, 'text_map', ddInfo)
          params.MessageAttributes._datadog = {
            DataType: 'String',
            StringValue: JSON.stringify(ddInfo),
          }
        }
        if (this.config.dsmEnabled) {
          if (!params.MessageAttributes._datadog) {
            params.MessageAttributes._datadog = {
              DataType: 'String',
              StringValue: JSON.stringify(ddInfo),
            }
          }
          const dataStreamsContext = this.setDSMCheckpoint(span, params, queueUrl)
          if (dataStreamsContext) {
            DsmPathwayCodec.encode(dataStreamsContext, ddInfo)
            params.MessageAttributes._datadog.StringValue = JSON.stringify(ddInfo)
          }
        }
        if (params.MessageAttributes._datadog && Object.keys(ddInfo).length === 0) {
          delete params.MessageAttributes._datadog
        }
      }
      setDSMCheckpoint(span, params, queueUrl) {
        const payloadSize = getHeadersSize({
          Body: params.MessageBody,
          MessageAttributes: params.MessageAttributes,
        })
        const queue = queueUrl.split('/').pop()
        const dataStreamsContext = this.tracer.setCheckpoint(
          ['direction:out', `topic:${queue}`, 'type:sqs'],
          span,
          payloadSize
        )
        return dataStreamsContext
      }
    }
    module2.exports = Sqs
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/states.js
var require_states = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/states.js'(exports2, module2) {
    'use strict'
    var Stepfunctions = require_stepfunctions()
    var States = class extends Stepfunctions {
      static id = 'states'
    }
    module2.exports = States
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/utils.js
var require_utils3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/utils.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var MODEL_TYPE_IDENTIFIERS = [
      'foundation-model/',
      'custom-model/',
      'provisioned-model/',
      'imported-module/',
      'prompt/',
      'endpoint/',
      'inference-profile/',
      'default-prompt-router/',
    ]
    var PROVIDER = {
      AI21: 'AI21',
      AMAZON: 'AMAZON',
      ANTHROPIC: 'ANTHROPIC',
      COHERE: 'COHERE',
      META: 'META',
      STABILITY: 'STABILITY',
      MISTRAL: 'MISTRAL',
    }
    function extractTextAndResponseReasonFromStream(chunks, modelProvider, modelName) {
      const modelProviderUpper = modelProvider.toUpperCase()
      if (
        (modelProviderUpper === PROVIDER.AMAZON && modelName.includes('embed')) ||
        (modelProviderUpper === PROVIDER.COHERE && modelName.includes('embed')) ||
        modelProviderUpper === PROVIDER.STABILITY
      ) {
        return {}
      }
      let message = ''
      let inputTokens = 0
      let outputTokens = 0
      let cacheReadTokens = 0
      let cacheWriteTokens = 0
      for (const {
        chunk: { bytes },
      } of chunks) {
        const body = JSON.parse(Buffer.from(bytes).toString('utf8'))
        switch (modelProviderUpper) {
          case PROVIDER.AMAZON: {
            if (body?.outputText) {
              message += body?.outputText
              inputTokens = body?.inputTextTokenCount
              outputTokens = body?.totalOutputTextTokenCount
            } else if (body?.contentBlockDelta?.delta?.text) {
              message += body.contentBlockDelta.delta.text
            }
            break
          }
          case PROVIDER.AI21: {
            const content = body?.choices?.[0]?.delta?.content
            if (content) {
              message += content
            }
            break
          }
          case PROVIDER.ANTHROPIC: {
            if (body.completion) {
              message += body.completion
            } else if (body.delta?.text) {
              message += body.delta.text
            }
            if (body.message?.usage?.input_tokens) inputTokens = body.message.usage.input_tokens
            if (body.message?.usage?.output_tokens) outputTokens = body.message.usage.output_tokens
            break
          }
          case PROVIDER.COHERE: {
            if (body?.event_type === 'stream-end') {
              message = body.response?.text
            }
            break
          }
          case PROVIDER.META: {
            message += body?.generation
            break
          }
          case PROVIDER.MISTRAL: {
            message += body?.outputs?.[0]?.text
            break
          }
        }
        const invocationMetrics = body['amazon-bedrock-invocationMetrics']
        if (invocationMetrics) {
          inputTokens = invocationMetrics.inputTokenCount
          outputTokens = invocationMetrics.outputTokenCount
          cacheReadTokens = invocationMetrics.cacheReadInputTokenCount
          cacheWriteTokens = invocationMetrics.cacheWriteInputTokenCount
        }
      }
      return new Generation({
        message,
        role: 'assistant',
        inputTokens,
        outputTokens,
        cacheReadTokens,
        cacheWriteTokens,
      })
    }
    var Generation = class {
      constructor({
        message = '',
        finishReason = '',
        choiceId = '',
        role,
        inputTokens,
        outputTokens,
        cacheReadTokens,
        cacheWriteTokens,
      } = {}) {
        this.message = typeof message === 'string' ? message : JSON.stringify(message) || ''
        this.finishReason = finishReason || ''
        this.choiceId = choiceId || void 0
        this.role = role
        this.usage = {
          inputTokens,
          outputTokens,
          cacheReadTokens,
          cacheWriteTokens,
        }
      }
    }
    var RequestParams = class {
      constructor({
        prompt = '',
        temperature,
        topP,
        topK,
        maxTokens,
        stopSequences = [],
        inputType = '',
        truncate = '',
        stream = '',
        n,
      } = {}) {
        this.prompt = prompt
        this.temperature = temperature
        this.topP = topP
        this.topK = topK
        this.maxTokens = maxTokens
        this.stopSequences = stopSequences || []
        this.inputType = inputType || ''
        this.truncate = truncate || ''
        this.stream = stream || ''
        this.n = n
      }
    }
    function parseModelId(modelId) {
      modelId = modelId.toLowerCase()
      if (!modelId.startsWith('arn:aws')) {
        const modelMeta = modelId.split('.')
        if (modelMeta.length < 2) {
          return { modelProvider: 'custom', modelName: modelMeta[0] }
        }
        return { modelProvider: modelMeta.at(-2), modelName: modelMeta.at(-1) }
      }
      for (const identifier of MODEL_TYPE_IDENTIFIERS) {
        if (!modelId.includes(identifier)) {
          continue
        }
        modelId = modelId.split(identifier).pop()
        if (['foundation-model/', 'custom-model/'].includes(identifier)) {
          const modelMeta = modelId.split('.')
          if (modelMeta.length < 2) {
            return { modelProvider: 'custom', modelName: modelId }
          }
          return { modelProvider: modelMeta.at(-2), modelName: modelMeta.at(-1) }
        }
        return { modelProvider: 'custom', modelName: modelId }
      }
      return { modelProvider: 'custom', modelName: 'custom' }
    }
    function extractRequestParams(params, provider) {
      const requestBody = JSON.parse(params.body)
      const modelId = params.modelId
      switch (provider.toUpperCase()) {
        case PROVIDER.AI21: {
          let userPrompt = requestBody.prompt
          if (modelId.includes('jamba')) {
            for (const message of requestBody.messages) {
              if (message.role === 'user') {
                userPrompt = message.content
              }
            }
          }
          return new RequestParams({
            prompt: userPrompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_tokens,
            stopSequences: requestBody.stop_sequences,
          })
        }
        case PROVIDER.AMAZON: {
          const prompt = requestBody.inputText
          if (modelId.includes('embed')) {
            return new RequestParams({ prompt })
          } else if (prompt !== void 0) {
            const textGenerationConfig = requestBody.textGenerationConfig || {}
            return new RequestParams({
              prompt,
              temperature: textGenerationConfig.temperature,
              topP: textGenerationConfig.topP,
              maxTokens: textGenerationConfig.maxTokenCount,
              stopSequences: textGenerationConfig.stopSequences,
            })
          } else if (Array.isArray(requestBody.messages)) {
            const inferenceConfig = requestBody.inferenceConfig || {}
            const messages = []
            if (Array.isArray(requestBody.system)) {
              for (const sysMsg of requestBody.system) {
                messages.push({
                  content: sysMsg.text,
                  role: 'system',
                })
              }
            }
            for (const message of requestBody.messages) {
              const textBlocks = message.content?.filter((block) => block.text) || []
              if (textBlocks.length > 0) {
                messages.push({
                  content: textBlocks.map((block) => block.text).join(''),
                  role: message.role,
                })
              }
            }
            return new RequestParams({
              prompt: messages,
              temperature: inferenceConfig.temperature,
              topP: inferenceConfig.topP,
              maxTokens: inferenceConfig.maxTokens,
              stopSequences: inferenceConfig.stopSequences,
            })
          }
          return new RequestParams({ prompt })
        }
        case PROVIDER.ANTHROPIC: {
          let prompt = requestBody.prompt
          if (Array.isArray(requestBody.messages)) {
            for (let idx = requestBody.messages.length - 1; idx >= 0; idx--) {
              const message = requestBody.messages[idx]
              if (message.role === 'user') {
                prompt = message.content
                  ?.filter((block) => block.type === 'text')
                  .map((block) => block.text)
                  .join('')
                break
              }
            }
          }
          return new RequestParams({
            prompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_tokens_to_sample ?? requestBody.max_tokens,
            stopSequences: requestBody.stop_sequences,
          })
        }
        case PROVIDER.COHERE: {
          if (modelId.includes('embed')) {
            return new RequestParams({
              prompt: requestBody.texts,
              inputType: requestBody.input_type,
              truncate: requestBody.truncate,
            })
          }
          return new RequestParams({
            prompt: requestBody.prompt,
            temperature: requestBody.temperature,
            topP: requestBody.p,
            maxTokens: requestBody.max_tokens,
            stopSequences: requestBody.stop_sequences,
            stream: requestBody.stream,
            n: requestBody.num_generations,
          })
        }
        case PROVIDER.META: {
          return new RequestParams({
            prompt: requestBody.prompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_gen_len,
          })
        }
        case PROVIDER.MISTRAL: {
          return new RequestParams({
            prompt: requestBody.prompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_tokens,
            stopSequences: requestBody.stop,
            topK: requestBody.top_k,
          })
        }
        case PROVIDER.STABILITY: {
          return new RequestParams()
        }
        default: {
          return new RequestParams()
        }
      }
    }
    function extractTextAndResponseReason(response, provider, modelName) {
      const body = JSON.parse(Buffer.from(response.body).toString('utf8'))
      const shouldSetChoiceIds = provider.toUpperCase() === PROVIDER.COHERE && !modelName.includes('embed')
      try {
        switch (provider.toUpperCase()) {
          case PROVIDER.AI21: {
            if (modelName.includes('jamba')) {
              const generations = body.choices || []
              if (generations.length > 0) {
                const generation = generations[0]
                return new Generation({
                  message: generation.message.content,
                  finishReason: generation.finish_reason,
                  choiceId: shouldSetChoiceIds ? generation.id : void 0,
                  role: generation.message.role,
                  inputTokens: body.usage?.prompt_tokens,
                  outputTokens: body.usage?.completion_tokens,
                })
              }
            }
            const completions = body.completions || []
            if (completions.length > 0) {
              const completion = completions[0]
              return new Generation({
                message: completion.data?.text,
                finishReason: completion?.finishReason,
                choiceId: shouldSetChoiceIds ? completion?.id : void 0,
                inputTokens: body.usage?.prompt_tokens,
                outputTokens: body.usage?.completion_tokens,
              })
            }
            return new Generation()
          }
          case PROVIDER.AMAZON: {
            if (modelName.includes('embed')) {
              return new Generation({ message: body.embedding })
            }
            if (body.results) {
              const results = body.results || []
              if (results.length > 0) {
                const result = results[0]
                return new Generation({
                  message: result.outputText,
                  finishReason: result.completionReason,
                  inputTokens: body.inputTextTokenCount,
                  outputTokens: result.tokenCount,
                })
              }
            } else if (body.output) {
              const output = body.output || {}
              return new Generation({
                message: output.message?.content[0]?.text ?? 'Unsupported content type',
                finishReason: body.stopReason,
                role: output.message?.role,
                inputTokens: body.usage?.inputTokens,
                outputTokens: body.usage?.outputTokens,
                cacheReadInputTokenCount: body.usage?.cacheReadInputTokenCount,
                cacheWriteInputTokenCount: body.usage?.cacheWriteInputTokenCount,
              })
            }
            break
          }
          case PROVIDER.ANTHROPIC: {
            let message = body.completion
            if (Array.isArray(body.content)) {
              message = body.content.find((item) => item.type === 'text')?.text ?? body.content
            } else if (body.content) {
              message = body.content
            }
            return new Generation({ message, finishReason: body.stop_reason })
          }
          case PROVIDER.COHERE: {
            if (modelName.includes('embed')) {
              const embeddings = body.embeddings || [[]]
              if (embeddings.length > 0) {
                return new Generation({ message: embeddings[0] })
              }
            }
            if (body.text) {
              return new Generation({
                message: body.text,
                finishReason: body.finish_reason,
                choiceId: shouldSetChoiceIds ? body.response_id : void 0,
              })
            }
            const generations = body.generations || []
            if (generations.length > 0) {
              const generation = generations[0]
              return new Generation({
                message: generation.text,
                finishReason: generation.finish_reason,
                choiceId: shouldSetChoiceIds ? generation.id : void 0,
              })
            }
            break
          }
          case PROVIDER.META: {
            return new Generation({
              message: body.generation,
              finishReason: body.stop_reason,
              inputTokens: body.prompt_token_count,
              outputTokens: body.generation_token_count,
            })
          }
          case PROVIDER.MISTRAL: {
            const mistralGenerations = body.outputs || []
            if (mistralGenerations.length > 0) {
              const generation = mistralGenerations[0]
              return new Generation({ message: generation.text, finishReason: generation.stop_reason })
            }
            break
          }
          case PROVIDER.STABILITY: {
            return new Generation()
          }
          default: {
            return new Generation()
          }
        }
      } catch {
        log.warn('Unable to extract text/finishReason from response body. Defaulting to empty text/finishReason.')
        return new Generation()
      }
      return new Generation()
    }
    module2.exports = {
      Generation,
      RequestParams,
      extractTextAndResponseReasonFromStream,
      parseModelId,
      extractRequestParams,
      extractTextAndResponseReason,
      PROVIDER,
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/tracing.js
var require_tracing3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/tracing.js'(exports2, module2) {
    'use strict'
    var BaseAwsSdkPlugin = require_base2()
    var { parseModelId } = require_utils3()
    var enabledOperations = /* @__PURE__ */ new Set(['invokeModel', 'invokeModelWithResponseStream'])
    var BedrockRuntime = class extends BaseAwsSdkPlugin {
      static id = 'bedrockruntime'
      isEnabled(request) {
        const operation = request.operation
        if (!enabledOperations.has(operation)) {
          return false
        }
        return super.isEnabled(request)
      }
      generateTags(params, operation) {
        const { modelProvider, modelName } = parseModelId(params.modelId)
        return {
          'resource.name': operation,
          'aws.bedrock.request.model': modelName,
          'aws.bedrock.request.model_provider': modelProvider.toLowerCase(),
        }
      }
    }
    module2.exports = BedrockRuntime
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/bedrockruntime.js
var require_bedrockruntime = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/bedrockruntime.js'(exports2, module2) {
    'use strict'
    var BaseLLMObsPlugin = require_base()
    var { storage } = require_datadog_core()
    var llmobsStore = storage('llmobs')
    var telemetry = require_telemetry4()
    var { extractRequestParams, extractTextAndResponseReason, parseModelId, extractTextAndResponseReasonFromStream } =
      require_utils3()
    var ENABLED_OPERATIONS = /* @__PURE__ */ new Set(['invokeModel', 'invokeModelWithResponseStream'])
    var requestIdsToTokens = {}
    var BedrockRuntimeLLMObsPlugin = class extends BaseLLMObsPlugin {
      constructor() {
        super(...arguments)
        this.addSub('apm:aws:request:complete:bedrockruntime', (ctx) => {
          const { response } = ctx
          const request = response.request
          const operation = request.operation
          if (!ENABLED_OPERATIONS.has(operation)) {
            return
          }
          const { modelProvider, modelName } = parseModelId(request.params.modelId)
          if (modelName.includes('embed')) {
            return
          }
          const span = ctx.currentStore?.span
          this.setLLMObsTags({ ctx, request, span, response, modelProvider, modelName })
        })
        this.addSub('apm:aws:response:deserialize:bedrockruntime', ({ headers }) => {
          const requestId = headers['x-amzn-requestid']
          const inputTokenCount = headers['x-amzn-bedrock-input-token-count']
          const outputTokenCount = headers['x-amzn-bedrock-output-token-count']
          const cacheReadTokenCount = headers['x-amzn-bedrock-cache-read-input-token-count']
          const cacheWriteTokenCount = headers['x-amzn-bedrock-cache-write-input-token-count']
          requestIdsToTokens[requestId] = {
            inputTokensFromHeaders: inputTokenCount && Number.parseInt(inputTokenCount),
            outputTokensFromHeaders: outputTokenCount && Number.parseInt(outputTokenCount),
            cacheReadTokensFromHeaders: cacheReadTokenCount && Number.parseInt(cacheReadTokenCount),
            cacheWriteTokensFromHeaders: cacheWriteTokenCount && Number.parseInt(cacheWriteTokenCount),
          }
        })
        this.addSub('apm:aws:response:streamed-chunk:bedrockruntime', ({ ctx, chunk }) => {
          if (!ctx.chunks) ctx.chunks = []
          if (chunk) ctx.chunks.push(chunk)
        })
      }
      setLLMObsTags({ ctx, request, span, response, modelProvider, modelName }) {
        const isStream = request?.operation?.toLowerCase().includes('stream')
        telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: true, integration: 'bedrock' })
        const parent = llmobsStore.getStore()?.span
        this._tagger.registerLLMObsSpan(span, {
          parent,
          modelName: modelName.toLowerCase(),
          modelProvider: modelProvider.toLowerCase(),
          kind: 'llm',
          name: 'bedrock-runtime.command',
          integration: 'bedrock',
        })
        const requestParams = extractRequestParams(request.params, modelProvider)
        const textAndResponseReason = isStream
          ? extractTextAndResponseReasonFromStream(ctx.chunks, modelProvider, modelName)
          : extractTextAndResponseReason(response, modelProvider, modelName)
        this._tagger.tagMetadata(span, {
          temperature: Number.parseFloat(requestParams.temperature) || 0,
          max_tokens: Number.parseInt(requestParams.maxTokens) || 0,
        })
        this._tagger.tagLLMIO(span, requestParams.prompt, [
          { content: textAndResponseReason.message, role: textAndResponseReason.role },
        ])
        const { inputTokens, outputTokens, totalTokens, cacheReadTokens, cacheWriteTokens } = extractTokens({
          requestId: response.$metadata.requestId,
          usage: textAndResponseReason.usage,
        })
        this._tagger.tagMetrics(span, {
          inputTokens,
          outputTokens,
          totalTokens,
          cacheReadTokens,
          cacheWriteTokens,
        })
      }
    }
    function extractTokens({ requestId, usage }) {
      const {
        inputTokensFromHeaders,
        outputTokensFromHeaders,
        cacheReadTokensFromHeaders,
        cacheWriteTokensFromHeaders,
      } = requestIdsToTokens[requestId] || {}
      delete requestIdsToTokens[requestId]
      const inputTokens = usage.inputTokens || inputTokensFromHeaders || 0
      const outputTokens = usage.outputTokens || outputTokensFromHeaders || 0
      const cacheReadTokens = usage.cacheReadTokens || cacheReadTokensFromHeaders || 0
      const cacheWriteTokens = usage.cacheWriteTokens || cacheWriteTokensFromHeaders || 0
      const normalizedInputTokens = inputTokens + cacheReadTokens + cacheWriteTokens
      return {
        inputTokens: normalizedInputTokens,
        outputTokens,
        totalTokens: normalizedInputTokens + outputTokens,
        cacheReadTokens,
        cacheWriteTokens,
      }
    }
    module2.exports = BedrockRuntimeLLMObsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/index.js
var require_bedrockruntime2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var BedrockRuntimeTracing = require_tracing3()
    var BedrockRuntimeLLMObsPlugin = require_bedrockruntime()
    var BedrockRuntimePlugin = class extends CompositePlugin {
      static id = 'bedrockruntime'
      static get plugins() {
        return {
          llmobs: BedrockRuntimeLLMObsPlugin,
          tracing: BedrockRuntimeTracing,
        }
      }
    }
    module2.exports = BedrockRuntimePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/default.js
var require_default = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/default.js'(exports2, module2) {
    'use strict'
    var BaseAwsSdkPlugin = require_base2()
    var Default = class extends BaseAwsSdkPlugin {}
    module2.exports = Default
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/index.js
var require_services = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/index.js'(exports2) {
    'use strict'
    exports2.cloudwatchlogs = require_cloudwatchlogs()
    exports2.dynamodb = require_dynamodb()
    exports2.eventbridge = require_eventbridge()
    exports2.kinesis = require_kinesis()
    exports2.lambda = require_lambda()
    exports2.redshift = require_redshift()
    exports2.s3 = require_s3()
    exports2.sfn = require_sfn()
    exports2.sns = require_sns()
    exports2.sqs = require_sqs()
    exports2.states = require_states()
    exports2.stepfunctions = require_stepfunctions()
    exports2.bedrockruntime = require_bedrockruntime2()
    exports2.default = require_default()
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js
var require_src3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var services = require_services()
    var AwsSdkPlugin = class extends Plugin {
      static id = 'aws-sdk'
      constructor(...args) {
        super(...args)
        this.services = {}
        for (const name in services) {
          const ServicePlugin = services[name]
          this.services[name] = new ServicePlugin(...args)
        }
      }
      configure(config) {
        for (const service of Object.values(this.services)) {
          service.configure(config)
        }
      }
    }
    module2.exports = AwsSdkPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/producer.js
var require_producer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/producer.js'(exports2, module2) {
    'use strict'
    var OutboundPlugin = require_outbound()
    var ProducerPlugin = class extends OutboundPlugin {
      static operation = 'publish'
      static kind = 'producer'
      static type = 'messaging'
      startSpan(options, enterOrCtx) {
        const spanDefaults = {
          kind: this.constructor.kind,
        }
        if (!options.service) {
          options.service = this.config.service || this.serviceName()
        }
        Object.keys(spanDefaults).forEach((key) => {
          if (!options[key]) options[key] = spanDefaults[key]
        })
        return super.startSpan(this.operationName(), options, enterOrCtx)
      }
    }
    module2.exports = ProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-azure-event-hubs/src/producer.js
var require_producer2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-azure-event-hubs/src/producer.js'(exports2, module2) {
    'use strict'
    var { getEnvironmentVariable } = require_config_helper()
    var ProducerPlugin = require_producer()
    var AzureEventHubsProducerPlugin = class extends ProducerPlugin {
      static get id() {
        return 'azure-event-hubs'
      }
      static get operation() {
        return 'send'
      }
      static get prefix() {
        return 'tracing:apm:azure-event-hubs:send'
      }
      bindStart(ctx) {
        if (!batchLinksAreEnabled() && ctx.functionName === 'tryAdd') {
          return ctx.currentStore
        }
        const qualifiedNamespace = ctx.config.endpoint.replace('sb://', '').replace('/', '')
        const entityPath = ctx.config.entityPath
        const span = this.startSpan(
          {
            resource: entityPath,
            type: 'messaging',
            meta: {
              component: 'azure-event-hubs',
              'messaging.system': 'eventhubs',
              'messaging.destination.name': entityPath,
              'network.destination.name': qualifiedNamespace,
            },
          },
          ctx
        )
        if (ctx.functionName === 'tryAdd') {
          span._spanContext._name = 'azure.eventhubs.create'
          span.setTag('messaging.operation', 'create')
          if (ctx.eventData.messageID !== void 0) {
            span.setTag('message.id', ctx.eventData.messageID)
          }
          if (batchLinksAreEnabled()) {
            ctx.batch._spanContexts.push(span.context())
            injectTraceContext(this.tracer, span, ctx.eventData)
          }
        }
        if (ctx.functionName === 'sendBatch') {
          const eventData = ctx.eventData
          const eventDataLength = eventData.length || eventData._context.connection._eventsCount
          span.setTag('messaging.operation', 'send')
          span.setTag('messaging.batch.message_count', eventDataLength)
          if (eventData.constructor.name !== 'EventDataBatchImpl' && Array.isArray(eventData)) {
            eventData.forEach((event) => {
              injectTraceContext(this.tracer, span, event)
            })
          } else {
            if (batchLinksAreEnabled()) {
              eventData._spanContexts.forEach((spanContext) => {
                span.addLink(spanContext)
              })
            }
          }
        }
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        super.finish()
      }
    }
    function injectTraceContext(tracer2, span, event) {
      if (!event.properties) {
        event.properties = {}
      }
      tracer2.inject(span, 'text_map', event.properties)
    }
    function batchLinksAreEnabled() {
      const eh = getEnvironmentVariable('DD_TRACE_AZURE_EVENTHUBS_BATCH_LINKS_ENABLED')
      return eh !== 'false'
    }
    module2.exports = AzureEventHubsProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-azure-event-hubs/src/index.js
var require_src4 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-azure-event-hubs/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer2()
    var CompositePlugin = require_composite()
    var AzureEventHubsPlugin = class extends CompositePlugin {
      static get id() {
        return 'azure-event-hubs'
      }
      static get plugins() {
        return {
          producer: ProducerPlugin,
        }
      }
    }
    module2.exports = AzureEventHubsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-core/src/utils/src/uniq.js
var require_uniq = __commonJS({
  'node_modules/dd-trace/packages/datadog-core/src/utils/src/uniq.js'(exports2, module2) {
    'use strict'
    module2.exports = function uniq(arr) {
      return [...new Set(arr)]
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js
var require_urlfilter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    function applyFilter(filter, uri) {
      if (typeof filter === 'function') {
        return filter(uri)
      } else if (filter instanceof RegExp) {
        return filter.test(uri)
      } else if (Array.isArray(filter)) {
        return filter.some((filter2) => applyFilter(filter2, uri))
      }
      return filter === uri
    }
    var urlFilter = {
      getFilter(config) {
        if (typeof config.filter === 'function') {
          return config.filter
        } else if (config.hasOwnProperty('filter')) {
          log.error('Expected `filter` to be a function. Overriding filter property to default.')
        }
        const allowlist = config.allowlist || config.whitelist || /.*/
        const blocklist = config.blocklist || config.blacklist || []
        return (uri) => applyFilter(allowlist, uri) && !applyFilter(blocklist, uri)
      },
    }
    module2.exports = urlFilter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/inferred_proxy.js
var require_inferred_proxy = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/inferred_proxy.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var tags = require_tags()
    var RESOURCE_NAME = tags.RESOURCE_NAME
    var SPAN_TYPE = tags.SPAN_TYPE
    var HTTP_URL = tags.HTTP_URL
    var HTTP_METHOD = tags.HTTP_METHOD
    var PROXY_HEADER_SYSTEM = 'x-dd-proxy'
    var PROXY_HEADER_START_TIME_MS = 'x-dd-proxy-request-time-ms'
    var PROXY_HEADER_PATH = 'x-dd-proxy-path'
    var PROXY_HEADER_HTTPMETHOD = 'x-dd-proxy-httpmethod'
    var PROXY_HEADER_DOMAIN = 'x-dd-proxy-domain-name'
    var PROXY_HEADER_STAGE = 'x-dd-proxy-stage'
    var supportedProxies = {
      'aws-apigateway': {
        spanName: 'aws.apigateway',
        component: 'aws-apigateway',
      },
    }
    function createInferredProxySpan(headers, childOf, tracer2, reqCtx, traceCtx, config, startSpanHelper) {
      if (!headers) {
        return null
      }
      if (!tracer2._config?.inferredProxyServicesEnabled) {
        return null
      }
      const proxyContext = extractInferredProxyContext(headers)
      if (!proxyContext) {
        return null
      }
      const proxySpanInfo = supportedProxies[proxyContext.proxySystemName]
      log.debug('Successfully extracted inferred span info %s for proxy:', proxyContext, proxyContext.proxySystemName)
      const span = startSpanHelper(
        tracer2,
        proxySpanInfo.spanName,
        {
          childOf,
          type: 'web',
          startTime: proxyContext.requestTime,
          integrationName: proxySpanInfo.component,
          meta: {
            service: proxyContext.domainName || tracer2._config.service,
            component: proxySpanInfo.component,
            [SPAN_TYPE]: 'web',
            [HTTP_METHOD]: proxyContext.method,
            [HTTP_URL]: proxyContext.domainName + proxyContext.path,
            stage: proxyContext.stage,
          },
        },
        traceCtx,
        config
      )
      reqCtx.inferredProxySpan = span
      childOf = span
      log.debug('Successfully created inferred proxy span.')
      setInferredProxySpanTags(span, proxyContext)
      return childOf
    }
    function setInferredProxySpanTags(span, proxyContext) {
      span.setTag(RESOURCE_NAME, `${proxyContext.method} ${proxyContext.path}`)
      span.setTag('_dd.inferred_span', 1)
      return span
    }
    function extractInferredProxyContext(headers) {
      if (!(PROXY_HEADER_START_TIME_MS in headers)) {
        return null
      }
      if (!(PROXY_HEADER_SYSTEM in headers && headers[PROXY_HEADER_SYSTEM] in supportedProxies)) {
        log.debug(
          'Received headers to create inferred proxy span but headers include an unsupported proxy type',
          headers
        )
        return null
      }
      return {
        requestTime: headers[PROXY_HEADER_START_TIME_MS]
          ? Number.parseInt(headers[PROXY_HEADER_START_TIME_MS], 10)
          : null,
        method: headers[PROXY_HEADER_HTTPMETHOD],
        path: headers[PROXY_HEADER_PATH],
        stage: headers[PROXY_HEADER_STAGE],
        domainName: headers[PROXY_HEADER_DOMAIN],
        proxySystemName: headers[PROXY_HEADER_SYSTEM],
      }
    }
    function finishInferredProxySpan(context) {
      const { req } = context
      if (!context.inferredProxySpan) return
      if (context.inferredProxySpanFinished && !req.stream) return
      if (context.inferredProxySpan) {
        context.inferredProxySpan.finish()
        context.inferredProxySpanFinished = true
      }
    }
    module2.exports = {
      createInferredProxySpan,
      finishInferredProxySpan,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/ip_extractor.js
var require_ip_extractor = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/ip_extractor.js'(exports2, module2) {
    'use strict'
    var net = require('net')
    var FORWARED_HEADER_NAME = 'forwarded'
    var ipHeaderList = [
      'x-forwarded-for',
      'x-real-ip',
      'true-client-ip',
      'x-client-ip',
      FORWARED_HEADER_NAME,
      'forwarded-for',
      'x-cluster-client-ip',
      'fastly-client-ip',
      'cf-connecting-ip',
      'cf-connecting-ipv6',
    ]
    var privateCIDRs = [
      '127.0.0.0/8',
      '10.0.0.0/8',
      '172.16.0.0/12',
      '192.168.0.0/16',
      '169.254.0.0/16',
      '100.65.0.0/10',
      '::1/128',
      'fec0::/10',
      'fe80::/10',
      'fc00::/7',
      'fd00::/8',
    ]
    var privateIPMatcher = new net.BlockList()
    for (const cidr of privateCIDRs) {
      const [address, prefix] = cidr.split('/')
      privateIPMatcher.addSubnet(address, Number.parseInt(prefix), net.isIPv6(address) ? 'ipv6' : 'ipv4')
    }
    function extractIp(config, req) {
      const headers = req.headers
      if (config.clientIpHeader) {
        if (!headers) return
        const ipHeaderName = config.clientIpHeader
        const header = headers[ipHeaderName]
        if (typeof header !== 'string') return
        const ip = findFirstIp(header, ipHeaderName === FORWARED_HEADER_NAME)
        return ip.public || ip.private
      }
      let firstPrivateIp
      if (headers) {
        for (const ipHeaderName of ipHeaderList) {
          const header = headers[ipHeaderName]
          if (typeof header !== 'string') continue
          const ip = findFirstIp(header, ipHeaderName === FORWARED_HEADER_NAME)
          if (ip.public) {
            return ip.public
          } else if (!firstPrivateIp && ip.private) {
            firstPrivateIp = ip.private
          }
        }
      }
      return firstPrivateIp || req.socket?.remoteAddress
    }
    function findFirstIp(str, isForwardedHeader) {
      const result = {}
      if (!str) return result
      const splitted = str.split(',')
      for (let chunk of splitted) {
        if (isForwardedHeader) {
          const forDirective = chunk.split(';').find((subchunk) => subchunk.trim().toLowerCase().startsWith('for='))
          if (forDirective) {
            chunk = forDirective.slice(4)
          }
        }
        chunk = chunk.trim()
        if (chunk.startsWith('"') && chunk.endsWith('"')) {
          chunk = chunk.slice(1, -1).trim()
        }
        chunk = cleanIp(chunk)
        if (!chunk) continue
        const type = net.isIP(chunk)
        if (!type) continue
        if (!privateIPMatcher.check(chunk, type === 6 ? 'ipv6' : 'ipv4')) {
          result.public = chunk
          return result
        }
        if (!result.private) result.private = chunk
      }
      return result
    }
    function cleanIp(input) {
      const colonIndex = input.indexOf(':')
      if (colonIndex !== -1 && input.includes('.')) {
        return input.slice(0, colonIndex).trim()
      }
      const closingBracketIndex = input.indexOf(']')
      if (closingBracketIndex !== -1 && input.startsWith('[')) {
        return input.slice(1, closingBracketIndex).trim()
      }
      return input
    }
    module2.exports = {
      extractIp,
      ipHeaderList,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js
var require_web3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js'(exports2, module2) {
    'use strict'
    var uniq = require_uniq()
    var analyticsSampler = require_analytics_sampler()
    var FORMAT_HTTP_HEADERS = 'http_headers'
    var log = require_log2()
    var tags = require_tags()
    var types = require_types()
    var kinds = require_kinds()
    var urlFilter = require_urlfilter()
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants2()
    var { createInferredProxySpan, finishInferredProxySpan } = require_inferred_proxy()
    var TracingPlugin = require_tracing()
    var { extractURL, obfuscateQs, calculateHttpEndpoint } = require_url()
    var extractIp
    var WEB = types.WEB
    var SERVER = kinds.SERVER
    var RESOURCE_NAME = tags.RESOURCE_NAME
    var SERVICE_NAME = tags.SERVICE_NAME
    var SPAN_TYPE = tags.SPAN_TYPE
    var SPAN_KIND = tags.SPAN_KIND
    var ERROR = tags.ERROR
    var HTTP_METHOD = tags.HTTP_METHOD
    var HTTP_URL = tags.HTTP_URL
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
    var HTTP_ROUTE = tags.HTTP_ROUTE
    var HTTP_ENDPOINT = tags.HTTP_ENDPOINT
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
    var HTTP_USERAGENT = tags.HTTP_USERAGENT
    var HTTP_CLIENT_IP = tags.HTTP_CLIENT_IP
    var MANUAL_DROP = tags.MANUAL_DROP
    var contexts = /* @__PURE__ */ new WeakMap()
    var ends = /* @__PURE__ */ new WeakMap()
    function createWebPlugin(tracer2, config = {}) {
      const plugin = new TracingPlugin(tracer2, tracer2._config)
      plugin.component = 'web'
      plugin.config = config
      return plugin
    }
    function startSpanHelper(tracer2, name, options, traceCtx, config = {}) {
      if (!web.plugin) {
        web.plugin = createWebPlugin(tracer2, config)
      }
      return web.plugin.startSpan(name, { ...options, tracer: tracer2, config }, traceCtx)
    }
    var web = {
      TYPE: WEB,
      plugin: null,
      // Ensure the configuration has the correct structure and defaults.
      normalizeConfig(config) {
        const headers = getHeadersToRecord(config)
        const validateStatus = getStatusValidator(config)
        const hooks = getHooks(config)
        const filter = urlFilter.getFilter(config)
        const middleware = getMiddlewareSetting(config)
        const queryStringObfuscation = getQsObfuscator(config)
        extractIp = config.clientIpEnabled && require_ip_extractor().extractIp
        return {
          ...config,
          headers,
          validateStatus,
          hooks,
          filter,
          middleware,
          queryStringObfuscation,
        }
      },
      setFramework(req, name, config) {
        const context = this.patch(req)
        const span = context.span
        if (!span) return
        span.context()._name = `${name}.request`
        span.context()._tags.component = name
        span._integrationName = name
        web.setConfig(req, config)
      },
      setConfig(req, config) {
        const context = contexts.get(req)
        const span = context.span
        context.config = config
        if (!config.filter(req.url)) {
          span.setTag(MANUAL_DROP, true)
          span.context()._trace.isRecording = false
        }
        if (config.service) {
          span.setTag(SERVICE_NAME, config.service)
        }
        analyticsSampler.sample(span, config.measured, true)
      },
      startSpan(tracer2, config, req, res, name, traceCtx) {
        const context = this.patch(req)
        let span
        if (context.span) {
          context.span.context()._name = name
          span = context.span
        } else {
          span = web.startChildSpan(tracer2, config, name, req, traceCtx)
        }
        context.tracer = tracer2
        context.span = span
        context.res = res
        this.setConfig(req, config)
        addRequestTags(context, this.TYPE)
        return span
      },
      wrap(req) {
        const context = contexts.get(req)
        if (!context.instrumented) {
          this.wrapEnd(context)
          context.instrumented = true
        }
      },
      // Start a span and activate a scope for a request.
      instrument(tracer2, config, req, res, name, callback) {
        const span = this.startSpan(tracer2, config, req, res, name)
        this.wrap(req)
        return callback && tracer2.scope().activate(span, () => callback(span))
      },
      // Reactivate the request scope in case it was changed by a middleware.
      reactivate(req, fn) {
        return reactivate(req, fn)
      },
      // Add a route segment that will be used for the resource name.
      enterRoute(req, path) {
        if (typeof path === 'string') {
          contexts.get(req).paths.push(path)
        }
      },
      setRoute(req, path) {
        const context = contexts.get(req)
        if (!context) return
        context.paths = [path]
      },
      // Remove the current route segment.
      exitRoute(req) {
        contexts.get(req).paths.pop()
      },
      // Start a new middleware span and activate a new scope with the span.
      wrapMiddleware(req, middleware, name, fn) {
        if (!this.active(req)) return fn()
        const context = contexts.get(req)
        const tracer2 = context.tracer
        const childOf = this.active(req)
        const config = context.config
        const traceCtx = context.traceCtx
        if (config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer2, childOf)
        const span = startSpanHelper(tracer2, name, { childOf }, traceCtx, config)
        analyticsSampler.sample(span, config.measured)
        span.addTags({
          [RESOURCE_NAME]: middleware._name || middleware.name || '<anonymous>',
        })
        context.middleware.push(span)
        return tracer2.scope().activate(span, fn)
      },
      // catch errors and apply to active span
      bindAndWrapMiddlewareErrors(fn, req, tracer2, activeSpan) {
        try {
          return tracer2.scope().bind(fn, activeSpan).apply(this, arguments)
        } catch (e) {
          web.addError(req, e)
          throw e
        }
      },
      // Finish the active middleware span.
      finish(req, error) {
        if (!this.active(req)) return
        const context = contexts.get(req)
        const span = context.middleware.pop()
        if (span) {
          if (error) {
            span.addTags({
              [ERROR_TYPE]: error.name,
              [ERROR_MESSAGE]: error.message,
              [ERROR_STACK]: error.stack,
            })
          }
          span.finish()
        }
      },
      // Register a callback to run before res.end() is called.
      beforeEnd(req, callback) {
        contexts.get(req).beforeEnd.push(callback)
      },
      // Prepare the request for instrumentation.
      patch(req) {
        let context = contexts.get(req)
        if (context) return context
        context = req.stream && contexts.get(req.stream)
        if (context) {
          contexts.set(req, context)
          return context
        }
        context = {
          req,
          span: null,
          paths: [],
          middleware: [],
          beforeEnd: [],
          config: {},
        }
        contexts.set(req, context)
        return context
      },
      // Return the request root span.
      root(req) {
        const context = contexts.get(req)
        return context ? context.span : null
      },
      // Return the active span.
      active(req) {
        const context = contexts.get(req)
        if (!context) return null
        if (context.middleware.length === 0) return context.span || null
        return context.middleware.at(-1)
      },
      // Extract the parent span from the headers and start a new span as its child
      startChildSpan(tracer2, config, name, req, traceCtx) {
        const headers = req.headers
        const reqCtx = contexts.get(req)
        let childOf = tracer2.extract(FORMAT_HTTP_HEADERS, headers)
        if (tracer2._config?.inferredProxyServicesEnabled) {
          const proxySpan = createInferredProxySpan(
            headers,
            childOf,
            tracer2,
            reqCtx,
            traceCtx,
            config,
            startSpanHelper
          )
          if (proxySpan) {
            childOf = proxySpan
          }
        }
        const span = startSpanHelper(tracer2, name, { childOf }, traceCtx, config)
        return span
      },
      // Validate a request's status code and then add error tags if necessary
      addStatusError(req, statusCode) {
        const context = contexts.get(req)
        const { span, inferredProxySpan, error } = context
        const spanHasExistingError = span.context()._tags.error || span.context()._tags[ERROR_MESSAGE]
        const inferredSpanContext = inferredProxySpan?.context()
        const inferredSpanHasExistingError =
          inferredSpanContext?._tags.error || inferredSpanContext?._tags[ERROR_MESSAGE]
        const isValidStatusCode = context.config.validateStatus(statusCode)
        if (!spanHasExistingError && !isValidStatusCode) {
          span.setTag(ERROR, error || true)
        }
        if (inferredProxySpan && !inferredSpanHasExistingError && !isValidStatusCode) {
          inferredProxySpan.setTag(ERROR, error || true)
        }
      },
      // Add an error to the request
      addError(req, error) {
        if (error instanceof Error) {
          const context = contexts.get(req)
          if (context) {
            context.error = error
          }
        }
      },
      finishMiddleware(context) {
        if (context.finished) return
        let span
        while ((span = context.middleware.pop())) {
          span.finish()
        }
      },
      finishSpan(context) {
        const { req, res } = context
        if (context.finished && !req.stream) return
        addRequestTags(context, this.TYPE)
        addResponseTags(context)
        context.config.hooks.request(context.span, req, res)
        addResourceTag(context)
        context.span.finish()
        context.finished = true
      },
      finishAll(context) {
        for (const beforeEnd of context.beforeEnd) {
          beforeEnd()
        }
        web.finishMiddleware(context)
        web.finishSpan(context)
        finishInferredProxySpan(context)
      },
      wrapWriteHead(context) {
        const { req, res } = context
        const writeHead = res.writeHead
        return function (statusCode, statusMessage, headers) {
          headers = typeof statusMessage === 'string' ? headers : statusMessage
          headers = { ...res.getHeaders(), ...headers }
          if (req.method.toLowerCase() === 'options' && isOriginAllowed(req, headers)) {
            addAllowHeaders(req, res, headers)
          }
          return writeHead.apply(this, arguments)
        }
      },
      getContext(req) {
        return contexts.get(req)
      },
      wrapRes(context, req, res, end) {
        return function () {
          web.finishAll(context)
          return end.apply(res, arguments)
        }
      },
      wrapEnd(context) {
        const scope = context.tracer.scope()
        const req = context.req
        const res = context.res
        const end = res.end
        res.writeHead = web.wrapWriteHead(context)
        ends.set(res, this.wrapRes(context, req, res, end))
        Object.defineProperty(res, 'end', {
          configurable: true,
          get() {
            return ends.get(this)
          },
          set(value) {
            ends.set(this, scope.bind(value, context.span))
          },
        })
      },
    }
    function addAllowHeaders(req, res, headers) {
      const allowHeaders = splitHeader(headers['access-control-allow-headers'])
      const requestHeaders = splitHeader(req.headers['access-control-request-headers'])
      const contextHeaders = [
        'x-datadog-origin',
        'x-datadog-parent-id',
        'x-datadog-sampled',
        // Deprecated, but still accept it in case it's sent.
        'x-datadog-sampling-priority',
        'x-datadog-trace-id',
        'x-datadog-tags',
      ]
      for (const header of contextHeaders) {
        if (requestHeaders.includes(header)) {
          allowHeaders.push(header)
        }
      }
      if (allowHeaders.length > 0) {
        res.setHeader('access-control-allow-headers', uniq(allowHeaders).join(','))
      }
    }
    function isOriginAllowed(req, headers) {
      const origin = req.headers.origin
      const allowOrigin = headers['access-control-allow-origin']
      return origin && (allowOrigin === '*' || allowOrigin === origin)
    }
    function splitHeader(str) {
      return typeof str === 'string' ? str.split(/\s*,\s*/) : []
    }
    function reactivate(req, fn) {
      const context = contexts.get(req)
      return context ? context.tracer.scope().activate(context.span, fn) : fn()
    }
    function addRequestTags(context, spanType) {
      const { req, span, inferredProxySpan, config } = context
      const url = extractURL(req)
      span.addTags({
        [HTTP_URL]: obfuscateQs(config, url),
        [HTTP_METHOD]: req.method,
        [SPAN_KIND]: SERVER,
        [SPAN_TYPE]: spanType,
        [HTTP_USERAGENT]: req.headers['user-agent'],
      })
      if (extractIp && !span.context()._tags.hasOwnProperty(HTTP_CLIENT_IP)) {
        const clientIp = extractIp(config, req)
        if (clientIp) {
          span.setTag(HTTP_CLIENT_IP, clientIp)
          inferredProxySpan?.setTag(HTTP_CLIENT_IP, clientIp)
        }
      }
      addHeaders(context)
    }
    function addResponseTags(context) {
      const { req, res, paths, span, inferredProxySpan, config } = context
      const route = paths.join('')
      if (route) {
        span.setTag(HTTP_ROUTE, route)
      } else if (config.resourceRenamingEnabled) {
        const url = span.context()._tags[HTTP_URL]
        const endpoint = url ? calculateHttpEndpoint(url) : '/'
        span.setTag(HTTP_ENDPOINT, endpoint)
      }
      span.addTags({
        [HTTP_STATUS_CODE]: res.statusCode,
      })
      inferredProxySpan?.addTags({
        [HTTP_STATUS_CODE]: res.statusCode,
      })
      web.addStatusError(req, res.statusCode)
    }
    function addResourceTag(context) {
      const { req, span } = context
      const tags2 = span.context()._tags
      if (tags2['resource.name']) return
      const resource = [req.method, tags2[HTTP_ROUTE]].filter(Boolean).join(' ')
      span.setTag(RESOURCE_NAME, resource)
    }
    function addHeaders(context) {
      const { req, res, config, span, inferredProxySpan } = context
      config.headers.forEach(([key, tag]) => {
        const reqHeader = req.headers[key]
        const resHeader = res.getHeader(key)
        if (reqHeader) {
          span.setTag(tag || `${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)
          inferredProxySpan?.setTag(tag || `${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)
        }
        if (resHeader) {
          span.setTag(tag || `${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)
          inferredProxySpan?.setTag(tag || `${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)
        }
      })
    }
    function getHeadersToRecord(config) {
      if (Array.isArray(config.headers)) {
        try {
          return config.headers.map((h) => h.split(':')).map(([key, tag]) => [key.toLowerCase(), tag])
        } catch (err) {
          log.error('Web plugin error getting headers', err)
        }
      } else if (config.hasOwnProperty('headers')) {
        log.error('Expected `headers` to be an array of strings.')
      }
      return []
    }
    function isNot500ErrorCode(code) {
      return code < 500
    }
    function getStatusValidator(config) {
      if (typeof config.validateStatus === 'function') {
        return config.validateStatus
      } else if (config.hasOwnProperty('validateStatus')) {
        log.error('Expected `validateStatus` to be a function.')
      }
      return isNot500ErrorCode
    }
    var noop = () => {}
    function getHooks(config) {
      const request = config.hooks?.request ?? noop
      return { request }
    }
    function getMiddlewareSetting(config) {
      if (config && typeof config.middleware === 'boolean') {
        return config.middleware
      } else if (config && config.hasOwnProperty('middleware')) {
        log.error('Expected `middleware` to be a boolean.')
      }
      return true
    }
    function getQsObfuscator(config) {
      const obfuscator = config.queryStringObfuscation
      if (typeof obfuscator === 'boolean') {
        return obfuscator
      }
      if (typeof obfuscator === 'string') {
        if (obfuscator === '') return false
        if (obfuscator === '.*') return true
        try {
          return new RegExp(obfuscator, 'gi')
        } catch (err) {
          log.error('Web plugin error getting qs obfuscator', err)
        }
      }
      if (config.hasOwnProperty('queryStringObfuscation')) {
        log.error('Expected `queryStringObfuscation` to be a regex string or boolean.')
      }
      return true
    }
    module2.exports = web
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/serverless.js
var require_serverless4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/serverless.js'(exports2, module2) {
    'use strict'
    var types = require_types()
    var web = require_web3()
    var serverless = { ...web, TYPE: types.SERVERLESS }
    module2.exports = serverless
  },
})

// node_modules/dd-trace/packages/datadog-plugin-azure-functions/src/index.js
var require_src5 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-azure-functions/src/index.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var serverless = require_serverless4()
    var web = require_web3()
    var triggerMap = {
      deleteRequest: 'Http',
      http: 'Http',
      get: 'Http',
      patch: 'Http',
      post: 'Http',
      put: 'Http',
      serviceBusQueue: 'ServiceBus',
      serviceBusTopic: 'ServiceBus',
      eventHub: 'EventHubs',
    }
    var AzureFunctionsPlugin = class extends TracingPlugin {
      static id = 'azure-functions'
      static operation = 'invoke'
      static kind = 'server'
      static type = 'serverless'
      static prefix = 'tracing:datadog:azure:functions:invoke'
      bindStart(ctx) {
        const meta = getMetaForTrigger(ctx)
        const triggerType = triggerMap[ctx.methodName]
        const isMessagingService = triggerType === 'ServiceBus' || triggerType === 'EventHubs'
        const childOf = isMessagingService ? null : extractTraceContext(this._tracer, ctx)
        const span = this.startSpan(
          this.operationName(),
          {
            childOf,
            service: this.serviceName(),
            type: 'serverless',
            meta,
          },
          ctx
        )
        if (isMessagingService) {
          setSpanLinks(triggerType, this.tracer, span, ctx)
        }
        ctx.span = span
        return ctx.currentStore
      }
      error(ctx) {
        this.addError(ctx.error)
        ctx.currentStore.span.setTag('error.message', ctx.error)
      }
      asyncEnd(ctx) {
        const { httpRequest, methodName, result = {} } = ctx
        if (triggerMap[methodName] === 'Http') {
          const path = new URL(httpRequest.url).pathname
          const req = {
            method: httpRequest.method,
            headers: Object.fromEntries(httpRequest.headers),
            url: path,
          }
          const context = web.patch(req)
          context.config = this.config
          context.paths = [path]
          context.res = { statusCode: result.status }
          context.span = ctx.currentStore.span
          serverless.finishSpan(context)
        } else {
          super.finish()
        }
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config))
      }
    }
    function getMetaForTrigger({ functionName, methodName, invocationContext }) {
      let meta = {
        'aas.function.name': functionName,
        'aas.function.trigger': mapTriggerTag(methodName),
      }
      if (triggerMap[methodName] === 'ServiceBus') {
        const triggerEntity = invocationContext.options.trigger.queueName || invocationContext.options.trigger.topicName
        meta = {
          ...meta,
          'messaging.message_id': invocationContext.triggerMetadata.messageId,
          'messaging.operation': 'receive',
          'messaging.system': 'servicebus',
          'messaging.destination.name': triggerEntity,
          'resource.name': `ServiceBus ${functionName}`,
          'span.kind': 'consumer',
        }
      } else if (triggerMap[methodName] === 'EventHubs') {
        const partitionContext = invocationContext.triggerMetadata.triggerPartitionContext
        meta = {
          ...meta,
          'messaging.destination.name': partitionContext.eventHubName,
          'messaging.operation': 'receive',
          'messaging.system': 'eventhubs',
          'resource.name': `EventHubs ${functionName}`,
          'span.kind': 'consumer',
        }
      }
      return meta
    }
    function mapTriggerTag(methodName) {
      return triggerMap[methodName] || 'Unknown'
    }
    function extractTraceContext(tracer2, ctx) {
      switch (String(triggerMap[ctx.methodName])) {
        case 'Http':
          return tracer2.extract('http_headers', Object.fromEntries(ctx.httpRequest.headers))
        default:
          null
      }
    }
    function setSpanLinks(triggerType, tracer2, span, ctx) {
      const cardinality = ctx.invocationContext.options.trigger.cardinality
      const triggerMetadata = ctx.invocationContext.triggerMetadata
      const isServiceBus = triggerType === 'ServiceBus'
      const properties = isServiceBus ? triggerMetadata.applicationProperties : triggerMetadata.properties
      const propertiesArray = isServiceBus
        ? triggerMetadata.applicationPropertiesArray
        : triggerMetadata.propertiesArray
      const addLinkFromProperties = (props) => {
        if (!props || Object.keys(props).length === 0) return
        const spanContext = tracer2.extract('text_map', props)
        if (spanContext) {
          span.addLink(spanContext)
        }
      }
      if (cardinality === 'many' && propertiesArray?.length > 0) {
        propertiesArray.forEach(addLinkFromProperties)
      } else if (cardinality === 'one') {
        addLinkFromProperties(properties)
      }
    }
    module2.exports = AzureFunctionsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-azure-service-bus/src/producer.js
var require_producer3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-azure-service-bus/src/producer.js'(exports2, module2) {
    'use strict'
    var { getEnvironmentVariable } = require_config_helper()
    var ProducerPlugin = require_producer()
    var spanContexts = /* @__PURE__ */ new WeakMap()
    var AzureServiceBusProducerPlugin = class extends ProducerPlugin {
      static get id() {
        return 'azure-service-bus'
      }
      static get operation() {
        return 'send'
      }
      static get prefix() {
        return 'tracing:apm:azure-service-bus:send'
      }
      bindStart(ctx) {
        if (!batchLinksAreEnabled() && ctx.functionName === 'tryAddMessage') {
          return ctx.currentStore
        }
        const qualifiedSenderNamespace = ctx.config.host
        const span = this.startSpan(
          {
            resource: ctx.entityPath,
            type: 'messaging',
            meta: {
              component: 'azure-service-bus',
              'messaging.destination.name': ctx.entityPath,
              'messaging.operation': 'send',
              'messaging.system': 'servicebus',
              'network.destination.name': qualifiedSenderNamespace,
            },
          },
          ctx
        )
        if (ctx.functionName === 'tryAddMessage') {
          span._spanContext._name = 'azure.servicebus.create'
          span.setTag('messaging.operation', 'create')
          if (ctx.msg.messageID !== void 0) {
            span.setTag('message.id', ctx.msg)
          }
          if (batchLinksAreEnabled()) {
            const spanContext = spanContexts.get(ctx.batch)
            if (spanContext) {
              spanContext.push(span.context())
            } else {
              spanContexts.set(ctx.batch, [span.context()])
            }
            injectTraceContext(this.tracer, span, ctx.msg)
          }
        }
        if (
          ctx.functionName === 'send' ||
          ctx.functionName === 'sendBatch' ||
          ctx.functionName === 'scheduleMessages'
        ) {
          const messages = ctx.msg
          const isBatch = messages.constructor?.name === 'ServiceBusMessageBatchImpl'
          if (isBatch) {
            span.setTag('messaging.batch.message_count', messages.count)
            if (batchLinksAreEnabled()) {
              const contexts = spanContexts.get(messages)
              if (contexts) {
                for (const spanContext of contexts) {
                  span.addLink(spanContext)
                }
              }
            }
          } else if (Array.isArray(messages)) {
            span.setTag('messaging.batch.message_count', messages.length)
            messages.forEach((event) => {
              injectTraceContext(this.tracer, span, event)
            })
          } else {
            injectTraceContext(this.tracer, span, messages)
          }
        }
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        super.finish(ctx)
      }
    }
    function injectTraceContext(tracer2, span, msg) {
      if (!msg.applicationProperties) {
        msg.applicationProperties = {}
      }
      tracer2.inject(span, 'text_map', msg.applicationProperties)
    }
    function batchLinksAreEnabled() {
      const sb = getEnvironmentVariable('DD_TRACE_AZURE_SERVICEBUS_BATCH_LINKS_ENABLED')
      return sb !== 'false'
    }
    module2.exports = AzureServiceBusProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-azure-service-bus/src/index.js
var require_src6 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-azure-service-bus/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer3()
    var CompositePlugin = require_composite()
    var AzureServiceBusPlugin = class extends CompositePlugin {
      static get id() {
        return 'azure-service-bus'
      }
      static get plugins() {
        return {
          producer: ProducerPlugin,
        }
      }
    }
    module2.exports = AzureServiceBusPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/dynamic-instrumentation/index.js
var require_dynamic_instrumentation = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/dynamic-instrumentation/index.js'(exports2, module2) {
    'use strict'
    var { join } = require('path')
    var { Worker, threadId: parentThreadId } = require('worker_threads')
    var { randomUUID } = require('crypto')
    var log = require_log2()
    var { getEnvironmentVariables } = require_config_helper()
    var getDebuggerConfig = require_config3()
    var probeIdToResolveBreakpointSet = /* @__PURE__ */ new Map()
    var probeIdToResolveBreakpointRemove = /* @__PURE__ */ new Map()
    var TestVisDynamicInstrumentation = class {
      constructor(config) {
        this._config = config
        this.worker = null
        this._readyPromise = new Promise((resolve) => {
          this._onReady = resolve
        })
        this.breakpointSetChannel = new MessageChannel()
        this.breakpointHitChannel = new MessageChannel()
        this.breakpointRemoveChannel = new MessageChannel()
        this.onHitBreakpointByProbeId = /* @__PURE__ */ new Map()
      }
      removeProbe(probeId) {
        return new Promise((resolve) => {
          this.breakpointRemoveChannel.port2.postMessage(probeId)
          probeIdToResolveBreakpointRemove.set(probeId, resolve)
        })
      }
      // Return 2 elements:
      // 1. Probe ID
      // 2. Promise that's resolved when the breakpoint is set
      addLineProbe({ file, line }, onHitBreakpoint) {
        if (!this.worker) {
          this.start()
        }
        const probeId = randomUUID()
        this.breakpointSetChannel.port2.postMessage({ id: probeId, file, line })
        this.onHitBreakpointByProbeId.set(probeId, onHitBreakpoint)
        return [
          probeId,
          new Promise((resolve) => {
            probeIdToResolveBreakpointSet.set(probeId, resolve)
          }),
        ]
      }
      isReady() {
        return this._readyPromise
      }
      start() {
        if (this.worker) return
        log.debug('Starting Test Visibility - Dynamic Instrumentation client...')
        const probeChannel = new MessageChannel()
        const configChannel = new MessageChannel()
        this.worker = new Worker(join(__dirname, 'worker', 'index.js'), {
          execArgv: [],
          // Not passing `NODE_OPTIONS` results in issues with yarn, which relies on NODE_OPTIONS
          // for PnP support, hence why we deviate from the DI pattern here.
          // To avoid infinite initialization loops, we're disabling DI and tracing in the worker.
          env: {
            ...getEnvironmentVariables(),
            DD_CIVISIBILITY_ENABLED: 'false',
            DD_TRACE_ENABLED: 'false',
            DD_TEST_FAILED_TEST_REPLAY_ENABLED: 'false',
            DD_CIVISIBILITY_MANUAL_API_ENABLED: 'false',
            DD_TRACING_ENABLED: 'false',
            DD_INSTRUMENTATION_TELEMETRY_ENABLED: 'false',
          },
          workerData: {
            config: getDebuggerConfig(this._config),
            parentThreadId,
            probePort: probeChannel.port1,
            configPort: configChannel.port1,
            breakpointSetChannel: this.breakpointSetChannel.port1,
            breakpointHitChannel: this.breakpointHitChannel.port1,
            breakpointRemoveChannel: this.breakpointRemoveChannel.port1,
          },
          transferList: [
            probeChannel.port1,
            configChannel.port1,
            this.breakpointSetChannel.port1,
            this.breakpointHitChannel.port1,
            this.breakpointRemoveChannel.port1,
          ],
        })
        this.worker.on('online', () => {
          log.debug('Test Visibility - Dynamic Instrumentation client is ready')
          this._onReady()
        })
        this.worker.on('error', (err) => {
          log.error('Test Visibility - Dynamic Instrumentation worker error', err)
        })
        this.worker.on('messageerror', (err) => {
          log.error('Test Visibility - Dynamic Instrumentation worker messageerror', err)
        })
        this.worker.unref()
        this.breakpointSetChannel.port2
          .on('message', (probeId) => {
            const resolve = probeIdToResolveBreakpointSet.get(probeId)
            if (resolve) {
              resolve()
              probeIdToResolveBreakpointSet.delete(probeId)
            }
          })
          .unref()
        this.breakpointHitChannel.port2
          .on('message', ({ snapshot }) => {
            const {
              probe: { id: probeId },
            } = snapshot
            const onHit = this.onHitBreakpointByProbeId.get(probeId)
            if (onHit) {
              onHit({ snapshot })
            } else {
              log.warn('Received a breakpoint hit for an unknown probe')
            }
          })
          .unref()
        this.breakpointRemoveChannel.port2
          .on('message', (probeId) => {
            const resolve = probeIdToResolveBreakpointRemove.get(probeId)
            if (resolve) {
              resolve()
              probeIdToResolveBreakpointRemove.delete(probeId)
            }
          })
          .unref()
      }
    }
    var dynamicInstrumentation
    module2.exports = function createAndGetTestVisDynamicInstrumentation(config) {
      if (dynamicInstrumentation) {
        return dynamicInstrumentation
      }
      dynamicInstrumentation = new TestVisDynamicInstrumentation(config)
      return dynamicInstrumentation
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/ci_plugin.js
var require_ci_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/ci_plugin.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var {
      getTestEnvironmentMetadata,
      getTestSessionName,
      getCodeOwnersFileEntries,
      getTestParentSpan,
      getTestCommonTags,
      getCodeOwnersForFilename,
      TEST_CODE_OWNERS,
      CI_APP_ORIGIN,
      getTestSessionCommonTags,
      getTestModuleCommonTags,
      TEST_SUITE_ID,
      TEST_MODULE_ID,
      TEST_SESSION_ID,
      TEST_COMMAND,
      TEST_MODULE,
      TEST_SESSION_NAME,
      getTestSuiteCommonTags,
      TEST_STATUS,
      TEST_SKIPPED_BY_ITR,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_LEVEL_EVENT_TYPES,
      TEST_SUITE,
      getFileAndLineNumberFromError,
      DI_ERROR_DEBUG_INFO_CAPTURED,
      DI_DEBUG_ERROR_PREFIX,
      DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX,
      DI_DEBUG_ERROR_FILE_SUFFIX,
      DI_DEBUG_ERROR_LINE_SUFFIX,
      getLibraryCapabilitiesTags,
      getPullRequestDiff,
      getModifiedFilesFromDiff,
      getPullRequestBaseBranch,
      TEST_IS_TEST_FRAMEWORK_WORKER,
    } = require_test()
    var { getRepositoryRoot } = require_git()
    var Plugin = require_plugin()
    var { COMPONENT } = require_constants2()
    var log = require_log2()
    var { incrementCountMetric, distributionMetric, TELEMETRY_EVENT_CREATED, TELEMETRY_ITR_SKIPPED } =
      require_telemetry()
    var {
      CI_PROVIDER_NAME,
      GIT_REPOSITORY_URL,
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      CI_WORKSPACE_PATH,
      GIT_COMMIT_MESSAGE,
      GIT_TAG,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_COMMIT_HEAD_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH,
      GIT_COMMIT_HEAD_MESSAGE,
    } = require_tags2()
    var { OS_VERSION, OS_PLATFORM, OS_ARCHITECTURE, RUNTIME_NAME, RUNTIME_VERSION } = require_env()
    var getDiClient = require_dynamic_instrumentation()
    var { DD_MAJOR } = require_version()
    var id = require_id()
    var FRAMEWORK_TO_TRIMMED_COMMAND = {
      vitest: 'vitest run',
      mocha: 'mocha',
      cucumber: 'cucumber-js',
      playwright: 'playwright test',
      jest: 'jest',
    }
    var WORKER_EXPORTER_TO_TEST_FRAMEWORK = {
      vitest_worker: 'vitest',
      jest_worker: 'jest',
      cucumber_worker: 'cucumber',
      mocha_worker: 'mocha',
      playwright_worker: 'playwright',
    }
    var TEST_FRAMEWORKS_TO_SKIP_GIT_METADATA_EXTRACTION = /* @__PURE__ */ new Set([
      'vitest',
      'jest',
      'mocha',
      'cucumber',
    ])
    function getTestSuiteLevelVisibilityTags(testSuiteSpan, testFramework) {
      const testSuiteSpanContext = testSuiteSpan.context()
      const suiteTags = {
        [TEST_SUITE_ID]: testSuiteSpanContext.toSpanId(),
        [TEST_SESSION_ID]: testSuiteSpanContext.toTraceId(),
        [TEST_COMMAND]: testSuiteSpanContext._tags[TEST_COMMAND],
        [TEST_MODULE]: testFramework,
      }
      if (testSuiteSpanContext._parentId) {
        suiteTags[TEST_MODULE_ID] = testSuiteSpanContext._parentId.toString(10)
      }
      return suiteTags
    }
    module2.exports = class CiPlugin extends Plugin {
      constructor(...args) {
        super(...args)
        this.fileLineToProbeId = /* @__PURE__ */ new Map()
        this.rootDir = process.cwd()
        this._testSuiteSpansByTestSuite = /* @__PURE__ */ new Map()
        this.addSub(`ci:${this.constructor.id}:library-configuration`, (ctx) => {
          const { onDone, isParallel, frameworkVersion } = ctx
          ctx.currentStore = storage('legacy').getStore()
          if (!this.tracer._exporter || !this.tracer._exporter.getLibraryConfiguration) {
            return onDone({ err: new Error('Test optimization was not initialized correctly') })
          }
          this.tracer._exporter.getLibraryConfiguration(this.testConfiguration, (err, libraryConfig) => {
            if (err) {
              log.error('Library configuration could not be fetched. %s', err.message)
            } else {
              this.libraryConfig = libraryConfig
            }
            const libraryCapabilitiesTags = getLibraryCapabilitiesTags(
              this.constructor.id,
              isParallel,
              frameworkVersion
            )
            const metadataTags = {
              test: {
                ...libraryCapabilitiesTags,
              },
            }
            this.tracer._exporter.addMetadataTags(metadataTags)
            onDone({ err, libraryConfig })
          })
        })
        this.addBind(`ci:${this.constructor.id}:test-suite:skippable`, (ctx) => {
          return ctx.currentStore
        })
        this.addSub(`ci:${this.constructor.id}:test-suite:skippable`, ({ onDone }) => {
          if (!this.tracer._exporter?.getSkippableSuites) {
            return onDone({ err: new Error('Test optimization was not initialized correctly') })
          }
          this.tracer._exporter.getSkippableSuites(this.testConfiguration, (err, skippableSuites, itrCorrelationId) => {
            if (err) {
              log.error('Skippable suites could not be fetched. %s', err.message)
            } else {
              this.itrCorrelationId = itrCorrelationId
            }
            onDone({ err, skippableSuites, itrCorrelationId })
          })
        })
        this.addSub(`ci:${this.constructor.id}:session:start`, ({ command, frameworkVersion, rootDir }) => {
          const childOf = getTestParentSpan(this.tracer)
          const testSessionSpanMetadata = getTestSessionCommonTags(command, frameworkVersion, this.constructor.id)
          const testModuleSpanMetadata = getTestModuleCommonTags(command, frameworkVersion, this.constructor.id)
          this.command = command
          this.frameworkVersion = frameworkVersion
          this.rootDir = rootDir
          const testSessionName = getTestSessionName(
            this.config,
            DD_MAJOR < 6 ? this.command : FRAMEWORK_TO_TRIMMED_COMMAND[this.constructor.id],
            this.testEnvironmentMetadata
          )
          const metadataTags = {}
          for (const testLevel of TEST_LEVEL_EVENT_TYPES) {
            metadataTags[testLevel] = {
              [TEST_SESSION_NAME]: testSessionName,
            }
          }
          if (this.tracer._exporter.addMetadataTags) {
            this.tracer._exporter.addMetadataTags(metadataTags)
          }
          this.testSessionSpan = this.tracer.startSpan(`${this.constructor.id}.test_session`, {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSessionSpanMetadata,
            },
            integrationName: this.constructor.id,
          })
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'session')
          this.testModuleSpan = this.tracer.startSpan(`${this.constructor.id}.test_module`, {
            childOf: this.testSessionSpan,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testModuleSpanMetadata,
            },
            integrationName: this.constructor.id,
          })
          if (this.constructor.id === 'vitest') {
            process.env.DD_CIVISIBILITY_TEST_SESSION_ID = this.testSessionSpan.context().toTraceId()
            process.env.DD_CIVISIBILITY_TEST_MODULE_ID = this.testModuleSpan.context().toSpanId()
            process.env.DD_CIVISIBILITY_TEST_COMMAND = this.command
          }
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'module')
        })
        this.addSub(`ci:${this.constructor.id}:itr:skipped-suites`, ({ skippedSuites, frameworkVersion }) => {
          const testCommand = this.testSessionSpan.context()._tags[TEST_COMMAND]
          skippedSuites.forEach((testSuite) => {
            const testSuiteMetadata = getTestSuiteCommonTags(
              testCommand,
              frameworkVersion,
              testSuite,
              this.constructor.id
            )
            if (this.itrCorrelationId) {
              testSuiteMetadata[ITR_CORRELATION_ID] = this.itrCorrelationId
            }
            this.tracer
              .startSpan(`${this.constructor.id}.test_suite`, {
                childOf: this.testModuleSpan,
                tags: {
                  [COMPONENT]: this.constructor.id,
                  ...this.testEnvironmentMetadata,
                  ...testSuiteMetadata,
                  [TEST_STATUS]: 'skip',
                  [TEST_SKIPPED_BY_ITR]: 'true',
                },
                integrationName: this.constructor.id,
              })
              .finish()
          })
          this.telemetry.count(TELEMETRY_ITR_SKIPPED, { testLevel: 'suite' }, skippedSuites.length)
        })
        this.addBind(`ci:${this.constructor.id}:known-tests`, (ctx) => {
          return ctx.currentStore
        })
        this.addSub(`ci:${this.constructor.id}:known-tests`, ({ onDone }) => {
          if (!this.tracer._exporter?.getKnownTests) {
            return onDone({ err: new Error('Test optimization was not initialized correctly') })
          }
          this.tracer._exporter.getKnownTests(this.testConfiguration, (err, knownTests) => {
            if (err) {
              log.error('Known tests could not be fetched. %s', err.message)
              this.libraryConfig.isEarlyFlakeDetectionEnabled = false
              this.libraryConfig.isKnownTestsEnabled = false
            }
            onDone({ err, knownTests })
          })
        })
        this.addBind(`ci:${this.constructor.id}:test-management-tests`, (ctx) => {
          return ctx.currentStore
        })
        this.addSub(`ci:${this.constructor.id}:test-management-tests`, ({ onDone }) => {
          if (!this.tracer._exporter?.getTestManagementTests) {
            return onDone({ err: new Error('Test optimization was not initialized correctly') })
          }
          this.tracer._exporter.getTestManagementTests(this.testConfiguration, (err, testManagementTests) => {
            if (err) {
              log.error('Test management tests could not be fetched. %s', err.message)
              this.libraryConfig.isTestManagementEnabled = false
            }
            onDone({ err, testManagementTests })
          })
        })
        this.addBind(`ci:${this.constructor.id}:modified-files`, (ctx) => {
          return ctx.currentStore
        })
        this.addSub(`ci:${this.constructor.id}:modified-files`, ({ onDone }) => {
          const {
            [GIT_PULL_REQUEST_BASE_BRANCH]: pullRequestBaseBranch,
            [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: pullRequestBaseBranchSha,
            [GIT_COMMIT_HEAD_SHA]: commitHeadSha,
          } = this.testEnvironmentMetadata
          const baseBranchSha = pullRequestBaseBranchSha || getPullRequestBaseBranch(pullRequestBaseBranch)
          if (baseBranchSha) {
            const diff = getPullRequestDiff(baseBranchSha, commitHeadSha)
            const modifiedFiles = getModifiedFilesFromDiff(diff)
            if (modifiedFiles) {
              return onDone({ err: null, modifiedFiles })
            }
          }
          return onDone({ err: new Error('No modified tests could have been retrieved') })
        })
        this.addSub(`ci:${this.constructor.id}:worker-report:trace`, (traces) => {
          const formattedTraces = JSON.parse(traces)
          for (const trace of formattedTraces) {
            for (const span of trace) {
              span.span_id = id(span.span_id)
              span.trace_id = id(span.trace_id)
              span.parent_id = id(span.parent_id)
              if (span.name?.startsWith(`${this.constructor.id}.`)) {
                span.meta[TEST_IS_TEST_FRAMEWORK_WORKER] = 'true'
                for (const key in this.testEnvironmentMetadata) {
                  if (key.startsWith('git.')) {
                    span.meta[key] = this.testEnvironmentMetadata[key]
                  }
                }
              }
              if (span.name === 'cucumber.test' || span.name === 'mocha.test') {
                const testSuite = span.meta[TEST_SUITE]
                const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite)
                if (!testSuiteSpan) {
                  log.warn(`Test suite span not found for test span with test suite ${testSuite}`)
                  continue
                }
                const testSuiteTags = getTestSuiteLevelVisibilityTags(testSuiteSpan, this.constructor.id)
                span.meta = {
                  ...span.meta,
                  ...testSuiteTags,
                }
              }
            }
            this.tracer._exporter.export(trace)
          }
        })
        this.addSub(`ci:${this.constructor.id}:worker-report:logs`, (logsPayloads) => {
          JSON.parse(logsPayloads).forEach(({ logMessage }) => {
            this.tracer._exporter.exportDiLogs(this.testEnvironmentMetadata, logMessage)
          })
        })
      }
      get telemetry() {
        const testFramework = this.constructor.id
        return {
          ciVisEvent: function (name, testLevel, tags = {}) {
            incrementCountMetric(name, {
              testLevel,
              testFramework,
              isUnsupportedCIProvider: !this.ciProviderName,
              ...tags,
            })
          },
          count: function (name, tags, value = 1) {
            incrementCountMetric(name, tags, value)
          },
          distribution: function (name, tags, measure) {
            distributionMetric(name, tags, measure)
          },
        }
      }
      configure(config, shouldGetEnvironmentData = true) {
        super.configure(config)
        if (!shouldGetEnvironmentData) {
          return
        }
        if (config.isTestDynamicInstrumentationEnabled && !this.di) {
          this.di = getDiClient()
        }
        if (this.testConfiguration) {
          return
        }
        const exporter = this.config.experimental?.exporter
        const workerTestFramework = WORKER_EXPORTER_TO_TEST_FRAMEWORK[exporter]
        this.shouldSkipGitMetadataExtraction =
          workerTestFramework && TEST_FRAMEWORKS_TO_SKIP_GIT_METADATA_EXTRACTION.has(workerTestFramework)
        this.testEnvironmentMetadata = getTestEnvironmentMetadata(
          this.constructor.id,
          this.config,
          this.shouldSkipGitMetadataExtraction
        )
        const {
          [GIT_REPOSITORY_URL]: repositoryUrl,
          [GIT_COMMIT_SHA]: sha,
          [OS_VERSION]: osVersion,
          [OS_PLATFORM]: osPlatform,
          [OS_ARCHITECTURE]: osArchitecture,
          [RUNTIME_NAME]: runtimeName,
          [RUNTIME_VERSION]: runtimeVersion,
          [GIT_BRANCH]: branch,
          [CI_PROVIDER_NAME]: ciProviderName,
          [CI_WORKSPACE_PATH]: repositoryRoot,
          [GIT_COMMIT_MESSAGE]: commitMessage,
          [GIT_TAG]: tag,
          [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: pullRequestBaseSha,
          [GIT_COMMIT_HEAD_SHA]: commitHeadSha,
          [GIT_COMMIT_HEAD_MESSAGE]: commitHeadMessage,
        } = this.testEnvironmentMetadata
        this.repositoryRoot = repositoryRoot || getRepositoryRoot() || process.cwd()
        this.codeOwnersEntries = getCodeOwnersFileEntries(this.repositoryRoot)
        this.ciProviderName = ciProviderName
        this.testConfiguration = {
          repositoryUrl,
          sha,
          osVersion,
          osPlatform,
          osArchitecture,
          runtimeName,
          runtimeVersion,
          branch,
          testLevel: 'suite',
          commitMessage,
          tag,
          pullRequestBaseSha,
          commitHeadSha,
          commitHeadMessage,
        }
      }
      getCodeOwners(tags) {
        const { [TEST_SOURCE_FILE]: testSourceFile, [TEST_SUITE]: testSuite } = tags
        let codeOwners = getCodeOwnersForFilename(testSourceFile, this.codeOwnersEntries)
        if (!codeOwners) {
          codeOwners = getCodeOwnersForFilename(testSuite, this.codeOwnersEntries)
        }
        return codeOwners
      }
      startTestSpan(testName, testSuite, testSuiteSpan, extraTags = {}) {
        const childOf = getTestParentSpan(this.tracer)
        let testTags = {
          ...getTestCommonTags(testName, testSuite, this.frameworkVersion, this.constructor.id),
          [COMPONENT]: this.constructor.id,
          ...extraTags,
        }
        const codeOwners = this.getCodeOwners(testTags)
        if (codeOwners) {
          testTags[TEST_CODE_OWNERS] = codeOwners
        }
        if (testSuiteSpan) {
          childOf._trace.startTime = testSuiteSpan.context()._trace.startTime
          childOf._trace.ticks = testSuiteSpan.context()._trace.ticks
          const suiteTags = {
            [TEST_SUITE_ID]: testSuiteSpan.context().toSpanId(),
            [TEST_SESSION_ID]: testSuiteSpan.context().toTraceId(),
            [TEST_COMMAND]: testSuiteSpan.context()._tags[TEST_COMMAND],
            [TEST_MODULE]: this.constructor.id,
          }
          if (testSuiteSpan.context()._parentId) {
            suiteTags[TEST_MODULE_ID] = testSuiteSpan.context()._parentId.toString(10)
          }
          testTags = {
            ...testTags,
            ...suiteTags,
          }
        }
        this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'test', { hasCodeOwners: !!codeOwners })
        const testSpan = this.tracer.startSpan(`${this.constructor.id}.test`, {
          childOf,
          tags: {
            ...this.testEnvironmentMetadata,
            ...testTags,
          },
          integrationName: this.constructor.id,
        })
        testSpan.context()._trace.origin = CI_APP_ORIGIN
        return testSpan
      }
      onDiBreakpointHit({ snapshot }) {
        if (!this.activeTestSpan || this.activeTestSpan.context()._isFinished) {
          log.warn('Breakpoint snapshot could not be attached to the active test span')
          return
        }
        const stackIndex = this.testErrorStackIndex
        this.activeTestSpan.setTag(DI_ERROR_DEBUG_INFO_CAPTURED, 'true')
        this.activeTestSpan.setTag(
          `${DI_DEBUG_ERROR_PREFIX}.${stackIndex}.${DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX}`,
          snapshot.id
        )
        this.activeTestSpan.setTag(
          `${DI_DEBUG_ERROR_PREFIX}.${stackIndex}.${DI_DEBUG_ERROR_FILE_SUFFIX}`,
          snapshot.probe.location.file
        )
        this.activeTestSpan.setTag(
          `${DI_DEBUG_ERROR_PREFIX}.${stackIndex}.${DI_DEBUG_ERROR_LINE_SUFFIX}`,
          Number(snapshot.probe.location.lines[0])
        )
        const activeTestSpanContext = this.activeTestSpan.context()
        this.tracer._exporter.exportDiLogs(this.testEnvironmentMetadata, {
          debugger: { snapshot },
          dd: {
            trace_id: activeTestSpanContext.toTraceId(),
            span_id: activeTestSpanContext.toSpanId(),
          },
        })
      }
      removeAllDiProbes() {
        if (this.fileLineToProbeId.size === 0) {
          return Promise.resolve()
        }
        log.debug('Removing all Dynamic Instrumentation probes')
        const promises = []
        for (const fileLine of this.fileLineToProbeId.keys()) {
          const [file, line] = fileLine.split(':')
          promises.push(this.removeDiProbe({ file, line }))
        }
        return Promise.all(promises)
      }
      removeDiProbe({ file, line }) {
        const probeId = this.fileLineToProbeId.get(`${file}:${line}`)
        log.warn('Removing probe from %s:%s, with id: %s', file, line, probeId)
        this.fileLineToProbeId.delete(probeId)
        return this.di.removeProbe(probeId)
      }
      addDiProbe(err) {
        if (!err?.stack) {
          log.warn('Can not add breakpoint if the test error does not have a stack')
          return
        }
        const [file, line, stackIndex] = getFileAndLineNumberFromError(err, this.repositoryRoot)
        if (!file || !Number.isInteger(line)) {
          log.warn('Could not add breakpoint for dynamic instrumentation')
          return
        }
        log.debug('Adding breakpoint for Dynamic Instrumentation')
        this.testErrorStackIndex = stackIndex
        const activeProbeKey = `${file}:${line}`
        if (this.fileLineToProbeId.has(activeProbeKey)) {
          log.warn('Probe already set for this line')
          const oldProbeId = this.fileLineToProbeId.get(activeProbeKey)
          return {
            probeId: oldProbeId,
            setProbePromise: Promise.resolve(),
            stackIndex,
            file,
            line,
          }
        }
        const [probeId, setProbePromise] = this.di.addLineProbe({ file, line }, this.onDiBreakpointHit.bind(this))
        this.fileLineToProbeId.set(activeProbeKey, probeId)
        return {
          probeId,
          setProbePromise,
          stackIndex,
          file,
          line,
        }
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js
var require_src7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js'(exports2, module2) {
    'use strict'
    var CiPlugin = require_ci_plugin()
    var { storage } = require_datadog_core()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      TEST_SKIP_REASON,
      TEST_STATUS,
      TEST_SOURCE_START,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      TEST_CODE_OWNERS,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      CUCUMBER_IS_PARALLEL,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED,
      isModifiedTest,
      getTestEndLine,
    } = require_test()
    var { RESOURCE_NAME } = require_tags()
    var { COMPONENT, ERROR_MESSAGE } = require_constants2()
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      TELEMETRY_TEST_SESSION,
    } = require_telemetry()
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 200
    var BREAKPOINT_SET_GRACE_PERIOD_MS = 400
    var isCucumberWorker = !!getEnvironmentVariable('CUCUMBER_WORKER_ID')
    var CucumberPlugin = class extends CiPlugin {
      static id = 'cucumber'
      constructor(...args) {
        super(...args)
        this.sourceRoot = process.cwd()
        this.addSub(
          'ci:cucumber:session:finish',
          ({
            status,
            isSuitesSkipped,
            numSkippedSuites,
            testCodeCoverageLinesTotal,
            hasUnskippableSuites,
            hasForcedToRunSuites,
            isEarlyFlakeDetectionEnabled,
            isEarlyFlakeDetectionFaulty,
            isTestManagementTestsEnabled,
            isParallel,
          }) => {
            const { isSuitesSkippingEnabled, isCodeCoverageEnabled } = this.libraryConfig || {}
            addIntelligentTestRunnerSpanTags(this.testSessionSpan, this.testModuleSpan, {
              isSuitesSkipped,
              isSuitesSkippingEnabled,
              isCodeCoverageEnabled,
              testCodeCoverageLinesTotal,
              skippingCount: numSkippedSuites,
              skippingType: 'suite',
              hasUnskippableSuites,
              hasForcedToRunSuites,
            })
            if (isEarlyFlakeDetectionEnabled) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, 'true')
            }
            if (isEarlyFlakeDetectionFaulty) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, 'faulty')
            }
            if (isParallel) {
              this.testSessionSpan.setTag(CUCUMBER_IS_PARALLEL, 'true')
            }
            if (isTestManagementTestsEnabled) {
              this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, 'true')
            }
            this.testSessionSpan.setTag(TEST_STATUS, status)
            this.testModuleSpan.setTag(TEST_STATUS, status)
            this.testModuleSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'module')
            this.testSessionSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'session')
            finishAllTraceSpans(this.testSessionSpan)
            this.telemetry.count(TELEMETRY_TEST_SESSION, {
              provider: this.ciProviderName,
              autoInjected: !!getEnvironmentVariable('DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER'),
            })
            this.libraryConfig = null
            this.tracer._exporter.flush()
          }
        )
        this.addSub(
          'ci:cucumber:test-suite:start',
          ({ testFileAbsolutePath, isUnskippable, isForcedToRun, itrCorrelationId }) => {
            const testSuitePath = getTestSuitePath(testFileAbsolutePath, process.cwd())
            const testSourceFile = getTestSuitePath(testFileAbsolutePath, this.repositoryRoot)
            const testSuiteMetadata = getTestSuiteCommonTags(
              this.command,
              this.frameworkVersion,
              testSuitePath,
              'cucumber'
            )
            if (isUnskippable) {
              this.telemetry.count(TELEMETRY_ITR_UNSKIPPABLE, { testLevel: 'suite' })
              testSuiteMetadata[TEST_ITR_UNSKIPPABLE] = 'true'
            }
            if (isForcedToRun) {
              this.telemetry.count(TELEMETRY_ITR_FORCED_TO_RUN, { testLevel: 'suite' })
              testSuiteMetadata[TEST_ITR_FORCED_RUN] = 'true'
            }
            if (itrCorrelationId) {
              testSuiteMetadata[ITR_CORRELATION_ID] = itrCorrelationId
            }
            if (testSourceFile) {
              testSuiteMetadata[TEST_SOURCE_FILE] = testSourceFile
              testSuiteMetadata[TEST_SOURCE_START] = 1
            }
            const codeOwners = this.getCodeOwners(testSuiteMetadata)
            if (codeOwners) {
              testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners
            }
            const testSuiteSpan = this.tracer.startSpan('cucumber.test_suite', {
              childOf: this.testModuleSpan,
              tags: {
                [COMPONENT]: this.constructor.id,
                ...this.testEnvironmentMetadata,
                ...testSuiteMetadata,
              },
              integrationName: this.constructor.id,
            })
            this._testSuiteSpansByTestSuite.set(testSuitePath, testSuiteSpan)
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'suite')
            if (this.libraryConfig?.isCodeCoverageEnabled) {
              this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_STARTED, 'suite', { library: 'istanbul' })
            }
          }
        )
        this.addSub('ci:cucumber:test-suite:finish', ({ status, testSuitePath }) => {
          const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuitePath)
          testSuiteSpan.setTag(TEST_STATUS, status)
          testSuiteSpan.finish()
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'suite')
        })
        this.addSub('ci:cucumber:test-suite:code-coverage', ({ coverageFiles, suiteFile, testSuitePath }) => {
          if (!this.libraryConfig?.isCodeCoverageEnabled) {
            return
          }
          if (!coverageFiles.length) {
            this.telemetry.count(TELEMETRY_CODE_COVERAGE_EMPTY)
          }
          const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuitePath)
          const relativeCoverageFiles = [...coverageFiles, suiteFile].map((filename) =>
            getTestSuitePath(filename, this.repositoryRoot)
          )
          this.telemetry.distribution(TELEMETRY_CODE_COVERAGE_NUM_FILES, {}, relativeCoverageFiles.length)
          const formattedCoverage = {
            sessionId: testSuiteSpan.context()._traceId,
            suiteId: testSuiteSpan.context()._spanId,
            files: relativeCoverageFiles,
          }
          this.tracer._exporter.exportCoverage(formattedCoverage)
          this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_FINISHED, 'suite', { library: 'istanbul' })
        })
        this.addBind('ci:cucumber:test:start', (ctx) => {
          const { testName, testFileAbsolutePath, testSourceLine, isParallel, promises } = ctx
          const store = storage('legacy').getStore()
          const testSuite = getTestSuitePath(testFileAbsolutePath, this.sourceRoot)
          const testSourceFile = getTestSuitePath(testFileAbsolutePath, this.repositoryRoot)
          const extraTags = {
            [TEST_SOURCE_START]: testSourceLine,
            [TEST_SOURCE_FILE]: testSourceFile,
          }
          if (isParallel) {
            extraTags[CUCUMBER_IS_PARALLEL] = 'true'
          }
          const span = this.startTestSpan(testName, testSuite, extraTags)
          ctx.parentStore = store
          ctx.currentStore = { ...store, span }
          this.activeTestSpan = span
          if (promises && this.runningTestProbe) {
            promises.hitBreakpointPromise = new Promise((resolve) => {
              setTimeout(resolve, BREAKPOINT_HIT_GRACE_PERIOD_MS)
            })
          }
          return ctx.currentStore
        })
        this.addSub('ci:cucumber:test:retry', ({ span, isFirstAttempt, error, isAtrRetry }) => {
          if (!isFirstAttempt) {
            span.setTag(TEST_IS_RETRY, 'true')
            if (isAtrRetry) {
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr)
            } else {
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext)
            }
          }
          span.setTag('error', error)
          if (isFirstAttempt && this.di && error && this.libraryConfig?.isDiEnabled) {
            const probeInformation = this.addDiProbe(error)
            if (probeInformation) {
              const { file, line, stackIndex } = probeInformation
              this.runningTestProbe = { file, line }
              this.testErrorStackIndex = stackIndex
              const waitUntil = Date.now() + BREAKPOINT_SET_GRACE_PERIOD_MS
              while (Date.now() < waitUntil) {}
            }
          }
          span.setTag(TEST_STATUS, 'fail')
          span.finish()
          finishAllTraceSpans(span)
        })
        this.addBind('ci:cucumber:test-step:start', (ctx) => {
          const { resource } = ctx
          const store = storage('legacy').getStore()
          const childOf = store ? store.span : store
          const span = this.tracer.startSpan('cucumber.step', {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.id,
              'cucumber.step': resource,
              [RESOURCE_NAME]: resource,
            },
            integrationName: this.constructor.id,
          })
          ctx.parentStore = store
          ctx.currentStore = { ...store, span }
          return ctx.currentStore
        })
        this.addSub(
          'ci:cucumber:test:finish',
          ({
            span,
            isStep,
            status,
            skipReason,
            error,
            errorMessage,
            isNew,
            isEfdRetry,
            isFlakyRetry,
            isAttemptToFix,
            isAttemptToFixRetry,
            hasFailedAllRetries,
            hasPassedAllRetries,
            hasFailedAttemptToFix,
            isDisabled,
            isQuarantined,
            isModified,
          }) => {
            const statusTag = isStep ? 'step.status' : TEST_STATUS
            span.setTag(statusTag, status)
            if (isNew) {
              span.setTag(TEST_IS_NEW, 'true')
              if (isEfdRetry) {
                span.setTag(TEST_IS_RETRY, 'true')
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd)
              }
            }
            if (skipReason) {
              span.setTag(TEST_SKIP_REASON, skipReason)
            }
            if (error) {
              span.setTag('error', error)
            } else if (errorMessage) {
              span.setTag(ERROR_MESSAGE, errorMessage)
            }
            if (isFlakyRetry > 0) {
              span.setTag(TEST_IS_RETRY, 'true')
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr)
            }
            if (hasFailedAllRetries) {
              span.setTag(TEST_HAS_FAILED_ALL_RETRIES, 'true')
            }
            if (isAttemptToFix) {
              span.setTag(TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX, 'true')
            }
            if (isAttemptToFixRetry) {
              span.setTag(TEST_IS_RETRY, 'true')
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atf)
              if (hasPassedAllRetries) {
                span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'true')
              } else if (hasFailedAttemptToFix) {
                span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'false')
              }
            }
            if (isDisabled) {
              span.setTag(TEST_MANAGEMENT_IS_DISABLED, 'true')
            }
            if (isQuarantined) {
              span.setTag(TEST_MANAGEMENT_IS_QUARANTINED, 'true')
            }
            if (isModified) {
              span.setTag(TEST_IS_MODIFIED, 'true')
              if (isEfdRetry) {
                span.setTag(TEST_IS_RETRY, 'true')
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd)
              }
            }
            span.finish()
            if (!isStep) {
              const spanTags = span.context()._tags
              this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
                hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
                isNew,
                isRum: spanTags[TEST_IS_RUM_ACTIVE] === 'true',
                browserDriver: spanTags[TEST_BROWSER_DRIVER],
              })
              finishAllTraceSpans(span)
              if (isCucumberWorker) {
                this.tracer._exporter.flush()
              }
              this.activeTestSpan = null
              if (this.runningTestProbe) {
                this.removeDiProbe(this.runningTestProbe)
                this.runningTestProbe = null
              }
            }
          }
        )
        this.addBind('ci:cucumber:error', (ctx) => {
          const { err } = ctx
          if (err) {
            const span = ctx.currentStore.span
            span.setTag('error', err)
            ctx.parentStore = ctx.currentStore
            ctx.currentStore = { ...ctx.currentStore, span }
          }
          return ctx.currentStore
        })
        this.addBind('ci:cucumber:test:fn', (ctx) => {
          return ctx.currentStore
        })
        this.addSub(
          'ci:cucumber:is-modified-test',
          ({ scenarios, testFileAbsolutePath, modifiedFiles, stepIds, stepDefinitions, setIsModified }) => {
            const testScenarioPath = getTestSuitePath(testFileAbsolutePath, this.repositoryRoot || process.cwd())
            for (const scenario of scenarios) {
              const isModified = isModifiedTest(
                testScenarioPath,
                scenario.location.line,
                scenario.steps[scenario.steps.length - 1].location.line,
                modifiedFiles,
                'cucumber'
              )
              if (isModified) {
                setIsModified(true)
                return
              }
            }
            for (const stepDefinition of stepDefinitions) {
              if (!stepIds?.includes(stepDefinition.id)) {
                continue
              }
              const testStartLineStep = stepDefinition.line
              const testEndLineStep = getTestEndLine(stepDefinition.code, testStartLineStep)
              const isModified = isModifiedTest(
                stepDefinition.uri,
                testStartLineStep,
                testEndLineStep,
                modifiedFiles,
                'cucumber'
              )
              if (isModified) {
                setIsModified(true)
                return
              }
            }
            setIsModified(false)
          }
        )
      }
      startTestSpan(testName, testSuite, extraTags) {
        const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite)
        return super.startTestSpan(testName, testSuite, testSuiteSpan, extraTags)
      }
    }
    module2.exports = CucumberPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-playwright/src/index.js
var require_src8 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-playwright/src/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var id = require_id()
    var CiPlugin = require_ci_plugin()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      TEST_STATUS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags,
      TEST_SOURCE_START,
      TEST_CODE_OWNERS,
      TEST_SOURCE_FILE,
      TEST_PARAMETERS,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TELEMETRY_TEST_SESSION,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_ENABLED,
      TEST_BROWSER_NAME,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_SESSION_ID,
      TEST_MODULE_ID,
      TEST_COMMAND,
      TEST_MODULE,
      TEST_SUITE,
      TEST_SUITE_ID,
      TEST_NAME,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_VERSION,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED,
      isModifiedTest,
    } = require_test()
    var { RESOURCE_NAME } = require_tags()
    var { COMPONENT } = require_constants2()
    var { TELEMETRY_EVENT_CREATED, TELEMETRY_EVENT_FINISHED } = require_telemetry()
    var { appClosing: appClosingTelemetry } = require_telemetry3()
    var log = require_log2()
    var PlaywrightPlugin = class extends CiPlugin {
      static id = 'playwright'
      constructor(...args) {
        super(...args)
        this._testSuiteSpansByTestSuiteAbsolutePath = /* @__PURE__ */ new Map()
        this.numFailedTests = 0
        this.numFailedSuites = 0
        this.addSub('ci:playwright:test:is-modified', ({ filePath, modifiedFiles, onDone }) => {
          const testSuite = getTestSuitePath(filePath, this.repositoryRoot)
          const isModified = isModifiedTest(testSuite, 0, 0, modifiedFiles, this.constructor.id)
          onDone({ isModified })
        })
        this.addSub(
          'ci:playwright:session:finish',
          ({
            status,
            isEarlyFlakeDetectionEnabled,
            isEarlyFlakeDetectionFaulty,
            isTestManagementTestsEnabled,
            onDone,
          }) => {
            this.testModuleSpan.setTag(TEST_STATUS, status)
            this.testSessionSpan.setTag(TEST_STATUS, status)
            if (isEarlyFlakeDetectionEnabled) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, 'true')
            }
            if (isEarlyFlakeDetectionFaulty) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, 'faulty')
            }
            if (this.numFailedSuites > 0) {
              let errorMessage = `Test suites failed: ${this.numFailedSuites}.`
              if (this.numFailedTests > 0) {
                errorMessage += ` Tests failed: ${this.numFailedTests}`
              }
              const error = new Error(errorMessage)
              this.testModuleSpan.setTag('error', error)
              this.testSessionSpan.setTag('error', error)
            }
            if (isTestManagementTestsEnabled) {
              this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, 'true')
            }
            this.testModuleSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'module')
            this.testSessionSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'session')
            finishAllTraceSpans(this.testSessionSpan)
            this.telemetry.count(TELEMETRY_TEST_SESSION, {
              provider: this.ciProviderName,
              autoInjected: !!getEnvironmentVariable('DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER'),
            })
            appClosingTelemetry()
            this.tracer._exporter.flush(onDone)
            this.numFailedTests = 0
          }
        )
        this.addBind('ci:playwright:test-suite:start', (ctx) => {
          const { testSuiteAbsolutePath } = ctx
          const store = storage('legacy').getStore()
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.rootDir)
          const testSourceFile = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
          const testSuiteMetadata = getTestSuiteCommonTags(this.command, this.frameworkVersion, testSuite, 'playwright')
          if (testSourceFile) {
            testSuiteMetadata[TEST_SOURCE_FILE] = testSourceFile
            testSuiteMetadata[TEST_SOURCE_START] = 1
          }
          const codeOwners = this.getCodeOwners(testSuiteMetadata)
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners
          }
          const testSuiteSpan = this.tracer.startSpan('playwright.test_suite', {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata,
            },
          })
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'suite')
          ctx.parentStore = store
          ctx.currentStore = { ...store, testSuiteSpan }
          this._testSuiteSpansByTestSuiteAbsolutePath.set(testSuiteAbsolutePath, testSuiteSpan)
          return ctx.currentStore
        })
        this.addSub('ci:playwright:test-suite:finish', ({ testSuiteSpan, status, error }) => {
          if (!testSuiteSpan) return
          if (error) {
            testSuiteSpan.setTag('error', error)
            testSuiteSpan.setTag(TEST_STATUS, 'fail')
          } else {
            testSuiteSpan.setTag(TEST_STATUS, status)
          }
          if (status === 'fail' || error) {
            this.numFailedSuites++
          }
          testSuiteSpan.finish()
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'suite')
        })
        this.addSub('ci:playwright:test:page-goto', ({ isRumActive, page }) => {
          const store = storage('legacy').getStore()
          const span = store && store.span
          if (!span) {
            log.error('ci:playwright:test:page-goto: test span not found')
            return
          }
          if (isRumActive) {
            span.setTag(TEST_IS_RUM_ACTIVE, 'true')
            if (page) {
              const browserVersion = page.context().browser().version()
              if (browserVersion) {
                span.setTag(TEST_BROWSER_VERSION, browserVersion)
              }
              const url = page.url()
              const domain = new URL(url).hostname
              page.context().addCookies([
                {
                  name: 'datadog-ci-visibility-test-execution-id',
                  value: span.context().toTraceId(),
                  domain,
                  path: '/',
                },
              ])
            }
          }
        })
        this.addSub('ci:playwright:worker:report', (serializedTraces) => {
          const traces = JSON.parse(serializedTraces)
          const formattedTraces = []
          for (const trace of traces) {
            const formattedTrace = []
            for (const span of trace) {
              const formattedSpan = {
                ...span,
                span_id: id(span.span_id),
                trace_id: id(span.trace_id),
                parent_id: id(span.parent_id),
              }
              if (span.name === 'playwright.test') {
                formattedSpan.meta[TEST_SESSION_ID] = this.testSessionSpan.context().toTraceId()
                formattedSpan.meta[TEST_MODULE_ID] = this.testModuleSpan.context().toSpanId()
                formattedSpan.meta[TEST_COMMAND] = this.command
                formattedSpan.meta[TEST_MODULE] = this.constructor.id
                const testSuite = this._testSuiteSpansByTestSuiteAbsolutePath.get(
                  formattedSpan.meta.test_suite_absolute_path
                )
                if (testSuite) {
                  formattedSpan.meta[TEST_SUITE_ID] = testSuite.context().toSpanId()
                }
                const testSuitePath = getTestSuitePath(formattedSpan.meta.test_suite_absolute_path, this.rootDir)
                const testSourceFile = getTestSuitePath(
                  formattedSpan.meta.test_suite_absolute_path,
                  this.repositoryRoot
                )
                formattedSpan.meta[TEST_SUITE] = testSuitePath
                formattedSpan.meta[TEST_SOURCE_FILE] = testSourceFile
                formattedSpan.resource = `${testSuitePath}.${formattedSpan.meta[TEST_NAME]}`
                delete formattedSpan.meta.test_suite_absolute_path
              }
              formattedTrace.push(formattedSpan)
            }
            formattedTraces.push(formattedTrace)
          }
          formattedTraces.forEach((trace) => {
            this.tracer._exporter.export(trace)
          })
        })
        this.addBind('ci:playwright:test:start', (ctx) => {
          const { testName, testSuiteAbsolutePath, testSourceLine, browserName, isDisabled } = ctx
          const store = storage('legacy').getStore()
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.rootDir)
          const testSourceFile = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
          const span = this.startTestSpan(
            testName,
            testSuiteAbsolutePath,
            testSuite,
            testSourceFile,
            testSourceLine,
            browserName
          )
          if (isDisabled) {
            span.setTag(TEST_MANAGEMENT_IS_DISABLED, 'true')
          }
          ctx.parentStore = store
          ctx.currentStore = { ...store, span }
          return ctx.currentStore
        })
        this.addSub(
          'ci:playwright:test:finish',
          ({
            span,
            testStatus,
            steps,
            error,
            extraTags,
            isNew,
            isEfdRetry,
            isRetry,
            isAttemptToFix,
            isDisabled,
            isQuarantined,
            isAttemptToFixRetry,
            hasFailedAllRetries,
            hasPassedAttemptToFixRetries,
            hasFailedAttemptToFixRetries,
            isAtrRetry,
            isModified,
            onDone,
          }) => {
            if (!span) return
            const isRUMActive = span.context()._tags[TEST_IS_RUM_ACTIVE]
            span.setTag(TEST_STATUS, testStatus)
            if (error) {
              span.setTag('error', error)
            }
            if (extraTags) {
              span.addTags(extraTags)
            }
            if (isNew) {
              span.setTag(TEST_IS_NEW, 'true')
              if (isEfdRetry) {
                span.setTag(TEST_IS_RETRY, 'true')
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd)
              }
            }
            if (isRetry) {
              span.setTag(TEST_IS_RETRY, 'true')
              if (isAtrRetry) {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr)
              } else {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext)
              }
            }
            if (hasFailedAllRetries) {
              span.setTag(TEST_HAS_FAILED_ALL_RETRIES, 'true')
            }
            if (isAttemptToFix) {
              span.setTag(TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX, 'true')
            }
            if (isAttemptToFixRetry) {
              span.setTag(TEST_IS_RETRY, 'true')
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atf)
            }
            if (hasPassedAttemptToFixRetries) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'true')
            } else if (hasFailedAttemptToFixRetries) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'false')
            }
            if (isDisabled) {
              span.setTag(TEST_MANAGEMENT_IS_DISABLED, 'true')
            }
            if (isQuarantined) {
              span.setTag(TEST_MANAGEMENT_IS_QUARANTINED, 'true')
            }
            if (isModified) {
              span.setTag(TEST_IS_MODIFIED, 'true')
              if (isEfdRetry) {
                span.setTag(TEST_IS_RETRY, 'true')
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd)
              }
            }
            steps.forEach((step) => {
              const stepStartTime = step.startTime.getTime()
              const stepSpan = this.tracer.startSpan('playwright.step', {
                childOf: span,
                startTime: stepStartTime,
                tags: {
                  [COMPONENT]: this.constructor.id,
                  'playwright.step': step.title,
                  [RESOURCE_NAME]: step.title,
                },
              })
              if (step.error) {
                stepSpan.setTag('error', step.error)
              }
              let stepDuration = step.duration
              if (stepDuration <= 0 || Number.isNaN(stepDuration)) {
                stepDuration = 0
              }
              stepSpan.finish(stepStartTime + stepDuration)
            })
            if (testStatus === 'fail') {
              this.numFailedTests++
            }
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
              hasCodeOwners: !!span.context()._tags[TEST_CODE_OWNERS],
              isNew,
              isRum: isRUMActive,
              browserDriver: 'playwright',
            })
            span.finish()
            finishAllTraceSpans(span)
            if (getEnvironmentVariable('DD_PLAYWRIGHT_WORKER')) {
              this.tracer._exporter.flush(onDone)
            }
          }
        )
        this.addSub(
          'ci:playwright:test:skip',
          ({
            testName,
            testSuiteAbsolutePath,
            testSourceLine,
            browserName,
            isNew,
            isDisabled,
            isModified,
            isQuarantined,
          }) => {
            const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.rootDir)
            const testSourceFile = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
            const span = this.startTestSpan(
              testName,
              testSuiteAbsolutePath,
              testSuite,
              testSourceFile,
              testSourceLine,
              browserName
            )
            span.setTag(TEST_STATUS, 'skip')
            if (isNew) {
              span.setTag(TEST_IS_NEW, 'true')
            }
            if (isDisabled) {
              span.setTag(TEST_MANAGEMENT_IS_DISABLED, 'true')
            }
            if (isModified) {
              span.setTag(TEST_IS_MODIFIED, 'true')
            }
            if (isQuarantined) {
              span.setTag(TEST_MANAGEMENT_IS_QUARANTINED, 'true')
            }
            span.finish()
          }
        )
      }
      // TODO: this runs both in worker and main process (main process: skipped tests that do not go through _runTest)
      startTestSpan(testName, testSuiteAbsolutePath, testSuite, testSourceFile, testSourceLine, browserName) {
        const testSuiteSpan = this._testSuiteSpansByTestSuiteAbsolutePath.get(testSuiteAbsolutePath)
        const extraTags = {
          [TEST_SOURCE_START]: testSourceLine,
        }
        if (testSourceFile) {
          extraTags[TEST_SOURCE_FILE] = testSourceFile || testSuite
        }
        if (browserName) {
          extraTags[TEST_PARAMETERS] = JSON.stringify({ arguments: { browser: browserName }, metadata: {} })
          extraTags[TEST_BROWSER_NAME] = browserName
        }
        extraTags.test_suite_absolute_path = testSuiteAbsolutePath
        return super.startTestSpan(testName, testSuite, testSuiteSpan, extraTags)
      }
    }
    module2.exports = PlaywrightPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/storage.js
var require_storage5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/storage.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var StoragePlugin = class extends ClientPlugin {
      static type = 'storage'
      constructor(...args) {
        super(...args)
        this.system = this.constructor.system || this.component
      }
      startSpan(name, options, ctx) {
        if (!options.service && this.system) {
          options.service = `${this.tracer._service}-${this.system}`
        }
        return super.startSpan(name, options, ctx)
      }
    }
    module2.exports = StoragePlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/database.js
var require_database = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/database.js'(exports2, module2) {
    'use strict'
    var StoragePlugin = require_storage5()
    var { PEER_SERVICE_KEY, PEER_SERVICE_SOURCE_KEY } = require_constants2()
    var DatabasePlugin = class extends StoragePlugin {
      static operation = 'query'
      static peerServicePrecursors = ['db.name']
      constructor(...args) {
        super(...args)
        this.serviceTags = {
          dddbs: '',
          encodedDddbs: '',
          dde: '',
          encodedDde: '',
          ddps: '',
          encodedDdps: '',
          ddpv: '',
          encodedDdpv: '',
        }
      }
      encodingServiceTags(serviceTag, encodeATag, spanConfig) {
        if (serviceTag !== spanConfig) {
          this.serviceTags[serviceTag] = spanConfig
          this.serviceTags[encodeATag] = encodeURIComponent(spanConfig)
        }
      }
      createDBMPropagationCommentService(serviceName, span) {
        this.encodingServiceTags('dddbs', 'encodedDddbs', serviceName)
        this.encodingServiceTags('dde', 'encodedDde', this.tracer._env)
        this.encodingServiceTags('ddps', 'encodedDdps', this.tracer._service)
        this.encodingServiceTags('ddpv', 'encodedDdpv', this.tracer._version)
        if (span.context()._tags['out.host']) {
          this.encodingServiceTags('ddh', 'encodedDdh', span._spanContext._tags['out.host'])
        }
        if (span.context()._tags['db.name']) {
          this.encodingServiceTags('dddb', 'encodedDddb', span._spanContext._tags['db.name'])
        }
        const { encodedDddb, encodedDddbs, encodedDde, encodedDdh, encodedDdps, encodedDdpv } = this.serviceTags
        let dbmComment = `dddb='${encodedDddb}',dddbs='${encodedDddbs}',dde='${encodedDde}',ddh='${encodedDdh}',ddps='${encodedDdps}',ddpv='${encodedDdpv}'`
        const peerData = this.getPeerService(span.context()._tags)
        if (peerData !== void 0 && peerData[PEER_SERVICE_SOURCE_KEY] === PEER_SERVICE_KEY) {
          this.encodingServiceTags('ddprs', 'encodedDdprs', peerData[PEER_SERVICE_KEY])
          const { encodedDdprs } = this.serviceTags
          dbmComment += `,ddprs='${encodedDdprs}'`
        }
        return dbmComment
      }
      getDbmServiceName(span, tracerService) {
        if (this._tracerConfig.spanComputePeerService) {
          const peerData = this.getPeerService(span.context()._tags)
          return this.getPeerServiceRemap(peerData)[PEER_SERVICE_KEY] || tracerService
        }
        return tracerService
      }
      createDbmComment(span, serviceName, disableFullMode = false) {
        const mode = this.config.dbmPropagationMode
        const dbmService = this.getDbmServiceName(span, serviceName)
        if (mode === 'disabled') {
          return null
        }
        const servicePropagation = this.createDBMPropagationCommentService(dbmService, span)
        if (disableFullMode || mode === 'service') {
          return servicePropagation
        } else if (mode === 'full') {
          span.setTag('_dd.dbm_trace_injected', 'true')
          span._processor.sample(span)
          const traceparent = span._spanContext.toTraceparent()
          return `${servicePropagation},traceparent='${traceparent}'`
        }
      }
      injectDbmQuery(span, query, serviceName, disableFullMode = false) {
        const dbmTraceComment = this.createDbmComment(span, serviceName, disableFullMode)
        if (!dbmTraceComment) {
          return query
        }
        return this.config.appendComment ? `${query} /*${dbmTraceComment}*/` : `/*${dbmTraceComment}*/ ${query}`
      }
      maybeTruncate(query) {
        const maxLength = typeof this.config.truncate === 'number' ? this.config.truncate : 5e3
        if (this.config.truncate && query && query.length > maxLength) {
          query = `${query.slice(0, maxLength - 3)}...`
        }
        return query
      }
    }
    module2.exports = DatabasePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js
var require_src9 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js'(exports2, module2) {
    'use strict'
    var DatabasePlugin = require_database()
    var ElasticsearchPlugin = class extends DatabasePlugin {
      static id = 'elasticsearch'
      bindStart(ctx) {
        const { params } = ctx
        const body = getBody(params.body || params.bulkBody)
        this.startSpan(
          this.operationName(),
          {
            service: this.serviceName({ pluginConfig: this.config }),
            resource: `${params.method} ${quantizePath(params.path)}`,
            type: 'elasticsearch',
            kind: 'client',
            meta: {
              'db.type': this.system,
              [`${this.system}.url`]: params.path,
              [`${this.system}.method`]: params.method,
              [`${this.system}.body`]: body,
              [`${this.system}.params`]: JSON.stringify(params.querystring || params.query),
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      bindFinish(ctx) {
        const { params } = ctx
        const span = this.activeSpan
        this.config.hooks.query(span, params)
        super.finish(ctx)
        return ctx.parentStore
      }
    }
    function getBody(body) {
      return body && JSON.stringify(body)
    }
    function quantizePath(path) {
      return path && path.replaceAll(/[0-9]+/g, '?')
    }
    module2.exports = ElasticsearchPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/producer.js
var require_producer4 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/producer.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer()
    var { DsmPathwayCodec, getHeadersSize } = require_datastreams()
    var GoogleCloudPubsubProducerPlugin = class extends ProducerPlugin {
      static id = 'google-cloud-pubsub'
      static operation = 'request'
      bindStart(ctx) {
        const { request, api, projectId } = ctx
        if (api !== 'publish') return
        const messages = request.messages || []
        const topic = request.topic
        const span = this.startSpan(
          {
            // TODO: rename
            resource: `${api} ${topic}`,
            meta: {
              'gcloud.project_id': projectId,
              'pubsub.method': api,
              // TODO: remove
              'pubsub.topic': topic,
            },
          },
          ctx
        )
        for (const msg of messages) {
          if (!msg.attributes) {
            msg.attributes = {}
          }
          this.tracer.inject(span, 'text_map', msg.attributes)
          if (this.config.dsmEnabled) {
            const payloadSize = getHeadersSize(msg)
            const dataStreamsContext = this.tracer.setCheckpoint(
              ['direction:out', `topic:${topic}`, 'type:google-pubsub'],
              span,
              payloadSize
            )
            DsmPathwayCodec.encode(dataStreamsContext, msg.attributes)
          }
        }
        return ctx.currentStore
      }
    }
    module2.exports = GoogleCloudPubsubProducerPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/inbound.js
var require_inbound = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/inbound.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var InboundPlugin = class extends TracingPlugin {
      bindFinish(ctx) {
        return ctx.parentStore
      }
    }
    module2.exports = InboundPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/consumer.js
var require_consumer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/consumer.js'(exports2, module2) {
    'use strict'
    var InboundPlugin = require_inbound()
    var ConsumerPlugin = class extends InboundPlugin {
      static operation = 'receive'
      static kind = 'consumer'
      static type = 'messaging'
      startSpan(options, enterOrCtx) {
        if (!options.service) {
          options.service = this.config.service || this.serviceName()
        }
        if (!options.kind) {
          options.kind = this.constructor.kind
        }
        return super.startSpan(this.operationName(), options, enterOrCtx)
      }
    }
    module2.exports = ConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/consumer.js
var require_consumer2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/consumer.js'(exports2, module2) {
    'use strict'
    var { getMessageSize } = require_datastreams()
    var ConsumerPlugin = require_consumer()
    var GoogleCloudPubsubConsumerPlugin = class extends ConsumerPlugin {
      static id = 'google-cloud-pubsub'
      static operation = 'receive'
      bindStart(ctx) {
        const { message } = ctx
        const subscription = message._subscriber._subscription
        const topic = subscription.metadata && subscription.metadata.topic
        const childOf = this.tracer.extract('text_map', message.attributes) || null
        const span = this.startSpan(
          {
            childOf,
            resource: topic,
            type: 'worker',
            meta: {
              'gcloud.project_id': subscription.pubsub.projectId,
              'pubsub.topic': topic,
            },
            metrics: {
              'pubsub.ack': 0,
            },
          },
          ctx
        )
        if (this.config.dsmEnabled && message?.attributes) {
          const payloadSize = getMessageSize(message)
          this.tracer.decodeDataStreamsContext(message.attributes)
          this.tracer.setCheckpoint(['direction:in', `topic:${topic}`, 'type:google-pubsub'], span, payloadSize)
        }
        return ctx.currentStore
      }
      bindFinish(ctx) {
        const { message } = ctx
        const span = ctx.currentStore.span
        if (message?._handled) {
          span.setTag('pubsub.ack', 1)
        }
        super.finish()
        return ctx.parentStore
      }
    }
    module2.exports = GoogleCloudPubsubConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/client.js
var require_client6 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/client.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var GoogleCloudPubsubClientPlugin = class extends ClientPlugin {
      static id = 'google-cloud-pubsub'
      static type = 'messaging'
      static operation = 'request'
      start(ctx) {
        const { request, api, projectId } = ctx
        if (api === 'publish') return
        this.startSpan(
          this.operationName(),
          {
            service: this.config.service || this.serviceName(),
            resource: [api, request.name].filter(Boolean).join(' '),
            kind: this.constructor.kind,
            meta: {
              'pubsub.method': api,
              'gcloud.project_id': projectId,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = GoogleCloudPubsubClientPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js
var require_src10 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer4()
    var ConsumerPlugin = require_consumer2()
    var ClientPlugin = require_client6()
    var CompositePlugin = require_composite()
    var GoogleCloudPubsubPlugin = class extends CompositePlugin {
      static id = 'google-cloud-pubsub'
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          client: ClientPlugin,
        }
      }
    }
    module2.exports = GoogleCloudPubsubPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/llm.js
var require_llm = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/util/llm.js'(exports2, module2) {
    'use strict'
    var Sampler = require_sampler2()
    var RE_NEWLINE = /\n/g
    var RE_TAB = /\t/g
    function normalize(text, limit = 128) {
      if (typeof text !== 'string' || text.length === 0) return
      if (text.length > limit) {
        return text.slice(0, limit) + '...'
      }
      text = text.replaceAll(RE_NEWLINE, String.raw`\n`).replaceAll(RE_TAB, String.raw`\t`)
      if (text.length > limit) {
        return text.slice(0, limit) + '...'
      }
      return text
    }
    function isPromptCompletionSampled(sampler, span) {
      return sampler.isSampled(span)
    }
    module2.exports = function makeUtilities(integrationName, tracerConfig) {
      const integrationConfig = tracerConfig[integrationName] || {}
      const { spanCharLimit, spanPromptCompletionSampleRate } = integrationConfig
      const sampler = new Sampler(spanPromptCompletionSampleRate ?? 1)
      return {
        normalize: (str) => normalize(str, spanCharLimit),
        /**
         * Determines whether a prompt completion should be sampled based on the configured sampling rate.
         *
         * @param {import('index').Span|import('index').SpanContext} span
         * @returns {boolean} `true` if the prompt completion should be sampled, otherwise `false`.
         */
        isPromptCompletionSampled: (span) => isPromptCompletionSampled(sampler, span),
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-vertexai/src/utils.js
var require_utils4 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-cloud-vertexai/src/utils.js'(exports2, module2) {
    'use strict'
    function extractModel(instance) {
      const model = instance.model || instance.resourcePath || instance.publisherModelEndpoint
      return model?.split('/').pop()
    }
    function extractSystemInstructions(instance) {
      const systemInstruction = instance.systemInstruction
      if (!systemInstruction) return []
      if (typeof systemInstruction === 'string') return [systemInstruction]
      return systemInstruction.parts?.map((part) => part.text)
    }
    module2.exports = {
      extractModel,
      extractSystemInstructions,
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-vertexai/src/tracing.js
var require_tracing4 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-cloud-vertexai/src/tracing.js'(exports2, module2) {
    'use strict'
    var { MEASURED } = require_tags()
    var { storage } = require_datadog_core()
    var TracingPlugin = require_tracing()
    var makeUtilities = require_llm()
    var { extractModel } = require_utils4()
    var GoogleCloudVertexAITracingPlugin = class extends TracingPlugin {
      static id = 'google-cloud-vertexai'
      static prefix = 'tracing:apm:vertexai:request'
      constructor() {
        super(...arguments)
        Object.assign(this, makeUtilities('vertexai', this._tracerConfig))
      }
      bindStart(ctx) {
        const { instance, resource } = ctx
        const span = this.startSpan(
          'vertexai.request',
          {
            service: this.config.service,
            resource,
            kind: 'client',
            meta: {
              [MEASURED]: 1,
              'vertexai.request.model': extractModel(instance),
            },
          },
          false
        )
        const store = storage('legacy').getStore() || {}
        ctx.currentStore = { ...store, span }
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore?.span
        if (!span) return
        span.finish()
      }
    }
    module2.exports = GoogleCloudVertexAITracingPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/vertexai.js
var require_vertexai = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/vertexai.js'(exports2, module2) {
    'use strict'
    var LLMObsPlugin = require_base()
    var { extractModel, extractSystemInstructions } = require_utils4()
    var VertexAILLMObsPlugin = class extends LLMObsPlugin {
      static integration = 'vertexai'
      // used for llmobs telemetry
      static id = 'vertexai'
      static prefix = 'tracing:apm:vertexai:request'
      getLLMObsSpanRegisterOptions(ctx) {
        const history = ctx.instance?.historyInternal || []
        ctx.history = history
        return {
          kind: 'llm',
          modelName: extractModel(ctx.instance),
          modelProvider: 'google',
          name: ctx.resource,
        }
      }
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span
        if (!span) return
        const { instance, result, request } = ctx
        const history = ctx.history || []
        const systemInstructions = extractSystemInstructions(instance)
        const metadata = getMetadata(instance)
        const inputMessages = extractInputMessages(request, history, systemInstructions)
        const outputMessages = extractOutputMessages(result)
        const metrics = extractMetrics(result)
        this._tagger.tagLLMIO(span, inputMessages, outputMessages)
        this._tagger.tagMetadata(span, metadata)
        this._tagger.tagMetrics(span, metrics)
      }
    }
    function getMetadata(instance) {
      const metadata = {}
      const modelConfig = instance.generationConfig
      if (!modelConfig) return metadata
      for (const [parameter, parameterKey] of [
        ['temperature', 'temperature'],
        ['maxOutputTokens', 'max_output_tokens'],
        ['candidateCount', 'candidate_count'],
        ['topP', 'top_p'],
        ['topK', 'top_k'],
      ]) {
        if (modelConfig[parameter]) {
          metadata[parameterKey] = modelConfig[parameter]
        }
      }
      return metadata
    }
    function extractInputMessages(request, history, systemInstructions) {
      const contents = typeof request === 'string' || Array.isArray(request) ? request : request.contents
      const messages = []
      if (systemInstructions) {
        for (const instruction of systemInstructions) {
          messages.push({ content: instruction || '', role: 'system' })
        }
      }
      for (const content of history) {
        messages.push(...extractMessagesFromContent(content))
      }
      if (typeof contents === 'string') {
        messages.push({ content: contents })
        return messages
      }
      if (isPart(contents)) {
        messages.push(extractMessageFromPart(contents))
        return messages
      }
      if (!Array.isArray(contents)) {
        messages.push({
          content: `[Non-array content object: ${typeof contents.toString === 'function' ? contents.toString() : String(contents)}]`,
        })
        return messages
      }
      for (const content of contents) {
        if (typeof content === 'string') {
          messages.push({ content })
          continue
        }
        if (isPart(content)) {
          messages.push(extractMessageFromPart(content))
          continue
        }
        messages.push(...extractMessagesFromContent(content))
      }
      return messages
    }
    function extractOutputMessages(result) {
      if (!result) return [{ content: '' }]
      const { response } = result
      if (!response) return [{ content: '' }]
      const outputMessages = []
      const candidates = response.candidates || []
      for (const candidate of candidates) {
        const content = candidate.content || ''
        outputMessages.push(...extractMessagesFromContent(content))
      }
      return outputMessages
    }
    function extractMessagesFromContent(content) {
      const messages = []
      const role = content.role || ''
      const parts = content.parts || []
      if (parts == null || parts.length === 0 || !Array.isArray(parts)) {
        const message = {
          content: `[Non-text content object: ${typeof content.toString === 'function' ? content.toString() : String(content)}]`,
        }
        if (role) message.role = role
        messages.push(message)
        return messages
      }
      for (const part of parts) {
        const message = extractMessageFromPart(part, role)
        messages.push(message)
      }
      return messages
    }
    function extractMessageFromPart(part, role) {
      const text = part.text || ''
      const functionCall = part.functionCall
      const functionResponse = part.functionResponse
      const message = { content: text }
      if (role) message.role = role
      if (functionCall) {
        message.toolCalls = [
          {
            name: functionCall.name,
            arguments: functionCall.args,
          },
        ]
      }
      if (functionResponse) {
        message.content = `[tool result: ${functionResponse.response}]`
      }
      return message
    }
    function extractMetrics(result) {
      if (!result) return {}
      const { response } = result
      if (!response) return {}
      const tokenCounts = response.usageMetadata
      const metrics = {}
      if (tokenCounts) {
        metrics.inputTokens = tokenCounts.promptTokenCount
        metrics.outputTokens = tokenCounts.candidatesTokenCount
        metrics.totalTokens = tokenCounts.totalTokenCount
      }
      return metrics
    }
    function isPart(part) {
      return part.text || part.functionCall || part.functionResponse
    }
    module2.exports = VertexAILLMObsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-vertexai/src/index.js
var require_src11 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-cloud-vertexai/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var GoogleVertexAITracingPlugin = require_tracing4()
    var VertexAILLMObsPlugin = require_vertexai()
    var GoogleCloudVertexAIPlugin = class extends CompositePlugin {
      static id = 'google-cloud-vertexai'
      static get plugins() {
        return {
          llmobs: VertexAILLMObsPlugin,
          tracing: GoogleVertexAITracingPlugin,
        }
      }
    }
    module2.exports = GoogleCloudVertexAIPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-genai/src/tracing.js
var require_tracing5 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-genai/src/tracing.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var GenAiTracingPlugin = class extends TracingPlugin {
      static id = 'google-genai'
      static operation = 'request'
      static prefix = 'tracing:apm:google:genai:request'
      static get type() {
        return 'web'
      }
      static get kind() {
        return 'client'
      }
      bindStart(ctx) {
        const { args, methodName } = ctx
        const inputs = args[0]
        const model = inputs?.model || 'unknown'
        this.startSpan(
          'google_genai.request',
          {
            meta: {
              'resource.name': methodName,
              'google_genai.request.model': model,
              'google_genai.request.provider': 'google',
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        const { span } = ctx.currentStore
        if (!span) return
        if (ctx.result) {
          span.setTag('google_genai.response.model', ctx.result.modelVersion || ctx.inputs?.model)
        }
        span.finish()
      }
    }
    module2.exports = GenAiTracingPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/genai/util.js
var require_util6 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/genai/util.js'(exports2, module2) {
    'use strict'
    var ROLES = {
      MODEL: 'model',
      ASSISTANT: 'assistant',
      USER: 'user',
      REASONING: 'reasoning',
    }
    function getOperation(methodName) {
      return methodName.includes('embed') ? 'embedding' : 'llm'
    }
    function extractTextParts(parts) {
      return parts.filter((part) => part.text).map((part) => part.text)
    }
    function groupPartsByRole(parts) {
      const grouped = {
        reasoning: '',
        assistant: '',
      }
      for (const part of parts) {
        if (!part.text) continue
        if (part.thought === true) {
          grouped.reasoning += part.text
        } else {
          grouped.assistant += part.text
        }
      }
      return grouped
    }
    function hasThoughtParts(parts) {
      return parts.some((part) => part.thought === true)
    }
    function determineRole(candidate, parts = []) {
      if (hasThoughtParts(parts)) {
        return ROLES.REASONING
      }
      const rawRole = candidate.role || candidate.content?.role || candidate[0]?.content?.role
      return normalizeRole(rawRole)
    }
    function normalizeRole(role) {
      if (role === ROLES.MODEL) return ROLES.ASSISTANT
      if (role === ROLES.ASSISTANT) return ROLES.ASSISTANT
      if (role === ROLES.USER) return ROLES.USER
      if (role === ROLES.REASONING) return ROLES.REASONING
      return ROLES.USER
    }
    function extractMetrics(response) {
      const metrics = {}
      const tokenUsage = response.usageMetadata
      if (!tokenUsage) return metrics
      if (tokenUsage.promptTokenCount) {
        metrics.inputTokens = tokenUsage.promptTokenCount
      }
      if (tokenUsage.candidatesTokenCount) {
        metrics.outputTokens = tokenUsage.candidatesTokenCount
      }
      const totalTokens =
        tokenUsage.totalTokenCount || (tokenUsage.promptTokenCount || 0) + (tokenUsage.candidatesTokenCount || 0)
      if (totalTokens) {
        metrics.totalTokens = totalTokens
      }
      return metrics
    }
    function extractMetadata(config) {
      if (!config) return {}
      const fieldMap = {
        temperature: 'temperature',
        top_p: 'topP',
        top_k: 'topK',
        candidate_count: 'candidateCount',
        max_output_tokens: 'maxOutputTokens',
        stop_sequences: 'stopSequences',
        response_logprobs: 'responseLogprobs',
        logprobs: 'logprobs',
        presence_penalty: 'presencePenalty',
        frequency_penalty: 'frequencyPenalty',
        seed: 'seed',
        response_mime_type: 'responseMimeType',
        safety_settings: 'safetySettings',
        automatic_function_calling: 'automaticFunctionCalling',
      }
      const metadata = {}
      for (const [metadataKey, configKey] of Object.entries(fieldMap)) {
        metadata[metadataKey] = config[configKey] ?? null
      }
      return metadata
    }
    function formatFunctionCallMessage(parts, functionCalls, role) {
      const toolCalls = functionCalls.map((part) => ({
        name: part.functionCall.name,
        arguments: part.functionCall.args,
        toolId: part.functionCall.id || '',
        type: 'function_call',
      }))
      const textParts = extractTextParts(parts)
      const content = textParts.length > 0 ? textParts.join('\n') : void 0
      const message = { role, toolCalls }
      if (content) message.content = content
      return message
    }
    function formatFunctionResponseMessage(functionResponses, role) {
      const toolResults = functionResponses.map((part) => ({
        name: part.functionResponse.name,
        result: JSON.stringify(part.functionResponse.response),
        toolId: part.functionResponse.id,
        type: 'function_response',
      }))
      return {
        role,
        toolResults,
      }
    }
    function aggregateStreamingChunks(chunks) {
      const response = { candidates: [] }
      for (const chunk of chunks) {
        if (chunk.candidates) {
          response.candidates.push(...chunk.candidates)
        }
        if (chunk.usageMetadata) {
          response.usageMetadata = chunk.usageMetadata
        }
      }
      return response
    }
    function formatContentObject(content) {
      const parts = content.parts || []
      const role = determineRole(content, parts)
      if (hasThoughtParts(parts)) {
        return {
          role: ROLES.REASONING,
          content: extractTextParts(parts).join('\n'),
        }
      }
      const functionCalls = parts.filter((part) => part.functionCall)
      if (functionCalls.length > 0) {
        return formatFunctionCallMessage(parts, functionCalls, role)
      }
      const functionResponses = parts.filter((part) => part.functionResponse)
      if (functionResponses.length > 0) {
        return formatFunctionResponseMessage(functionResponses, role)
      }
      return {
        role,
        content: extractTextParts(parts).join('\n'),
      }
    }
    function formatInputMessages(contents) {
      if (!contents) return []
      const contentArray = Array.isArray(contents) ? contents : [contents]
      const messages = []
      for (const content of contentArray) {
        if (typeof content === 'string') {
          messages.push({ role: ROLES.USER, content })
        } else if (content.text) {
          messages.push({ role: ROLES.USER, content: content.text })
        } else if (content.parts) {
          const message = formatContentObject(content)
          if (message) messages.push(message)
        } else {
          messages.push({ role: ROLES.USER, content: JSON.stringify(content) })
        }
      }
      return messages
    }
    function formatEmbeddingInput(contents) {
      if (!contents) return []
      const contentArray = Array.isArray(contents) ? contents : [contents]
      const documents = []
      for (const content of contentArray) {
        if (typeof content === 'string') {
          documents.push({ text: content })
        } else if (content.text) {
          documents.push({ text: content.text })
        } else if (content.parts) {
          for (const part of content.parts) {
            if (typeof part === 'string') {
              documents.push({ text: part })
            } else if (part.text) {
              documents.push({ text: part.text })
            }
          }
        }
      }
      return documents
    }
    function formatNonStreamingCandidate(candidate) {
      const messages = []
      const content = Array.isArray(candidate) ? candidate[0].content : candidate.content
      if (!content?.parts) return messages
      const { parts } = content
      const functionCalls = parts.filter((part) => part.functionCall)
      if (functionCalls.length > 0) {
        messages.push(formatFunctionCallMessage(parts, functionCalls, ROLES.ASSISTANT))
        return messages
      }
      const executableCode = parts.find((part) => part.executableCode)
      if (executableCode) {
        messages.push({
          role: ROLES.ASSISTANT,
          content: JSON.stringify({
            language: executableCode.executableCode.language,
            code: executableCode.executableCode.code,
          }),
        })
        return messages
      }
      const codeExecutionResult = parts.find((part) => part.codeExecutionResult)
      if (codeExecutionResult) {
        messages.push({
          role: ROLES.ASSISTANT,
          content: JSON.stringify({
            outcome: codeExecutionResult.codeExecutionResult.outcome,
            output: codeExecutionResult.codeExecutionResult.output,
          }),
        })
        return messages
      }
      const partsByRole = groupPartsByRole(parts)
      if (partsByRole.reasoning) {
        messages.push({
          role: ROLES.REASONING,
          content: partsByRole.reasoning,
        })
      }
      if (partsByRole.assistant) {
        messages.push({
          role: ROLES.ASSISTANT,
          content: partsByRole.assistant,
        })
      }
      return messages
    }
    function formatStreamingOutput(response) {
      const messages = []
      const messagesByRole = /* @__PURE__ */ new Map()
      for (const candidate of response.candidates) {
        const content = Array.isArray(candidate) ? candidate[0].content : candidate.content
        if (!content?.parts) continue
        if (content.parts.some((part) => part.functionCall || part.executableCode || part.codeExecutionResult)) {
          messages.push(...formatNonStreamingCandidate(candidate))
          continue
        }
        const partsByRole = groupPartsByRole(content.parts)
        for (const [partRole, textContent] of Object.entries(partsByRole)) {
          if (!textContent) continue
          if (messagesByRole.has(partRole)) {
            const index = messagesByRole.get(partRole)
            messages[index].content += textContent
          } else {
            const messageIndex = messages.length
            messages.push({ role: partRole, content: textContent })
            messagesByRole.set(partRole, messageIndex)
          }
        }
      }
      return messages.length > 0 ? messages : [{ content: '' }]
    }
    function formatNonStreamingOutput(response) {
      const messages = []
      for (const candidate of response.candidates) {
        messages.push(...formatNonStreamingCandidate(candidate))
      }
      return messages.length > 0 ? messages : [{ content: '' }]
    }
    function formatOutputMessages(response, isStreaming = false) {
      if (!response?.candidates?.length) {
        return [{ content: '' }]
      }
      if (isStreaming) {
        return formatStreamingOutput(response)
      }
      return formatNonStreamingOutput(response)
    }
    function formatEmbeddingOutput(response) {
      if (!response?.embeddings?.length) {
        return ''
      }
      const embeddingCount = response.embeddings.length
      const firstEmbedding = response.embeddings[0]
      if (firstEmbedding.values && Array.isArray(firstEmbedding.values)) {
        const embeddingDim = firstEmbedding.values.length
        return `[${embeddingCount} embedding(s) returned with size ${embeddingDim}]`
      }
      return `[${embeddingCount} embedding(s) returned]`
    }
    module2.exports = {
      getOperation,
      extractMetrics,
      extractMetadata,
      aggregateStreamingChunks,
      formatInputMessages,
      formatEmbeddingInput,
      formatOutputMessages,
      formatEmbeddingOutput,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/genai/index.js
var require_genai = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/genai/index.js'(exports2, module2) {
    'use strict'
    var LLMObsPlugin = require_base()
    var {
      getOperation,
      extractMetrics,
      extractMetadata,
      aggregateStreamingChunks,
      formatInputMessages,
      formatEmbeddingInput,
      formatOutputMessages,
      formatEmbeddingOutput,
    } = require_util6()
    var GenAiLLMObsPlugin = class extends LLMObsPlugin {
      static id = 'google-genai'
      static integration = 'genai'
      static prefix = 'tracing:apm:google:genai:request'
      constructor() {
        super(...arguments)
        this.addSub('apm:google:genai:request:chunk', ({ ctx, chunk, done }) => {
          ctx.isStreaming = true
          ctx.chunks = ctx.chunks || []
          if (chunk) ctx.chunks.push(chunk)
          if (!done) return
          ctx.result = aggregateStreamingChunks(ctx.chunks)
        })
      }
      getLLMObsSpanRegisterOptions(ctx) {
        const { args, methodName } = ctx
        if (!methodName) return
        const inputs = args[0]
        const operation = getOperation(methodName)
        return {
          modelProvider: 'google',
          modelName: inputs.model,
          kind: operation,
          name: 'google_genai.request',
        }
      }
      setLLMObsTags(ctx) {
        const { args, methodName } = ctx
        const span = ctx.currentStore?.span
        if (!methodName) return
        const inputs = args[0]
        const response = ctx.result
        const error = !!span.context()._tags.error
        const operation = getOperation(methodName)
        if (operation === 'llm') {
          this.#tagGenerateContent(span, inputs, response, error, ctx.isStreaming)
        } else if (operation === 'embedding') {
          this.#tagEmbedding(span, inputs, response, error)
        }
        if (!error && response) {
          const metrics = extractMetrics(response)
          this._tagger.tagMetrics(span, metrics)
        }
      }
      #tagGenerateContent(span, inputs, response, error, isStreaming = false) {
        const { config = {} } = inputs
        const inputMessages = formatInputMessages(inputs.contents)
        const metadata = extractMetadata(config)
        this._tagger.tagMetadata(span, metadata)
        if (error) {
          this._tagger.tagLLMIO(span, inputMessages, [{ content: '' }])
          return
        }
        const outputMessages = formatOutputMessages(response, isStreaming)
        this._tagger.tagLLMIO(span, inputMessages, outputMessages)
      }
      #tagEmbedding(span, inputs, response, error) {
        const embeddingInput = formatEmbeddingInput(inputs.contents)
        if (error) {
          this._tagger.tagEmbeddingIO(span, embeddingInput)
          return
        }
        const embeddingOutput = formatEmbeddingOutput(response)
        this._tagger.tagEmbeddingIO(span, embeddingInput, embeddingOutput)
      }
    }
    module2.exports = GenAiLLMObsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-google-genai/src/index.js
var require_src12 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-google-genai/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var GenAiTracingPlugin = require_tracing5()
    var GenAiLLMObsPlugin = require_genai()
    var GenAiPlugin = class extends CompositePlugin {
      static id = 'google-genai'
      static get plugins() {
        return {
          llmobs: GenAiLLMObsPlugin,
          tracing: GenAiTracingPlugin,
        }
      }
    }
    module2.exports = GenAiPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/server.js
var require_server5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/server.js'(exports2, module2) {
    'use strict'
    var InboundPlugin = require_inbound()
    var ServerPlugin = class extends InboundPlugin {
      static operation = 'request'
      static kind = 'server'
      static type = 'web'
      // a default that may eventually be overriden by nonweb servers
    }
    module2.exports = ServerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js
var require_util7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js'(exports2, module2) {
    'use strict'
    var pick = require_pick()
    var log = require_log2()
    function getEmptyObject() {
      return {}
    }
    module2.exports = {
      getMethodMetadata(path, kind) {
        const tags = {
          path,
          kind,
          name: '',
          service: '',
          package: '',
        }
        if (typeof path !== 'string') return tags
        const methodParts = path.split('/')
        if (methodParts.length > 2) {
          const serviceParts = methodParts[1].split('.')
          const name = methodParts[2]
          const service = serviceParts.pop()
          const pkg = serviceParts.join('.')
          tags.name = name
          tags.service = service
          tags.package = pkg
        } else {
          tags.name = methodParts.at(-1)
        }
        return tags
      },
      addMetadataTags(span, metadata, filter, type) {
        if (!metadata || typeof metadata.getMap !== 'function') return
        const values = filter(metadata.getMap())
        for (const key in values) {
          span.setTag(`grpc.${type}.metadata.${key}`, values[key])
        }
      },
      // TODO: extract this to shared utils and add unit tests
      getFilter(config, filter) {
        if (typeof config[filter] === 'function') {
          return config[filter]
        }
        if (Array.isArray(config[filter])) {
          return (element) => pick(element, config[filter])
        }
        if (config.hasOwnProperty(filter)) {
          log.error("Expected '%s' to be an array or function.", filter)
        }
        return getEmptyObject
      },
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js
var require_server6 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var ServerPlugin = require_server5()
    var { TEXT_MAP } = require_formats()
    var { addMetadataTags, getFilter, getMethodMetadata } = require_util7()
    var GrpcServerPlugin = class extends ServerPlugin {
      static id = 'grpc'
      static operation = 'server:request'
      static prefix = 'apm:grpc:server:request'
      constructor(...args) {
        super(...args)
        this.addTraceSub('update', ({ code }) => {
          const span = this.activeSpan
          if (!span) return
          this.addCode(span, code)
        })
        this.addTraceBind('emit', ({ currentStore }) => {
          return currentStore
        })
      }
      bindStart(message) {
        const store = storage('legacy').getStore()
        const { name, metadata, type } = message
        const metadataFilter = this.config.metadataFilter
        const childOf = extract(this.tracer, metadata)
        const method = getMethodMetadata(name, type)
        const span = this.startSpan(this.operationName(), {
          childOf,
          service: this.config.service || this.serviceName(),
          resource: name,
          kind: 'server',
          type: 'web',
          meta: {
            component: 'grpc',
            'grpc.method.kind': method.kind,
            'grpc.method.path': method.path,
            'grpc.method.name': method.name,
            'grpc.method.service': method.service,
            'grpc.method.package': method.package,
          },
          metrics: {
            'grpc.status.code': 0,
          },
        })
        addMetadataTags(span, metadata, metadataFilter, 'request')
        message.span = span
        message.parentStore = store
        message.currentStore = { ...store, span }
        return message.currentStore
      }
      bindAsyncStart({ parentStore }) {
        return parentStore
      }
      error({ error }) {
        const span = this.activeSpan
        if (!span) return
        this.addCode(span, error.code)
        if (error.code && !this._tracerConfig.grpc.server.error.statuses.includes(error.code)) {
          return
        }
        this.addError(error)
      }
      finish({ span, code, trailer }) {
        if (!span) return
        const metadataFilter = this.config.metadataFilter
        this.addCode(span, code)
        if (trailer && metadataFilter) {
          addMetadataTags(span, trailer, metadataFilter, 'response')
        }
        span.finish()
      }
      configure(config) {
        const metadataFilter = getFilter(config, 'metadata')
        return super.configure({ ...config, metadataFilter })
      }
      addCode(span, code) {
        if (code !== void 0) {
          span.setTag('grpc.status.code', code)
        }
      }
    }
    function extract(tracer2, metadata) {
      if (!metadata || typeof metadata.getMap !== 'function') return null
      return tracer2.extract(TEXT_MAP, metadata.getMap())
    }
    module2.exports = GrpcServerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js
var require_client7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var ClientPlugin = require_client5()
    var { TEXT_MAP } = require_formats()
    var { addMetadataTags, getFilter, getMethodMetadata } = require_util7()
    var GrpcClientPlugin = class extends ClientPlugin {
      static id = 'grpc'
      static operation = 'client:request'
      static prefix = 'apm:grpc:client:request'
      static peerServicePrecursors = ['rpc.service']
      constructor(...args) {
        super(...args)
        this.addTraceBind('emit', ({ parentStore }) => {
          return parentStore
        })
      }
      bindStart(message) {
        const store = storage('legacy').getStore()
        const { metadata, path, type } = message
        const metadataFilter = this.config.metadataFilter
        const method = getMethodMetadata(path, type)
        const span = this.startSpan(
          this.operationName(),
          {
            service: this.config.service || this.serviceName(),
            resource: path,
            kind: 'client',
            type: 'http',
            meta: {
              component: 'grpc',
              'grpc.method.kind': method.kind,
              'grpc.method.path': method.path,
              'grpc.method.name': method.name,
              'grpc.method.service': method.service,
              'grpc.method.package': method.package,
            },
            metrics: {
              'grpc.status.code': 0,
            },
          },
          false
        )
        if (method.service && method.package) {
          span.setTag('rpc.service', method.package + '.' + method.service)
        }
        if (metadata) {
          addMetadataTags(span, metadata, metadataFilter, 'request')
          inject(this.tracer, span, metadata)
        }
        message.span = span
        message.parentStore = store
        message.currentStore = { ...store, span }
        return message.currentStore
      }
      bindAsyncStart({ parentStore }) {
        return parentStore
      }
      error({ span = this.activeSpan, error }) {
        this.addCode(span, error.code)
        if (error.code && !this._tracerConfig.grpc.client.error.statuses.includes(error.code)) {
          return
        }
        this.addError(error, span)
      }
      finish({ span, result, peer }) {
        if (!span) return
        const { code, metadata } = result || {}
        const metadataFilter = this.config.metadataFilter
        this.addCode(span, code)
        if (metadata && metadataFilter) {
          addMetadataTags(span, metadata, metadataFilter, 'response')
        }
        if (peer) {
          const parts = peer.split(':')
          if (/^\d+/.test(parts.at(-1))) {
            const port = parts.at(-1)
            const ip = parts.slice(0, -1).join(':')
            span.setTag('network.destination.ip', ip)
            span.setTag('network.destination.port', port)
          } else {
            span.setTag('network.destination.ip', peer)
          }
        }
        this.tagPeerService(span)
        span.finish()
      }
      configure(config) {
        const metadataFilter = getFilter(config, 'metadata')
        return super.configure({ ...config, metadataFilter })
      }
      addCode(span, code) {
        if (code !== void 0 && span) {
          span.setTag('grpc.status.code', code)
        }
      }
    }
    function inject(tracer2, span, metadata) {
      if (typeof metadata.set !== 'function') return
      const carrier = {}
      tracer2.inject(span, TEXT_MAP, carrier)
      for (const key in carrier) {
        metadata.set(key, carrier[key])
      }
    }
    module2.exports = GrpcClientPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js
var require_src13 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js'(exports2, module2) {
    'use strict'
    var GrpcServerPlugin = require_server6()
    var GrpcClientPlugin = require_client7()
    var CompositePlugin = require_composite()
    var GrpcPlugin = class extends CompositePlugin {
      static id = 'grpc'
      static get plugins() {
        return {
          server: GrpcServerPlugin,
          client: GrpcClientPlugin,
        }
      }
    }
    module2.exports = GrpcPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-web/src/index.js
var require_src14 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-web/src/index.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var web = require_web3()
    var WebPlugin = class extends Plugin {
      static id = 'web'
      configure(config) {
        return super.configure(web.normalizeConfig(config))
      }
      setFramework(req, name, config) {
        web.setFramework(req, name, config)
      }
    }
    module2.exports = WebPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-router/src/index.js
var require_src15 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-router/src/index.js'(exports2, module2) {
    'use strict'
    var web = require_web3()
    var WebPlugin = require_src14()
    var analyticsSampler = require_analytics_sampler()
    var { storage } = require_datadog_core()
    var { COMPONENT } = require_constants2()
    var RouterPlugin = class extends WebPlugin {
      static id = 'router'
      constructor(...args) {
        super(...args)
        this._storeStack = []
        this._contexts = /* @__PURE__ */ new WeakMap()
        this.addSub(`apm:${this.constructor.id}:middleware:enter`, ({ req, name, route }) => {
          const childOf = this._getActive(req) || this._getStoreSpan()
          if (!childOf) return
          const span = this._getMiddlewareSpan(name, childOf)
          const context = this._createContext(req, route, childOf)
          if (childOf !== span) {
            context.middleware.push(span)
          }
          const store = storage('legacy').getStore()
          this._storeStack.push(store)
          this.enter(span, store)
          web.patch(req)
          web.setRoute(req, context.route)
        })
        this.addSub(`apm:${this.constructor.id}:middleware:next`, ({ req }) => {
          const context = this._contexts.get(req)
          if (!context) return
          context.stack.pop()
        })
        this.addSub(`apm:${this.constructor.id}:middleware:finish`, ({ req }) => {
          const context = this._contexts.get(req)
          if (!context || context.middleware.length === 0) return
          context.middleware.pop().finish()
        })
        this.addSub(`apm:${this.constructor.id}:middleware:exit`, ({ req }) => {
          const savedStore = this._storeStack.pop()
          const span = savedStore && savedStore.span
          this.enter(span, savedStore)
        })
        this.addSub(`apm:${this.constructor.id}:middleware:error`, ({ req, error }) => {
          web.addError(req, error)
          if (!this.config.middleware) return
          const span = this._getActive(req)
          if (!span) return
          span.setTag('error', error)
        })
        this.addSub('apm:http:server:request:finish', ({ req }) => {
          const context = this._contexts.get(req)
          if (!context) return
          let span
          while ((span = context.middleware.pop())) {
            span.finish()
          }
        })
      }
      _getActive(req) {
        const context = this._contexts.get(req)
        if (!context) return
        if (context.middleware.length === 0) return context.span
        return context.middleware.at(-1)
      }
      _getStoreSpan() {
        const store = storage('legacy').getStore()
        return store && store.span
      }
      _getMiddlewareSpan(name, childOf) {
        if (this.config.middleware === false) {
          return childOf
        }
        const span = this.tracer.startSpan(`${this.constructor.id}.middleware`, {
          childOf,
          integrationName: this.constructor.id,
          tags: {
            [COMPONENT]: this.constructor.id,
            'resource.name': name || '<anonymous>',
          },
        })
        analyticsSampler.sample(span, this.config.measured)
        return span
      }
      _createContext(req, route, span) {
        let context = this._contexts.get(req)
        if (!route || route === '/' || route === '*') {
          route = ''
        }
        if (context) {
          context.stack.push(route)
          route = context.stack.join('')
          if (isMoreSpecificThan(route, context.route)) {
            context.route = route
          }
        } else {
          context = {
            span,
            stack: [route],
            route,
            middleware: [],
          }
          this._contexts.set(req, context)
        }
        return context
      }
    }
    function isMoreSpecificThan(routeA, routeB) {
      if (!routeIsRegex(routeA) && routeIsRegex(routeB)) {
        return true
      }
      return routeA.length > routeB.length
    }
    function routeIsRegex(route) {
      return route.includes('(/')
    }
    module2.exports = RouterPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js
var require_src16 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var RouterPlugin = require_src15()
    var web = require_web3()
    var HapiPlugin = class extends RouterPlugin {
      static id = 'hapi'
      constructor(...args) {
        super(...args)
        this._requestSpans = /* @__PURE__ */ new WeakMap()
        this.addSub('apm:hapi:request:handle', ({ req }) => {
          const store = storage('legacy').getStore()
          const span = store && store.span
          this.setFramework(req, 'hapi', this.config)
          this._requestSpans.set(req, span)
        })
        this.addSub('apm:hapi:request:route', ({ req, route }) => {
          web.setRoute(req, route)
        })
        this.addSub('apm:hapi:request:error', (error) => {
          if (!error || !error.isBoom || !this.config.validateStatus(error.output.statusCode)) {
            this.addError(error)
          }
        })
        this.addBind('apm:hapi:extension:start', ({ req }) => {
          return this._requestSpans.get(req)
        })
      }
    }
    module2.exports = HapiPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js
var require_src17 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js'(exports2, module2) {
    'use strict'
    var CiPlugin = require_ci_plugin()
    var { storage } = require_datadog_core()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      TEST_STATUS,
      JEST_TEST_RUNNER,
      finishAllTraceSpans,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags,
      TEST_PARAMETERS,
      TEST_COMMAND,
      TEST_FRAMEWORK_VERSION,
      TEST_SOURCE_START,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      TEST_CODE_OWNERS,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      JEST_DISPLAY_NAME,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      getFormattedError,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED,
    } = require_test()
    var { COMPONENT } = require_constants2()
    var id = require_id()
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TELEMETRY_TEST_SESSION,
    } = require_telemetry()
    var log = require_log2()
    var isJestWorker = !!getEnvironmentVariable('JEST_WORKER_ID')
    var CHILD_MESSAGE_END = 2
    function withTimeout(promise, timeoutMs) {
      return new Promise((resolve) => {
        setTimeout(resolve, timeoutMs)
        promise.then(resolve)
      })
    }
    var JestPlugin = class extends CiPlugin {
      static id = 'jest'
      // The lists are the same for every test suite, so we can cache them
      getUnskippableSuites(unskippableSuitesList) {
        if (!this.unskippableSuites) {
          this.unskippableSuites = JSON.parse(unskippableSuitesList)
        }
        return this.unskippableSuites
      }
      getForcedToRunSuites(forcedToRunSuitesList) {
        if (!this.forcedToRunSuites) {
          this.forcedToRunSuites = JSON.parse(forcedToRunSuitesList)
        }
        return this.forcedToRunSuites
      }
      constructor(...args) {
        super(...args)
        if (isJestWorker) {
          const handler = ([message]) => {
            if (message === CHILD_MESSAGE_END) {
              if (this.testSuiteSpan) {
                this.testSuiteSpan.finish()
                finishAllTraceSpans(this.testSuiteSpan)
              }
              this.tracer._exporter.flush()
              process.removeListener('message', handler)
            }
          }
          process.on('message', handler)
        }
        this.testSuiteSpanPerTestSuiteAbsolutePath = /* @__PURE__ */ new Map()
        this.addSub(
          'ci:jest:session:finish',
          ({
            status,
            isSuitesSkipped,
            isSuitesSkippingEnabled,
            isCodeCoverageEnabled,
            testCodeCoverageLinesTotal,
            numSkippedSuites,
            hasUnskippableSuites,
            hasForcedToRunSuites,
            error,
            isEarlyFlakeDetectionEnabled,
            isEarlyFlakeDetectionFaulty,
            isTestManagementTestsEnabled,
            onDone,
          }) => {
            this.testSessionSpan.setTag(TEST_STATUS, status)
            this.testModuleSpan.setTag(TEST_STATUS, status)
            if (error) {
              this.testSessionSpan.setTag('error', error)
              this.testModuleSpan.setTag('error', error)
            }
            addIntelligentTestRunnerSpanTags(this.testSessionSpan, this.testModuleSpan, {
              isSuitesSkipped,
              isSuitesSkippingEnabled,
              isCodeCoverageEnabled,
              testCodeCoverageLinesTotal,
              skippingType: 'suite',
              skippingCount: numSkippedSuites,
              hasUnskippableSuites,
              hasForcedToRunSuites,
            })
            if (isEarlyFlakeDetectionEnabled) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, 'true')
            }
            if (isEarlyFlakeDetectionFaulty) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, 'faulty')
            }
            if (isTestManagementTestsEnabled) {
              this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, 'true')
            }
            this.testModuleSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'module')
            this.testSessionSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'session')
            finishAllTraceSpans(this.testSessionSpan)
            this.telemetry.count(TELEMETRY_TEST_SESSION, {
              provider: this.ciProviderName,
              autoInjected: !!getEnvironmentVariable('DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER'),
            })
            this.tracer._exporter.flush(() => {
              if (onDone) {
                onDone()
              }
            })
          }
        )
        this.addSub('ci:jest:session:configuration', (configs) => {
          configs.forEach((config) => {
            config._ddTestSessionId = this.testSessionSpan.context().toTraceId()
            config._ddTestModuleId = this.testModuleSpan.context().toSpanId()
            config._ddTestCommand = this.testSessionSpan.context()._tags[TEST_COMMAND]
            config._ddItrCorrelationId = this.itrCorrelationId
            config._ddIsEarlyFlakeDetectionEnabled = !!this.libraryConfig?.isEarlyFlakeDetectionEnabled
            config._ddEarlyFlakeDetectionNumRetries = this.libraryConfig?.earlyFlakeDetectionNumRetries ?? 0
            config._ddRepositoryRoot = this.repositoryRoot
            config._ddIsFlakyTestRetriesEnabled = this.libraryConfig?.isFlakyTestRetriesEnabled ?? false
            config._ddIsTestManagementTestsEnabled = this.libraryConfig?.isTestManagementEnabled ?? false
            config._ddTestManagementAttemptToFixRetries = this.libraryConfig?.testManagementAttemptToFixRetries ?? 0
            config._ddFlakyTestRetriesCount = this.libraryConfig?.flakyTestRetriesCount
            config._ddIsDiEnabled = this.libraryConfig?.isDiEnabled ?? false
            config._ddIsKnownTestsEnabled = this.libraryConfig?.isKnownTestsEnabled ?? false
            config._ddIsImpactedTestsEnabled = this.libraryConfig?.isImpactedTestsEnabled ?? false
          })
        })
        this.addSub(
          'ci:jest:test-suite:start',
          ({
            testSuite,
            testSourceFile,
            testEnvironmentOptions,
            frameworkVersion,
            displayName,
            testSuiteAbsolutePath,
          }) => {
            const {
              _ddTestSessionId: testSessionId,
              _ddTestCommand: testCommand,
              _ddTestModuleId: testModuleId,
              _ddItrCorrelationId: itrCorrelationId,
              _ddForcedToRun,
              _ddUnskippable,
              _ddTestCodeCoverageEnabled,
            } = testEnvironmentOptions
            const testSessionSpanContext = this.tracer.extract('text_map', {
              'x-datadog-trace-id': testSessionId,
              'x-datadog-parent-id': testModuleId,
            })
            const testSuiteMetadata = getTestSuiteCommonTags(testCommand, frameworkVersion, testSuite, 'jest')
            if (_ddUnskippable) {
              const unskippableSuites = this.getUnskippableSuites(_ddUnskippable)
              if (unskippableSuites[testSuite]) {
                this.telemetry.count(TELEMETRY_ITR_UNSKIPPABLE, { testLevel: 'suite' })
                testSuiteMetadata[TEST_ITR_UNSKIPPABLE] = 'true'
              }
              if (_ddForcedToRun) {
                const forcedToRunSuites = this.getForcedToRunSuites(_ddForcedToRun)
                if (forcedToRunSuites[testSuite]) {
                  this.telemetry.count(TELEMETRY_ITR_FORCED_TO_RUN, { testLevel: 'suite' })
                  testSuiteMetadata[TEST_ITR_FORCED_RUN] = 'true'
                }
              }
            }
            if (itrCorrelationId) {
              testSuiteMetadata[ITR_CORRELATION_ID] = itrCorrelationId
            }
            if (displayName) {
              testSuiteMetadata[JEST_DISPLAY_NAME] = displayName
            }
            if (testSourceFile) {
              testSuiteMetadata[TEST_SOURCE_FILE] = testSourceFile
              testSuiteMetadata[TEST_SOURCE_START] = 1
            }
            const codeOwners = this.getCodeOwners(testSuiteMetadata)
            if (codeOwners) {
              testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners
            }
            this.testSuiteSpan = this.tracer.startSpan('jest.test_suite', {
              childOf: testSessionSpanContext,
              tags: {
                [COMPONENT]: this.constructor.id,
                ...this.testEnvironmentMetadata,
                ...testSuiteMetadata,
              },
              integrationName: this.constructor.id,
            })
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'suite')
            if (_ddTestCodeCoverageEnabled) {
              this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_STARTED, 'suite', { library: 'istanbul' })
            }
            this.testSuiteSpanPerTestSuiteAbsolutePath.set(testSuiteAbsolutePath, this.testSuiteSpan)
          }
        )
        this.addSub('ci:jest:worker-report:coverage', (data) => {
          const formattedCoverages = JSON.parse(data).map((coverage) => ({
            sessionId: id(coverage.sessionId),
            suiteId: id(coverage.suiteId),
            files: coverage.files,
          }))
          formattedCoverages.forEach((formattedCoverage) => {
            this.tracer._exporter.exportCoverage(formattedCoverage)
          })
        })
        this.addSub('ci:jest:test-suite:finish', ({ status, errorMessage, error, testSuiteAbsolutePath }) => {
          const testSuiteSpan = this.testSuiteSpanPerTestSuiteAbsolutePath.get(testSuiteAbsolutePath)
          if (!testSuiteSpan) {
            log.warn(
              '"ci:jest:test-suite:finish": no span found for test suite absolute path %s',
              testSuiteAbsolutePath
            )
            return
          }
          testSuiteSpan.setTag(TEST_STATUS, status)
          if (error) {
            testSuiteSpan.setTag('error', error)
            testSuiteSpan.setTag(TEST_STATUS, 'fail')
          } else if (errorMessage) {
            testSuiteSpan.setTag('error', new Error(errorMessage))
            testSuiteSpan.setTag(TEST_STATUS, 'fail')
          }
          process.nextTick(() => {
            testSuiteSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'suite')
            finishAllTraceSpans(testSuiteSpan)
            if (isJestWorker) {
              this.tracer._exporter.flush()
            }
            this.removeAllDiProbes()
            this.testSuiteSpanPerTestSuiteAbsolutePath.delete(testSuiteAbsolutePath)
          })
        })
        this.addSub('ci:jest:test-suite:error', ({ error, errorMessage, testSuiteAbsolutePath }) => {
          const runningTestSuiteSpan = this.testSuiteSpanPerTestSuiteAbsolutePath.get(testSuiteAbsolutePath)
          if (!runningTestSuiteSpan) {
            log.warn('"ci:jest:test-suite:error": no span found for test suite absolute path %s', testSuiteAbsolutePath)
            return
          }
          if (error) {
            runningTestSuiteSpan.setTag('error', error)
          } else if (errorMessage) {
            runningTestSuiteSpan.setTag('error', new Error(errorMessage))
          }
        })
        this.addSub('ci:jest:test-suite:code-coverage', ({ coverageFiles, testSuite, mockedFiles }) => {
          if (!coverageFiles.length) {
            this.telemetry.count(TELEMETRY_CODE_COVERAGE_EMPTY)
          }
          const files = [...coverageFiles, ...mockedFiles, testSuite]
          const { _traceId, _spanId } = this.testSuiteSpan.context()
          const formattedCoverage = {
            sessionId: _traceId,
            suiteId: _spanId,
            files,
          }
          this.tracer._exporter.exportCoverage(formattedCoverage)
          this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_FINISHED, 'suite', { library: 'istanbul' })
          this.telemetry.distribution(TELEMETRY_CODE_COVERAGE_NUM_FILES, {}, files.length)
        })
        this.addBind('ci:jest:test:start', (ctx) => {
          const store = storage('legacy').getStore()
          const span = this.startTestSpan(ctx)
          ctx.parentStore = store
          ctx.currentStore = { ...store, span }
          this.activeTestSpan = span
          return ctx.currentStore
        })
        this.addBind('ci:jest:test:fn', (ctx) => {
          return ctx.currentStore
        })
        this.addSub(
          'ci:jest:test:finish',
          ({ span, status, testStartLine, attemptToFixPassed, failedAllTests, attemptToFixFailed, isAtrRetry }) => {
            span.setTag(TEST_STATUS, status)
            if (testStartLine) {
              span.setTag(TEST_SOURCE_START, testStartLine)
            }
            if (attemptToFixPassed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'true')
            } else if (attemptToFixFailed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'false')
            }
            if (failedAllTests) {
              span.setTag(TEST_HAS_FAILED_ALL_RETRIES, 'true')
            }
            if (isAtrRetry) {
              span.setTag(TEST_IS_RETRY, 'true')
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr)
            }
            const spanTags = span.context()._tags
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
              hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
              isNew: spanTags[TEST_IS_NEW] === 'true',
              isRum: spanTags[TEST_IS_RUM_ACTIVE] === 'true',
              browserDriver: spanTags[TEST_BROWSER_DRIVER],
            })
            span.finish()
            finishAllTraceSpans(span)
            this.activeTestSpan = null
          }
        )
        this.addSub('ci:jest:test:err', ({ span, error, shouldSetProbe, promises }) => {
          if (error && span) {
            span.setTag(TEST_STATUS, 'fail')
            span.setTag('error', getFormattedError(error, this.repositoryRoot))
            if (shouldSetProbe) {
              const probeInformation = this.addDiProbe(error)
              if (probeInformation) {
                const { setProbePromise } = probeInformation
                promises.isProbeReady = withTimeout(setProbePromise, 2e3)
              }
            }
          }
        })
        this.addSub('ci:jest:test:skip', ({ test, isDisabled }) => {
          const span = this.startTestSpan(test)
          span.setTag(TEST_STATUS, 'skip')
          if (isDisabled) {
            span.setTag(TEST_MANAGEMENT_IS_DISABLED, 'true')
          }
          span.finish()
        })
      }
      startTestSpan(test) {
        const {
          suite,
          name,
          displayName,
          testParameters,
          frameworkVersion,
          testStartLine,
          testSourceFile,
          isNew,
          isEfdRetry,
          isAttemptToFix,
          isAttemptToFixRetry,
          isJestRetry,
          isDisabled,
          isQuarantined,
          isModified,
          testSuiteAbsolutePath,
        } = test
        const extraTags = {
          [JEST_TEST_RUNNER]: 'jest-circus',
          [TEST_PARAMETERS]: testParameters,
          [TEST_FRAMEWORK_VERSION]: frameworkVersion,
        }
        if (testStartLine) {
          extraTags[TEST_SOURCE_START] = testStartLine
        }
        extraTags[TEST_SOURCE_FILE] = testSourceFile || suite
        if (displayName) {
          extraTags[JEST_DISPLAY_NAME] = displayName
        }
        if (isAttemptToFix) {
          extraTags[TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX] = 'true'
        }
        if (isAttemptToFixRetry) {
          extraTags[TEST_IS_RETRY] = 'true'
          extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.atf
        } else if (isEfdRetry) {
          extraTags[TEST_IS_RETRY] = 'true'
          extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd
        } else if (isJestRetry) {
          extraTags[TEST_IS_RETRY] = 'true'
          extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.ext
        }
        if (isDisabled) {
          extraTags[TEST_MANAGEMENT_IS_DISABLED] = 'true'
        }
        if (isQuarantined) {
          extraTags[TEST_MANAGEMENT_IS_QUARANTINED] = 'true'
        }
        if (isModified) {
          extraTags[TEST_IS_MODIFIED] = 'true'
        }
        if (isNew) {
          extraTags[TEST_IS_NEW] = 'true'
        }
        const testSuiteSpan =
          this.testSuiteSpanPerTestSuiteAbsolutePath.get(testSuiteAbsolutePath) || this.testSuiteSpan
        return super.startTestSpan(name, suite, testSuiteSpan, extraTags)
      }
    }
    module2.exports = JestPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js
var require_src18 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js'(exports2, module2) {
    'use strict'
    var RouterPlugin = require_src15()
    var web = require_web3()
    var KoaPlugin = class extends RouterPlugin {
      static id = 'koa'
      constructor(...args) {
        super(...args)
        this.addSub('apm:koa:request:handle', ({ req }) => {
          this.setFramework(req, 'koa', this.config)
        })
        this.addSub('apm:koa:request:route', ({ req, route }) => {
          web.setRoute(req, route)
        })
      }
    }
    module2.exports = KoaPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-langchain/src/handlers/default.js
var require_default2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-langchain/src/handlers/default.js'(exports2, module2) {
    'use strict'
    var LangChainHandler = class {
      // no-op for default handler
      extractProvider(instance) {}
      // no-op for default handler
      extractModel(instance) {}
    }
    module2.exports = LangChainHandler
  },
})

// node_modules/dd-trace/packages/datadog-plugin-langchain/src/handlers/language_models.js
var require_language_models = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-langchain/src/handlers/language_models.js'(exports2, module2) {
    'use strict'
    var LangChainHandler = require_default2()
    var LangChainLanguageModelHandler = class extends LangChainHandler {
      extractProvider(instance) {
        return typeof instance._llmType === 'function' && instance._llmType().split('-')[0]
      }
      extractModel(instance) {
        for (const attr of ['model', 'modelName', 'modelId', 'modelKey', 'repoId']) {
          const modelName = instance[attr]
          if (modelName) return modelName
        }
      }
    }
    module2.exports = LangChainLanguageModelHandler
  },
})

// node_modules/dd-trace/packages/datadog-plugin-langchain/src/handlers/embedding.js
var require_embedding = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-langchain/src/handlers/embedding.js'(exports2, module2) {
    'use strict'
    var LangChainHandler = require_default2()
    var LangChainEmbeddingHandler = class extends LangChainHandler {
      extractProvider(instance) {
        return instance.constructor.name.split('Embeddings')[0].toLowerCase()
      }
      extractModel(instance) {
        for (const attr of ['model', 'modelName', 'modelId', 'modelKey', 'repoId']) {
          const modelName = instance[attr]
          if (modelName) return modelName
        }
      }
    }
    module2.exports = LangChainEmbeddingHandler
  },
})

// node_modules/dd-trace/packages/datadog-plugin-langchain/src/tracing.js
var require_tracing6 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-langchain/src/tracing.js'(exports2, module2) {
    'use strict'
    var { MEASURED } = require_tags()
    var { storage } = require_datadog_core()
    var TracingPlugin = require_tracing()
    var MODEL = 'langchain.request.model'
    var PROVIDER = 'langchain.request.provider'
    var TYPE = 'langchain.request.type'
    var LangChainHandler = require_default2()
    var LangChainLanguageModelHandler = require_language_models()
    var LangChainEmbeddingHandler = require_embedding()
    var defaultNs = ['langchain', 'embeddings']
    var BaseLangChainTracingPlugin = class extends TracingPlugin {
      static id = 'langchain'
      static operation = 'invoke'
      static system = 'langchain'
      constructor() {
        super(...arguments)
        this.handlers = {
          chain: new LangChainHandler(this._tracerConfig),
          chat_model: new LangChainLanguageModelHandler(this._tracerConfig),
          llm: new LangChainLanguageModelHandler(this._tracerConfig),
          embedding: new LangChainEmbeddingHandler(this._tracerConfig),
          default: new LangChainHandler(this._tracerConfig),
        }
      }
      bindStart(ctx) {
        ctx.args = ctx.arguments
        ctx.instance = ctx.self
        const type = (ctx.type = this.constructor.lcType)
        const ns =
          ctx.self.lc_namespace ||
          (ctx.self.constructor.name === 'OpenAIEmbeddings' ? [...defaultNs, 'openai'] : defaultNs)
        const resourceParts = [...ns, ctx.self.constructor.name]
        if (type === 'tool') {
          resourceParts.push(ctx.instance.name)
        }
        const resource = (ctx.resource = resourceParts.join('.'))
        const handler = this.handlers[type] || this.handlers.default
        const instance = ctx.instance
        const provider = handler.extractProvider(instance)
        const model = handler.extractModel(instance)
        const span = this.startSpan(
          'langchain.request',
          {
            service: this.config.service,
            resource,
            kind: 'client',
            meta: {
              [MEASURED]: 1,
            },
          },
          false
        )
        const tags = {}
        if (provider) tags[PROVIDER] = provider
        if (model) tags[MODEL] = model
        if (type) tags[TYPE] = type
        span.addTags(tags)
        const store = storage('legacy').getStore() || {}
        ctx.currentStore = { ...store, span }
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore.span
        span.finish()
      }
      getHandler(type) {
        return this.handlers[type] || this.handlers.default
      }
    }
    var RunnableSequenceInvokePlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_rs_invoke'
      static lcType = 'chain'
      static prefix = 'tracing:orchestrion:@langchain/core:RunnableSequence_invoke'
    }
    var RunnableSequenceBatchPlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_rs_batch'
      static lcType = 'chain'
      static prefix = 'tracing:orchestrion:@langchain/core:RunnableSequence_batch'
    }
    var BaseChatModelGeneratePlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_chat_model_generate'
      static lcType = 'chat_model'
      static prefix = 'tracing:orchestrion:@langchain/core:BaseChatModel_generate'
    }
    var BaseLLMGeneratePlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_llm_generate'
      static lcType = 'llm'
      static prefix = 'tracing:orchestrion:@langchain/core:BaseLLM_generate'
    }
    var EmbeddingsEmbedQueryPlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_embeddings_embed_query'
      static lcType = 'embedding'
      static prefix = 'tracing:orchestrion:@langchain/core:Embeddings_embedQuery'
    }
    var EmbeddingsEmbedDocumentsPlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_embeddings_embed_documents'
      static lcType = 'embedding'
      static prefix = 'tracing:orchestrion:@langchain/core:Embeddings_embedDocuments'
    }
    var ToolInvokePlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_tool_invoke'
      static lcType = 'tool'
      static prefix = 'tracing:orchestrion:@langchain/core:Tool_invoke'
    }
    var VectorStoreSimilaritySearchPlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_vectorstore_similarity_search'
      static lcType = 'similarity_search'
      static prefix = 'tracing:orchestrion:@langchain/core:VectorStore_similaritySearch'
    }
    var VectorStoreSimilaritySearchWithScorePlugin = class extends BaseLangChainTracingPlugin {
      static id = 'langchain_vectorstore_similarity_search_with_score'
      static lcType = 'similarity_search'
      static prefix = 'tracing:orchestrion:@langchain/core:VectorStore_similaritySearchWithScore'
    }
    module2.exports = [
      RunnableSequenceInvokePlugin,
      RunnableSequenceBatchPlugin,
      BaseChatModelGeneratePlugin,
      BaseLLMGeneratePlugin,
      EmbeddingsEmbedQueryPlugin,
      EmbeddingsEmbedDocumentsPlugin,
      ToolInvokePlugin,
      VectorStoreSimilaritySearchPlugin,
      VectorStoreSimilaritySearchWithScorePlugin,
    ]
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/index.js
var require_handlers = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/index.js'(exports2, module2) {
    'use strict'
    var ROLE_MAPPINGS = {
      human: 'user',
      ai: 'assistant',
      system: 'system',
    }
    var LangChainLLMObsHandler = class {
      constructor(tagger) {
        this._tagger = tagger
      }
      getName({ span }) {
        return span?.context()._tags?.['resource.name']
      }
      setMetaTags() {}
      formatIO(messages) {
        if (messages.constructor.name === 'Object') {
          const formatted = {}
          for (const [key, value] of Object.entries(messages)) {
            formatted[key] = this.formatIO(value)
          }
          return formatted
        } else if (Array.isArray(messages)) {
          return messages.map((message) => this.formatIO(message))
        }
        return this.getContentFromMessage(messages)
      }
      getContentFromMessage(message) {
        if (typeof message === 'string') {
          return message
        }
        try {
          const messageContent = {
            content: message.content || '',
          }
          const role = this.getRole(message)
          if (role) messageContent.role = role
          return messageContent
        } catch {
          return JSON.stringify(message)
        }
      }
      checkTokenUsageChatOrLLMResult(results) {
        const llmOutput = results.llmOutput
        const tokens = {
          inputTokens: 0,
          outputTokens: 0,
          totalTokens: 0,
        }
        if (!llmOutput) return tokens
        const tokenUsage = llmOutput.tokenUsage || llmOutput.usageMetadata || llmOutput.usage || {}
        if (!tokenUsage) return tokens
        tokens.inputTokens = tokenUsage.promptTokens || tokenUsage.inputTokens || 0
        tokens.outputTokens = tokenUsage.completionTokens || tokenUsage.outputTokens || 0
        tokens.totalTokens = tokenUsage.totalTokens || tokens.inputTokens + tokens.outputTokens
        return tokens
      }
      checkTokenUsageFromAIMessage(message) {
        let usage = message.usage_metadata || message.additional_kwargs?.usage
        const runId = message.run_id || message.id || ''
        const runIdBase = runId ? runId.split('-').slice(0, -1).join('-') : ''
        const responseMetadata = message.response_metadata || {}
        usage = usage || responseMetadata.usage || responseMetadata.tokenUsage || {}
        const inputTokens = usage.promptTokens || usage.inputTokens || usage.prompt_tokens || usage.input_tokens || 0
        const outputTokens =
          usage.completionTokens || usage.outputTokens || usage.completion_tokens || usage.output_tokens || 0
        const totalTokens = usage.totalTokens || inputTokens + outputTokens
        return {
          tokens: {
            inputTokens,
            outputTokens,
            totalTokens,
          },
          runId: runIdBase,
        }
      }
      getRole(message) {
        if (message.role) return ROLE_MAPPINGS[message.role] || message.role
        const type =
          (typeof message.getType === 'function' && message.getType()) ||
          (typeof message._getType === 'function' && message._getType())
        return ROLE_MAPPINGS[type] || type
      }
    }
    module2.exports = LangChainLLMObsHandler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/util.js
var require_util8 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/util.js'(exports2, module2) {
    'use strict'
    var { SPAN_KINDS } = require_tags3()
    function encodeUnicode(str = '') {
      let result = ''
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i)
        result += code > 127 ? String.raw`\u${code.toString(16).padStart(4, '0')}` : str[i]
      }
      return result
    }
    function validateKind(kind) {
      if (!SPAN_KINDS.includes(kind)) {
        throw new Error(`
      Invalid span kind specified: "${kind}"
      Must be one of: ${SPAN_KINDS.join(', ')}
    `)
      }
      return kind
    }
    function parseArgumentNames(str) {
      const result = []
      let current = ''
      let closerCount = 0
      let recording = true
      let inSingleLineComment = false
      let inMultiLineComment = false
      for (let i = 0; i < str.length; i++) {
        const char = str[i]
        const nextChar = str[i + 1]
        if (!inMultiLineComment && char === '/' && nextChar === '/') {
          inSingleLineComment = true
          i++
          continue
        }
        if (!inSingleLineComment && char === '/' && nextChar === '*') {
          inMultiLineComment = true
          i++
          continue
        }
        if (inSingleLineComment && char === '\n') {
          inSingleLineComment = false
          continue
        }
        if (inMultiLineComment && char === '*' && nextChar === '/') {
          inMultiLineComment = false
          i++
          continue
        }
        if (inSingleLineComment || inMultiLineComment) {
          continue
        }
        if (['{', '[', '('].includes(char)) {
          closerCount++
        } else if (['}', ']', ')'].includes(char)) {
          closerCount--
        } else if (char === '=' && nextChar !== '>' && closerCount === 0) {
          recording = false
          result.push(current.trim())
          current = ''
          continue
        } else if (char === ',' && closerCount === 0) {
          if (recording) {
            result.push(current.trim())
            current = ''
          }
          recording = true
          continue
        }
        if (recording) {
          current += char
        }
      }
      if (current && recording) {
        result.push(current.trim())
      }
      return result
    }
    function findArgumentsBounds(str) {
      let start = -1
      let end = -1
      let closerCount = 0
      for (let i = 0; i < str.length; i++) {
        const char = str[i]
        if (char === '(') {
          if (closerCount === 0) {
            start = i
          }
          closerCount++
        } else if (char === ')') {
          closerCount--
          if (closerCount === 0) {
            end = i
            break
          }
        }
      }
      return { start, end }
    }
    var memo = /* @__PURE__ */ new WeakMap()
    function getFunctionArguments(fn, args = []) {
      if (!fn) return
      if (!args.length) return
      if (args.length === 1) return args[0]
      try {
        let names
        if (memo.has(fn)) {
          names = memo.get(fn)
        } else {
          const fnString = fn.toString()
          const { start, end } = findArgumentsBounds(fnString)
          names = parseArgumentNames(fnString.slice(start + 1, end))
          memo.set(fn, names)
        }
        const argsObject = {}
        for (const argIdx in args) {
          const name = names[argIdx]
          const arg = args[argIdx]
          const spread = name?.startsWith('...')
          if (spread) {
            argsObject[name.slice(3)] = args.slice(argIdx)
            break
          }
          argsObject[name] = arg
        }
        return argsObject
      } catch {
        return args
      }
    }
    function spanHasError(span) {
      const tags = span.context()._tags
      return !!(tags.error || tags['error.type'])
    }
    module2.exports = {
      encodeUnicode,
      validateKind,
      getFunctionArguments,
      spanHasError,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/chain.js
var require_chain = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/chain.js'(exports2, module2) {
    'use strict'
    var LangChainLLMObsHandler = require_handlers()
    var { spanHasError } = require_util8()
    var LangChainLLMObsChainHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        let input
        if (inputs) {
          input = this.formatIO(inputs)
        }
        const output = !results || spanHasError(span) ? '' : this.formatIO(results)
        this._tagger.tagTextIO(span, input, output)
      }
    }
    module2.exports = LangChainLLMObsChainHandler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/chat_model.js
var require_chat_model = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/chat_model.js'(exports2, module2) {
    'use strict'
    var LangChainLLMObsHandler = require_handlers()
    var LLMObsTagger = require_tagger2()
    var { spanHasError } = require_util8()
    var LLM = 'llm'
    var LangChainLLMObsChatModelHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results, options, integrationName }) {
        if (integrationName === 'openai' && options?.response_format) {
          this._tagger.changeKind(span, LLM)
        }
        const spanKind = LLMObsTagger.getSpanKind(span)
        const isWorkflow = spanKind === 'workflow'
        const inputMessages = []
        if (!Array.isArray(inputs)) inputs = [inputs]
        for (const messageSet of inputs) {
          for (const message of messageSet) {
            const content = message.content || ''
            const role = this.getRole(message)
            inputMessages.push({ content, role })
          }
        }
        if (spanHasError(span)) {
          if (isWorkflow) {
            this._tagger.tagTextIO(span, inputMessages, [{ content: '' }])
          } else {
            this._tagger.tagLLMIO(span, inputMessages, [{ content: '' }])
          }
          return
        }
        const outputMessages = []
        let inputTokens = 0
        let outputTokens = 0
        let totalTokens = 0
        let tokensSetTopLevel = false
        const tokensPerRunId = {}
        if (!isWorkflow) {
          const tokens = this.checkTokenUsageChatOrLLMResult(results)
          inputTokens = tokens.inputTokens
          outputTokens = tokens.outputTokens
          totalTokens = tokens.totalTokens
          tokensSetTopLevel = totalTokens > 0
        }
        for (const messageSet of results.generations) {
          for (const chatCompletion of messageSet) {
            const chatCompletionMessage = chatCompletion.message
            const role = this.getRole(chatCompletionMessage)
            const content = chatCompletionMessage.text || ''
            const toolCalls = this.extractToolCalls(chatCompletionMessage)
            outputMessages.push({ content, role, toolCalls })
            if (!isWorkflow && !tokensSetTopLevel) {
              const { tokens, runId } = this.checkTokenUsageFromAIMessage(chatCompletionMessage)
              if (tokensPerRunId[runId]) {
                tokensPerRunId[runId].inputTokens += tokens.inputTokens
                tokensPerRunId[runId].outputTokens += tokens.outputTokens
                tokensPerRunId[runId].totalTokens += tokens.totalTokens
              } else {
                tokensPerRunId[runId] = tokens
              }
            }
          }
        }
        if (!isWorkflow && !tokensSetTopLevel) {
          inputTokens = Object.values(tokensPerRunId).reduce((acc, val) => acc + val.inputTokens, 0)
          outputTokens = Object.values(tokensPerRunId).reduce((acc, val) => acc + val.outputTokens, 0)
          totalTokens = Object.values(tokensPerRunId).reduce((acc, val) => acc + val.totalTokens, 0)
        }
        if (isWorkflow) {
          this._tagger.tagTextIO(span, inputMessages, outputMessages)
        } else {
          this._tagger.tagLLMIO(span, inputMessages, outputMessages)
          this._tagger.tagMetrics(span, {
            inputTokens,
            outputTokens,
            totalTokens,
          })
        }
      }
      extractToolCalls(message) {
        let toolCalls = message.tool_calls
        if (!toolCalls) return []
        const toolCallsInfo = []
        if (!Array.isArray(toolCalls)) toolCalls = [toolCalls]
        for (const toolCall of toolCalls) {
          toolCallsInfo.push({
            name: toolCall.name || '',
            arguments: toolCall.args || {},
            tool_id: toolCall.id || '',
          })
        }
        return toolCallsInfo
      }
    }
    module2.exports = LangChainLLMObsChatModelHandler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/llm.js
var require_llm2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/llm.js'(exports2, module2) {
    'use strict'
    var LangChainLLMObsHandler = require_handlers()
    var LLMObsTagger = require_tagger2()
    var { spanHasError } = require_util8()
    var LangChainLLMObsLlmHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        const isWorkflow = LLMObsTagger.getSpanKind(span) === 'workflow'
        const prompts = Array.isArray(inputs) ? inputs : [inputs]
        let outputs
        if (spanHasError(span)) {
          outputs = [{ content: '' }]
        } else {
          outputs = results.generations.map((completion) => ({ content: completion[0].text }))
          if (!isWorkflow) {
            const tokens = this.checkTokenUsageChatOrLLMResult(results)
            this._tagger.tagMetrics(span, tokens)
          }
        }
        if (isWorkflow) {
          this._tagger.tagTextIO(span, prompts, outputs)
        } else {
          this._tagger.tagLLMIO(span, prompts, outputs)
        }
      }
    }
    module2.exports = LangChainLLMObsLlmHandler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/embedding.js
var require_embedding2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/embedding.js'(exports2, module2) {
    'use strict'
    var LangChainLLMObsHandler = require_handlers()
    var LLMObsTagger = require_tagger2()
    var { spanHasError } = require_util8()
    var LangChainLLMObsEmbeddingHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        const isWorkflow = LLMObsTagger.getSpanKind(span) === 'workflow'
        let embeddingInput, embeddingOutput
        if (isWorkflow) {
          embeddingInput = this.formatIO(inputs)
        } else {
          const input = Array.isArray(inputs) ? inputs : [inputs]
          embeddingInput = input.map((doc) => ({ text: doc }))
        }
        if (spanHasError(span) || !results) {
          embeddingOutput = ''
        } else {
          let embeddingDimensions, embeddingsCount
          if (typeof results[0] === 'number') {
            embeddingsCount = 1
            embeddingDimensions = results.length
          } else {
            embeddingsCount = results.length
            embeddingDimensions = results[0].length
          }
          embeddingOutput = `[${embeddingsCount} embedding(s) returned with size ${embeddingDimensions}]`
        }
        if (isWorkflow) {
          this._tagger.tagTextIO(span, embeddingInput, embeddingOutput)
        } else {
          this._tagger.tagEmbeddingIO(span, embeddingInput, embeddingOutput)
        }
      }
    }
    module2.exports = LangChainLLMObsEmbeddingHandler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/tool.js
var require_tool = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/tool.js'(exports2, module2) {
    'use strict'
    var LangChainLLMObsHandler = require_handlers()
    var LangChainLLMObsToolHandler = class extends LangChainLLMObsHandler {
      getName({ instance }) {
        return instance.name
      }
      setMetaTags({ span, inputs, results }) {
        this._tagger.tagTextIO(span, inputs, results)
      }
    }
    module2.exports = LangChainLLMObsToolHandler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/vectorstore.js
var require_vectorstore = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/handlers/vectorstore.js'(exports2, module2) {
    'use strict'
    var LangChainLLMObsHandler = require_handlers()
    var { spanHasError } = require_util8()
    var LangChainLLMObsVectorStoreHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        const input = this.formatIO(inputs)
        if (spanHasError(span)) {
          this._tagger.tagRetrievalIO(span, input)
          return
        }
        const documents = []
        for (const documentResult of results) {
          let document, score
          if (Array.isArray(documentResult)) {
            document = documentResult[0]
            score = documentResult[1]
          } else {
            document = documentResult
          }
          documents.push({
            text: document.pageContent,
            id: document.id,
            name: document.metadata?.source,
            score,
          })
        }
        this._tagger.tagRetrievalIO(span, input, documents)
      }
    }
    module2.exports = LangChainLLMObsVectorStoreHandler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/index.js
var require_langchain3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/langchain/index.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var LLMObsPlugin = require_base()
    var pluginManager = require_dd_trace2()._pluginManager
    var ANTHROPIC_PROVIDER_NAME = 'anthropic'
    var BEDROCK_PROVIDER_NAME = 'amazon_bedrock'
    var OPENAI_PROVIDER_NAME = 'openai'
    var SUPPORTED_INTEGRATIONS = /* @__PURE__ */ new Set(['openai'])
    var LLM_SPAN_TYPES = /* @__PURE__ */ new Set(['llm', 'chat_model', 'embedding'])
    var LLM = 'llm'
    var WORKFLOW = 'workflow'
    var EMBEDDING = 'embedding'
    var TOOL = 'tool'
    var RETRIEVAL = 'retrieval'
    var ChainHandler = require_chain()
    var ChatModelHandler = require_chat_model()
    var LlmHandler = require_llm2()
    var EmbeddingHandler = require_embedding2()
    var ToolHandler = require_tool()
    var VectorStoreHandler = require_vectorstore()
    var BaseLangChainLLMObsPlugin = class extends LLMObsPlugin {
      static integration = 'langchain'
      static id = 'langchain'
      static prefix = 'tracing:apm:langchain:invoke'
      constructor() {
        super(...arguments)
        this._handlers = {
          chain: new ChainHandler(this._tagger),
          chat_model: new ChatModelHandler(this._tagger),
          llm: new LlmHandler(this._tagger),
          embedding: new EmbeddingHandler(this._tagger),
          tool: new ToolHandler(this._tagger),
          similarity_search: new VectorStoreHandler(this._tagger),
        }
      }
      getLLMObsSpanRegisterOptions(ctx) {
        const span = ctx.currentStore?.span
        const tags = span?.context()._tags || {}
        const modelProvider = tags['langchain.request.provider']
        const modelName = tags['langchain.request.model']
        const kind = this.getKind(ctx.type, modelProvider)
        const instance = ctx.instance || ctx.self
        const handler = this._handlers[ctx.type]
        const name = handler?.getName({ span, instance })
        return {
          modelProvider,
          modelName,
          kind,
          name,
        }
      }
      setLLMObsTags(ctx) {
        ctx.args = ctx.arguments
        ctx.instance = ctx.self
        const span = ctx.currentStore?.span
        const type = (ctx.type = this.constructor.lcType)
        if (!Object.keys(this._handlers).includes(type)) {
          log.warn('Unsupported LangChain operation type:', type)
          return
        }
        const provider = span?.context()._tags['langchain.request.provider']
        const integrationName = this.getIntegrationName(type, provider)
        this.setMetadata(span, provider)
        const inputs = ctx.args?.[0]
        const options = ctx.args?.[1]
        const results = ctx.result
        this._handlers[type].setMetaTags({ span, inputs, results, options, integrationName })
      }
      setMetadata(span, provider) {
        if (!provider) return
        const metadata = {}
        const temperature =
          span?.context()._tags[`langchain.request.${provider}.parameters.temperature`] ||
          span?.context()._tags[`langchain.request.${provider}.parameters.model_kwargs.temperature`]
        const maxTokens =
          span?.context()._tags[`langchain.request.${provider}.parameters.max_tokens`] ||
          span?.context()._tags[`langchain.request.${provider}.parameters.maxTokens`] ||
          span?.context()._tags[`langchain.request.${provider}.parameters.model_kwargs.max_tokens`]
        if (temperature) {
          metadata.temperature = Number.parseFloat(temperature)
        }
        if (maxTokens) {
          metadata.maxTokens = Number.parseInt(maxTokens)
        }
        this._tagger.tagMetadata(span, metadata)
      }
      getKind(type, provider) {
        if (LLM_SPAN_TYPES.has(type)) {
          const llmobsIntegration = this.getIntegrationName(type, provider)
          if (!this.isLLMIntegrationEnabled(llmobsIntegration)) {
            return type === 'embedding' ? EMBEDDING : LLM
          }
        }
        switch (type) {
          case 'tool':
            return TOOL
          case 'similarity_search':
            return RETRIEVAL
          default:
            return WORKFLOW
        }
      }
      getIntegrationName(type, provider = 'custom') {
        if (provider.startsWith(BEDROCK_PROVIDER_NAME)) {
          return 'bedrock'
        } else if (provider.startsWith(OPENAI_PROVIDER_NAME)) {
          return 'openai'
        } else if (type === 'chat_model' && provider.startsWith(ANTHROPIC_PROVIDER_NAME)) {
          return 'anthropic'
        }
        return provider
      }
      isLLMIntegrationEnabled(integration) {
        return SUPPORTED_INTEGRATIONS.has(integration) && pluginManager?._pluginsByName[integration]?.llmobs?._enabled
      }
    }
    var RunnableSequenceInvokePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_rs_invoke'
      static lcType = 'chain'
      static prefix = 'tracing:orchestrion:@langchain/core:RunnableSequence_invoke'
    }
    var RunnableSequenceBatchPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_rs_batch'
      static lcType = 'chain'
      static prefix = 'tracing:orchestrion:@langchain/core:RunnableSequence_batch'
    }
    var BaseChatModelGeneratePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_chat_model_generate'
      static lcType = 'chat_model'
      static prefix = 'tracing:orchestrion:@langchain/core:BaseChatModel_generate'
    }
    var BaseLLMGeneratePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_llm_generate'
      static lcType = 'llm'
      static prefix = 'tracing:orchestrion:@langchain/core:BaseLLM_generate'
    }
    var EmbeddingsEmbedQueryPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_embeddings_embed_query'
      static lcType = 'embedding'
      static prefix = 'tracing:orchestrion:@langchain/core:Embeddings_embedQuery'
    }
    var EmbeddingsEmbedDocumentsPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_embeddings_embed_documents'
      static lcType = 'embedding'
      static prefix = 'tracing:orchestrion:@langchain/core:Embeddings_embedDocuments'
    }
    var ToolInvokePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_tool_invoke'
      static lcType = 'tool'
      static prefix = 'tracing:orchestrion:@langchain/core:Tool_invoke'
    }
    var VectorStoreSimilaritySearchPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_vectorstore_similarity_search'
      static lcType = 'similarity_search'
      static prefix = 'tracing:orchestrion:@langchain/core:VectorStore_similaritySearch'
    }
    var VectorStoreSimilaritySearchWithScorePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = 'llmobs_langchain_vectorstore_similarity_search_with_score'
      static lcType = 'similarity_search'
      static prefix = 'tracing:orchestrion:@langchain/core:VectorStore_similaritySearchWithScore'
    }
    module2.exports = [
      RunnableSequenceInvokePlugin,
      RunnableSequenceBatchPlugin,
      BaseChatModelGeneratePlugin,
      BaseLLMGeneratePlugin,
      EmbeddingsEmbedQueryPlugin,
      EmbeddingsEmbedDocumentsPlugin,
      ToolInvokePlugin,
      VectorStoreSimilaritySearchPlugin,
      VectorStoreSimilaritySearchWithScorePlugin,
    ]
  },
})

// node_modules/dd-trace/packages/datadog-plugin-langchain/src/index.js
var require_src19 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-langchain/src/index.js'(exports2, module2) {
    'use strict'
    var langChainTracingPlugins = require_tracing6()
    var langChainLLMObsPlugins = require_langchain3()
    var CompositePlugin = require_composite()
    var plugins = {}
    for (const Plugin of langChainLLMObsPlugins) {
      plugins[Plugin.id] = Plugin
    }
    for (const Plugin of langChainTracingPlugins) {
      plugins[Plugin.id] = Plugin
    }
    var LangChainPlugin = class extends CompositePlugin {
      static id = 'langchain'
      static plugins = plugins
    }
    module2.exports = LangChainPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/cache.js
var require_cache = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/cache.js'(exports2, module2) {
    'use strict'
    var StoragePlugin = require_storage5()
    var CachePlugin = class extends StoragePlugin {
      static operation = 'command'
      startSpan(options, ctx) {
        if (!options.kind) {
          options.kind = this.constructor.kind
        }
        return super.startSpan(this.operationName(), options, ctx)
      }
    }
    module2.exports = CachePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js
var require_src20 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY } = require_constants2()
    var CachePlugin = require_cache()
    var urlFilter = require_urlfilter()
    var RedisPlugin = class extends CachePlugin {
      static id = 'redis'
      static system = 'redis'
      constructor(...args) {
        super(...args)
        this._spanType = 'redis'
      }
      bindStart(ctx) {
        const { db, command, args, connectionOptions, connectionName } = ctx
        const resource = command
        const normalizedCommand = command.toUpperCase()
        if (!this.config.filter(normalizedCommand)) {
          return { noop: true }
        }
        this.startSpan(
          {
            resource,
            service: this.serviceName({ pluginConfig: this.config, system: this.system, connectionName }),
            type: this._spanType,
            meta: {
              'db.type': this._spanType,
              'db.name': db || '0',
              [`${this._spanType}.raw_command`]: formatCommand(normalizedCommand, args),
              'out.host': connectionOptions.host,
              [CLIENT_PORT_KEY]: connectionOptions.port,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      configure(config) {
        super.configure(normalizeConfig(config))
      }
    }
    function formatCommand(command, args) {
      if (!args || command === 'AUTH') return command
      for (let i = 0, l = args.length; i < l; i++) {
        if (typeof args[i] === 'function') continue
        command = `${command} ${formatArg(args[i])}`
        if (command.length > 1e3) return trim(command, 1e3)
      }
      return command
    }
    function formatArg(arg) {
      switch (typeof arg) {
        case 'string':
        case 'number':
          return trim(String(arg), 100)
        default:
          return '?'
      }
    }
    function trim(str, maxlen) {
      if (str.length > maxlen) {
        str = str.slice(0, maxlen - 3) + '...'
      }
      return str
    }
    function normalizeConfig(config) {
      if (config.allowlist) uppercaseAllEntries(config.allowlist)
      if (config.whitelist) uppercaseAllEntries(config.whitelist)
      if (config.blocklist) uppercaseAllEntries(config.blocklist)
      if (config.blacklist) uppercaseAllEntries(config.blacklist)
      const filter = urlFilter.getFilter(config)
      return { ...config, filter }
    }
    function uppercaseAllEntries(entries) {
      for (let i = 0; i < entries.length; i++) {
        entries[i] = String(entries[i]).toUpperCase()
      }
    }
    module2.exports = RedisPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-opensearch/src/index.js
var require_src21 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-opensearch/src/index.js'(exports2, module2) {
    'use strict'
    var ElasticsearchPlugin = require_src9()
    var OpenSearchPlugin = class extends ElasticsearchPlugin {
      static id = 'opensearch'
    }
    module2.exports = OpenSearchPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-prisma/src/client.js
var require_client8 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-prisma/src/client.js'(exports2, module2) {
    'use strict'
    var DatabasePlugin = require_database()
    var PrismaClientPlugin = class extends DatabasePlugin {
      static id = 'prisma'
      static operation = 'client'
      static system = 'prisma'
      static prefix = 'tracing:apm:prisma:client'
      bindStart(ctx) {
        const service = this.serviceName({ pluginConfig: this.config })
        const resource = formatResourceName(ctx.resourceName, ctx.attributes)
        const options = { service, resource }
        if (ctx.resourceName === 'operation') {
          options.meta = {
            prisma: {
              method: ctx.attributes.method,
              model: ctx.attributes.model,
              type: 'client',
            },
          }
        }
        const operationName = this.operationName({ operation: this.operation })
        this.startSpan(operationName, options, ctx)
        return ctx.currentStore
      }
      end(ctx) {
        if (Object.hasOwn(ctx, 'result')) {
          this.finish(ctx)
        }
      }
      bindAsyncStart(ctx) {
        return this.bindFinish(ctx)
      }
      asyncStart(ctx) {
        this.finish(ctx)
      }
      error(error) {
        this.addError(error)
      }
    }
    function formatResourceName(resource, attributes) {
      if (attributes?.name) {
        return `${attributes.name}`.trim()
      }
      if (attributes?.model && attributes.method) {
        return `${attributes.model}.${attributes.method}`.trim()
      }
      return resource
    }
    module2.exports = PrismaClientPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-prisma/src/engine.js
var require_engine = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-prisma/src/engine.js'(exports2, module2) {
    'use strict'
    var DatabasePlugin = require_database()
    var { CLIENT_PORT_KEY } = require_constants2()
    var databaseDriverMapper = {
      postgresql: {
        type: 'sql',
        'db.type': 'postgres',
      },
      mysql: {
        type: 'sql',
        'db.type': 'mysql',
      },
      mongodb: {
        type: 'mongodb',
        'db.type': 'mongodb',
      },
      sqlite: {
        type: 'sql',
        'db.type': 'sqlite',
      },
    }
    var PrismaEngine = class extends DatabasePlugin {
      static id = 'prisma'
      static operation = 'engine'
      static system = 'prisma'
      start(ctx) {
        const { engineSpan, allEngineSpans, childOf, dbConfig } = ctx
        const service = this.serviceName({ pluginConfig: this.config, system: this.system })
        const spanName = engineSpan.name.slice(14)
        const options = {
          childOf,
          resource: spanName,
          service,
          kind: engineSpan.kind,
          meta: {
            prisma: {
              name: spanName,
              type: 'engine',
            },
          },
        }
        if (spanName === 'db_query') {
          const query = engineSpan.attributes['db.query.text']
          const originalStatement = this.maybeTruncate(query)
          const type = databaseDriverMapper[engineSpan.attributes['db.system']]?.type
          const dbType = databaseDriverMapper[engineSpan.attributes['db.system']]?.['db.type']
          options.resource = originalStatement
          options.type = type || engineSpan.attributes['db.system']
          options.meta['db.type'] = dbType || engineSpan.attributes['db.system']
          options.meta['db.name'] = dbConfig?.database
          options.meta['db.user'] = dbConfig?.user
          options.meta['out.host'] = dbConfig?.host
          options.meta[CLIENT_PORT_KEY] = dbConfig?.port
        }
        const activeSpan = this.startSpan(this.operationName({ operation: this.operation }), options)
        activeSpan._startTime = hrTimeToUnixTimeMs(engineSpan.startTime)
        for (const span of allEngineSpans) {
          if (span.parentId === engineSpan.id) {
            const startCtx = { engineSpan: span, allEngineSpans, childOf: activeSpan, dbConfig }
            this.start(startCtx)
          }
        }
        const unixEndTime = hrTimeToUnixTimeMs(engineSpan.endTime)
        activeSpan.finish(unixEndTime)
      }
    }
    function hrTimeToUnixTimeMs([seconds, nanoseconds]) {
      return seconds * 1e3 + nanoseconds / 1e6
    }
    module2.exports = PrismaEngine
  },
})

// node_modules/dd-trace/packages/datadog-plugin-prisma/src/index.js
var require_src22 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-prisma/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var PrismaClientPlugin = require_client8()
    var PrismaEnginePlugin = require_engine()
    var PrismaPlugin = class extends CompositePlugin {
      static id = 'prisma'
      static get plugins() {
        return {
          client: PrismaClientPlugin,
          engine: PrismaEnginePlugin,
        }
      }
      configure(config) {
        return super.configure(config)
      }
    }
    module2.exports = PrismaPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-vitest/src/index.js
var require_src23 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-vitest/src/index.js'(exports2, module2) {
    'use strict'
    var CiPlugin = require_ci_plugin()
    var { storage } = require_datadog_core()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      TEST_STATUS,
      VITEST_POOL,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags,
      getTestSessionName,
      getIsFaultyEarlyFlakeDetection,
      TEST_SOURCE_FILE,
      TEST_IS_RETRY,
      TEST_CODE_COVERAGE_LINES_PCT,
      TEST_CODE_OWNERS,
      TEST_LEVEL_EVENT_TYPES,
      TEST_SESSION_NAME,
      TEST_SOURCE_START,
      TEST_IS_NEW,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_HAS_FAILED_ALL_RETRIES,
      getLibraryCapabilitiesTags,
      TEST_RETRY_REASON_TYPES,
      isModifiedTest,
      TEST_IS_MODIFIED,
    } = require_test()
    var { COMPONENT } = require_constants2()
    var { TELEMETRY_EVENT_CREATED, TELEMETRY_EVENT_FINISHED, TELEMETRY_TEST_SESSION } = require_telemetry()
    var { DD_MAJOR } = require_version()
    var MILLISECONDS_TO_SUBTRACT_FROM_FAILED_TEST_DURATION = 5
    var VitestPlugin = class extends CiPlugin {
      static id = 'vitest'
      constructor(...args) {
        super(...args)
        this.taskToFinishTime = /* @__PURE__ */ new WeakMap()
        this.addSub('ci:vitest:test:is-new', ({ knownTests, testSuiteAbsolutePath, testName, onDone }) => {
          if (!knownTests.vitest) {
            return onDone(false)
          }
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
          const testsForThisTestSuite = knownTests.vitest[testSuite] || []
          onDone(!testsForThisTestSuite.includes(testName))
        })
        this.addSub(
          'ci:vitest:test:is-attempt-to-fix',
          ({ testManagementTests, testSuiteAbsolutePath, testName, onDone }) => {
            const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
            const { isAttemptToFix } = this.getTestProperties(testManagementTests, testSuite, testName)
            onDone(isAttemptToFix ?? false)
          }
        )
        this.addSub(
          'ci:vitest:test:is-disabled',
          ({ testManagementTests, testSuiteAbsolutePath, testName, onDone }) => {
            const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
            const { isDisabled } = this.getTestProperties(testManagementTests, testSuite, testName)
            onDone(isDisabled)
          }
        )
        this.addSub(
          'ci:vitest:test:is-quarantined',
          ({ testManagementTests, testSuiteAbsolutePath, testName, onDone }) => {
            const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
            const { isQuarantined } = this.getTestProperties(testManagementTests, testSuite, testName)
            onDone(isQuarantined)
          }
        )
        this.addSub('ci:vitest:test:is-modified', ({ modifiedFiles, testSuiteAbsolutePath, onDone }) => {
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
          const isModified = isModifiedTest(testSuite, 0, 0, modifiedFiles, this.constructor.id)
          onDone(isModified)
        })
        this.addSub('ci:vitest:is-early-flake-detection-faulty', ({ knownTests, testFilepaths, onDone }) => {
          const isFaulty = getIsFaultyEarlyFlakeDetection(
            testFilepaths.map((testFilepath) => getTestSuitePath(testFilepath, this.repositoryRoot)),
            knownTests,
            this.libraryConfig.earlyFlakeDetectionFaultyThreshold
          )
          onDone(isFaulty)
        })
        this.addBind('ci:vitest:test:start', (ctx) => {
          const {
            testName,
            testSuiteAbsolutePath,
            isRetry,
            isNew,
            isAttemptToFix,
            isQuarantined,
            isDisabled,
            mightHitProbe,
            isRetryReasonEfd,
            isRetryReasonAttemptToFix,
            isRetryReasonAtr,
            isModified,
          } = ctx
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
          const store = storage('legacy').getStore()
          const extraTags = {
            [TEST_SOURCE_FILE]: testSuite,
          }
          if (isRetry) {
            extraTags[TEST_IS_RETRY] = 'true'
            if (isRetryReasonAttemptToFix) {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.atf
            } else if (isRetryReasonEfd) {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd
            } else if (isRetryReasonAtr) {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.atr
            } else {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.ext
            }
          }
          if (isNew) {
            extraTags[TEST_IS_NEW] = 'true'
          }
          if (isAttemptToFix) {
            extraTags[TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX] = 'true'
          }
          if (isQuarantined) {
            extraTags[TEST_MANAGEMENT_IS_QUARANTINED] = 'true'
          }
          if (isDisabled) {
            extraTags[TEST_MANAGEMENT_IS_DISABLED] = 'true'
          }
          if (isModified) {
            extraTags[TEST_IS_MODIFIED] = 'true'
          }
          const span = this.startTestSpan(testName, testSuite, this.testSuiteSpan, extraTags)
          ctx.parentStore = store
          ctx.currentStore = { ...store, span }
          if (mightHitProbe) {
            this.activeTestSpan = span
          }
          return ctx.currentStore
        })
        this.addBind('ci:vitest:test:finish-time', (ctx) => {
          const { status, task, attemptToFixPassed, attemptToFixFailed } = ctx
          const span = ctx.currentStore?.span
          if (span) {
            span.setTag(TEST_STATUS, status)
            if (attemptToFixPassed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'true')
            } else if (attemptToFixFailed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'false')
            }
            this.taskToFinishTime.set(task, span._getTime())
            ctx.parentStore = ctx.currentStore
            ctx.currentStore = { ...ctx.currentStore, span }
          }
          return ctx.currentStore
        })
        this.addSub('ci:vitest:test:pass', ({ span, task }) => {
          if (span) {
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
              hasCodeowners: !!span.context()._tags[TEST_CODE_OWNERS],
            })
            span.setTag(TEST_STATUS, 'pass')
            span.finish(this.taskToFinishTime.get(task))
            finishAllTraceSpans(span)
          }
        })
        this.addSub(
          'ci:vitest:test:error',
          ({ span, duration, error, shouldSetProbe, promises, hasFailedAllRetries, attemptToFixFailed }) => {
            if (!span) {
              return
            }
            if (shouldSetProbe && this.di && error?.stack) {
              const probeInformation = this.addDiProbe(error)
              if (probeInformation) {
                const { file, line, stackIndex, setProbePromise } = probeInformation
                this.runningTestProbe = { file, line }
                this.testErrorStackIndex = stackIndex
                promises.setProbePromise = setProbePromise
              }
            }
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
              hasCodeowners: !!span.context()._tags[TEST_CODE_OWNERS],
            })
            span.setTag(TEST_STATUS, 'fail')
            if (error) {
              span.setTag('error', error)
            }
            if (hasFailedAllRetries) {
              span.setTag(TEST_HAS_FAILED_ALL_RETRIES, 'true')
            }
            if (attemptToFixFailed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'false')
            }
            if (duration) {
              span.finish(span._startTime + duration - MILLISECONDS_TO_SUBTRACT_FROM_FAILED_TEST_DURATION)
            } else {
              span.finish()
            }
            finishAllTraceSpans(span)
          }
        )
        this.addSub('ci:vitest:test:skip', ({ testName, testSuiteAbsolutePath, isNew, isDisabled }) => {
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
          const testSpan = this.startTestSpan(testName, testSuite, this.testSuiteSpan, {
            [TEST_SOURCE_FILE]: testSuite,
            [TEST_SOURCE_START]: 1,
            // we can't get the proper start line in vitest
            [TEST_STATUS]: 'skip',
            ...(isDisabled ? { [TEST_MANAGEMENT_IS_DISABLED]: 'true' } : {}),
            ...(isNew ? { [TEST_IS_NEW]: 'true' } : {}),
          })
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
            hasCodeowners: !!testSpan.context()._tags[TEST_CODE_OWNERS],
          })
          testSpan.finish()
        })
        this.addBind('ci:vitest:test-suite:start', (ctx) => {
          const { testSuiteAbsolutePath, frameworkVersion } = ctx
          this.command = getEnvironmentVariable('DD_CIVISIBILITY_TEST_COMMAND')
          this.frameworkVersion = frameworkVersion
          const testSessionSpanContext = this.tracer.extract('text_map', {
            'x-datadog-trace-id': getEnvironmentVariable('DD_CIVISIBILITY_TEST_SESSION_ID'),
            'x-datadog-parent-id': getEnvironmentVariable('DD_CIVISIBILITY_TEST_MODULE_ID'),
          })
          const trimmedCommand = DD_MAJOR < 6 ? this.command : 'vitest run'
          const testSessionName = getTestSessionName(this.config, trimmedCommand, this.testEnvironmentMetadata)
          const metadataTags = {}
          for (const testLevel of TEST_LEVEL_EVENT_TYPES) {
            metadataTags[testLevel] = {
              [TEST_SESSION_NAME]: testSessionName,
            }
          }
          if (this.tracer._exporter.addMetadataTags) {
            const libraryCapabilitiesTags = getLibraryCapabilitiesTags(this.constructor.id)
            metadataTags.test = {
              ...metadataTags.test,
              ...libraryCapabilitiesTags,
            }
            this.tracer._exporter.addMetadataTags(metadataTags)
          }
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
          const testSuiteMetadata = getTestSuiteCommonTags(this.command, this.frameworkVersion, testSuite, 'vitest')
          testSuiteMetadata[TEST_SOURCE_FILE] = testSuite
          testSuiteMetadata[TEST_SOURCE_START] = 1
          const codeOwners = this.getCodeOwners(testSuiteMetadata)
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners
          }
          const testSuiteSpan = this.tracer.startSpan('vitest.test_suite', {
            childOf: testSessionSpanContext,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata,
            },
          })
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'suite')
          const store = storage('legacy').getStore()
          ctx.parentStore = store
          ctx.currentStore = { ...store, testSuiteSpan }
          this.testSuiteSpan = testSuiteSpan
          return ctx.currentStore
        })
        this.addSub('ci:vitest:test-suite:finish', ({ testSuiteSpan, status, onFinish }) => {
          if (testSuiteSpan) {
            testSuiteSpan.setTag(TEST_STATUS, status)
            testSuiteSpan.finish()
            finishAllTraceSpans(testSuiteSpan)
          }
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'suite')
          this.tracer._exporter.flush(onFinish)
          if (this.runningTestProbe) {
            this.removeDiProbe(this.runningTestProbe)
          }
        })
        this.addBind('ci:vitest:test-suite:error', (ctx) => {
          const { error } = ctx
          const testSuiteSpan = ctx.currentStore?.testSuiteSpan
          if (testSuiteSpan && error) {
            testSuiteSpan.setTag('error', error)
            testSuiteSpan.setTag(TEST_STATUS, 'fail')
            ctx.parentStore = ctx.currentStore
            ctx.currentStore = { ...ctx.currentStore, testSuiteSpan }
          }
          return ctx.currentStore
        })
        this.addSub(
          'ci:vitest:session:finish',
          ({
            status,
            error,
            testCodeCoverageLinesTotal,
            isEarlyFlakeDetectionEnabled,
            isEarlyFlakeDetectionFaulty,
            isTestManagementTestsEnabled,
            vitestPool,
            onFinish,
          }) => {
            this.testSessionSpan.setTag(TEST_STATUS, status)
            this.testModuleSpan.setTag(TEST_STATUS, status)
            if (error) {
              this.testModuleSpan.setTag('error', error)
              this.testSessionSpan.setTag('error', error)
            }
            if (testCodeCoverageLinesTotal !== void 0) {
              this.testModuleSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal)
              this.testSessionSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal)
            }
            if (isEarlyFlakeDetectionEnabled) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, 'true')
            }
            if (isEarlyFlakeDetectionFaulty) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, 'faulty')
            }
            if (isTestManagementTestsEnabled) {
              this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, 'true')
            }
            if (vitestPool) {
              this.testSessionSpan.setTag(VITEST_POOL, vitestPool)
            }
            this.testModuleSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'module')
            this.testSessionSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'session')
            finishAllTraceSpans(this.testSessionSpan)
            this.telemetry.count(TELEMETRY_TEST_SESSION, {
              provider: this.ciProviderName,
              autoInjected: !!getEnvironmentVariable('DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER'),
            })
            this.tracer._exporter.flush(onFinish)
          }
        )
      }
      getTestProperties(testManagementTests, testSuite, testName) {
        const {
          attempt_to_fix: isAttemptToFix,
          disabled: isDisabled,
          quarantined: isQuarantined,
        } = testManagementTests?.vitest?.suites?.[testSuite]?.tests?.[testName]?.properties || {}
        return { isAttemptToFix, isDisabled, isQuarantined }
      }
    }
    module2.exports = VitestPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-aerospike/src/index.js
var require_src24 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-aerospike/src/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var DatabasePlugin = require_database()
    var AEROSPIKE_PEER_SERVICE = 'aerospike.namespace'
    var AerospikePlugin = class extends DatabasePlugin {
      static id = 'aerospike'
      static operation = 'command'
      static system = 'aerospike'
      static prefix = 'tracing:apm:aerospike:command'
      static peerServicePrecursors = [AEROSPIKE_PEER_SERVICE]
      bindStart(ctx) {
        const { commandName, commandArgs } = ctx
        const resourceName = commandName.slice(0, commandName.indexOf('Command'))
        const store = storage('legacy').getStore()
        const childOf = store ? store.span : null
        const meta = getMeta(resourceName, commandArgs)
        const span = this.startSpan(
          this.operationName(),
          {
            childOf,
            service: this.serviceName({ pluginConfig: this.config }),
            type: 'aerospike',
            kind: 'client',
            resource: resourceName,
            meta,
          },
          false
        )
        ctx.parentStore = store
        ctx.currentStore = { ...store, span }
        return ctx.currentStore
      }
      bindAsyncStart(ctx) {
        if (ctx.currentStore) {
          this.tagPeerService(ctx.currentStore.span)
          ctx.currentStore.span.finish()
        }
        return ctx.parentStore
      }
      end(ctx) {
        if (ctx.result) {
          this.tagPeerService(ctx.currentStore.span)
          ctx.currentStore.span.finish()
        }
      }
      error(ctx) {
        if (ctx.error) {
          const error = ctx.error
          const span = ctx.currentStore.span
          span.setTag('error', error)
        }
      }
    }
    function getMeta(resourceName, commandArgs) {
      let meta = {}
      if (resourceName.includes('Index')) {
        const [ns, set, bin, exp, index] = commandArgs
        meta = commandArgs.length > 8 ? getMetaForIndex(ns, set, bin, index) : getMetaForIndex(ns, set, bin, exp)
      } else if (resourceName === 'Query') {
        const { ns, set } = commandArgs[2]
        meta = getMetaForQuery({ ns, set })
      } else if (isKeyObject(commandArgs[0])) {
        const { ns, set, key } = commandArgs[0]
        meta = getMetaForKey(ns, set, key)
      }
      return meta
    }
    function getMetaForIndex(ns, set, bin, index) {
      return {
        [AEROSPIKE_PEER_SERVICE]: ns,
        'aerospike.setname': set,
        'aerospike.bin': bin,
        'aerospike.index': index,
      }
    }
    function getMetaForKey(ns, set, key) {
      return {
        'aerospike.key': `${ns}:${set}:${key}`,
        [AEROSPIKE_PEER_SERVICE]: ns,
        'aerospike.setname': set,
        'aerospike.userkey': key,
      }
    }
    function getMetaForQuery(queryObj) {
      const { ns, set } = queryObj
      return {
        [AEROSPIKE_PEER_SERVICE]: ns,
        'aerospike.setname': set,
      }
    }
    function isKeyObject(obj) {
      return obj && obj.ns !== void 0 && obj.set !== void 0 && obj.key !== void 0
    }
    module2.exports = AerospikePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ai/src/utils.js
var require_utils5 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ai/src/utils.js'(exports2, module2) {
    'use strict'
    var { parseModelId } = require_utils3()
    function getModelProvider(tags) {
      const modelProviderTag = tags['ai.model.provider']
      const providerParts = modelProviderTag?.split('.')
      const provider = providerParts?.[0]
      if (provider === 'amazon-bedrock') {
        const modelId = tags['ai.model.id']
        const model = modelId && parseModelId(modelId)
        return model?.modelProvider ?? provider
      }
      return provider
    }
    module2.exports = {
      getModelProvider,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/ai/util.js
var require_util9 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/ai/util.js'(exports2, module2) {
    'use strict'
    var MODEL_METADATA_KEYS = /* @__PURE__ */ new Set([
      'frequency_penalty',
      'max_tokens',
      'presence_penalty',
      'temperature',
      'top_p',
      'top_k',
      'stop_sequences',
    ])
    function getSpanTags(ctx) {
      const span = ctx.currentStore?.span
      const carrier = ctx.attributes ?? span?.context()._tags ?? {}
      return carrier
    }
    function getOperation(span) {
      const name = span._name
      if (!name) return
      return name.split('.').pop()
    }
    function getUsage(tags) {
      const usage = {}
      const inputTokens = tags['ai.usage.inputTokens'] ?? tags['ai.usage.promptTokens']
      const outputTokens = tags['ai.usage.outputTokens'] ?? tags['ai.usage.completionTokens']
      if (inputTokens != null) usage.inputTokens = inputTokens
      if (outputTokens != null) usage.outputTokens = outputTokens
      const totalTokens = tags['ai.usage.totalTokens'] ?? inputTokens + outputTokens
      if (!Number.isNaN(totalTokens)) usage.totalTokens = totalTokens
      return usage
    }
    function getJsonStringValue(str, defaultValue) {
      let maybeValue = defaultValue
      try {
        maybeValue = JSON.parse(str)
      } catch {}
      return maybeValue
    }
    function getModelMetadata(tags) {
      const modelMetadata = {}
      for (const metadata of MODEL_METADATA_KEYS) {
        const metadataTagKey = `gen_ai.request.${metadata}`
        const metadataValue = tags[metadataTagKey]
        if (metadataValue) {
          modelMetadata[metadata] = metadataValue
        }
      }
      return Object.keys(modelMetadata).length ? modelMetadata : null
    }
    function getGenerationMetadata(tags) {
      const metadata = {}
      for (const tag of Object.keys(tags)) {
        if (!tag.startsWith('ai.settings')) continue
        const settingKey = tag.split('.').pop()
        const transformedKey = settingKey.replaceAll(/[A-Z]/g, (letter) => '_' + letter.toLowerCase())
        if (MODEL_METADATA_KEYS.has(transformedKey)) continue
        const settingValue = tags[tag]
        metadata[settingKey] = settingValue
      }
      return Object.keys(metadata).length ? metadata : null
    }
    function getToolNameFromTags(tags) {
      const toolName = tags['ai.toolCall.name']
      if (!toolName) return null
      const parsedToolName = Number.parseInt(toolName)
      if (!Number.isNaN(parsedToolName)) return null
      return toolName
    }
    function getToolCallResultContent(content) {
      const { output, result } = content
      if (output) {
        if (output.type === 'text') {
          return output.value
        } else if (output.type === 'json') {
          return JSON.stringify(output.value)
        }
        return '[Unparsable Tool Result]'
      } else if (result) {
        if (typeof result === 'string') {
          return result
        }
        try {
          return JSON.stringify(result)
        } catch {
          return '[Unparsable Tool Result]'
        }
      } else {
        return '[Unsupported Tool Result]'
      }
    }
    function getLlmObsSpanName(operation, functionId) {
      return functionId ? `${functionId}.${operation}` : operation
    }
    module2.exports = {
      getSpanTags,
      getOperation,
      getUsage,
      getJsonStringValue,
      getModelMetadata,
      getGenerationMetadata,
      getToolNameFromTags,
      getToolCallResultContent,
      getLlmObsSpanName,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/ai/index.js
var require_ai2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/ai/index.js'(exports2, module2) {
    'use strict'
    var BaseLLMObsPlugin = require_base()
    var { getModelProvider } = require_utils5()
    var { channel } = require_dc_polyfill()
    var toolCreationCh = channel('dd-trace:vercel-ai:tool')
    var setAttributesCh = channel('dd-trace:vercel-ai:span:setAttributes')
    var { MODEL_NAME, MODEL_PROVIDER, NAME } = require_tags3()
    var {
      getSpanTags,
      getOperation,
      getUsage,
      getJsonStringValue,
      getModelMetadata,
      getGenerationMetadata,
      getToolNameFromTags,
      getToolCallResultContent,
      getLlmObsSpanName,
    } = require_util9()
    var SPAN_NAME_TO_KIND_MAPPING = {
      // embeddings
      embed: 'workflow',
      embedMany: 'workflow',
      doEmbed: 'embedding',
      // object generation
      generateObject: 'workflow',
      streamObject: 'workflow',
      // text generation
      generateText: 'workflow',
      streamText: 'workflow',
      // llm operations
      doGenerate: 'llm',
      doStream: 'llm',
      // tools
      toolCall: 'tool',
    }
    var VercelAILLMObsPlugin = class extends BaseLLMObsPlugin {
      static id = 'ai'
      static integration = 'ai'
      static prefix = 'tracing:dd-trace:vercel-ai'
      /**
       * The available tools within the runtime scope of this integration.
       * This essentially acts as a global registry for all tools made through the Vercel AI SDK.
       * @type {Set<Record<string, any>>}
       */
      #availableTools
      /**
       * A mapping of tool call IDs to tool names.
       * This is used to map the tool call ID to the tool name for the output message.
       * @type {Record<string, string>}
       */
      #toolCallIdsToName
      constructor(...args) {
        super(...args)
        this.#toolCallIdsToName = {}
        this.#availableTools = /* @__PURE__ */ new Set()
        toolCreationCh.subscribe((toolArgs) => {
          this.#availableTools.add(toolArgs)
        })
        setAttributesCh.subscribe(({ ctx, attributes }) => {
          Object.assign(ctx.attributes, attributes)
        })
      }
      /**
       * Does a best-effort attempt to find the right tool name for the given tool description.
       * This is because the Vercel AI SDK does not tag tools by name properly, but
       * rather by the index they were passed in. Tool names appear nowhere in the span tags.
       *
       * We use the tool description as the next best identifier for a tool.
       *
       * @param {string} toolName
       * @param {string} toolDescription
       * @returns {string | undefined}
       */
      findToolName(toolName, toolDescription) {
        if (Number.isNaN(Number.parseInt(toolName))) return toolName
        for (const availableTool of this.#availableTools) {
          const description = availableTool.description
          if (description === toolDescription && availableTool.id) {
            return availableTool.id
          }
        }
      }
      /**
       * @override
       */
      getLLMObsSpanRegisterOptions(ctx) {
        const span = ctx.currentStore?.span
        const operation = getOperation(span)
        const kind = SPAN_NAME_TO_KIND_MAPPING[operation]
        if (!kind) return
        return { kind, name: getLlmObsSpanName(operation, ctx.attributes['ai.telemetry.functionId']) }
      }
      /**
       * @override
       */
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span
        if (!span) return
        const operation = getOperation(span)
        const kind = SPAN_NAME_TO_KIND_MAPPING[operation]
        if (!kind) return
        const tags = getSpanTags(ctx)
        if (['embedding', 'llm'].includes(kind)) {
          this._tagger._setTag(span, MODEL_NAME, tags['ai.model.id'])
          this._tagger._setTag(span, MODEL_PROVIDER, getModelProvider(tags))
        }
        switch (operation) {
          case 'embed':
          case 'embedMany':
            this.setEmbeddingWorkflowTags(span, tags)
            break
          case 'doEmbed':
            this.setEmbeddingTags(span, tags)
            break
          case 'generateObject':
          case 'streamObject':
            this.setObjectGenerationTags(span, tags)
            break
          case 'generateText':
          case 'streamText':
            this.setTextGenerationTags(span, tags)
            break
          case 'doGenerate':
          case 'doStream':
            this.setLLMOperationTags(span, tags)
            break
          case 'toolCall':
            this.setToolTags(span, tags)
            break
          default:
            break
        }
      }
      setEmbeddingWorkflowTags(span, tags) {
        const inputs = tags['ai.value'] ?? tags['ai.values']
        const parsedInputs = Array.isArray(inputs)
          ? inputs.map((input) => getJsonStringValue(input, ''))
          : getJsonStringValue(inputs, '')
        const embeddingsOutput = tags['ai.embedding'] ?? tags['ai.embeddings']
        const isSingleEmbedding = !Array.isArray(embeddingsOutput)
        const numberOfEmbeddings = isSingleEmbedding ? 1 : embeddingsOutput.length
        const embeddingsLength = getJsonStringValue(
          isSingleEmbedding ? embeddingsOutput : embeddingsOutput?.[0],
          []
        ).length
        const output = `[${numberOfEmbeddings} embedding(s) returned with size ${embeddingsLength}]`
        this._tagger.tagTextIO(span, parsedInputs, output)
        const metadata = getGenerationMetadata(tags)
        this._tagger.tagMetadata(span, metadata)
      }
      setEmbeddingTags(span, tags) {
        const inputs = tags['ai.values']
        if (!Array.isArray(inputs)) return
        const parsedInputs = inputs.map((input) => getJsonStringValue(input, ''))
        const embeddingsOutput = tags['ai.embeddings']
        const numberOfEmbeddings = embeddingsOutput?.length
        const embeddingsLength = getJsonStringValue(embeddingsOutput?.[0], []).length
        const output = `[${numberOfEmbeddings} embedding(s) returned with size ${embeddingsLength}]`
        this._tagger.tagEmbeddingIO(span, parsedInputs, output)
        const usage = tags['ai.usage.tokens']
        this._tagger.tagMetrics(span, {
          inputTokens: usage,
          totalTokens: usage,
        })
      }
      setObjectGenerationTags(span, tags) {
        const promptInfo = getJsonStringValue(tags['ai.prompt'], {})
        const lastUserPrompt =
          promptInfo.prompt ?? promptInfo.messages.reverse().find((message) => message.role === 'user')?.content
        const prompt = Array.isArray(lastUserPrompt)
          ? lastUserPrompt.map((part) => part.text ?? '').join('')
          : lastUserPrompt
        const output = tags['ai.response.object']
        this._tagger.tagTextIO(span, prompt, output)
        const metadata = getGenerationMetadata(tags) ?? {}
        metadata.schema = getJsonStringValue(tags['ai.schema'], {})
        this._tagger.tagMetadata(span, metadata)
      }
      setTextGenerationTags(span, tags) {
        const promptInfo = getJsonStringValue(tags['ai.prompt'], {})
        const lastUserPrompt =
          promptInfo.prompt ?? promptInfo.messages.reverse().find((message) => message.role === 'user')?.content
        const prompt = Array.isArray(lastUserPrompt)
          ? lastUserPrompt.map((part) => part.text ?? '').join('')
          : lastUserPrompt
        const output = tags['ai.response.text']
        this._tagger.tagTextIO(span, prompt, output)
        const metadata = getGenerationMetadata(tags)
        this._tagger.tagMetadata(span, metadata)
      }
      /**
       * @param {import('../../../opentracing/span')} span
       * @param {Record<string, unknown>} tags
       */
      setLLMOperationTags(span, tags) {
        const toolsForModel = tags['ai.prompt.tools']?.map(getJsonStringValue)
        const inputMessages = getJsonStringValue(tags['ai.prompt.messages'], [])
        const parsedInputMessages = []
        for (const message of inputMessages) {
          const formattedMessages = this.formatMessage(message, toolsForModel)
          parsedInputMessages.push(...formattedMessages)
        }
        const outputMessage = this.formatOutputMessage(tags, toolsForModel)
        this._tagger.tagLLMIO(span, parsedInputMessages, outputMessage)
        const metadata = getModelMetadata(tags)
        this._tagger.tagMetadata(span, metadata)
        const usage = getUsage(tags)
        this._tagger.tagMetrics(span, usage)
      }
      setToolTags(span, tags) {
        const toolCallId = tags['ai.toolCall.id']
        const name = getToolNameFromTags(tags) ?? this.#toolCallIdsToName[toolCallId]
        if (name) this._tagger._setTag(span, NAME, name)
        const input = tags['ai.toolCall.args']
        const output = tags['ai.toolCall.result']
        this._tagger.tagTextIO(span, input, output)
      }
      formatOutputMessage(tags, toolsForModel) {
        const outputMessageText = tags['ai.response.text'] ?? tags['ai.response.object']
        const outputMessageToolCalls = getJsonStringValue(tags['ai.response.toolCalls'], [])
        const formattedToolCalls = []
        for (const toolCall of outputMessageToolCalls) {
          const toolArgs = toolCall.args ?? toolCall.input
          const toolCallArgs = typeof toolArgs === 'string' ? getJsonStringValue(toolArgs, {}) : toolArgs
          const toolDescription = toolsForModel?.find((tool) => toolCall.toolName === tool.name)?.description
          const name = this.findToolName(toolCall.toolName, toolDescription)
          this.#toolCallIdsToName[toolCall.toolCallId] = name
          formattedToolCalls.push({
            arguments: toolCallArgs,
            name,
            toolId: toolCall.toolCallId,
            type: toolCall.toolCallType ?? 'function',
          })
        }
        return {
          role: 'assistant',
          content: outputMessageText,
          toolCalls: formattedToolCalls,
        }
      }
      /**
       * Returns a list of formatted messages from a message object.
       * Most of these will just be one entry, but in the case of a "tool" role,
       * it is possible to have multiple tool call results in a single message that we
       * need to split into multiple messages.
       *
       * @param {*} message
       * @param {*} toolsForModel
       * @returns {Array<{role: string, content: string, toolId?: string,
       *   toolCalls?: Array<{arguments: string, name: string, toolId: string, type: string}>}>}
       */
      formatMessage(message, toolsForModel) {
        const { role, content } = message
        if (role === 'system') {
          return [{ role, content }]
        } else if (role === 'user') {
          let finalContent = ''
          for (const part of content) {
            const { type } = part
            if (type === 'text') {
              finalContent += part.text
            }
          }
          return [{ role, content: finalContent }]
        } else if (role === 'assistant') {
          const toolCalls = []
          let finalContent = ''
          for (const part of content) {
            const { type } = part
            if (['text', 'reasoning', 'redacted-reasoning'].includes(type)) {
              finalContent += part.text ?? part.data
            } else if (type === 'tool-call') {
              const toolDescription = toolsForModel?.find((tool) => part.toolName === tool.name)?.description
              const name = this.findToolName(part.toolName, toolDescription)
              toolCalls.push({
                arguments: part.args ?? part.input,
                name,
                toolId: part.toolCallId,
                type: 'function',
              })
            }
          }
          const finalMessage = {
            role,
            content: finalContent,
          }
          if (toolCalls.length) {
            finalMessage.toolCalls = toolCalls.length ? toolCalls : void 0
          }
          return [finalMessage]
        } else if (role === 'tool') {
          const finalMessages = []
          for (const part of content) {
            if (part.type === 'tool-result') {
              const safeResult = getToolCallResultContent(part)
              finalMessages.push({
                role,
                content: safeResult,
                toolId: part.toolCallId,
              })
            }
          }
          return finalMessages
        }
        return []
      }
    }
    module2.exports = VercelAILLMObsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ai/src/tracing.js
var require_tracing7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ai/src/tracing.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var { getModelProvider } = require_utils5()
    var VercelAITracingPlugin = class extends TracingPlugin {
      static id = 'ai'
      static prefix = 'tracing:dd-trace:vercel-ai'
      bindStart(ctx) {
        const { attributes, name } = ctx
        const model = attributes['ai.model.id']
        const modelProvider = getModelProvider(attributes)
        this.startSpan(
          name,
          {
            meta: {
              'resource.name': attributes['resource.name'] ?? name,
              'ai.request.model': model,
              'ai.request.model_provider': modelProvider,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore?.span
        span?.finish()
      }
    }
    module2.exports = VercelAITracingPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ai/src/index.js
var require_src25 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ai/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var VercelAILLMObsPlugin = require_ai2()
    var VercelAITracingPlugin = require_tracing7()
    var VercelAIPlugin = class extends CompositePlugin {
      static get id() {
        return 'ai'
      }
      static get plugins() {
        return {
          llmobs: VercelAILLMObsPlugin,
          tracing: VercelAITracingPlugin,
        }
      }
    }
    module2.exports = VercelAIPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/util.js
var require_util10 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqp10/src/util.js'(exports2, module2) {
    'use strict'
    function getAddress(link) {
      if (!link || !link.session || !link.session.connection) return {}
      return link.session.connection.address || {}
    }
    function getShortName(link) {
      if (!link || !link.name) return null
      return link.name.split('_').slice(0, -1).join('_')
    }
    module2.exports = { getAddress, getShortName }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/producer.js
var require_producer5 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqp10/src/producer.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer()
    var { CLIENT_PORT_KEY } = require_constants2()
    var { getAddress, getShortName } = require_util10()
    var Amqp10ProducerPlugin = class extends ProducerPlugin {
      static id = 'amqp10'
      static operation = 'send'
      static system = 'amqp'
      bindStart(ctx) {
        const { link } = ctx
        const address = getAddress(link)
        const target = getShortName(link)
        this.startSpan(
          {
            resource: ['send', target].filter(Boolean).join(' '),
            meta: {
              'amqp.link.target.address': target,
              'amqp.link.role': 'sender',
              'out.host': address.host,
              [CLIENT_PORT_KEY]: address.port,
              'amqp.link.name': link.name,
              'amqp.link.handle': link.handle,
              'amqp.connection.host': address.host,
              'amqp.connection.port': address.port,
              'amqp.connection.user': address.user,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = Amqp10ProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/consumer.js
var require_consumer3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqp10/src/consumer.js'(exports2, module2) {
    'use strict'
    var ConsumerPlugin = require_consumer()
    var { getAddress, getShortName } = require_util10()
    var Amqp10ConsumerPlugin = class extends ConsumerPlugin {
      static id = 'amqp10'
      static system = 'amqp'
      bindStart(ctx) {
        const { link } = ctx
        const source = getShortName(link)
        const address = getAddress(link)
        this.startSpan(
          {
            resource: ['receive', source].filter(Boolean).join(' '),
            type: 'worker',
            meta: {
              'amqp.link.source.address': source,
              'amqp.link.role': 'receiver',
              'amqp.link.name': link.name,
              'amqp.link.handle': link.handle,
              'amqp.connection.host': address.host,
              'amqp.connection.port': address.port,
              'amqp.connection.user': address.user,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = Amqp10ConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js
var require_src26 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer5()
    var ConsumerPlugin = require_consumer3()
    var CompositePlugin = require_composite()
    var Amqp10Plugin = class extends CompositePlugin {
      static id = 'amqp10'
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
        }
      }
    }
    module2.exports = Amqp10Plugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/util.js
var require_util11 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqplib/src/util.js'(exports2, module2) {
    'use strict'
    function getResourceName(method, fields = {}) {
      return [method, fields.exchange, fields.routingKey, fields.queue, fields.source, fields.destination]
        .filter(Boolean)
        .join(' ')
    }
    module2.exports = { getResourceName }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/producer.js
var require_producer6 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqplib/src/producer.js'(exports2, module2) {
    'use strict'
    var { TEXT_MAP } = require_formats()
    var { CLIENT_PORT_KEY } = require_constants2()
    var ProducerPlugin = require_producer()
    var { DsmPathwayCodec, getAmqpMessageSize } = require_datastreams()
    var { getResourceName } = require_util11()
    var AmqplibProducerPlugin = class extends ProducerPlugin {
      static id = 'amqplib'
      static operation = 'publish'
      bindStart(ctx) {
        const { channel = {}, method, fields, message } = ctx
        if (method !== 'basic.publish') return
        const stream = (channel.connection && channel.connection.stream) || {}
        const span = this.startSpan(
          {
            resource: getResourceName(method, fields),
            meta: {
              'out.host': stream._host,
              [CLIENT_PORT_KEY]: stream.remotePort,
              'amqp.queue': fields.queue,
              'amqp.exchange': fields.exchange,
              'amqp.routingKey': fields.routingKey,
              'amqp.consumerTag': fields.consumerTag,
              'amqp.source': fields.source,
              'amqp.destination': fields.destination,
            },
          },
          ctx
        )
        fields.headers = fields.headers || {}
        this.tracer.inject(span, TEXT_MAP, fields.headers)
        if (this.config.dsmEnabled) {
          const hasRoutingKey = fields.routingKey != null
          const payloadSize = getAmqpMessageSize({ content: message, headers: fields.headers })
          const exchangeOrTopicTag =
            hasRoutingKey && !fields.exchange ? `topic:${fields.routingKey}` : `exchange:${fields.exchange}`
          const dataStreamsContext = this.tracer.setCheckpoint(
            ['direction:out', exchangeOrTopicTag, `has_routing_key:${hasRoutingKey}`, 'type:rabbitmq'],
            span,
            payloadSize
          )
          DsmPathwayCodec.encode(dataStreamsContext, fields.headers)
        }
        return ctx.currentStore
      }
    }
    module2.exports = AmqplibProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/consumer.js
var require_consumer4 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqplib/src/consumer.js'(exports2, module2) {
    'use strict'
    var { TEXT_MAP } = require_formats()
    var ConsumerPlugin = require_consumer()
    var { getAmqpMessageSize } = require_datastreams()
    var { getResourceName } = require_util11()
    var AmqplibConsumerPlugin = class extends ConsumerPlugin {
      static id = 'amqplib'
      static operation = 'consume'
      bindStart(ctx) {
        const { method, fields = {}, message, queue } = ctx
        if (method !== 'basic.deliver' && method !== 'basic.get') return
        const childOf = extract(this.tracer, message)
        const queueName = queue || fields.queue || fields.routingKey
        const span = this.startSpan(
          {
            childOf,
            resource: getResourceName(method, fields),
            type: 'worker',
            meta: {
              'amqp.queue': queueName,
              'amqp.exchange': fields.exchange,
              'amqp.routingKey': fields.routingKey,
              'amqp.consumerTag': fields.consumerTag,
              'amqp.source': fields.source,
              'amqp.destination': fields.destination,
            },
          },
          ctx
        )
        if (this.config.dsmEnabled && message?.properties?.headers) {
          const payloadSize = getAmqpMessageSize({ headers: message.properties.headers, content: message.content })
          this.tracer.decodeDataStreamsContext(message.properties.headers)
          this.tracer.setCheckpoint(['direction:in', `topic:${queueName}`, 'type:rabbitmq'], span, payloadSize)
        }
        return ctx.currentStore
      }
    }
    function extract(tracer2, message) {
      return message ? tracer2.extract(TEXT_MAP, message.properties.headers) : null
    }
    module2.exports = AmqplibConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/client.js
var require_client9 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqplib/src/client.js'(exports2, module2) {
    'use strict'
    var { TEXT_MAP } = require_formats()
    var { CLIENT_PORT_KEY } = require_constants2()
    var ClientPlugin = require_client5()
    var { getResourceName } = require_util11()
    var AmqplibClientPlugin = class extends ClientPlugin {
      static id = 'amqplib'
      static type = 'messaging'
      static operation = 'command'
      bindStart(ctx) {
        const { channel = {}, method, fields } = ctx
        if (method === 'basic.deliver' || method === 'basic.get') return
        if (method === 'basic.publish') return
        const stream = (channel.connection && channel.connection.stream) || {}
        const span = this.startSpan(
          this.operationName(),
          {
            service: this.config.service || this.serviceName(),
            resource: getResourceName(method, fields),
            kind: this.constructor.kind,
            meta: {
              'out.host': stream._host,
              [CLIENT_PORT_KEY]: stream.remotePort,
              'amqp.queue': fields.queue,
              'amqp.exchange': fields.exchange,
              'amqp.routingKey': fields.routingKey,
              'amqp.consumerTag': fields.consumerTag,
              'amqp.source': fields.source,
              'amqp.destination': fields.destination,
            },
          },
          ctx
        )
        fields.headers = fields.headers || {}
        this.tracer.inject(span, TEXT_MAP, fields.headers)
        return ctx.currentStore
      }
    }
    module2.exports = AmqplibClientPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js
var require_src27 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer6()
    var ConsumerPlugin = require_consumer4()
    var ClientPlugin = require_client9()
    var CompositePlugin = require_composite()
    var AmqplibPlugin = class extends CompositePlugin {
      static id = 'amqplib'
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          client: ClientPlugin,
        }
      }
    }
    module2.exports = AmqplibPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/schema.js
var require_schema2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/schema.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var SERIALIZATION = 'serialization'
    var DESERIALIZATION = 'deserialization'
    var SchemaPlugin = class extends Plugin {
      constructor(...args) {
        super(...args)
        this.addSub(`apm:${this.constructor.id}:serialize-start`, this.handleSerializeStart.bind(this))
        this.addSub(`apm:${this.constructor.id}:deserialize-end`, this.handleDeserializeFinish.bind(this))
      }
      handleSerializeStart(args) {
        const activeSpan = this.tracer.scope().active()
        if (activeSpan && this.config.dsmEnabled) {
          this.constructor.schemaExtractor.attachSchemaOnSpan(args, activeSpan, SERIALIZATION, this.tracer)
        }
      }
      handleDeserializeFinish(args) {
        const activeSpan = this.tracer.scope().active()
        if (activeSpan && this.config.dsmEnabled) {
          this.constructor.schemaExtractor.attachSchemaOnSpan(args, activeSpan, DESERIALIZATION, this.tracer)
        }
      }
    }
    module2.exports = SchemaPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-avsc/src/schema_iterator.js
var require_schema_iterator = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-avsc/src/schema_iterator.js'(exports2, module2) {
    'use strict'
    var AVRO = 'avro'
    var { SCHEMA_DEFINITION, SCHEMA_ID, SCHEMA_NAME, SCHEMA_OPERATION, SCHEMA_WEIGHT, SCHEMA_TYPE } =
      require_constants2()
    var log = require_log2()
    var { SchemaBuilder } = require_datastreams()
    var SchemaExtractor = class _SchemaExtractor {
      constructor(schema) {
        this.schema = schema
      }
      static getType(type) {
        const typeMapping = {
          string: 'string',
          int: 'integer',
          long: 'integer',
          float: 'number',
          double: 'number',
          boolean: 'boolean',
          bytes: 'string',
          record: 'object',
          enum: 'string',
          array: 'array',
          map: 'object',
          fixed: 'string',
        }
        const typeName = type.typeName ?? type.name ?? type
        return typeName === 'null' ? typeName : typeMapping[typeName] || 'string'
      }
      static extractProperty(field, schemaName, fieldName, builder, depth) {
        let array = false
        let type
        let format
        let enumValues
        let description
        let ref
        const fieldType = field.type?.types ?? field.type?.typeName ?? field.type
        if (Array.isArray(fieldType)) {
          type = 'union[' + fieldType.map((t) => _SchemaExtractor.getType(t.type || t)).join(',') + ']'
        } else if (fieldType === 'array') {
          array = true
          const nestedType = field.type.itemsType.typeName
          type = _SchemaExtractor.getType(nestedType)
        } else if (fieldType === 'record') {
          type = 'object'
          ref = `#/components/schemas/${field.type.name}`
          if (!_SchemaExtractor.extractSchema(field.type, builder, depth + 1, this)) {
            return false
          }
        } else if (fieldType === 'enum') {
          enumValues = []
          let i = 0
          type = 'string'
          while (field.type.symbols[i]) {
            enumValues.push(field.type.symbols[i])
            i += 1
          }
        } else {
          type = _SchemaExtractor.getType(fieldType.type || fieldType)
          if (fieldType === 'bytes') {
            format = 'byte'
          } else if (fieldType === 'int') {
            format = 'int32'
          } else if (fieldType === 'long') {
            format = 'int64'
          } else if (fieldType === 'float') {
            format = 'float'
          } else if (fieldType === 'double') {
            format = 'double'
          }
        }
        return builder.addProperty(schemaName, fieldName, array, type, description, ref, format, enumValues)
      }
      static extractSchema(schema, builder, depth, extractor) {
        depth += 1
        const schemaName = schema.name
        if (extractor) {
          const nestedSchemaExtractor = new _SchemaExtractor(schema)
          builder.iterator = nestedSchemaExtractor
          const nestedSchema = SchemaBuilder.getSchema(schemaName, nestedSchemaExtractor, builder)
          for (const nestedSubSchemaName in nestedSchema.components.schemas) {
            if (nestedSchema.components.schemas.hasOwnProperty(nestedSubSchemaName)) {
              builder.schema.components.schemas[nestedSubSchemaName] =
                nestedSchema.components.schemas[nestedSubSchemaName]
            }
          }
          return true
        }
        if (!builder.shouldExtractSchema(schemaName, depth)) {
          return false
        }
        if (schema.fields?.[Symbol.iterator]) {
          for (const field of schema.fields) {
            if (!this.extractProperty(field, schemaName, field.name, builder, depth)) {
              log.warn(
                'DSM: Unable to extract field with name: %s from Avro schema with name: %s',
                field.name,
                schemaName
              )
            }
          }
        } else {
          log.warn('DSM: schema.fields is not iterable from Avro schema with name: %s', schemaName)
        }
        return true
      }
      static extractSchemas(descriptor, dataStreamsProcessor) {
        return dataStreamsProcessor.getSchema(descriptor.name, new _SchemaExtractor(descriptor))
      }
      iterateOverSchema(builder) {
        this.constructor.extractSchema(this.schema, builder, 0)
      }
      static attachSchemaOnSpan(args, span, operation, tracer2) {
        const { messageClass } = args
        const descriptor = messageClass?.constructor?.type ?? messageClass
        if (!descriptor || !span) {
          return
        }
        if (span.context()._tags[SCHEMA_TYPE] && operation === 'serialization') {
          return
        }
        span.setTag(SCHEMA_TYPE, AVRO)
        span.setTag(SCHEMA_NAME, descriptor.name)
        span.setTag(SCHEMA_OPERATION, operation)
        if (!tracer2._dataStreamsProcessor.canSampleSchema(operation)) {
          return
        }
        if (!tracer2._prioritySampler.isSampled(span)) {
          return
        }
        const weight = tracer2._dataStreamsProcessor.trySampleSchema(operation)
        if (weight === 0) {
          return
        }
        const schemaData = SchemaBuilder.getSchemaDefinition(
          this.extractSchemas(descriptor, tracer2._dataStreamsProcessor)
        )
        span.setTag(SCHEMA_DEFINITION, schemaData.definition)
        span.setTag(SCHEMA_WEIGHT, weight)
        span.setTag(SCHEMA_ID, schemaData.id)
      }
    }
    module2.exports = SchemaExtractor
  },
})

// node_modules/dd-trace/packages/datadog-plugin-avsc/src/index.js
var require_src28 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-avsc/src/index.js'(exports2, module2) {
    'use strict'
    var SchemaPlugin = require_schema2()
    var SchemaExtractor = require_schema_iterator()
    var AvscPlugin = class extends SchemaPlugin {
      static id = 'avsc'
      static schemaExtractor = SchemaExtractor
    }
    module2.exports = AvscPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js
var require_log_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js'(exports2, module2) {
    'use strict'
    var { LOG } = require_formats()
    var Plugin = require_plugin()
    var { storage } = require_datadog_core()
    function messageProxy(message, holder) {
      return new Proxy(message, {
        get(target, key) {
          if (shouldOverride(target, key)) {
            return holder.dd
          }
          return target[key]
        },
        ownKeys(target) {
          const ownKeys = Reflect.ownKeys(target)
          if (!Object.hasOwn(target, 'dd') && Reflect.isExtensible(target)) {
            ownKeys.push('dd')
          }
          return ownKeys
        },
        getOwnPropertyDescriptor(target, p) {
          return Reflect.getOwnPropertyDescriptor(shouldOverride(target, p) ? holder : target, p)
        },
      })
    }
    function shouldOverride(target, p) {
      return p === 'dd' && !Object.hasOwn(target, p) && Reflect.isExtensible(target)
    }
    module2.exports = class LogPlugin extends Plugin {
      constructor(...args) {
        super(...args)
        this.addSub(`apm:${this.constructor.id}:log`, (arg) => {
          const span = storage('legacy').getStore()?.span
          const holder = {}
          this.tracer.inject(span, LOG, holder)
          arg.message = messageProxy(arg.message, holder)
        })
      }
      configure(config) {
        return super.configure({
          ...config,
          enabled: config.enabled && (config.logInjection || config.ciVisAgentlessLogSubmissionEnabled),
        })
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js
var require_src29 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js'(exports2, module2) {
    'use strict'
    var LogPlugin = require_log_plugin()
    var BunyanPlugin = class extends LogPlugin {
      static id = 'bunyan'
    }
    module2.exports = BunyanPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js
var require_src30 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js'(exports2, module2) {
    'use strict'
    var DatabasePlugin = require_database()
    var CASSANDRA_CONTACT_POINTS_KEY = 'db.cassandra.contact.points'
    var CassandraDriverPlugin = class extends DatabasePlugin {
      static id = 'cassandra-driver'
      static system = 'cassandra'
      static peerServicePrecursors = [CASSANDRA_CONTACT_POINTS_KEY]
      bindStart(ctx) {
        let { keyspace, query, contactPoints = {} } = ctx
        if (Array.isArray(query)) {
          query = combine(query)
        }
        this.startSpan(
          this.operationName(),
          {
            service: this.serviceName({ pluginConfig: this.config, system: this.system }),
            resource: trim(query, 5e3),
            type: 'cassandra',
            kind: 'client',
            meta: {
              'db.type': 'cassandra',
              'cassandra.query': query,
              'cassandra.keyspace': keyspace,
              [CASSANDRA_CONTACT_POINTS_KEY]: contactPoints.join(',') || null,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    function combine(queries) {
      return queries.map((query) => (query.query || query).replace(/;?$/, ';')).join(' ')
    }
    function trim(str, size) {
      if (!str || str.length <= size) return str
      return `${str.slice(0, size - 3)}...`
    }
    module2.exports = CassandraDriverPlugin
  },
})

// node_modules/dd-trace/vendor/dist/shell-quote/index.js
var require_shell_quote = __commonJS({
  'node_modules/dd-trace/vendor/dist/shell-quote/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e = {
          './shell-quote/parse.js': function (e2) {
            for (
              var t2 = '(?:\\|\\||\\&\\&|;;|\\|\\&|\\<\\(|\\<\\<\\<|>>|>\\&|<\\&|[&;()|<>])',
                r2 = RegExp('^' + t2 + '$'),
                n2 = '|&;()<> \\t',
                o = /^#$/,
                i = '',
                s = 0;
              s < 4;
              s++
            )
              i += (4294967296 * Math.random()).toString(16)
            var a = RegExp('^' + i)
            e2.exports = function (e3, s2, u) {
              var c = (function (e4, s3, a2) {
                a2 || (a2 = {})
                var u2 = a2.escape || '\\',
                  c2 = (function (e5, t3) {
                    for (var r3, n3 = t3.lastIndex, o2 = []; (r3 = t3.exec(e5)); )
                      (o2.push(r3), t3.lastIndex === r3.index && (t3.lastIndex += 1))
                    return ((t3.lastIndex = n3), o2)
                  })(
                    e4,
                    RegExp(
                      [
                        '(' + t2 + ')',
                        '(' +
                          ('(\\' + u2 + `['"` + n2 + `]|[^\\s'"` + n2) +
                          `])+|"((\\\\"|[^"])*?)"|'((\\\\'|[^'])*?)')+`,
                      ].join('|'),
                      'g'
                    )
                  )
                if (0 === c2.length) return []
                s3 || (s3 = {})
                var f = false
                return c2
                  .map(function (t3) {
                    var n3,
                      a3 = t3[0]
                    if (a3 && !f) {
                      if (r2.test(a3)) return { op: a3 }
                      var c3 = false,
                        l = false,
                        p = '',
                        x = false
                      for (n3 = 0; n3 < a3.length; n3++) {
                        var v = a3.charAt(n3)
                        if (((x = x || (!c3 && ('*' === v || '?' === v))), l)) ((p += v), (l = false))
                        else if (c3)
                          v === c3
                            ? (c3 = false)
                            : "'" == c3
                              ? (p += v)
                              : v === u2
                                ? ((n3 += 1),
                                  '"' === (v = a3.charAt(n3)) || v === u2 || '$' === v ? (p += v) : (p += u2 + v))
                                : '$' === v
                                  ? (p += g())
                                  : (p += v)
                        else if ('"' === v || "'" === v) c3 = v
                        else if (r2.test(v)) return { op: a3 }
                        else if (o.test(v)) {
                          f = true
                          var d = { comment: e4.slice(t3.index + n3 + 1) }
                          if (p.length) return [p, d]
                          return [d]
                        } else v === u2 ? (l = true) : '$' === v ? (p += g()) : (p += v)
                      }
                      return x ? { op: 'glob', pattern: p } : p
                    }
                    function g() {
                      n3 += 1
                      var e5,
                        t4,
                        r3,
                        o2,
                        u3,
                        c4 = a3.charAt(n3)
                      if ('{' === c4) {
                        if (((n3 += 1), '}' === a3.charAt(n3)))
                          throw Error('Bad substitution: ' + a3.slice(n3 - 2, n3 + 1))
                        if ((o2 = a3.indexOf('}', n3)) < 0) throw Error('Bad substitution: ' + a3.slice(n3))
                        ;((u3 = a3.slice(n3, o2)), (n3 = o2))
                      } else if (/[*@#?$!_-]/.test(c4)) ((u3 = c4), (n3 += 1))
                      else {
                        var f2 = a3.slice(n3)
                        ;(o2 = f2.match(/[^\w\d_]/))
                          ? ((u3 = f2.slice(0, o2.index)), (n3 += o2.index - 1))
                          : ((u3 = f2), (n3 = a3.length))
                      }
                      return (
                        (e5 = s3),
                        (t4 = u3),
                        (void 0 === (r3 = 'function' == typeof e5 ? e5(t4) : e5[t4]) && '' != t4
                          ? (r3 = '')
                          : void 0 === r3 && (r3 = '$'),
                        'object' == typeof r3)
                          ? '' + i + JSON.stringify(r3) + i
                          : '' + r3
                      )
                    }
                  })
                  .reduce(function (e5, t3) {
                    return void 0 === t3 ? e5 : e5.concat(t3)
                  }, [])
              })(e3, s2, u)
              return 'function' != typeof s2
                ? c
                : c.reduce(function (e4, t3) {
                    if ('object' == typeof t3) return e4.concat(t3)
                    var r3 = t3.split(RegExp('(' + i + '.*?' + i + ')', 'g'))
                    return 1 === r3.length
                      ? e4.concat(r3[0])
                      : e4.concat(
                          r3.filter(Boolean).map(function (e5) {
                            return a.test(e5) ? JSON.parse(e5.split(i)[1]) : e5
                          })
                        )
                  }, [])
            }
          },
          './shell-quote/quote.js': function (e2) {
            e2.exports = function (e3) {
              return e3
                .map(function (e4) {
                  return '' === e4
                    ? "''"
                    : e4 && 'object' == typeof e4
                      ? e4.op.replace(/(.)/g, '\\$1')
                      : /["\s\\]/.test(e4) && !/'/.test(e4)
                        ? "'" + e4.replace(/(['])/g, '\\$1') + "'"
                        : /["'\s]/.test(e4)
                          ? '"' + e4.replace(/(["\\$`!])/g, '\\$1') + '"'
                          : String(e4).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, '$1\\$2')
                })
                .join(' ')
            }
          },
        },
        t = {}
      function r(n2) {
        var o = t[n2]
        if (void 0 !== o) return o.exports
        var i = (t[n2] = { exports: {} })
        return (e[n2](i, i.exports, r), i.exports)
      }
      var n = {}
      ;((n.quote = r('./shell-quote/quote.js')), (n.parse = r('./shell-quote/parse.js')), (module2.exports = n))
    })()
  },
})

// node_modules/dd-trace/packages/datadog-plugin-child_process/src/scrub-cmd-params.js
var require_scrub_cmd_params = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-child_process/src/scrub-cmd-params.js'(exports2, module2) {
    'use strict'
    var shellParser = require_shell_quote().parse
    var ALLOWED_ENV_VARIABLES = /* @__PURE__ */ new Set(['LD_PRELOAD', 'LD_LIBRARY_PATH', 'PATH'])
    var PROCESS_DENYLIST = /* @__PURE__ */ new Set(['md5'])
    var VARNAMES_REGEX = /\$([\w\d_]*)(?:[^\w\d_]|$)/gim
    var PARAM_PATTERN =
      '^-{0,2}(?:p(?:ass(?:w(?:or)?d)?)?|address|api[-_]?key|e?mail|secret(?:[-_]?key)?|a(?:ccess|uth)[-_]?token|mysql_pwd|credentials|(?:stripe)?token)$'
    var regexParam = new RegExp(PARAM_PATTERN, 'i')
    var ENV_PATTERN = String.raw`^(\w+=\w+;)*\w+=\w+;?$`
    var envVarRegex = new RegExp(ENV_PATTERN)
    var REDACTED = '?'
    function extractVarNames(expression) {
      const varNames = /* @__PURE__ */ new Set()
      let match
      while ((match = VARNAMES_REGEX.exec(expression))) {
        varNames.add(match[1])
      }
      const varNamesObject = {}
      for (const varName of varNames.keys()) {
        varNamesObject[varName] = `$${varName}`
      }
      return varNamesObject
    }
    function getTokensByExpression(expressionTokens) {
      const expressionListTokens = []
      let wipExpressionTokens = []
      let isNewExpression = true
      expressionTokens.forEach((token) => {
        if (isNewExpression) {
          expressionListTokens.push(wipExpressionTokens)
          isNewExpression = false
        }
        wipExpressionTokens.push(token)
        if (token.op) {
          wipExpressionTokens = []
          isNewExpression = true
        }
      })
      return expressionListTokens
    }
    function scrubChildProcessCmd(expression) {
      const varNames = extractVarNames(expression)
      const expressionTokens = shellParser(expression, varNames)
      const expressionListTokens = getTokensByExpression(expressionTokens)
      const result = []
      expressionListTokens.forEach((expressionTokens2) => {
        let foundBinary = false
        for (let index = 0; index < expressionTokens2.length; index++) {
          const token = expressionTokens2[index]
          if (token === null) {
            continue
          } else if (typeof token === 'object') {
            if (token.pattern) {
              result.push(token.pattern)
            } else if (token.op) {
              result.push(token.op)
            } else if (token.comment) {
              result.push(`#${token.comment}`)
            }
          } else if (foundBinary) {
            const paramKeyValue = token.split('=')
            const paramKey = paramKeyValue[0]
            if (regexParam.test(paramKey)) {
              if (paramKeyValue.length === 1) {
                expressionTokens2[index + 1] = REDACTED
                result.push(token)
              } else {
                result.push(`${paramKey}=${REDACTED}`)
              }
            } else {
              result.push(token)
            }
          } else {
            if (envVarRegex.test(token)) {
              const envSplit = token.split('=')
              if (ALLOWED_ENV_VARIABLES.has(envSplit[0])) {
                result.push(token)
              } else {
                envSplit[1] = REDACTED
                const newToken = envSplit.join('=')
                expressionTokens2[index] = newToken
                result.push(newToken)
              }
            } else {
              foundBinary = true
              result.push(token)
              if (PROCESS_DENYLIST.has(token)) {
                for (index++; index < expressionTokens2.length; index++) {
                  const token2 = expressionTokens2[index]
                  if (token2.op) {
                    result.push(token2.op)
                  } else {
                    expressionTokens2[index] = REDACTED
                    result.push(REDACTED)
                  }
                }
                break
              }
            }
          }
        }
      })
      return result
    }
    module2.exports = scrubChildProcessCmd
  },
})

// node_modules/dd-trace/packages/datadog-plugin-child_process/src/index.js
var require_src31 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-child_process/src/index.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var scrubChildProcessCmd = require_scrub_cmd_params()
    var MAX_ARG_SIZE = 4096
    function truncateCommand(cmdFields) {
      let size = cmdFields[0].length
      let truncated = false
      for (let i = 1; i < cmdFields.length; i++) {
        if (size >= MAX_ARG_SIZE) {
          truncated = true
          cmdFields[i] = ''
          continue
        }
        const argLen = cmdFields[i].length
        if (size < MAX_ARG_SIZE && size + argLen > MAX_ARG_SIZE) {
          cmdFields[i] = cmdFields[i].slice(0, 2)
          truncated = true
        }
        size += argLen
      }
      return truncated
    }
    var ChildProcessPlugin = class extends TracingPlugin {
      static id = 'child_process'
      static prefix = 'tracing:datadog:child_process:execution'
      get tracer() {
        return this._tracer
      }
      start(ctx) {
        const { command, shell } = ctx
        if (typeof command !== 'string') {
          return
        }
        const cmdFields = scrubChildProcessCmd(command)
        const truncated = truncateCommand(cmdFields)
        const property = shell === true ? 'cmd.shell' : 'cmd.exec'
        const meta = {
          component: 'subprocess',
          [property]: shell === true ? cmdFields.join(' ') : JSON.stringify(cmdFields),
        }
        if (truncated) {
          meta['cmd.truncated'] = `${truncated}`
        }
        this.startSpan(
          'command_execution',
          {
            service: this.config.service || this._tracerConfig.service,
            resource: shell === true ? 'sh' : cmdFields[0],
            type: 'system',
            meta,
          },
          ctx
        )
        return ctx.currentStore
      }
      end(ctx) {
        const { result, error } = ctx
        let exitCode
        if (result !== void 0) {
          exitCode = result?.status || 0
        } else if (error === void 0) {
          return
        } else {
          exitCode = error?.status || error?.code || 0
        }
        const span = ctx.currentStore?.span || this.activeSpan
        span?.setTag('cmd.exit_code', `${exitCode}`)
        span?.finish()
        return ctx.parentStore
      }
      error(ctx) {
        const { error } = ctx
        const span = ctx.currentStore?.span || this.activeSpan
        this.addError(error, span)
        return ctx.parentStore
      }
      asyncEnd(ctx) {
        const { result } = ctx
        const span = ctx.currentStore?.span || this.activeSpan
        span?.setTag('cmd.exit_code', `${result}`)
        span?.finish()
        return ctx.parentStore
      }
    }
    module2.exports = ChildProcessPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js
var require_src32 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js'(exports2, module2) {
    'use strict'
    var RouterPlugin = require_src15()
    var ConnectPlugin = class extends RouterPlugin {
      static id = 'connect'
      constructor(...args) {
        super(...args)
        this.addSub('apm:connect:request:handle', ({ req }) => {
          this.setFramework(req, 'connect', this.config)
        })
      }
    }
    module2.exports = ConnectPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js
var require_src33 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js'(exports2, module2) {
    'use strict'
    var StoragePlugin = require_storage5()
    var { storage } = require_datadog_core()
    var CouchBasePlugin = class extends StoragePlugin {
      static id = 'couchbase'
      static peerServicePrecursors = ['db.couchbase.seed.nodes']
      addBinds(func, start) {
        this.addBind(`apm:couchbase:${func}:start`, start)
        this.addSub(`apm:couchbase:${func}:error`, ({ error }) => this.addError(error))
        this.addSub(`apm:couchbase:${func}:finish`, (ctx) => this.finish(ctx))
        this.addBind(`apm:couchbase:${func}:callback:start`, callbackStart)
        this.addBind(`apm:couchbase:${func}:callback:finish`, callbackFinish)
      }
      startSpan(operation, customTags, { bucket, collection, seedNodes }, ctx) {
        const tags = {
          'db.type': 'couchbase',
          component: 'couchbase',
          'resource.name': `couchbase.${operation}`,
          'span.kind': this.constructor.kind,
          'db.couchbase.seed.nodes': seedNodes,
        }
        if (bucket) tags['couchbase.bucket.name'] = bucket.name
        if (collection) tags['couchbase.collection.name'] = collection.name
        for (const tag in customTags) {
          tags[tag] = customTags[tag]
        }
        return super.startSpan(
          this.operationName({ operation }),
          {
            service: this.serviceName({ pluginConfig: this.config }),
            meta: tags,
          },
          ctx
        )
      }
      constructor(...args) {
        super(...args)
        this.addBinds('query', (ctx) => {
          const { resource, bucket, seedNodes } = ctx
          this.startSpan(
            'query',
            {
              'span.type': 'sql',
              'resource.name': resource,
              'span.kind': this.constructor.kind,
            },
            { bucket, seedNodes },
            ctx
          )
          return ctx.currentStore
        })
        this.addBind('apm:couchbase:bucket:maybeInvoke:callback:start', callbackStart)
        this.addBind('apm:couchbase:bucket:maybeInvoke:callback:finish', callbackFinish)
        this.addBind('apm:couchbase:cluster:maybeInvoke:callback:start', callbackStart)
        this.addBind('apm:couchbase:cluster:maybeInvoke:callback:finish', callbackFinish)
        this._addCommandSubs('upsert')
        this._addCommandSubs('insert')
        this._addCommandSubs('replace')
        this._addCommandSubs('append')
        this._addCommandSubs('prepend')
      }
      _addCommandSubs(name) {
        this.addBinds(name, (ctx) => {
          const { bucket, collection, seedNodes } = ctx
          this.startSpan(name, {}, { bucket, collection, seedNodes }, ctx)
          return ctx.currentStore
        })
      }
    }
    function callbackStart(ctx) {
      ctx.parentStore = storage('legacy').getStore()
      return ctx.parentStore
    }
    function callbackFinish(ctx) {
      return ctx.parentStore
    }
    module2.exports = CouchBasePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js
var require_src34 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var CypressPlugin = class extends Plugin {
      static id = 'cypress'
    }
    module2.exports = CypressPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup.js
var require_lookup = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var DNSLookupPlugin = class extends ClientPlugin {
      static id = 'dns'
      static operation = 'lookup'
      bindStart(ctx) {
        const [hostname] = ctx.args
        this.startSpan(
          'dns.lookup',
          {
            service: this.config.service,
            resource: hostname,
            kind: 'client',
            meta: {
              'dns.hostname': hostname,
              'dns.address': '',
              'dns.addresses': '',
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      bindFinish(ctx) {
        const span = ctx.currentStore.span
        const result = ctx.result
        if (Array.isArray(result)) {
          const addresses = Array.isArray(result) ? result.map((address) => address.address).sort() : [result]
          span.setTag('dns.address', addresses[0])
          span.setTag('dns.addresses', addresses.join(','))
        } else {
          span.setTag('dns.address', result)
        }
        return ctx.parentStore
      }
    }
    module2.exports = DNSLookupPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup_service.js
var require_lookup_service = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup_service.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var DNSLookupServicePlugin = class extends ClientPlugin {
      static id = 'dns'
      static operation = 'lookup_service'
      bindStart(ctx) {
        const [address, port] = ctx.args
        this.startSpan(
          'dns.lookup_service',
          {
            service: this.config.service,
            resource: `${address}:${port}`,
            kind: 'client',
            meta: {
              'dns.address': address,
            },
            metrics: {
              'dns.port': port,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = DNSLookupServicePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-dns/src/resolve.js
var require_resolve = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-dns/src/resolve.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var DNSResolvePlugin = class extends ClientPlugin {
      static id = 'dns'
      static operation = 'resolve'
      bindStart(ctx) {
        const [hostname, maybeType] = ctx.args
        const rrtype = typeof maybeType === 'string' ? maybeType : 'A'
        this.startSpan(
          'dns.resolve',
          {
            service: this.config.service,
            resource: `${rrtype} ${hostname}`,
            kind: 'client',
            meta: {
              'dns.hostname': hostname,
              'dns.rrtype': rrtype,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = DNSResolvePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-dns/src/reverse.js
var require_reverse = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-dns/src/reverse.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var DNSReversePlugin = class extends ClientPlugin {
      static id = 'dns'
      static operation = 'reverse'
      bindStart(ctx) {
        const [ip] = ctx.args
        this.startSpan(
          'dns.reverse',
          {
            service: this.config.service,
            resource: ip,
            kind: 'client',
            meta: {
              'dns.ip': ip,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = DNSReversePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js
var require_src35 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var DNSLookupPlugin = require_lookup()
    var DNSLookupServicePlugin = require_lookup_service()
    var DNSResolvePlugin = require_resolve()
    var DNSReversePlugin = require_reverse()
    var DNSPlugin = class extends CompositePlugin {
      static id = 'dns'
      static get plugins() {
        return {
          lookup: DNSLookupPlugin,
          lookup_service: DNSLookupServicePlugin,
          resolve: DNSResolvePlugin,
          reverse: DNSReversePlugin,
        }
      }
    }
    module2.exports = DNSPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-dd-trace-api/src/index.js
var require_src36 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-dd-trace-api/src/index.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var telemetryMetrics = require_metrics()
    var apiMetrics = telemetryMetrics.manager.namespace('tracers')
    var { getEnvironmentVariable } = require_config_helper()
    var objectMap = /* @__PURE__ */ new WeakMap()
    var injectionEnabledTag = `injection_enabled:${getEnvironmentVariable('DD_INJECTION_ENABLED') ? 'yes' : 'no'}`
    module2.exports = class DdTraceApiPlugin extends Plugin {
      static id = 'dd-trace-api'
      constructor(...args) {
        super(...args)
        const tracer2 = this._tracer
        this.addSub('datadog-api:v1:tracerinit', ({ proxy }) => {
          const proxyVal = proxy()
          objectMap.set(proxyVal, tracer2)
          objectMap.set(proxyVal.appsec, tracer2.appsec)
          objectMap.set(proxyVal.dogstatsd, tracer2.dogstatsd)
        })
        const handleEvent = (name) => {
          const counter = apiMetrics.count('public_api.called', [
            `name:${name.replaceAll(':', '.')}`,
            'api_version:v1',
            injectionEnabledTag,
          ])
          this.addSub(`datadog-api:v1:${name}`, ({ self: self2, args: args2, ret, proxy, revProxy }) => {
            counter.inc()
            if (name.includes(':')) {
              name = name.split(':').pop()
            }
            if (objectMap.has(self2)) {
              self2 = objectMap.get(self2)
            }
            for (let i = 0; i < args2.length; i++) {
              if (objectMap.has(args2[i])) {
                args2[i] = objectMap.get(args2[i])
              }
              if (typeof args2[i] === 'function') {
                const orig = args2[i]
                args2[i] = (...fnArgs) => {
                  for (let j = 0; j < fnArgs.length; j++) {
                    if (revProxy && revProxy[j]) {
                      const proxyVal = revProxy[j]()
                      objectMap.set(proxyVal, fnArgs[j])
                      fnArgs[j] = proxyVal
                    }
                  }
                  return orig(...fnArgs)
                }
              }
            }
            try {
              ret.value = self2[name](...args2)
              if (proxy) {
                const proxyVal = proxy()
                objectMap.set(proxyVal, ret.value)
                ret.value = proxyVal
              }
            } catch (e) {
              ret.error = e
            }
          })
        }
        handleEvent('startSpan')
        handleEvent('wrap')
        handleEvent('trace')
        handleEvent('inject')
        handleEvent('extract')
        handleEvent('getRumData')
        handleEvent('profilerStarted')
        handleEvent('context:toTraceId')
        handleEvent('context:toSpanId')
        handleEvent('context:toTraceparent')
        handleEvent('span:context')
        handleEvent('span:setTag')
        handleEvent('span:addTags')
        handleEvent('span:finish')
        handleEvent('span:addLink')
        handleEvent('scope')
        handleEvent('scope:activate')
        handleEvent('scope:active')
        handleEvent('scope:bind')
        handleEvent('appsec:blockRequest')
        handleEvent('appsec:isUserBlocked')
        handleEvent('appsec:setUser')
        handleEvent('appsec:trackCustomEvent')
        handleEvent('appsec:trackUserLoginFailureEvent')
        handleEvent('appsec:trackUserLoginSuccessEvent')
        handleEvent('dogstatsd:decrement')
        handleEvent('dogstatsd:distribution')
        handleEvent('dogstatsd:flush')
        handleEvent('dogstatsd:gauge')
        handleEvent('dogstatsd:histogram')
        handleEvent('dogstatsd:increment')
        handleEvent('use')
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-express/src/tracing.js
var require_tracing8 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-express/src/tracing.js'(exports2, module2) {
    'use strict'
    var RouterPlugin = require_src15()
    var ExpressTracingPlugin = class extends RouterPlugin {
      static id = 'express'
      constructor(...args) {
        super(...args)
        this.addSub('apm:express:request:handle', ({ req }) => {
          this.setFramework(req, 'express', this.config)
        })
      }
    }
    module2.exports = ExpressTracingPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-express/src/code_origin.js
var require_code_origin = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-express/src/code_origin.js'(exports2, module2) {
    'use strict'
    var { entryTags } = require_datadog_code_origin()
    var Plugin = require_plugin()
    var web = require_web3()
    var ExpressCodeOriginForSpansPlugin = class extends Plugin {
      static id = 'express'
      constructor(...args) {
        super(...args)
        const layerTags = /* @__PURE__ */ new WeakMap()
        this.addSub('apm:express:middleware:enter', ({ req, layer }) => {
          const tags = layerTags.get(layer)
          if (!tags) return
          web.getContext(req)?.span?.addTags(tags)
        })
        this.addSub('apm:express:route:added', ({ topOfStackFunc, layer }) => {
          if (!layer) return
          if (layerTags.has(layer)) return
          layerTags.set(layer, entryTags(topOfStackFunc))
        })
        this.addSub('apm:router:middleware:enter', ({ req, layer }) => {
          const tags = layerTags.get(layer)
          if (!tags) return
          web.getContext(req)?.span?.addTags(tags)
        })
        this.addSub('apm:router:route:added', ({ topOfStackFunc, layer }) => {
          if (!layer) return
          if (layerTags.has(layer)) return
          layerTags.set(layer, entryTags(topOfStackFunc))
        })
      }
    }
    module2.exports = ExpressCodeOriginForSpansPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-express/src/index.js
var require_src37 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-express/src/index.js'(exports2, module2) {
    'use strict'
    var ExpressTracingPlugin = require_tracing8()
    var ExpressCodeOriginForSpansPlugin = require_code_origin()
    var CompositePlugin = require_composite()
    var ExpressPlugin = class extends CompositePlugin {
      static id = 'express'
      static get plugins() {
        return {
          tracing: ExpressTracingPlugin,
          codeOriginForSpans: ExpressCodeOriginForSpansPlugin,
        }
      }
    }
    module2.exports = ExpressPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-fastify/src/tracing.js
var require_tracing9 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-fastify/src/tracing.js'(exports2, module2) {
    'use strict'
    var RouterPlugin = require_src15()
    var { storage } = require_datadog_core()
    var FastifyTracingPlugin = class extends RouterPlugin {
      static id = 'fastify'
      constructor(...args) {
        super(...args)
        this.addSub('apm:fastify:request:handle', ({ req }) => {
          this.setFramework(req, 'fastify', this.config)
        })
        this.addBind('datadog:fastify:pre-parsing:start', getParentStore)
        this.addBind('datadog:fastify:pre-validation:start', getParentStore)
        this.addSub('datadog:fastify:pre-parsing:finish', (ctx) => {
          return ctx.parentStore
        })
        this.addSub('datadog:fastify:pre-validation:finish', (ctx) => {
          return ctx.parentStore
        })
        this.addSub('datadog:fastify:callback:execute', getParentStore)
      }
    }
    function getParentStore(ctx) {
      ctx.parentStore = ctx.parentStore ?? storage('legacy').getStore()
      return ctx.parentStore
    }
    module2.exports = FastifyTracingPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-fastify/src/code_origin.js
var require_code_origin2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-fastify/src/code_origin.js'(exports2, module2) {
    'use strict'
    var { entryTags } = require_datadog_code_origin()
    var Plugin = require_plugin()
    var web = require_web3()
    var kCodeOriginForSpansTagsSym = /* @__PURE__ */ Symbol('datadog.codeOriginForSpansTags')
    var FastifyCodeOriginForSpansPlugin = class extends Plugin {
      static id = 'fastify'
      constructor(...args) {
        super(...args)
        this.addSub('apm:fastify:request:handle', ({ req, routeConfig }) => {
          const tags = routeConfig?.[kCodeOriginForSpansTagsSym]
          if (!tags) return
          web.getContext(req)?.span?.addTags(tags)
        })
        this.addSub('apm:fastify:route:added', ({ routeOptions, onRoute }) => {
          if (!routeOptions.config) routeOptions.config = {}
          routeOptions.config[kCodeOriginForSpansTagsSym] = entryTags(onRoute)
        })
      }
    }
    module2.exports = FastifyCodeOriginForSpansPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js
var require_src38 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js'(exports2, module2) {
    'use strict'
    var FastifyTracingPlugin = require_tracing9()
    var FastifyCodeOriginForSpansPlugin = require_code_origin2()
    var CompositePlugin = require_composite()
    var FastifyPlugin = class extends CompositePlugin {
      static id = 'fastify'
      static get plugins() {
        return {
          tracing: FastifyTracingPlugin,
          codeOriginForSpans: FastifyCodeOriginForSpansPlugin,
        }
      }
    }
    module2.exports = FastifyPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-find-my-way/src/index.js
var require_src39 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-find-my-way/src/index.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var web = require_web3()
    var FindMyWayPlugin = class extends Plugin {
      static id = 'find-my-way'
      constructor(...args) {
        super(...args)
        this.addSub('apm:find-my-way:request:route', ({ req, route }) => {
          web.setRoute(req, route)
        })
      }
    }
    module2.exports = FindMyWayPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-http/src/client.js
var require_client10 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-http/src/client.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var { storage } = require_datadog_core()
    var tags = require_tags()
    var analyticsSampler = require_analytics_sampler()
    var formats = require_formats()
    var HTTP_HEADERS = formats.HTTP_HEADERS
    var urlFilter = require_urlfilter()
    var log = require_log2()
    var { CLIENT_PORT_KEY, COMPONENT, ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants2()
    var { URL: URL2 } = require('url')
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
    var HttpClientPlugin = class extends ClientPlugin {
      static id = 'http'
      static prefix = 'apm:http:client:request'
      bindStart(message) {
        const { args, http = {} } = message
        const store = storage('legacy').getStore()
        const options = args.options
        const agent = options.agent || options._defaultAgent || http.globalAgent || {}
        const protocol = options.protocol || agent.protocol || 'http:'
        const hostname = options.hostname || options.host || 'localhost'
        const host = options.port ? `${hostname}:${options.port}` : hostname
        const pathname = options.path || options.pathname
        const path = pathname ? pathname.split(/[?#]/)[0] : '/'
        const uri = `${protocol}//${host}${path}`
        const allowed = this.config.filter(uri)
        const method = (options.method || 'GET').toUpperCase()
        const childOf = store && allowed ? store.span : null
        const span = this.startSpan(
          this.operationName(),
          {
            childOf,
            integrationName: this.constructor.id,
            meta: {
              [COMPONENT]: this.constructor.id,
              'span.kind': 'client',
              'service.name': this.serviceName({
                pluginConfig: this.config,
                sessionDetails: extractSessionDetails(options),
              }),
              'resource.name': method,
              'span.type': 'http',
              'http.method': method,
              'http.url': uri,
              'out.host': hostname,
            },
            metrics: {
              [CLIENT_PORT_KEY]: Number.parseInt(options.port),
            },
          },
          false
        )
        if (!allowed) {
          span._spanContext._trace.record = false
        }
        if (this.shouldInjectTraceHeaders(options, uri)) {
          options.headers = { ...options.headers }
          this.tracer.inject(span, HTTP_HEADERS, options.headers)
        }
        analyticsSampler.sample(span, this.config.measured)
        message.span = span
        message.parentStore = store
        message.currentStore = { ...store, span }
        return message.currentStore
      }
      shouldInjectTraceHeaders(options, uri) {
        if (!this.config.propagationFilter(uri)) {
          return false
        }
        return true
      }
      bindAsyncStart({ parentStore }) {
        return parentStore
      }
      finish(ctx) {
        const { req, res, span } = ctx
        if (!span) return
        if (res) {
          const status = res.status || res.statusCode
          span.setTag(HTTP_STATUS_CODE, status)
          if (!this.config.validateStatus(status)) {
            span.setTag('error', 1)
          }
          addResponseHeaders(res, span, this.config)
        }
        if (req) {
          addRequestHeaders(req, span, this.config)
        }
        this.config.hooks.request(span, req, res)
        super.finish(ctx)
      }
      error({ span, error, args, customRequestTimeout }) {
        if (!span) return
        if (error) {
          span.addTags({
            [ERROR_TYPE]: error.name,
            [ERROR_MESSAGE]: error.message || error.code,
            [ERROR_STACK]: error.stack,
          })
        } else {
          if (!args.options.agent?.options?.timeout && !customRequestTimeout) return
          span.setTag('error', 1)
        }
      }
      configure(config) {
        return super.configure(normalizeClientConfig(config))
      }
    }
    function addResponseHeaders(res, span, config) {
      if (!res.headers) return
      const headers =
        typeof res.headers.entries === 'function' ? Object.fromEntries(res.headers.entries()) : res.headers
      config.headers.forEach(([key, tag]) => {
        const value = headers[key]
        if (value) {
          span.setTag(tag || `${HTTP_RESPONSE_HEADERS}.${key}`, value)
        }
      })
    }
    function addRequestHeaders(req, span, config) {
      const headers =
        req.headers && typeof req.headers.entries === 'function'
          ? Object.fromEntries(req.headers.entries())
          : req.headers || req.getHeaders()
      config.headers.forEach(([key, tag]) => {
        const value = Array.isArray(headers[key]) ? headers[key].toString() : headers[key]
        if (value) {
          span.setTag(tag || `${HTTP_REQUEST_HEADERS}.${key}`, value)
        }
      })
    }
    function normalizeClientConfig(config) {
      const validateStatus = getStatusValidator(config)
      const filter = getFilter(config)
      const propagationFilter = getFilter({ blocklist: config.propagationBlocklist })
      const headers = getHeaders(config)
      const hooks = getHooks(config)
      return {
        ...config,
        validateStatus,
        filter,
        propagationFilter,
        headers,
        hooks,
      }
    }
    function is400ErrorCode(code) {
      return code < 400 || code >= 500
    }
    function getStatusValidator(config) {
      if (typeof config.validateStatus === 'function') {
        return config.validateStatus
      } else if (config.hasOwnProperty('validateStatus')) {
        log.error('Expected `validateStatus` to be a function.')
      }
      return is400ErrorCode
    }
    function getFilter(config) {
      config = { ...config, blocklist: config.blocklist || [] }
      return urlFilter.getFilter(config)
    }
    function getHeaders(config) {
      if (!Array.isArray(config.headers)) return []
      const result = []
      for (const header of config.headers) {
        if (typeof header === 'string') {
          const separatorIndex = header.indexOf(':')
          result.push(
            separatorIndex === -1
              ? [header, void 0]
              : [header.slice(0, separatorIndex).toLowerCase(), header.slice(separatorIndex + 1)]
          )
        }
      }
      return result
    }
    var noop = () => {}
    function getHooks(config) {
      const request = config.hooks?.request ?? noop
      return { request }
    }
    function extractSessionDetails(options) {
      if (typeof options === 'string') {
        return new URL2(options).host
      }
      const host = options.hostname || options.host || 'localhost'
      const port = options.port
      return { host, port }
    }
    module2.exports = HttpClientPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-fetch/src/index.js
var require_src40 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-fetch/src/index.js'(exports2, module2) {
    'use strict'
    var HttpClientPlugin = require_client10()
    var FetchPlugin = class extends HttpClientPlugin {
      static id = 'fetch'
      static prefix = 'tracing:apm:fetch:request'
      bindStart(ctx) {
        const req = ctx.req
        const options = new URL(req.url)
        options.headers = Object.fromEntries(req.headers.entries())
        options.method = req.method
        ctx.args = { options }
        const store = super.bindStart(ctx)
        for (const name in options.headers) {
          if (!req.headers.has(name)) {
            req.headers.set(name, options.headers[name])
          }
        }
        return store
      }
      error(ctx) {
        if (ctx.error.name === 'AbortError') return
        return super.error(ctx)
      }
      asyncEnd(ctx) {
        ctx.res = ctx.result
        return this.finish(ctx)
      }
    }
    module2.exports = FetchPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/utils.js
var require_utils6 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/utils.js'(exports2, module2) {
    'use strict'
    function extractErrorIntoSpanEvent(config, span, exc) {
      const attributes = {}
      if (exc.name) {
        attributes.type = exc.name
      }
      if (exc.stack) {
        attributes.stacktrace = exc.stack
      }
      if (exc.locations) {
        attributes.locations = []
        for (const location of exc.locations) {
          attributes.locations.push(`${location.line}:${location.column}`)
        }
      }
      if (exc.path) {
        attributes.path = exc.path.map(String)
      }
      if (exc.message) {
        attributes.message = exc.message
      }
      if (config.graphqlErrorExtensions) {
        for (const ext of config.graphqlErrorExtensions) {
          if (exc.extensions?.[ext]) {
            const value = exc.extensions[ext]
            if (typeof value === 'number' || typeof value === 'boolean') {
              attributes[`extensions.${ext}`] = value
            } else {
              attributes[`extensions.${ext}`] = String(value)
            }
          }
        }
      }
      span.addEvent('dd.graphql.query.error', attributes, Date.now())
    }
    module2.exports = {
      extractErrorIntoSpanEvent,
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/execute.js
var require_execute2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/execute.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var { extractErrorIntoSpanEvent } = require_utils6()
    var tools
    var GraphQLExecutePlugin = class extends TracingPlugin {
      static id = 'graphql'
      static operation = 'execute'
      static type = 'graphql'
      static kind = 'server'
      bindStart(ctx) {
        const { operation, args, docSource } = ctx
        const type = operation && operation.operation
        const name = operation && operation.name && operation.name.value
        const document = args.document
        const source = this.config.source && document && docSource
        const span = this.startSpan(
          this.operationName(),
          {
            service: this.config.service || this.serviceName(),
            resource: getSignature(document, name, type, this.config.signature),
            kind: this.constructor.kind,
            type: this.constructor.type,
            meta: {
              'graphql.operation.type': type,
              'graphql.operation.name': name,
              'graphql.source': source,
            },
          },
          ctx
        )
        addVariableTags(this.config, span, args.variableValues)
        return ctx.currentStore
      }
      finish(ctx) {
        const { res, args } = ctx
        const span = ctx?.currentStore?.span || this.activeSpan
        this.config.hooks.execute(span, args, res)
        if (res?.errors) {
          for (const err of res.errors) {
            extractErrorIntoSpanEvent(this._tracerConfig, span, err)
          }
        }
        super.finish(ctx)
        return ctx.parentStore
      }
    }
    function addVariableTags(config, span, variableValues) {
      const tags = {}
      if (variableValues && config.variables) {
        const variables = config.variables(variableValues)
        for (const param in variables) {
          tags[`graphql.variables.${param}`] = variables[param]
        }
      }
      span.addTags(tags)
    }
    function getSignature(document, operationName, operationType, calculate) {
      if (calculate !== false && tools !== false) {
        try {
          try {
            tools = tools || require_tools()
          } catch (e) {
            tools = false
            throw e
          }
          return tools.defaultEngineReportingSignature(document, operationName)
        } catch {}
      }
      return [operationType, operationName].filter(Boolean).join(' ')
    }
    module2.exports = GraphQLExecutePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/parse.js
var require_parse = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/parse.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var GraphQLParsePlugin = class extends TracingPlugin {
      static id = 'graphql'
      static operation = 'parser'
      bindStart(ctx) {
        this.startSpan(
          'graphql.parse',
          {
            service: this.config.service,
            type: 'graphql',
            meta: {},
          },
          ctx
        )
        return ctx.currentStore
      }
      finish(ctx) {
        const { source, document, docSource } = ctx
        const span = ctx?.currentStore?.span || this.activeSpan
        if (this.config.source && document) {
          span.setTag('graphql.source', docSource)
        }
        this.config.hooks.parse(span, source, document)
        super.finish(ctx)
        return ctx.parentStore
      }
    }
    module2.exports = GraphQLParsePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/validate.js
var require_validate2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/validate.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var { extractErrorIntoSpanEvent } = require_utils6()
    var GraphQLValidatePlugin = class extends TracingPlugin {
      static id = 'graphql'
      static operation = 'validate'
      bindStart(ctx) {
        const { docSource, document } = ctx
        const source = this.config.source && document && docSource
        this.startSpan(
          'graphql.validate',
          {
            service: this.config.service,
            type: 'graphql',
            meta: {
              'graphql.source': source,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      finish(ctx) {
        const { document, errors } = ctx
        const span = ctx?.currentStore?.span || this.activeSpan
        this.config.hooks.validate(span, document, errors)
        if (errors) {
          for (const err of errors) {
            extractErrorIntoSpanEvent(this._tracerConfig, span, err)
          }
        }
        super.finish(ctx)
        return ctx.parentStore
      }
    }
    module2.exports = GraphQLValidatePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/resolve.js
var require_resolve2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/resolve.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var dc = require_dc_polyfill()
    var collapsedPathSym = /* @__PURE__ */ Symbol('collapsedPaths')
    var GraphQLResolvePlugin = class extends TracingPlugin {
      static id = 'graphql'
      static operation = 'resolve'
      start(fieldCtx) {
        const { info, rootCtx, args } = fieldCtx
        const path = getPath(info, this.config)
        const parentField = getParentField(rootCtx, pathToArray(info && info.path))
        const childOf = parentField?.ctx?.currentStore?.span
        fieldCtx.parent = parentField
        if (!shouldInstrument(this.config, path)) return
        const computedPathString = path.join('.')
        if (this.config.collapse) {
          if (rootCtx.fields[computedPathString]) return
          if (!rootCtx[collapsedPathSym]) {
            rootCtx[collapsedPathSym] = {}
          } else if (rootCtx[collapsedPathSym][computedPathString]) {
            return
          }
          rootCtx[collapsedPathSym][computedPathString] = true
        }
        const document = rootCtx.source
        const fieldNode = info.fieldNodes.find((fieldNode2) => fieldNode2.kind === 'Field')
        const loc = this.config.source && document && fieldNode && fieldNode.loc
        const source = loc && document.slice(loc.start, loc.end)
        const span = this.startSpan(
          'graphql.resolve',
          {
            service: this.config.service,
            resource: `${info.fieldName}:${info.returnType}`,
            childOf,
            type: 'graphql',
            meta: {
              'graphql.field.name': info.fieldName,
              'graphql.field.path': computedPathString,
              'graphql.field.type': info.returnType.name,
              'graphql.source': source,
            },
          },
          fieldCtx
        )
        if (fieldNode && this.config.variables && fieldNode.arguments) {
          const variables = this.config.variables(info.variableValues)
          fieldNode.arguments
            .filter((arg) => arg.value?.name && arg.value.kind === 'Variable' && variables[arg.value.name.value])
            .forEach((arg) => {
              const name = arg.value.name.value
              span.setTag(`graphql.variables.${name}`, variables[name])
            })
        }
        if (this.resolverStartCh.hasSubscribers) {
          this.resolverStartCh.publish({ ctx: rootCtx, resolverInfo: getResolverInfo(info, args) })
        }
        return fieldCtx.currentStore
      }
      constructor(...args) {
        super(...args)
        this.addTraceSub('updateField', (ctx) => {
          const { field, info, error } = ctx
          const path = getPath(info, this.config)
          if (!shouldInstrument(this.config, path)) return
          const span = ctx?.currentStore?.span || this.activeSpan
          field.finishTime = span._getTime ? span._getTime() : 0
          field.error = field.error || error
        })
        this.resolverStartCh = dc.channel('datadog:graphql:resolver:start')
      }
      configure(config) {
        super.configure(config.depth === 0 ? false : config)
      }
      finish(ctx) {
        const { finishTime } = ctx
        const span = ctx?.currentStore?.span || this.activeSpan
        span.finish(finishTime)
        return ctx.parentStore
      }
    }
    function shouldInstrument(config, path) {
      let depth = 0
      for (const item of path) {
        if (typeof item === 'string') {
          depth += 1
        }
      }
      return config.depth < 0 || config.depth >= depth
    }
    function getPath(info, config) {
      const responsePathAsArray = config.collapse ? withCollapse(pathToArray) : pathToArray
      return responsePathAsArray(info && info.path)
    }
    function pathToArray(path) {
      const flattened = []
      let curr = path
      while (curr) {
        flattened.push(curr.key)
        curr = curr.prev
      }
      return flattened.reverse()
    }
    function withCollapse(responsePathAsArray) {
      return function () {
        return responsePathAsArray
          .apply(this, arguments)
          .map((segment) => (typeof segment === 'number' ? '*' : segment))
      }
    }
    function getResolverInfo(info, args) {
      let resolverInfo = null
      const resolverVars = {}
      if (args) {
        Object.assign(resolverVars, args)
      }
      let hasResolvers = false
      const directives = info.fieldNodes?.[0]?.directives
      if (Array.isArray(directives)) {
        for (const directive of directives) {
          const argList = {}
          for (const argument of directive.arguments) {
            argList[argument.name.value] = argument.value.value
          }
          if (directive.arguments.length > 0) {
            hasResolvers = true
            resolverVars[directive.name.value] = argList
          }
        }
      }
      if (hasResolvers || (args && Object.keys(resolverVars).length)) {
        resolverInfo = { [info.fieldName]: resolverVars }
      }
      return resolverInfo
    }
    function getParentField(parentCtx, path) {
      for (let i = path.length - 1; i > 0; i--) {
        const field = getField(parentCtx, path.slice(0, i))
        if (field) {
          return field
        }
      }
      return null
    }
    function getField(parentCtx, path) {
      return parentCtx.fields[path.join('.')]
    }
    module2.exports = GraphQLResolvePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js
var require_src41 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js'(exports2, module2) {
    'use strict'
    var pick = require_pick()
    var CompositePlugin = require_composite()
    var log = require_log2()
    var GraphQLExecutePlugin = require_execute2()
    var GraphQLParsePlugin = require_parse()
    var GraphQLValidatePlugin = require_validate2()
    var GraphQLResolvePlugin = require_resolve2()
    var GraphQLPlugin = class extends CompositePlugin {
      static id = 'graphql'
      static get plugins() {
        return {
          execute: GraphQLExecutePlugin,
          parse: GraphQLParsePlugin,
          validate: GraphQLValidatePlugin,
          resolve: GraphQLResolvePlugin,
        }
      }
      /**
       * @override
       */
      configure(config) {
        return super.configure(validateConfig(config))
      }
    }
    function validateConfig(config) {
      return {
        ...config,
        depth: getDepth(config),
        variables: getVariablesFilter(config),
        collapse: config.collapse === void 0 || !!config.collapse,
        hooks: getHooks(config),
      }
    }
    function getDepth(config) {
      if (typeof config.depth === 'number') {
        return config.depth
      } else if (config.hasOwnProperty('depth')) {
        log.error('Expected `depth` to be a integer.')
      }
      return -1
    }
    function getVariablesFilter(config) {
      if (typeof config.variables === 'function') {
        return config.variables
      } else if (Array.isArray(config.variables)) {
        return (variables) => pick(variables, config.variables)
      } else if (config.hasOwnProperty('variables')) {
        log.error('Expected `variables` to be an array or function.')
      }
      return null
    }
    var noop = () => {}
    function getHooks({ hooks }) {
      const execute = hooks?.execute ?? noop
      const parse = hooks?.parse ?? noop
      const validate = hooks?.validate ?? noop
      return { execute, parse, validate }
    }
    module2.exports = GraphQLPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-hono/src/index.js
var require_src42 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-hono/src/index.js'(exports2, module2) {
    'use strict'
    var RouterPlugin = require_src15()
    var web = require_web3()
    var HonoPlugin = class extends RouterPlugin {
      static id = 'hono'
      constructor(...args) {
        super(...args)
        this.addSub('apm:hono:request:handle', ({ req }) => {
          this.setFramework(req, 'hono', this.config)
        })
        this.addSub('apm:hono:request:route', ({ req, route }) => {
          web.setRoute(req, route)
        })
        this.addSub('apm:hono:request:error', ({ req, error }) => {
          web.addError(req, error)
        })
      }
    }
    module2.exports = HonoPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/channels.js
var require_channels2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/channels.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    module2.exports = {
      apolloChannel: dc.tracingChannel('datadog:apollo:request'),
      apolloHttpServerChannel: dc.tracingChannel('datadog:apollo:httpserver'),
      apolloServerCoreChannel: dc.tracingChannel('datadog:apollo-server-core:request'),
      bodyParser: dc.channel('datadog:body-parser:read:finish'),
      childProcessExecutionTracingChannel: dc.tracingChannel('datadog:child_process:execution'),
      cookieParser: dc.channel('datadog:cookie-parser:read:finish'),
      expressMiddlewareError: dc.channel('apm:express:middleware:error'),
      expressProcessParams: dc.channel('datadog:express:process_params:start'),
      expressResponseRenderStart: dc.channel('tracing:datadog:express:response:render:start'),
      expressSession: dc.channel('datadog:express-session:middleware:finish'),
      fastifyBodyParser: dc.channel('datadog:fastify:body-parser:finish'),
      fastifyCookieParser: dc.channel('datadog:fastify-cookie:read:finish'),
      fastifyMiddlewareError: dc.channel('apm:fastify:middleware:error'),
      fastifyPathParams: dc.channel('datadog:fastify:path-params:finish'),
      fastifyQueryParams: dc.channel('datadog:fastify:query-params:finish'),
      fastifyResponseChannel: dc.channel('datadog:fastify:response:finish'),
      fsOperationStart: dc.channel('apm:fs:operation:start'),
      graphqlMiddlewareChannel: dc.tracingChannel('datadog:apollo:middleware'),
      httpClientRequestStart: dc.channel('apm:http:client:request:start'),
      incomingHttpRequestEnd: dc.channel('dd-trace:incomingHttpRequestEnd'),
      incomingHttpRequestStart: dc.channel('dd-trace:incomingHttpRequestStart'),
      multerParser: dc.channel('datadog:multer:read:finish'),
      mysql2OuterQueryStart: dc.channel('datadog:mysql2:outerquery:start'),
      nextBodyParsed: dc.channel('apm:next:body-parsed'),
      nextQueryParsed: dc.channel('apm:next:query-parsed'),
      passportUser: dc.channel('datadog:passport:deserializeUser:finish'),
      passportVerify: dc.channel('datadog:passport:verify:finish'),
      pgPoolQueryStart: dc.channel('datadog:pg:pool:query:start'),
      pgQueryStart: dc.channel('apm:pg:query:start'),
      queryParser: dc.channel('datadog:query:read:finish'),
      responseBody: dc.channel('datadog:express:response:json:start'),
      responseSetHeader: dc.channel('datadog:http:server:response:set-header:start'),
      responseWriteHead: dc.channel('apm:http:server:response:writeHead:start'),
      routerParam: dc.channel('datadog:router:param:start'),
      routerMiddlewareError: dc.channel('apm:router:middleware:error'),
      setCookieChannel: dc.channel('datadog:iast:set-cookie'),
      setUncaughtExceptionCaptureCallbackStart: dc.channel('datadog:process:setUncaughtExceptionCaptureCallback:start'),
      startGraphqlResolve: dc.channel('datadog:graphql:resolver:start'),
      wafRunFinished: dc.channel('datadog:waf:run:finish'),
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-http/src/server.js
var require_server7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-http/src/server.js'(exports2, module2) {
    'use strict'
    var ServerPlugin = require_server5()
    var { storage } = require_datadog_core()
    var web = require_web3()
    var { incomingHttpRequestStart, incomingHttpRequestEnd } = require_channels2()
    var { COMPONENT } = require_constants2()
    var HttpServerPlugin = class extends ServerPlugin {
      static id = 'http'
      static prefix = 'apm:http:server:request'
      constructor(...args) {
        super(...args)
        this._parentStore = void 0
        this.addTraceSub('exit', (message) => this.exit(message))
      }
      start({ req, res, abortController }) {
        const store = storage('legacy').getStore()
        const span = web.startSpan(
          this.tracer,
          {
            ...this.config,
            service: this.config.service || this.serviceName(),
          },
          req,
          res,
          this.operationName()
        )
        span.setTag(COMPONENT, this.constructor.id)
        span._integrationName = this.constructor.id
        this._parentStore = store
        this.enter(span, { ...store, req, res })
        const context = web.getContext(req)
        if (!context.instrumented) {
          context.res.writeHead = web.wrapWriteHead(context)
          context.instrumented = true
        }
        if (incomingHttpRequestStart.hasSubscribers) {
          incomingHttpRequestStart.publish({ req, res, abortController })
        }
      }
      error(error) {
        web.addError(error)
      }
      finish({ req }) {
        const context = web.getContext(req)
        if (!context || !context.res) return
        if (incomingHttpRequestEnd.hasSubscribers) {
          incomingHttpRequestEnd.publish({ req, res: context.res })
        }
        web.finishAll(context)
      }
      exit({ req }) {
        const span = this._parentStore && this._parentStore.span
        this.enter(span, this._parentStore)
        this._parentStore = void 0
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config))
      }
    }
    module2.exports = HttpServerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-http/src/index.js
var require_src43 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-http/src/index.js'(exports2, module2) {
    'use strict'
    var HttpServerPlugin = require_server7()
    var HttpClientPlugin = require_client10()
    var CompositePlugin = require_composite()
    var HttpPlugin = class extends CompositePlugin {
      static id = 'http'
      static get plugins() {
        return {
          server: HttpServerPlugin,
          client: HttpClientPlugin,
        }
      }
    }
    module2.exports = HttpPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js
var require_server8 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js'(exports2, module2) {
    'use strict'
    var ServerPlugin = require_server5()
    var web = require_web3()
    var { COMPONENT } = require_constants2()
    var Http2ServerPlugin = class extends ServerPlugin {
      constructor(tracer2, config) {
        super(tracer2, config)
        this.addBind('apm:http2:server:response:emit', this.bindEmit)
      }
      static id = 'http2'
      static prefix = 'apm:http2:server:request'
      bindStart(ctx) {
        const { req, res } = ctx
        const span = web.startSpan(
          this.tracer,
          {
            ...this.config,
            service: this.config.service || this.serviceName(),
          },
          req,
          res,
          this.operationName(),
          ctx
        )
        span.setTag(COMPONENT, this.constructor.id)
        span._integrationName = this.constructor.id
        ctx.currentStore.req = req
        ctx.currentStore.res = res
        const context = web.getContext(req)
        if (!context.instrumented) {
          context.res.writeHead = web.wrapWriteHead(context)
          context.instrumented = true
        }
        return ctx.currentStore
      }
      bindEmit(ctx) {
        if (ctx.eventName !== 'close') return ctx.currentStore
        const { req } = ctx
        const context = web.getContext(req)
        if (!context || !context.res) return
        web.finishAll(context)
        return ctx.currentStore
      }
      error(error) {
        web.addError(error)
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config))
      }
    }
    module2.exports = Http2ServerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js
var require_client11 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var ClientPlugin = require_client5()
    var URL2 = require('url').URL
    var log = require_log2()
    var tags = require_tags()
    var kinds = require_kinds()
    var formats = require_formats()
    var { COMPONENT, CLIENT_PORT_KEY } = require_constants2()
    var urlFilter = require_urlfilter()
    var HTTP_HEADERS = formats.HTTP_HEADERS
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS
    var SPAN_KIND = tags.SPAN_KIND
    var CLIENT = kinds.CLIENT
    var HTTP2_HEADER_METHOD = ':method'
    var HTTP2_HEADER_PATH = ':path'
    var HTTP2_HEADER_STATUS = ':status'
    var HTTP2_METHOD_GET = 'GET'
    var Http2ClientPlugin = class extends ClientPlugin {
      static id = 'http2'
      static prefix = 'apm:http2:client:request'
      bindStart(message) {
        const { authority, options, headers = {} } = message
        const sessionDetails = extractSessionDetails(authority, options)
        const path = headers[HTTP2_HEADER_PATH] || '/'
        const pathname = path.split(/[?#]/)[0]
        const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET
        const uri = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${pathname}`
        const allowed = this.config.filter(uri)
        const store = storage('legacy').getStore()
        const childOf = store && allowed ? store.span : null
        const span = this.startSpan(
          this.operationName(),
          {
            childOf,
            integrationName: this.constructor.id,
            meta: {
              [COMPONENT]: this.constructor.id,
              [SPAN_KIND]: CLIENT,
              'service.name': this.serviceName({ pluginConfig: this.config, sessionDetails }),
              'resource.name': method,
              'span.type': 'http',
              'http.method': method,
              'http.url': uri,
              'out.host': sessionDetails.host,
            },
            metrics: {
              [CLIENT_PORT_KEY]: Number.parseInt(sessionDetails.port),
            },
          },
          false
        )
        if (!allowed) {
          span._spanContext._trace.record = false
        }
        addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, this.config)
        if (!hasAmazonSignature(headers, path)) {
          this.tracer.inject(span, HTTP_HEADERS, headers)
        }
        message.parentStore = store
        message.currentStore = { ...store, span }
        return message.currentStore
      }
      bindAsyncStart(ctx) {
        const { eventName, eventData, currentStore, parentStore } = ctx
        if (!currentStore) return storage('legacy').getStore()
        switch (eventName) {
          case 'response':
            this._onResponse(currentStore, eventData)
            return parentStore
          case 'error':
            this._onError(currentStore, eventData, ctx)
            return parentStore
          case 'close':
            this._onClose(ctx)
            return parentStore
        }
        return storage('legacy').getStore()
      }
      configure(config) {
        return super.configure(normalizeConfig(config))
      }
      _onResponse(store, headers) {
        const status = headers && headers[HTTP2_HEADER_STATUS]
        store.span.setTag(HTTP_STATUS_CODE, status)
        if (!this.config.validateStatus(status)) {
          storage('legacy').run(store, () => this.addError())
        }
        addHeaderTags(store.span, headers, HTTP_RESPONSE_HEADERS, this.config)
      }
      _onError({ span }, error, ctx) {
        span.setTag('error', error)
        super.finish(ctx)
      }
      _onClose(ctx) {
        super.finish(ctx)
      }
    }
    function extractSessionDetails(authority, options) {
      if (typeof authority === 'string') {
        authority = new URL2(authority)
      }
      const protocol = authority.protocol || options.protocol || 'https:'
      let port = authority.port === '' ? (authority.protocol === 'http:' ? '80' : '443') : String(authority.port)
      let host = authority.hostname || authority.host || 'localhost'
      if (protocol === 'https:' && options) {
        port = options.port || port
        host = options.host || host
      }
      return { protocol, port, host }
    }
    function hasAmazonSignature(headers, path) {
      if (path?.toLowerCase().includes('x-amz-signature=')) {
        return true
      }
      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          const lowerCaseKey = key.toLowerCase()
          if (lowerCaseKey === 'x-amz-signature' && value) {
            return true
          }
          if (lowerCaseKey === 'authorization' && value) {
            const authorization = Array.isArray(value) ? value : [value]
            if (authorization.some((val) => val.startsWith('AWS4-HMAC-SHA256'))) {
              return true
            }
          }
        }
      }
      return false
    }
    function is400ErrorCode(code) {
      return code < 400 || code >= 500
    }
    function getStatusValidator(config) {
      if (typeof config.validateStatus === 'function') {
        return config.validateStatus
      } else if (config.hasOwnProperty('validateStatus')) {
        log.error('Expected `validateStatus` to be a function.')
      }
      return is400ErrorCode
    }
    function normalizeConfig(config) {
      const validateStatus = getStatusValidator(config)
      const filter = getFilter(config)
      const headers = getHeaders(config)
      return {
        ...config,
        validateStatus,
        filter,
        headers,
      }
    }
    function getFilter(config) {
      config = { ...config, blocklist: config.blocklist || [] }
      return urlFilter.getFilter(config)
    }
    function addHeaderTags(span, headers, prefix, config) {
      if (!headers) return
      config.headers.forEach((key) => {
        const value = headers[key]
        if (value) {
          span.setTag(`${prefix}.${key}`, value)
        }
      })
    }
    function getHeaders(config) {
      if (!Array.isArray(config.headers)) return []
      return config.headers.filter((key) => typeof key === 'string').map((key) => key.toLowerCase())
    }
    module2.exports = Http2ClientPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js
var require_src44 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js'(exports2, module2) {
    'use strict'
    var Http2ServerPlugin = require_server8()
    var Http2ClientPlugin = require_client11()
    var CompositePlugin = require_composite()
    var Http2Plugin = class extends CompositePlugin {
      static id = 'http2'
      static get plugins() {
        return {
          server: Http2ServerPlugin,
          client: Http2ClientPlugin,
        }
      }
    }
    module2.exports = Http2Plugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js
var require_src45 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js'(exports2, module2) {
    'use strict'
    var RedisPlugin = require_src20()
    var IORedisPlugin = class extends RedisPlugin {
      static id = 'ioredis'
    }
    module2.exports = IORedisPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-iovalkey/src/index.js
var require_src46 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-iovalkey/src/index.js'(exports2, module2) {
    'use strict'
    var RedisPlugin = require_src20()
    var IOValkeyPlugin = class extends RedisPlugin {
      static id = 'iovalkey'
      static system = 'valkey'
      constructor(...args) {
        super(...args)
        this._spanType = 'valkey'
      }
    }
    module2.exports = IOValkeyPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/producer.js
var require_producer7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/producer.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer()
    var { DsmPathwayCodec, getMessageSize } = require_datastreams()
    var BOOTSTRAP_SERVERS_KEY = 'messaging.kafka.bootstrap.servers'
    var MESSAGING_DESTINATION_KEY = 'messaging.destination.name'
    var KafkajsProducerPlugin = class extends ProducerPlugin {
      static id = 'kafkajs'
      static operation = 'produce'
      static peerServicePrecursors = [BOOTSTRAP_SERVERS_KEY]
      constructor() {
        super(...arguments)
        this.addSub(`apm:${this.constructor.id}:produce:commit`, (message) => this.commit(message))
      }
      /**
       * Transform individual commit details sent by kafkajs' event reporter
       * into actionable backlog items for DSM
       *
       * @typedef {object} ProducerBacklog
       * @property {number} type
       * @property {string} topic
       * @property {number} partition
       * @property {number} offset
       */
      /**
       *
       * @typedef {object} ProducerResponseItem
       * @property {string} topic
       * @property {number} partition
       * @property {import('kafkajs/utils/long').Long} [offset]
       * @property {import('kafkajs/utils/long').Long} [baseOffset]
       *
       * @param {ProducerResponseItem} response
       * @returns {ProducerBacklog}
       */
      transformProduceResponse(response) {
        const { topicName: topic, partition, offset, baseOffset } = response
        const offsetAsLong = offset || baseOffset
        return {
          type: 'kafka_produce',
          partition,
          offset: offsetAsLong ? Number(offsetAsLong) : void 0,
          topic,
        }
      }
      /**
       *
       * @param {{ result: ProducerResponseItem[] }} ctx
       * @returns {void}
       */
      commit(ctx) {
        const commitList = ctx.result
        if (!this.config.dsmEnabled) return
        if (!commitList || !Array.isArray(commitList)) return
        const keys = ['type', 'partition', 'offset', 'topic']
        for (const commit of commitList.map(this.transformProduceResponse)) {
          if (keys.some((key) => !commit.hasOwnProperty(key))) continue
          this.tracer.setOffset(commit)
        }
      }
      bindStart(ctx) {
        const { topic, messages, bootstrapServers, clusterId, disableHeaderInjection } = ctx
        const span = this.startSpan(
          {
            resource: topic,
            meta: {
              component: this.constructor.id,
              'kafka.topic': topic,
              'kafka.cluster_id': clusterId,
              [MESSAGING_DESTINATION_KEY]: topic,
            },
            metrics: {
              'kafka.batch_size': messages.length,
            },
          },
          ctx
        )
        if (bootstrapServers) {
          span.setTag(BOOTSTRAP_SERVERS_KEY, bootstrapServers)
        }
        for (const message of messages) {
          if (message !== null && typeof message === 'object') {
            if (!disableHeaderInjection) {
              message.headers ??= {}
              this.tracer.inject(span, 'text_map', message.headers)
            }
            if (this.config.dsmEnabled) {
              const payloadSize = getMessageSize(message)
              const edgeTags = ['direction:out', `topic:${topic}`, 'type:kafka']
              if (clusterId) {
                edgeTags.push(`kafka_cluster_id:${clusterId}`)
              }
              const dataStreamsContext = this.tracer.setCheckpoint(edgeTags, span, payloadSize)
              if (!disableHeaderInjection) {
                DsmPathwayCodec.encode(dataStreamsContext, message.headers)
              }
            }
          }
        }
        return ctx.currentStore
      }
    }
    module2.exports = KafkajsProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/utils.js
var require_utils7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/utils.js'(exports2, module2) {
    'use strict'
    function convertToTextMap(bufferMap) {
      if (!bufferMap) return null
      if (Array.isArray(bufferMap)) {
        const headers = {}
        for (const headerMap of bufferMap) {
          for (const key of Object.keys(headerMap)) {
            headers[key] = headerMap[key].toString()
          }
        }
        return headers
      }
      const textMap = {}
      for (const key of Object.keys(bufferMap)) {
        if (bufferMap[key] === null || bufferMap[key] === void 0) continue
        textMap[key] = bufferMap[key].toString()
      }
      return textMap
    }
    module2.exports = {
      convertToTextMap,
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/consumer.js
var require_consumer5 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/consumer.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var { getMessageSize } = require_datastreams()
    var ConsumerPlugin = require_consumer()
    var { convertToTextMap } = require_utils7()
    var afterStartCh = dc.channel('dd-trace:kafkajs:consumer:afterStart')
    var beforeFinishCh = dc.channel('dd-trace:kafkajs:consumer:beforeFinish')
    var MESSAGING_DESTINATION_KEY = 'messaging.destination.name'
    var KafkajsConsumerPlugin = class extends ConsumerPlugin {
      static id = 'kafkajs'
      static operation = 'consume'
      constructor() {
        super(...arguments)
        this.addSub(`apm:${this.constructor.id}:consume:commit`, (message) => this.commit(message))
      }
      /**
       * Transform individual commit details sent by kafkajs' event reporter
       * into actionable backlog items for DSM
       *
       * @typedef {object} ConsumerBacklog
       * @property {number} type
       * @property {string} consumer_group
       * @property {string} topic
       * @property {number} partition
       * @property {number} offset
       */
      /**
       * @typedef {object} CommitEventItem
       * @property {string} groupId
       * @property {string} topic
       * @property {number} partition
       * @property {import('kafkajs/utils/long').Long} offset
       *
       * @param {CommitEventItem} commit
       * @returns {ConsumerBacklog}
       */
      transformCommit(commit) {
        const { groupId, partition, offset, topic } = commit
        return {
          partition,
          topic,
          type: 'kafka_commit',
          offset: Number(offset),
          consumer_group: groupId,
        }
      }
      commit(commitList) {
        if (!this.config.dsmEnabled) return
        const keys = ['consumer_group', 'type', 'partition', 'offset', 'topic']
        for (const commit of commitList.map(this.transformCommit)) {
          if (keys.some((key) => !commit.hasOwnProperty(key))) continue
          this.tracer.setOffset(commit)
        }
      }
      bindStart(ctx) {
        const { topic, partition, message, groupId, clusterId } = ctx.extractedArgs || ctx
        let childOf
        const headers = convertToTextMap(message?.headers)
        if (headers) {
          childOf = this.tracer.extract('text_map', headers)
        }
        const span = this.startSpan(
          {
            childOf,
            resource: topic,
            type: 'worker',
            meta: {
              component: this.constructor.id,
              'kafka.topic': topic,
              'kafka.cluster_id': clusterId,
              [MESSAGING_DESTINATION_KEY]: topic,
            },
            metrics: {
              'kafka.partition': partition,
            },
          },
          ctx
        )
        if (message?.offset) span.setTag('kafka.message.offset', message?.offset)
        if (this.config.dsmEnabled && headers) {
          const payloadSize = getMessageSize(message)
          this.tracer.decodeDataStreamsContext(headers)
          const edgeTags = ['direction:in', `group:${groupId}`, `topic:${topic}`, 'type:kafka']
          if (clusterId) {
            edgeTags.push(`kafka_cluster_id:${clusterId}`)
          }
          this.tracer.setCheckpoint(edgeTags, span, payloadSize)
        }
        if (afterStartCh.hasSubscribers) {
          afterStartCh.publish({ topic, partition, message, groupId, currentStore: ctx.currentStore })
        }
        return ctx.currentStore
      }
      finish(ctx) {
        if (beforeFinishCh.hasSubscribers) {
          beforeFinishCh.publish()
        }
        super.finish(ctx)
      }
    }
    module2.exports = KafkajsConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/batch-consumer.js
var require_batch_consumer = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/batch-consumer.js'(exports2, module2) {
    'use strict'
    var ConsumerPlugin = require_consumer()
    var { getMessageSize } = require_datastreams()
    var { convertToTextMap } = require_utils7()
    var KafkajsBatchConsumerPlugin = class extends ConsumerPlugin {
      static id = 'kafkajs'
      static operation = 'consume-batch'
      start(ctx) {
        const { topic, messages, groupId, clusterId } = ctx.extractedArgs || ctx
        if (!this.config.dsmEnabled) return
        for (const message of messages) {
          if (!message || !message.headers) continue
          const payloadSize = getMessageSize(message)
          this.tracer.decodeDataStreamsContext(convertToTextMap(message.headers))
          const edgeTags = ['direction:in', `group:${groupId}`, `topic:${topic}`, 'type:kafka']
          if (clusterId) {
            edgeTags.push(`kafka_cluster_id:${clusterId}`)
          }
          this.tracer.setCheckpoint(edgeTags, null, payloadSize)
        }
      }
    }
    module2.exports = KafkajsBatchConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js
var require_src47 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer7()
    var ConsumerPlugin = require_consumer5()
    var BatchConsumerPlugin = require_batch_consumer()
    var CompositePlugin = require_composite()
    var KafkajsPlugin = class extends CompositePlugin {
      static id = 'kafkajs'
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          batchConsumer: BatchConsumerPlugin,
        }
      }
    }
    module2.exports = KafkajsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/producer.js
var require_producer8 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/producer.js'(exports2, module2) {
    'use strict'
    var KafkajsProducerPlugin = require_producer7()
    var ConfluentKafkaJsProducerPlugin = class extends KafkajsProducerPlugin {
      static id = 'confluentinc-kafka-javascript'
    }
    module2.exports = ConfluentKafkaJsProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/consumer.js
var require_consumer6 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/consumer.js'(exports2, module2) {
    'use strict'
    var KafkajsConsumerPlugin = require_consumer5()
    var ConfluentKafkaJsConsumerPlugin = class extends KafkajsConsumerPlugin {
      static id = 'confluentinc-kafka-javascript'
    }
    module2.exports = ConfluentKafkaJsConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/batch-consumer.js
var require_batch_consumer2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/batch-consumer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var KafkajsBatchConsumerPlugin = require_batch_consumer()
    var ConfluentKafkaJsBatchConsumerPlugin = class extends KafkajsBatchConsumerPlugin {
      static id = 'confluentinc-kafka-javascript'
    }
    module2.exports = ConfluentKafkaJsBatchConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/index.js
var require_src48 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-confluentinc-kafka-javascript/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer8()
    var ConsumerPlugin = require_consumer6()
    var BatchConsumerPlugin = require_batch_consumer2()
    var KafkajsPlugin = require_src47()
    var ConfluentKafkaJsPlugin = class extends KafkajsPlugin {
      /**
       * @override
       */
      static id = 'confluentinc-kafka-javascript'
      /**
       * @override
       */
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          batchConsumer: BatchConsumerPlugin,
        }
      }
    }
    module2.exports = ConfluentKafkaJsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js
var require_src49 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var CLIENT_PORT_KEY = require_constants2()
    var DatabasePlugin = require_database()
    var MySQLPlugin = class extends DatabasePlugin {
      static id = 'mysql'
      static system = 'mysql'
      constructor() {
        super(...arguments)
        this.addSub(`apm:${this.component}:connection:start`, (ctx) => {
          ctx.parentStore = storage('legacy').getStore()
        })
        this.addBind(`apm:${this.component}:connection:finish`, (ctx) => ctx.parentStore)
      }
      bindStart(ctx) {
        const service = this.serviceName({ pluginConfig: this.config, dbConfig: ctx.conf, system: this.system })
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            resource: ctx.sql,
            type: 'sql',
            kind: 'client',
            meta: {
              'db.type': this.system,
              'db.user': ctx.conf.user,
              'db.name': ctx.conf.database,
              'out.host': ctx.conf.host,
              [CLIENT_PORT_KEY]: ctx.conf.port,
            },
          },
          ctx
        )
        ctx.sql = this.injectDbmQuery(span, ctx.sql, service)
        return ctx.currentStore
      }
    }
    module2.exports = MySQLPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-mariadb/src/index.js
var require_src50 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-mariadb/src/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var MySQLPlugin = require_src49()
    var MariadbPlugin = class extends MySQLPlugin {
      static id = 'mariadb'
      static system = 'mariadb'
      constructor(...args) {
        super(...args)
        this.addBind(`apm:${this.component}:pool:skip`, () => ({ noop: true }))
        this.addSub(`apm:${this.component}:command:add`, (ctx) => {
          ctx.parentStore = storage('legacy').getStore()
        })
      }
    }
    module2.exports = MariadbPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js
var require_src51 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY } = require_constants2()
    var CachePlugin = require_cache()
    var MemcachedPlugin = class extends CachePlugin {
      static id = 'memcached'
      bindStart(ctx) {
        const { client, server, query } = ctx
        const address = getAddress(client, server, query)
        const meta = {
          'out.host': address[0],
          [CLIENT_PORT_KEY]: address[1],
        }
        if (this.config.memcachedCommandEnabled) {
          meta['memcached.command'] = query.command
        }
        this.startSpan(
          {
            service: this.serviceName({ pluginConfig: this.config, system: this.system }),
            resource: query.type,
            type: 'memcached',
            meta,
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    function getAddress(client, server, query) {
      if (!server) {
        if (client.servers.length === 1) {
          server = client.servers[0]
        } else {
          let redundancy = client.redundancy && client.redundancy < client.servers.length
          const queryRedundancy = query.redundancyEnabled
          if (redundancy && queryRedundancy) {
            redundancy = client.HashRing.range(query.key, client.redundancy + 1, true)
            server = redundancy.shift()
          } else {
            server = client.HashRing.get(query.key)
          }
        }
      }
      return server && server.split(':')
    }
    module2.exports = MemcachedPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js
var require_src52 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js'(exports2, module2) {
    'use strict'
    var RouterPlugin = require_src15()
    var web = require_web3()
    var MicrogatewayCorePlugin = class extends RouterPlugin {
      static id = 'microgateway-core'
      constructor(...args) {
        super(...args)
        this.addSub('apm:microgateway-core:request:handle', ({ req }) => {
          this.setFramework(req, 'microgateway', this.config)
        })
        this.addSub('apm:microgateway-core:request:route', ({ req, route }) => {
          web.setRoute(req, route)
        })
        this.addSub('apm:microgateway-core:request:error', ({ error }) => {
          this.addError(error)
        })
      }
    }
    module2.exports = MicrogatewayCorePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js
var require_src53 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js'(exports2, module2) {
    'use strict'
    var CiPlugin = require_ci_plugin()
    var { storage } = require_datadog_core()
    var { getEnvironmentVariable } = require_config_helper()
    var {
      TEST_STATUS,
      TEST_PARAMETERS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestParametersString,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags,
      TEST_SOURCE_START,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      TEST_CODE_OWNERS,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      MOCHA_IS_PARALLEL,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED,
      isModifiedTest,
    } = require_test()
    var { COMPONENT } = require_constants2()
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TELEMETRY_TEST_SESSION,
    } = require_telemetry()
    var BREAKPOINT_SET_GRACE_PERIOD_MS = 200
    var MochaPlugin = class extends CiPlugin {
      static id = 'mocha'
      constructor(...args) {
        super(...args)
        this._testTitleToParams = {}
        this.sourceRoot = process.cwd()
        this.addSub('ci:mocha:test-suite:code-coverage', ({ coverageFiles, suiteFile }) => {
          if (!this.libraryConfig?.isCodeCoverageEnabled) {
            return
          }
          const testSuite = getTestSuitePath(suiteFile, this.sourceRoot)
          const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite)
          if (!coverageFiles.length) {
            this.telemetry.count(TELEMETRY_CODE_COVERAGE_EMPTY)
          }
          const relativeCoverageFiles = [...coverageFiles, suiteFile].map((filename) =>
            getTestSuitePath(filename, this.repositoryRoot || this.sourceRoot)
          )
          const { _traceId, _spanId } = testSuiteSpan.context()
          const formattedCoverage = {
            sessionId: _traceId,
            suiteId: _spanId,
            files: relativeCoverageFiles,
          }
          this.tracer._exporter.exportCoverage(formattedCoverage)
          this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_FINISHED, 'suite', { library: 'istanbul' })
          this.telemetry.distribution(TELEMETRY_CODE_COVERAGE_NUM_FILES, {}, relativeCoverageFiles.length)
        })
        this.addBind('ci:mocha:test-suite:start', (ctx) => {
          const { testSuiteAbsolutePath, isUnskippable, isForcedToRun, itrCorrelationId } = ctx
          if (!this.testModuleSpan) {
            return
          }
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.sourceRoot)
          const testSuiteMetadata = getTestSuiteCommonTags(this.command, this.frameworkVersion, testSuite, 'mocha')
          if (isUnskippable) {
            testSuiteMetadata[TEST_ITR_UNSKIPPABLE] = 'true'
            this.telemetry.count(TELEMETRY_ITR_UNSKIPPABLE, { testLevel: 'suite' })
          }
          if (isForcedToRun) {
            testSuiteMetadata[TEST_ITR_FORCED_RUN] = 'true'
            this.telemetry.count(TELEMETRY_ITR_FORCED_TO_RUN, { testLevel: 'suite' })
          }
          testSuiteMetadata[TEST_SOURCE_FILE] =
            this.repositoryRoot !== this.sourceRoot && !!this.repositoryRoot
              ? getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
              : testSuite
          if (testSuiteMetadata[TEST_SOURCE_FILE]) {
            testSuiteMetadata[TEST_SOURCE_START] = 1
          }
          const codeOwners = this.getCodeOwners(testSuiteMetadata)
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners
          }
          const testSuiteSpan = this.tracer.startSpan('mocha.test_suite', {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata,
            },
            integrationName: this.constructor.id,
          })
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, 'suite')
          if (this.libraryConfig?.isCodeCoverageEnabled) {
            this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_STARTED, 'suite', { library: 'istanbul' })
          }
          if (itrCorrelationId) {
            testSuiteSpan.setTag(ITR_CORRELATION_ID, itrCorrelationId)
          }
          const store = storage('legacy').getStore()
          ctx.parentStore = store
          ctx.currentStore = { ...store, testSuiteSpan }
          this._testSuiteSpansByTestSuite.set(testSuite, testSuiteSpan)
        })
        this.addSub('ci:mocha:test-suite:finish', ({ testSuiteSpan, status }) => {
          if (testSuiteSpan) {
            if (!testSuiteSpan.context()._tags[TEST_STATUS]) {
              testSuiteSpan.setTag(TEST_STATUS, status)
            }
            testSuiteSpan.finish()
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'suite')
          }
        })
        this.addBind('ci:mocha:test-suite:error', (ctx) => {
          const { error } = ctx
          const testSuiteSpan = ctx.currentStore?.testSuiteSpan
          if (testSuiteSpan) {
            testSuiteSpan.setTag('error', error)
            testSuiteSpan.setTag(TEST_STATUS, 'fail')
            ctx.parentStore = ctx.currentStore
            ctx.currentStore = { ...ctx.currentStore, testSuiteSpan }
          }
          return ctx.currentStore
        })
        this.addSub('ci:mocha:test:is-modified', ({ modifiedFiles, file, onDone }) => {
          const testPath = getTestSuitePath(file, this.repositoryRoot)
          const isModified = isModifiedTest(testPath, null, null, modifiedFiles, this.constructor.id)
          onDone(isModified)
        })
        this.addBind('ci:mocha:test:fn', (ctx) => {
          return ctx.currentStore
        })
        this.addBind('ci:mocha:test:start', (ctx) => {
          const store = storage('legacy').getStore()
          const span = this.startTestSpan(ctx)
          ctx.parentStore = store
          ctx.currentStore = { ...store, span }
          this.activeTestSpan = span
          return ctx.currentStore
        })
        this.addSub('ci:mocha:worker:finish', () => {
          this.tracer._exporter.flush()
        })
        this.addSub(
          'ci:mocha:test:finish',
          ({
            span,
            status,
            hasBeenRetried,
            isLastRetry,
            hasFailedAllRetries,
            attemptToFixPassed,
            attemptToFixFailed,
            isAttemptToFixRetry,
            isAtrRetry,
          }) => {
            if (span) {
              span.setTag(TEST_STATUS, status)
              if (hasBeenRetried) {
                span.setTag(TEST_IS_RETRY, 'true')
                if (isAtrRetry) {
                  span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr)
                } else {
                  span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext)
                }
              }
              if (hasFailedAllRetries) {
                span.setTag(TEST_HAS_FAILED_ALL_RETRIES, 'true')
              }
              if (attemptToFixPassed) {
                span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'true')
              } else if (attemptToFixFailed) {
                span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, 'false')
              }
              if (isAttemptToFixRetry) {
                span.setTag(TEST_IS_RETRY, 'true')
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atf)
              }
              const spanTags = span.context()._tags
              this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
                hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
                isNew: spanTags[TEST_IS_NEW] === 'true',
                isRum: spanTags[TEST_IS_RUM_ACTIVE] === 'true',
                browserDriver: spanTags[TEST_BROWSER_DRIVER],
              })
              span.finish()
              finishAllTraceSpans(span)
              this.activeTestSpan = null
              if (this.di && this.libraryConfig?.isDiEnabled && this.runningTestProbe && isLastRetry) {
                this.removeDiProbe(this.runningTestProbe)
                this.runningTestProbe = null
              }
            }
          }
        )
        this.addBind('ci:mocha:test:skip', (ctx) => {
          const store = storage('legacy').getStore()
          if (!store) {
            const span = this.startTestSpan(ctx)
            ctx.parentStore = store
            ctx.currentStore = { ...store, span }
            this.activeTestSpan = span
          }
          return ctx.currentStore
        })
        this.addBind('ci:mocha:test:error', (ctx) => {
          const { err } = ctx
          const span = ctx.currentStore?.span
          if (err && span) {
            if (err.constructor.name === 'Pending' && !this.forbidPending) {
              span.setTag(TEST_STATUS, 'skip')
            } else {
              span.setTag(TEST_STATUS, 'fail')
              span.setTag('error', err)
            }
            ctx.parentStore = ctx.currentStore
            ctx.currentStore = { ...ctx.currentStore, span }
            this.activeTestSpan = span
          }
          return ctx.currentStore
        })
        this.addSub('ci:mocha:test:retry', ({ span, isFirstAttempt, willBeRetried, err, test, isAtrRetry }) => {
          if (span) {
            span.setTag(TEST_STATUS, 'fail')
            if (!isFirstAttempt) {
              span.setTag(TEST_IS_RETRY, 'true')
              if (isAtrRetry) {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr)
              } else {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext)
              }
            }
            if (err) {
              span.setTag('error', err)
            }
            const spanTags = span.context()._tags
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'test', {
              hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
              isNew: spanTags[TEST_IS_NEW] === 'true',
              isRum: spanTags[TEST_IS_RUM_ACTIVE] === 'true',
              browserDriver: spanTags[TEST_BROWSER_DRIVER],
            })
            if (isFirstAttempt && willBeRetried && this.di && this.libraryConfig?.isDiEnabled) {
              const probeInformation = this.addDiProbe(err)
              if (probeInformation) {
                const { file, line, stackIndex } = probeInformation
                this.runningTestProbe = { file, line }
                this.testErrorStackIndex = stackIndex
                test._ddShouldWaitForHitProbe = true
                const waitUntil = Date.now() + BREAKPOINT_SET_GRACE_PERIOD_MS
                while (Date.now() < waitUntil) {}
              }
            }
            span.finish()
            finishAllTraceSpans(span)
          }
        })
        this.addSub('ci:mocha:test:parameterize', ({ title, params }) => {
          this._testTitleToParams[title] = params
        })
        this.addSub(
          'ci:mocha:session:finish',
          ({
            status,
            isSuitesSkipped,
            testCodeCoverageLinesTotal,
            numSkippedSuites,
            hasForcedToRunSuites,
            hasUnskippableSuites,
            error,
            isEarlyFlakeDetectionEnabled,
            isEarlyFlakeDetectionFaulty,
            isTestManagementEnabled,
            isParallel,
          }) => {
            if (this.testSessionSpan) {
              const { isSuitesSkippingEnabled, isCodeCoverageEnabled } = this.libraryConfig || {}
              this.testSessionSpan.setTag(TEST_STATUS, status)
              this.testModuleSpan.setTag(TEST_STATUS, status)
              if (error) {
                this.testSessionSpan.setTag('error', error)
                this.testModuleSpan.setTag('error', error)
              }
              if (isParallel) {
                this.testSessionSpan.setTag(MOCHA_IS_PARALLEL, 'true')
              }
              if (isTestManagementEnabled) {
                this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, 'true')
              }
              addIntelligentTestRunnerSpanTags(this.testSessionSpan, this.testModuleSpan, {
                isSuitesSkipped,
                isSuitesSkippingEnabled,
                isCodeCoverageEnabled,
                testCodeCoverageLinesTotal,
                skippingCount: numSkippedSuites,
                skippingType: 'suite',
                hasForcedToRunSuites,
                hasUnskippableSuites,
              })
              if (isEarlyFlakeDetectionEnabled) {
                this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, 'true')
              }
              if (isEarlyFlakeDetectionFaulty) {
                this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, 'faulty')
              }
              this.testModuleSpan.finish()
              this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'module')
              this.testSessionSpan.finish()
              this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, 'session')
              finishAllTraceSpans(this.testSessionSpan)
              this.telemetry.count(TELEMETRY_TEST_SESSION, {
                provider: this.ciProviderName,
                autoInjected: !!getEnvironmentVariable('DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER'),
              })
            }
            this.libraryConfig = null
            this.tracer._exporter.flush()
          }
        )
        this.addBind('ci:mocha:global:run', (ctx) => {
          return ctx.currentStore
        })
      }
      startTestSpan(testInfo) {
        const {
          testName,
          testSuiteAbsolutePath,
          title,
          isNew,
          isEfdRetry,
          testStartLine,
          isParallel,
          isAttemptToFix,
          isDisabled,
          isQuarantined,
          isModified,
        } = testInfo
        const extraTags = {}
        const testParametersString = getTestParametersString(this._testTitleToParams, title)
        if (testParametersString) {
          extraTags[TEST_PARAMETERS] = testParametersString
        }
        if (testStartLine) {
          extraTags[TEST_SOURCE_START] = testStartLine
        }
        if (isParallel) {
          extraTags[MOCHA_IS_PARALLEL] = 'true'
        }
        if (isAttemptToFix) {
          extraTags[TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX] = 'true'
        }
        if (isDisabled) {
          extraTags[TEST_MANAGEMENT_IS_DISABLED] = 'true'
        }
        if (isQuarantined) {
          extraTags[TEST_MANAGEMENT_IS_QUARANTINED] = 'true'
        }
        if (isModified) {
          extraTags[TEST_IS_MODIFIED] = 'true'
          if (isEfdRetry) {
            extraTags[TEST_IS_RETRY] = 'true'
            extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd
          }
        }
        const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.sourceRoot)
        const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite)
        extraTags[TEST_SOURCE_FILE] =
          this.repositoryRoot !== this.sourceRoot && !!this.repositoryRoot
            ? getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot)
            : testSuite
        if (isNew) {
          extraTags[TEST_IS_NEW] = 'true'
          if (isEfdRetry) {
            extraTags[TEST_IS_RETRY] = 'true'
            extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd
          }
        }
        return super.startTestSpan(testName, testSuite, testSuiteSpan, extraTags)
      }
    }
    module2.exports = MochaPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js
var require_util12 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js'(exports2, module2) {
    'use strict'
    function moleculerTags(broker, ctx, config) {
      const service = ctx.service || {}
      const action = ctx.action || {}
      const meta = config.meta && ctx.meta
      return {
        'moleculer.context.action': action.name,
        'moleculer.context.meta': meta,
        'moleculer.context.node_id': ctx.nodeID,
        'moleculer.context.request_id': ctx.requestID,
        'moleculer.context.service': service.name,
        'moleculer.namespace': broker.namespace,
        'moleculer.node_id': broker.nodeID,
      }
    }
    module2.exports = { moleculerTags }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js
var require_server9 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js'(exports2, module2) {
    'use strict'
    var ServerPlugin = require_server5()
    var { moleculerTags } = require_util12()
    var MoleculerServerPlugin = class extends ServerPlugin {
      static id = 'moleculer'
      static operation = 'action'
      bindStart(ctx) {
        const { action, middlewareCtx, broker } = ctx
        const followsFrom = this.tracer.extract('text_map', middlewareCtx.meta)
        this.startSpan(
          this.operationName(),
          {
            childOf: followsFrom || ctx?.currentStore?.span || this.activeSpan,
            service: this.config.service || this.serviceName(),
            resource: action.name,
            kind: 'server',
            type: 'web',
            meta: {
              'resource.name': action.name,
              ...moleculerTags(broker, middlewareCtx, this.config),
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = MoleculerServerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js
var require_client12 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var { moleculerTags } = require_util12()
    var MoleculerClientPlugin = class extends ClientPlugin {
      static id = 'moleculer'
      static operation = 'call'
      bindStart(ctx) {
        const { actionName, opts } = ctx
        const span = this.startSpan(
          this.operationName(),
          {
            service: this.config.service || this.serviceName(),
            resource: actionName,
            kind: 'client',
          },
          ctx
        )
        this.tracer.inject(span, 'text_map', opts.meta)
        return ctx.currentStore
      }
      finish(ctx) {
        const { promiseCtx, broker } = ctx
        const span = ctx.currentStore.span || this.activeSpan
        if (promiseCtx) {
          const endpoint = promiseCtx.endpoint || {}
          const node = endpoint.node || {}
          this.addHost({ hostname: node.hostname, port: node.port })
          span.addTags(moleculerTags(broker, promiseCtx, this.config))
        }
        super.finish(ctx)
      }
    }
    module2.exports = MoleculerClientPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js
var require_src54 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js'(exports2, module2) {
    'use strict'
    var MoleculerServerPlugin = require_server9()
    var MoleculerClientPlugin = require_client12()
    var CompositePlugin = require_composite()
    var MoleculerPlugin = class extends CompositePlugin {
      static id = 'moleculer'
      static get plugins() {
        return {
          server: MoleculerServerPlugin,
          client: MoleculerClientPlugin,
        }
      }
    }
    module2.exports = MoleculerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js
var require_src55 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js'(exports2, module2) {
    'use strict'
    var { isTrue } = require_util()
    var DatabasePlugin = require_database()
    var { getEnvironmentVariable } = require_config_helper()
    var MongodbCorePlugin = class extends DatabasePlugin {
      static id = 'mongodb-core'
      static component = 'mongodb'
      // avoid using db.name for peer.service since it includes the collection name
      // should be removed if one day this will be fixed
      /**
       * @override
       */
      static peerServicePrecursors = []
      /**
       * @override
       */
      configure(config) {
        super.configure(config)
        const heartbeatFromEnv = getEnvironmentVariable('DD_TRACE_MONGODB_HEARTBEAT_ENABLED')
        this.config.heartbeatEnabled = config.heartbeatEnabled ?? (heartbeatFromEnv && isTrue(heartbeatFromEnv)) ?? true
      }
      bindStart(ctx) {
        const { ns, ops, options = {}, name } = ctx
        if (!this.config.heartbeatEnabled && isHeartbeat(ops, this.config)) {
          return
        }
        const query = getQuery(ops)
        const resource = truncate(getResource(this, ns, query, name))
        const service = this.serviceName({ pluginConfig: this.config })
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            resource,
            type: 'mongodb',
            kind: 'client',
            meta: {
              // this is not technically correct since it includes the collection but we changing will break customer stuff
              'db.name': ns,
              'mongodb.query': query,
              'out.host': options.host,
              'out.port': options.port,
            },
          },
          ctx
        )
        const comment = this.injectDbmComment(span, ops.comment, service)
        if (comment) {
          ops.comment = comment
        }
        return ctx.currentStore
      }
      /**
       * @override
       */
      getPeerService(tags) {
        let ns = tags['db.name']
        if (ns && tags['peer.service'] === void 0) {
          const dotIndex = ns.indexOf('.')
          if (dotIndex !== -1) {
            ns = ns.slice(0, dotIndex)
          }
          tags['peer.service'] = ns
        }
        return super.getPeerService(tags)
      }
      injectDbmComment(span, comment, serviceName) {
        const dbmTraceComment = this.createDbmComment(span, serviceName)
        if (!dbmTraceComment) {
          return comment
        }
        if (comment) {
          if (typeof comment === 'string') {
            comment += `,${dbmTraceComment}`
          } else if (Array.isArray(comment)) {
            comment.push(dbmTraceComment)
          }
        } else {
          comment = dbmTraceComment
        }
        return comment
      }
    }
    function sanitizeBigInt(data) {
      return JSON.stringify(data, (_key, value) => (typeof value === 'bigint' ? value.toString() : value))
    }
    function extractQuery(statements) {
      if (statements.length === 1 && statements[0].q) return statements[0].q
      const extractedQueries = []
      for (let i = 0; i < statements.length; i++) {
        if (statements[i].q) {
          extractedQueries.push(limitDepth(statements[i].q))
        }
      }
      return extractedQueries
    }
    function getQuery(cmd) {
      if (!cmd || (typeof cmd !== 'object' && !Array.isArray(cmd))) return
      if (Array.isArray(cmd)) return sanitizeBigInt(extractQuery(cmd))
      if (cmd.query) return sanitizeBigInt(limitDepth(cmd.query))
      if (cmd.filter) return sanitizeBigInt(limitDepth(cmd.filter))
      if (cmd.pipeline) return sanitizeBigInt(limitDepth(cmd.pipeline))
      if (cmd.deletes) return sanitizeBigInt(extractQuery(cmd.deletes))
      if (cmd.updates) return sanitizeBigInt(extractQuery(cmd.updates))
    }
    function getResource(plugin, ns, query, operationName) {
      let resource = `${operationName} ${ns}`
      if (plugin.config.queryInResourceName && query) {
        resource += ` ${query}`
      }
      return resource
    }
    function truncate(input) {
      return input.slice(0, Math.min(input.length, 1e4))
    }
    function shouldSimplify(input) {
      return !isObject(input) || typeof input.toJSON === 'function'
    }
    function shouldHide(input) {
      return Buffer.isBuffer(input) || typeof input === 'function' || isBinary(input)
    }
    function limitDepth(input) {
      if (isBSON(input)) {
        input = input.toJSON()
      }
      if (shouldHide(input)) return '?'
      if (shouldSimplify(input)) return input
      const output = {}
      const queue = [
        {
          input,
          output,
          depth: 0,
        },
      ]
      while (queue.length) {
        const { input: input2, output: output2, depth } = queue.pop()
        const nextDepth = depth + 1
        for (const key in input2) {
          if (typeof input2[key] === 'function') continue
          let child = input2[key]
          if (isBSON(child)) {
            child = typeof child.toJSON === 'function' ? child.toJSON() : '?'
          }
          if (depth >= 10 || shouldHide(child)) {
            output2[key] = '?'
          } else if (shouldSimplify(child)) {
            output2[key] = child
          } else {
            queue.push({
              input: child,
              output: (output2[key] = {}),
              depth: nextDepth,
            })
          }
        }
      }
      return output
    }
    function isObject(val) {
      return val !== null && typeof val === 'object' && !Array.isArray(val)
    }
    function isBSON(val) {
      return val && val._bsontype && !isBinary(val)
    }
    function isBinary(val) {
      return val && val._bsontype === 'Binary'
    }
    function isHeartbeat(ops, config) {
      return ops && typeof ops === 'object' && (ops.hello === 1 || ops.helloOk === true)
    }
    module2.exports = MongodbCorePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-mongoose/src/index.js
var require_src56 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-mongoose/src/index.js'(exports2, module2) {
    'use strict'
    var DatabasePlugin = require_database()
    var { storage } = require_datadog_core()
    var MongoosePlugin = class extends DatabasePlugin {
      static id = 'mongoose'
      static operation = 'exec'
      bindStart(ctx) {
        ctx.parentStore = storage('legacy').getStore()
        return ctx.parentStore
      }
      bindFinish(ctx) {
        return ctx.parentStore
      }
    }
    module2.exports = MongoosePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js
var require_src57 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var MySQLPlugin = require_src49()
    var MySQL2Plugin = class extends MySQLPlugin {
      static id = 'mysql2'
      constructor() {
        super(...arguments)
        this.addSub(`apm:${this.component}:command:add`, (ctx) => {
          ctx.parentStore = storage('legacy').getStore()
        })
        this.addBind(`apm:${this.component}:command:start`, (ctx) => ctx.parentStore)
        this.addBind(`apm:${this.component}:command:finish`, (ctx) => ctx.parentStore)
      }
      bindStart(ctx) {
        return storage('legacy').run(ctx.parentStore, () => super.bindStart(ctx))
      }
    }
    module2.exports = MySQL2Plugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-net/src/ipc.js
var require_ipc = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-net/src/ipc.js'(exports2, module2) {
    'use strict'
    var ClientPlugin = require_client5()
    var NetIPCPlugin = class extends ClientPlugin {
      static id = 'net'
      static operation = 'ipc'
      bindStart(ctx) {
        this.startSpan(
          'ipc.connect',
          {
            service: this.config.service,
            resource: ctx.options.path,
            kind: 'client',
            meta: {
              'ipc.path': ctx.options.path,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = NetIPCPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-net/src/tcp.js
var require_tcp = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-net/src/tcp.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY } = require_constants2()
    var ClientPlugin = require_client5()
    var NetTCPPlugin = class extends ClientPlugin {
      static id = 'net'
      static operation = 'tcp'
      constructor(...args) {
        super(...args)
        this.addTraceBind('ready', (ctx) => {
          return ctx.parentStore
        })
        this.addTraceSub('connection', (ctx) => {
          const span = ctx.currentStore.span
          span.addTags({
            'tcp.local.address': ctx.socket.localAddress,
            'tcp.local.port': ctx.socket.localPort,
          })
        })
      }
      bindStart(ctx) {
        const host = ctx.options.host || 'localhost'
        const port = ctx.options.port || 0
        const family = ctx.options.family || 4
        this.startSpan(
          'tcp.connect',
          {
            service: this.config.service,
            resource: [host, port].filter(Boolean).join(':'),
            kind: 'client',
            meta: {
              'tcp.remote.host': host,
              'tcp.family': `IPv${family}`,
              'tcp.local.address': '',
              'out.host': host,
            },
            metrics: {
              'tcp.remote.port': port,
              'tcp.local.port': 0,
              [CLIENT_PORT_KEY]: port,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = NetTCPPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-net/src/index.js
var require_src58 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-net/src/index.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var NetIPCPlugin = require_ipc()
    var NetTCPPlugin = require_tcp()
    var NetPlugin = class extends Plugin {
      static id = 'net'
      constructor(...args) {
        super(...args)
        this._ipc = new NetIPCPlugin(...args)
        this._tcp = new NetTCPPlugin(...args)
      }
      configure(config) {
        this._ipc.configure(config)
        this._tcp.configure(config)
      }
    }
    module2.exports = NetPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-next/src/index.js
var require_src59 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-next/src/index.js'(exports2, module2) {
    'use strict'
    var ServerPlugin = require_server5()
    var { storage } = require_datadog_core()
    var analyticsSampler = require_analytics_sampler()
    var { COMPONENT } = require_constants2()
    var web = require_web3()
    var errorPages = /* @__PURE__ */ new Set(['/404', '/500', '/_error', '/_not-found', '/_not-found/page'])
    var NextPlugin = class extends ServerPlugin {
      static id = 'next'
      #requestsBySpanId = /* @__PURE__ */ new WeakMap()
      constructor(...args) {
        super(...args)
        this.addSub('apm:next:page:load', (message) => this.pageLoad(message))
      }
      bindStart({ req, res }) {
        const store = storage('legacy').getStore()
        const childOf = store ? store.span : store
        const span = this.tracer.startSpan(this.operationName(), {
          childOf,
          tags: {
            [COMPONENT]: this.constructor.id,
            'service.name': this.config.service || this.serviceName(),
            'resource.name': req.method,
            'span.type': 'web',
            'span.kind': 'server',
            'http.method': req.method,
          },
          integrationName: this.constructor.id,
        })
        analyticsSampler.sample(span, this.config.measured, true)
        const spanId = span.context()._spanId
        this.#requestsBySpanId.set(spanId, req)
        return { ...store, span }
      }
      error({ span, error }) {
        if (!span) {
          const store = storage('legacy').getStore()
          if (!store) return
          span = store.span
        }
        this.addError(error, span)
      }
      finish({ req, res, nextRequest = {} }) {
        const store = storage('legacy').getStore()
        if (!store) return
        const span = store.span
        const error = span.context()._tags.error
        const requestError = req.error || nextRequest.error
        if (requestError) {
          span.setTag('error', requestError)
          web.addError(req, requestError)
        } else if (error) {
          span.setTag('error', error)
          web.addError(req, requestError || error)
        } else if (!this.config.validateStatus(res.statusCode)) {
          span.setTag('error', true)
          web.addError(req, true)
        }
        span.addTags({
          'http.status_code': res.statusCode,
        })
        this.config.hooks.request(span, req, res)
        span.finish()
      }
      pageLoad({ page, isAppPath = false, isStatic = false }) {
        const store = storage('legacy').getStore()
        if (!store) return
        const span = store.span
        const spanId = span.context()._spanId
        const parentSpanId = span.context()._parentId
        const req = this.#requestsBySpanId.get(spanId) ?? this.#requestsBySpanId.get(parentSpanId)
        if (!req) return
        const current = span.context()._tags['next.page']
        const isErrorPage = errorPages.has(page)
        if (current && isErrorPage) {
          return
        }
        if (isAppPath && !isErrorPage) page = page.slice(0, Math.max(0, page.lastIndexOf('/')))
        if (isStatic) {
          page = req.url.includes('_next/static') ? '/_next/static/*' : '/public/*'
        }
        span.addTags({
          [COMPONENT]: this.constructor.id,
          'resource.name': `${req.method} ${page}`.trim(),
          'next.page': page,
        })
        web.setRoute(req, page)
      }
      configure(config) {
        return super.configure(normalizeConfig(config))
      }
    }
    function normalizeConfig(config) {
      const hooks = getHooks(config)
      const validateStatus = typeof config.validateStatus === 'function' ? config.validateStatus : (code) => code < 500
      return { ...config, hooks, validateStatus }
    }
    var noop = () => {}
    function getHooks(config) {
      const request = config.hooks?.request ?? noop
      return { request }
    }
    module2.exports = NextPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-nyc/src/index.js
var require_src60 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-nyc/src/index.js'(exports2, module2) {
    'use strict'
    var CiPlugin = require_ci_plugin()
    var NycPlugin = class extends CiPlugin {
      static id = 'nyc'
      constructor(...args) {
        super(...args)
        this.addSub('ci:nyc:wrap', (nyc) => {
          if (nyc?.config?.all) {
            this.nyc = nyc
          }
        })
        this.addSub('ci:nyc:get-coverage', ({ onDone }) => {
          if (this.nyc?.getCoverageMapFromAllCoverageFiles) {
            this.nyc
              .getCoverageMapFromAllCoverageFiles()
              .then((untestedCoverageMap) => {
                this.nyc = null
                onDone(untestedCoverageMap)
              })
              .catch((e) => {
                this.nyc = null
                onDone()
              })
          } else {
            this.nyc = null
            onDone()
          }
        })
      }
    }
    module2.exports = NycPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-oracledb/src/connection-parser.js
var require_connection_parser = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-oracledb/src/connection-parser.js'(exports2, module2) {
    'use strict'
    var { URL: URL2 } = require('url')
    var log = require_log2()
    function parseOracleDescriptor(descriptor) {
      const hostnameMatch = descriptor.match(/HOST\s*=\s*([^)]+)/i)
      const hostname = hostnameMatch?.[1] || 'localhost'
      const portMatch = descriptor.match(/PORT\s*=\s*([^)]+)/i)
      const port = portMatch?.[1] || '1521'
      const sidMatch = descriptor.match(/SID\s*=\s*([^)]+)/i)
      const dbInstance = sidMatch?.[1] || descriptor.match(/SERVICE_NAME\s*=\s*([^)]+)/i)?.[1] || 'XEPDB1'
      return { hostname, port, dbInstance }
    }
    module2.exports = function getDBInformation(connAttrs) {
      const connectString = ((connAttrs.connectString || connAttrs.connectionString) ?? '').trim()
      if (connectString.startsWith('(')) {
        return parseOracleDescriptor(connectString)
      }
      try {
        const url = new URL2(`oracle://${connectString}`)
        return {
          hostname: url.hostname || 'localhost',
          // Default Oracle hostname
          port: url.port || '1521',
          // Default Oracle port
          dbInstance: (url.pathname && url.pathname.slice(1)) || 'XEPDB1',
          // Default Oracle service name
        }
      } catch (error) {
        log.error('Invalid oracle connection string', error)
        return {}
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js
var require_src61 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY } = require_constants2()
    var DatabasePlugin = require_database()
    var parser
    var OracledbPlugin = class extends DatabasePlugin {
      static id = 'oracledb'
      static system = 'oracle'
      static peerServicePrecursors = ['db.instance', 'db.hostname']
      bindStart(ctx) {
        let { query, connAttrs, port, hostname, dbInstance } = ctx
        const service = this.serviceName({ pluginConfig: this.config, params: connAttrs })
        if (hostname === void 0) {
          parser ??= require_connection_parser()
          const dbInfo = parser(connAttrs)
          hostname = dbInfo.hostname
          port ??= dbInfo.port
          dbInstance ??= dbInfo.dbInstance
        }
        this.startSpan(
          this.operationName(),
          {
            service,
            resource: query,
            type: 'sql',
            kind: 'client',
            meta: {
              'db.user': this.config.user,
              'db.instance': dbInstance,
              'db.hostname': hostname,
              [CLIENT_PORT_KEY]: port,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
    }
    module2.exports = OracledbPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/external-logger/src/index.js
var require_src62 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/external-logger/src/index.js'(exports2, module2) {
    'use strict'
    var tracerLogger = require_log2()
    var https = require('https')
    var ExternalLogger = class _ExternalLogger {
      // Note: these attribute names match the corresponding entry in the JSON payload.
      constructor({
        ddsource,
        hostname,
        service,
        apiKey,
        site = 'datadoghq.com',
        interval = 1e4,
        timeout = 2e3,
        limit = 1e3,
      }) {
        this.enabled = !!apiKey
        this.ddsource = ddsource
        this.hostname = hostname
        this.service = service
        this.interval = interval
        this.timeout = timeout
        this.queue = []
        this.limit = limit
        this.endpoint = '/api/v2/logs'
        this.site = site
        this.intake = `http-intake.logs.${this.site}`
        this.headers = {
          'DD-API-KEY': apiKey,
          'Content-Type': 'application/json',
        }
        this.timer = setInterval(() => {
          this.flush()
        }, this.interval).unref()
        tracerLogger.debug(`started log writer to https://${this.intake}${this.endpoint}`)
      }
      static tagString(tags) {
        const tagArray = []
        for (const key in tags) {
          tagArray.push(key + ':' + tags[key])
        }
        return tagArray.join(',')
      }
      // Parses and enqueues a log
      log(log, span, tags) {
        if (!this.enabled) return
        const logTags = _ExternalLogger.tagString(tags)
        if (span) {
          log['dd.trace_id'] = String(span.trace_id)
          log['dd.span_id'] = String(span.span_id)
        }
        const payload = {
          ...log,
          timestamp: Date.now(),
          hostname: log.hostname || this.hostname,
          ddsource: log.ddsource || this.ddsource,
          service: log.service || this.service,
          ddtags: logTags || void 0,
        }
        this.enqueue(payload)
      }
      // Enqueues a raw, non-formatted log object
      enqueue(log) {
        if (this.queue.length >= this.limit) {
          this.flush()
        }
        this.queue.push(log)
      }
      shutdown() {
        clearInterval(this.timer)
        this.flush()
      }
      // Flushes logs with optional callback for when the call is complete
      flush(cb = () => {}) {
        let logs
        let numLogs
        let encodedLogs
        if (!this.queue.length) {
          setImmediate(() => cb())
          return
        }
        try {
          logs = this.queue
          this.queue = []
          numLogs = logs.length
          encodedLogs = JSON.stringify(logs)
        } catch (error) {
          tracerLogger.error(`failed to encode ${numLogs} logs`)
          setImmediate(() => cb(error))
          return
        }
        const options = {
          hostname: this.intake,
          port: 443,
          path: this.endpoint,
          method: 'POST',
          headers: this.headers,
          timeout: this.timeout,
        }
        const req = https.request(options, (res) => {
          tracerLogger.info(`statusCode: ${res.statusCode}`)
        })
        req.once('error', (e) => {
          tracerLogger.error(`failed to send ${numLogs} log(s), with error ${e.message}`)
          cb(e)
        })
        req.write(encodedLogs)
        req.end()
        req.once('response', (res) => {
          if (res.statusCode >= 400) {
            const error = new Error(`failed to send ${numLogs} logs, received response code ${res.statusCode}`)
            tracerLogger.error(error.message)
            cb(error)
            return
          }
          cb()
        })
      }
    }
    var NoopExternalLogger = class {
      log() {}
      enqueue() {}
      shutdown() {}
      flush() {}
    }
    module2.exports.ExternalLogger = ExternalLogger
    module2.exports.NoopExternalLogger = NoopExternalLogger
  },
})

// node_modules/dd-trace/packages/datadog-plugin-openai/src/services.js
var require_services2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-openai/src/services.js'(exports2, module2) {
    'use strict'
    var { DogStatsDClient } = require_dogstatsd2()
    var NoopDogStatsDClient = require_dogstatsd()
    var { ExternalLogger, NoopExternalLogger } = require_src62()
    var FLUSH_INTERVAL = 10 * 1e3
    var metrics = null
    var logger = null
    var interval = null
    module2.exports.init = function (tracerConfig) {
      metrics =
        tracerConfig && tracerConfig.dogstatsd
          ? new DogStatsDClient({
              host: tracerConfig.dogstatsd.hostname,
              port: tracerConfig.dogstatsd.port,
              tags: [
                `service:${tracerConfig.tags.service}`,
                `env:${tracerConfig.tags.env}`,
                `version:${tracerConfig.tags.version}`,
              ],
            })
          : new NoopDogStatsDClient()
      logger =
        tracerConfig && tracerConfig.apiKey
          ? new ExternalLogger({
              ddsource: 'openai',
              hostname: tracerConfig.hostname,
              service: tracerConfig.service,
              apiKey: tracerConfig.apiKey,
              interval: FLUSH_INTERVAL,
            })
          : new NoopExternalLogger()
      interval = setInterval(() => {
        metrics.flush()
      }, FLUSH_INTERVAL).unref()
      return { metrics, logger }
    }
    module2.exports.shutdown = function () {
      clearInterval(interval)
      metrics = null
      logger = null
      interval = null
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-openai/src/stream-helpers.js
var require_stream_helpers = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-openai/src/stream-helpers.js'(exports2, module2) {
    'use strict'
    function convertBuffersToObjects(chunks) {
      return Buffer.concat(chunks)
        .toString()
        .split(/(?=data:)/)
        .map((chunk) => chunk.replaceAll('\n', '').slice(6))
        .slice(0, -1)
        .map(JSON.parse)
    }
    function constructResponseFromStreamedChunks(chunks, n, onChoice) {
      const body = { ...chunks[0], choices: Array.from({ length: n }) }
      for (const chunk of chunks) {
        body.usage = chunk.usage
        for (const choice of chunk.choices) {
          const choiceIdx = choice.index
          const oldChoice = body.choices.find((choice2) => choice2?.index === choiceIdx)
          if (!oldChoice) {
            body.choices[choiceIdx] = choice
            continue
          }
          if (!oldChoice.finish_reason) {
            oldChoice.finish_reason = choice.finish_reason
          }
          onChoice(choice, oldChoice)
        }
      }
      return body
    }
    function constructCompletionResponseFromStreamedChunks(chunks, n) {
      return constructResponseFromStreamedChunks(chunks, n, (choice, oldChoice) => {
        const text = choice.text
        if (text) {
          if (oldChoice.text) {
            oldChoice.text += text
          } else {
            oldChoice.text = text
          }
        }
      })
    }
    function constructChatCompletionResponseFromStreamedChunks(chunks, n) {
      return constructResponseFromStreamedChunks(chunks, n, (choice, oldChoice) => {
        const delta = choice.delta
        if (!delta) return
        const content = delta.content
        if (content) {
          if (oldChoice.delta.content) {
            oldChoice.delta.content += content
          } else {
            oldChoice.delta.content = content
          }
        }
        const tools = delta.tool_calls
        if (!tools) return
        oldChoice.delta.tool_calls = tools.map((newTool, toolIdx) => {
          const oldTool = oldChoice.delta.tool_calls?.[toolIdx]
          if (oldTool) {
            oldTool.function.arguments += newTool.function.arguments
            return oldTool
          }
          return newTool
        })
      })
    }
    function constructResponseResponseFromStreamedChunks(chunks) {
      const responseStatusSet = /* @__PURE__ */ new Set(['done', 'incomplete', 'completed'])
      for (let i = chunks.length - 1; i >= 0; i--) {
        const chunk = chunks[i]
        if (chunk.response && responseStatusSet.has(chunk.response.status)) {
          return chunk.response
        }
      }
    }
    module2.exports = {
      convertBuffersToObjects,
      constructCompletionResponseFromStreamedChunks,
      constructChatCompletionResponseFromStreamedChunks,
      constructResponseResponseFromStreamedChunks,
    }
  },
})

// node_modules/dd-trace/packages/datadog-plugin-openai/src/tracing.js
var require_tracing10 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-openai/src/tracing.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var TracingPlugin = require_tracing()
    var { storage } = require_datadog_core()
    var services = require_services2()
    var Sampler = require_sampler2()
    var { MEASURED } = require_tags()
    var {
      convertBuffersToObjects,
      constructCompletionResponseFromStreamedChunks,
      constructChatCompletionResponseFromStreamedChunks,
      constructResponseResponseFromStreamedChunks,
    } = require_stream_helpers()
    var { DD_MAJOR } = require_version()
    var OpenAiTracingPlugin = class extends TracingPlugin {
      static id = 'openai'
      static operation = 'request'
      static system = 'openai'
      static prefix = 'tracing:apm:openai:request'
      constructor(...args) {
        super(...args)
        const { metrics, logger } = services.init(this._tracerConfig)
        this.metrics = metrics
        this.logger = logger
        this.sampler = new Sampler(0.1)
        this.addSub('apm:openai:request:chunk', ({ ctx, chunk, done }) => {
          if (!ctx.chunks) ctx.chunks = []
          if (chunk) ctx.chunks.push(chunk)
          if (!done) return
          let chunks = ctx.chunks
          if (chunks.length === 0) return
          const firstChunk = chunks[0]
          if (firstChunk instanceof Buffer) {
            chunks = convertBuffersToObjects(chunks)
          }
          const methodName = ctx.currentStore.normalizedMethodName
          let n = 1
          const prompt = ctx.args[0].prompt
          if (Array.isArray(prompt) && typeof prompt[0] !== 'number') {
            n *= prompt.length
          }
          let response = {}
          if (methodName === 'createCompletion') {
            response = constructCompletionResponseFromStreamedChunks(chunks, n)
          } else if (methodName === 'createChatCompletion') {
            response = constructChatCompletionResponseFromStreamedChunks(chunks, n)
          } else if (methodName === 'createResponse') {
            response = constructResponseResponseFromStreamedChunks(chunks)
          }
          ctx.result = { data: response }
        })
      }
      configure(config) {
        if (config.enabled === false) {
          services.shutdown()
        }
        super.configure(config)
      }
      bindStart(ctx) {
        const { methodName, args } = ctx
        const payload = normalizeRequestPayload(methodName, args)
        const normalizedMethodName = normalizeMethodName(methodName)
        const store = storage('legacy').getStore() || {}
        store.originalMethodName = methodName
        store.normalizedMethodName = normalizedMethodName
        const span = this.startSpan(
          'openai.request',
          {
            service: this.config.service,
            resource: DD_MAJOR >= 6 ? normalizedMethodName : methodName,
            type: 'openai',
            kind: 'client',
            meta: {
              [MEASURED]: 1,
              // Only model is added to all requests
              'openai.request.model': payload.model,
            },
          },
          false
        )
        const openaiStore = /* @__PURE__ */ Object.create(null)
        const tags = {}
        if (payload.stream) {
          tags['openai.request.stream'] = payload.stream
        }
        switch (normalizedMethodName) {
          case 'createImage':
          case 'createImageEdit':
          case 'createImageVariation':
            commonCreateImageRequestExtraction(tags, payload, openaiStore)
            break
          case 'createChatCompletion':
            createChatCompletionRequestExtraction(tags, payload, openaiStore)
            break
          case 'createFile':
          case 'retrieveFile':
            commonFileRequestExtraction(tags, payload)
            break
          case 'createTranscription':
          case 'createTranslation':
            commonCreateAudioRequestExtraction(tags, payload, openaiStore)
            break
          case 'retrieveModel':
            retrieveModelRequestExtraction(tags, payload)
            break
          case 'createEdit':
            createEditRequestExtraction(tags, payload, openaiStore)
            break
          case 'createResponse':
            createResponseRequestExtraction(tags, payload, openaiStore)
            break
        }
        span.addTags(tags)
        ctx.currentStore = { ...store, span, openai: openaiStore }
        return ctx.currentStore
      }
      asyncEnd(ctx) {
        const { result } = ctx
        const store = ctx.currentStore
        const span = store?.span
        if (!span) return
        const error = !!span.context()._tags.error
        let headers, body, method, path2
        if (!error) {
          headers = result.headers
          body = result.data
          method = result.request.method
          path2 = result.request.path
        }
        if (!error && headers?.constructor.name === 'Headers') {
          headers = Object.fromEntries(headers)
        }
        const resource = span._spanContext._tags['resource.name']
        const normalizedMethodName = store.normalizedMethodName
        body = coerceResponseBody(body, normalizedMethodName)
        const openaiStore = store.openai
        if (!error && (path2?.startsWith('https://') || path2?.startsWith('http://'))) {
          path2 = new URL(path2).pathname
        }
        const originalMethodName = store.originalMethodName
        const endpoint = lookupOperationEndpoint(normalizedMethodName, originalMethodName, path2)
        const tags = error
          ? {}
          : {
              'openai.request.endpoint': endpoint,
              'openai.request.method': method.toUpperCase(),
              'openai.response.model': headers['openai-model'] || body.model,
              // specific model, often undefined
              'openai.response.id': body.id,
              // common creation value, numeric epoch
              'openai.response.deleted': body.deleted,
              // common boolean field in delete responses
              // The OpenAI API appears to use both created and created_at in different places
              // Here we're conciously choosing to surface this inconsistency instead of normalizing
              'openai.response.created': body.created,
              'openai.response.created_at': body.created_at,
            }
        responseDataExtractionByMethod(normalizedMethodName, tags, body, openaiStore)
        span.addTags(tags)
        span.finish()
        this.sendLog(resource, span, tags, openaiStore, error)
        this.sendMetrics(headers, body, endpoint, span._duration, error, tags)
      }
      sendMetrics(headers, body, endpoint, duration, error, spanTags) {
        const tags = [`error:${Number(!!error)}`]
        if (error) {
          this.metrics.increment('openai.request.error', 1, tags)
        } else {
          tags.push(
            `org:${headers['openai-organization']}`,
            `endpoint:${endpoint}`,
            `model:${headers['openai-model'] || body.model}`
          )
        }
        this.metrics.distribution('openai.request.duration', duration * 1e3, tags)
        const promptTokens = spanTags['openai.response.usage.prompt_tokens']
        const promptTokensEstimated = spanTags['openai.response.usage.prompt_tokens_estimated']
        const completionTokens = spanTags['openai.response.usage.completion_tokens']
        const completionTokensEstimated = spanTags['openai.response.usage.completion_tokens_estimated']
        const totalTokens = spanTags['openai.response.usage.total_tokens']
        if (!error) {
          if (promptTokens != null) {
            if (promptTokensEstimated) {
              this.metrics.distribution('openai.tokens.prompt', promptTokens, [...tags, 'openai.estimated:true'])
            } else {
              this.metrics.distribution('openai.tokens.prompt', promptTokens, tags)
            }
          }
          if (completionTokens != null) {
            if (completionTokensEstimated) {
              this.metrics.distribution('openai.tokens.completion', completionTokens, [
                ...tags,
                'openai.estimated:true',
              ])
            } else {
              this.metrics.distribution('openai.tokens.completion', completionTokens, tags)
            }
          }
          if (totalTokens != null) {
            if (promptTokensEstimated || completionTokensEstimated) {
              this.metrics.distribution('openai.tokens.total', totalTokens, [...tags, 'openai.estimated:true'])
            } else {
              this.metrics.distribution('openai.tokens.total', totalTokens, tags)
            }
          }
        }
        if (headers) {
          if (headers['x-ratelimit-limit-requests']) {
            this.metrics.gauge('openai.ratelimit.requests', Number(headers['x-ratelimit-limit-requests']), tags)
          }
          if (headers['x-ratelimit-remaining-requests']) {
            this.metrics.gauge(
              'openai.ratelimit.remaining.requests',
              Number(headers['x-ratelimit-remaining-requests']),
              tags
            )
          }
          if (headers['x-ratelimit-limit-tokens']) {
            this.metrics.gauge('openai.ratelimit.tokens', Number(headers['x-ratelimit-limit-tokens']), tags)
          }
          if (headers['x-ratelimit-remaining-tokens']) {
            this.metrics.gauge(
              'openai.ratelimit.remaining.tokens',
              Number(headers['x-ratelimit-remaining-tokens']),
              tags
            )
          }
        }
      }
      sendLog(methodName, span, tags, openaiStore, error) {
        if (!openaiStore) return
        if (!Object.keys(openaiStore).length) return
        if (!this.sampler.isSampled(span)) return
        const log = {
          status: error ? 'error' : 'info',
          message: `sampled ${methodName}`,
          ...openaiStore,
        }
        this.logger.log(log, span, tags)
      }
    }
    function normalizeMethodName(methodName) {
      switch (methodName) {
        // moderations
        case 'moderations.create':
          return 'createModeration'
        // completions
        case 'completions.create':
          return 'createCompletion'
        // chat completions
        case 'chat.completions.create':
          return 'createChatCompletion'
        // edits
        case 'edits.create':
          return 'createEdit'
        // embeddings
        case 'embeddings.create':
          return 'createEmbedding'
        // responses
        case 'responses.create':
          return 'createResponse'
        // files
        case 'files.create':
          return 'createFile'
        case 'files.retrieve':
          return 'retrieveFile'
        case 'files.del':
        case 'files.delete':
          return 'deleteFile'
        case 'files.retrieveContent':
        case 'files.content':
          return 'downloadFile'
        case 'files.list':
          return 'listFiles'
        // fine-tuning
        case 'fine_tuning.jobs.list':
        case 'fine-tune.list':
          return 'listFineTunes'
        case 'fine_tuning.jobs.listEvents':
        case 'fine-tune.listEvents':
          return 'listFineTuneEvents'
        case 'fine_tuning.jobs.create':
        case 'fine-tune.create':
          return 'createFineTune'
        case 'fine_tuning.jobs.retrieve':
        case 'fine-tune.retrieve':
          return 'retrieveFineTune'
        case 'fine_tuning.jobs.cancel':
        case 'fine-tune.cancel':
          return 'cancelFineTune'
        // audio
        case 'audio.transcriptions.create':
          return 'createTranscription'
        case 'audio.translations.create':
          return 'createTranslation'
        // images
        case 'images.generate':
          return 'createImage'
        case 'images.edit':
          return 'createImageEdit'
        case 'images.createVariation':
          return 'createImageVariation'
        // models
        case 'models.list':
          return 'listModels'
        case 'models.retrieve':
          return 'retrieveModel'
        case 'models.del':
        case 'models.delete':
          return 'deleteModel'
        default:
          return methodName
      }
    }
    function createEditRequestExtraction(tags, payload, openaiStore) {
      const instruction = payload.instruction
      openaiStore.instruction = instruction
    }
    function createResponseRequestExtraction(tags, payload, openaiStore) {
      if (payload.model) {
        tags['openai.request.model'] = payload.model
      }
      openaiStore.responseData = payload
    }
    function retrieveModelRequestExtraction(tags, payload) {
      tags['openai.request.id'] = payload.id
    }
    function createChatCompletionRequestExtraction(tags, payload, openaiStore) {
      const messages = payload.messages
      if (!defensiveArrayLength(messages)) return
      openaiStore.messages = payload.messages
    }
    function commonCreateImageRequestExtraction(tags, payload, openaiStore) {
      const img = payload.file || payload.image
      if (img !== null && typeof img === 'object' && img.path) {
        const file = path.basename(img.path)
        openaiStore.file = file
      }
      if (payload.mask !== null && typeof payload.mask === 'object' && payload.mask.path) {
        const mask = path.basename(payload.mask.path)
        openaiStore.mask = mask
      }
    }
    function responseDataExtractionByMethod(methodName, tags, body, openaiStore) {
      switch (methodName) {
        case 'createCompletion':
        case 'createChatCompletion':
        case 'createEdit':
          commonCreateResponseExtraction(tags, body, openaiStore, methodName)
          break
        case 'createResponse':
          createResponseResponseExtraction(tags, body, openaiStore)
          break
        case 'listFiles':
        case 'listFineTunes':
        case 'listFineTuneEvents':
          commonListCountResponseExtraction(tags, body)
          break
        case 'createFile':
        case 'retrieveFile':
          createRetrieveFileResponseExtraction(tags, body)
          break
        case 'deleteFile':
          deleteFileResponseExtraction(tags, body)
          break
        case 'downloadFile':
          downloadFileResponseExtraction(tags, body)
          break
        case 'listModels':
          listModelsResponseExtraction(tags, body)
          break
        case 'retrieveModel':
          retrieveModelResponseExtraction(tags, body)
          break
      }
    }
    function retrieveModelResponseExtraction(tags, body) {
      tags['openai.response.owned_by'] = body.owned_by
      tags['openai.response.parent'] = body.parent
      tags['openai.response.root'] = body.root
      if (!body.permission) return
      tags['openai.response.permission.id'] = body.permission[0].id
      tags['openai.response.permission.created'] = body.permission[0].created
      tags['openai.response.permission.allow_create_engine'] = body.permission[0].allow_create_engine
      tags['openai.response.permission.allow_sampling'] = body.permission[0].allow_sampling
      tags['openai.response.permission.allow_logprobs'] = body.permission[0].allow_logprobs
      tags['openai.response.permission.allow_search_indices'] = body.permission[0].allow_search_indices
      tags['openai.response.permission.allow_view'] = body.permission[0].allow_view
      tags['openai.response.permission.allow_fine_tuning'] = body.permission[0].allow_fine_tuning
      tags['openai.response.permission.organization'] = body.permission[0].organization
      tags['openai.response.permission.group'] = body.permission[0].group
      tags['openai.response.permission.is_blocking'] = body.permission[0].is_blocking
    }
    function listModelsResponseExtraction(tags, body) {
      if (!body.data) return
      tags['openai.response.count'] = body.data.length
    }
    function downloadFileResponseExtraction(tags, body) {
      if (typeof body.file !== 'string') return
      tags['openai.response.total_bytes'] = Buffer.byteLength(body.file)
    }
    function deleteFileResponseExtraction(tags, body) {
      tags['openai.response.id'] = body.id
    }
    function commonCreateAudioRequestExtraction(tags, body, openaiStore) {
      if (body.file !== null && typeof body.file === 'object' && body.file.path) {
        const filename = path.basename(body.file.path)
        openaiStore.file = filename
      }
    }
    function commonFileRequestExtraction(tags, body) {
      tags['openai.request.purpose'] = body.purpose
      if (body.file !== null && typeof body.file === 'object' && body.file.path) {
        tags['openai.request.filename'] = path.basename(body.file.path)
      }
    }
    function createRetrieveFileResponseExtraction(tags, body) {
      tags['openai.response.filename'] = body.filename
      tags['openai.response.purpose'] = body.purpose
      tags['openai.response.bytes'] = body.bytes
      tags['openai.response.status'] = body.status
      tags['openai.response.status_details'] = body.status_details
    }
    function commonListCountResponseExtraction(tags, body) {
      if (!body.data) return
      tags['openai.response.count'] = body.data.length
    }
    function commonCreateResponseExtraction(tags, body, openaiStore, methodName) {
      if (!body.choices) return
      openaiStore.choices = body.choices
    }
    function createResponseResponseExtraction(tags, body, openaiStore) {
      if (body.id) {
        tags['openai.response.id'] = body.id
      }
      if (body.status) {
        tags['openai.response.status'] = body.status
      }
      if (body.model) {
        tags['openai.response.model'] = body.model
      }
      openaiStore.response = body
    }
    function coerceResponseBody(body, methodName) {
      switch (methodName) {
        case 'downloadFile':
          return { file: body }
      }
      const type = typeof body
      if (type === 'string') {
        try {
          return JSON.parse(body)
        } catch {
          return body
        }
      } else if (type === 'object') {
        return body
      } else {
        return {}
      }
    }
    function lookupOperationEndpoint(operationId, methodName, url) {
      switch (operationId) {
        case 'deleteModel':
        case 'retrieveModel':
          return '/v1/models/*'
        case 'deleteFile':
        case 'retrieveFile':
          return '/v1/files/*'
        case 'downloadFile':
          return '/v1/files/*/content'
        case 'retrieveFineTune':
          switch (methodName) {
            case 'fine_tuning.jobs.retrieve':
              return '/v1/fine_tuning/jobs/*'
            default:
              return '/v1/fine-tunes/*'
          }
        case 'listFineTuneEvents':
          switch (methodName) {
            case 'fine_tuning.jobs.listEvents':
              return '/v1/fine_tuning/jobs/*/events'
            default:
              return '/v1/fine-tunes/*/events'
          }
        case 'cancelFineTune':
          switch (methodName) {
            case 'fine_tuning.jobs.cancel':
              return '/v1/fine_tuning/jobs/*/cancel'
            default:
              return '/v1/fine-tunes/*/cancel'
          }
      }
      return url
    }
    function normalizeRequestPayload(methodName, args) {
      switch (methodName) {
        case 'listModels':
        case 'models.list':
        case 'listFiles':
        case 'files.list':
        case 'listFineTunes':
        case 'fine_tuning.jobs.list':
        case 'fine-tune.list':
          return {}
        case 'retrieveModel':
        case 'models.retrieve':
          return { id: args[0] }
        case 'createFile':
          return {
            file: args[0],
            purpose: args[1],
          }
        case 'deleteFile':
        case 'files.del':
        case 'files.delete':
        case 'retrieveFile':
        case 'files.retrieve':
        case 'downloadFile':
        case 'files.retrieveContent':
        case 'files.content':
          return { file_id: args[0] }
        case 'listFineTuneEvents':
        case 'fine_tuning.jobs.listEvents':
        case 'fine-tune.listEvents':
          return {
            fine_tune_id: args[0],
            stream: args[1],
            // undocumented
          }
        case 'retrieveFineTune':
        case 'fine_tuning.jobs.retrieve':
        case 'fine-tune.retrieve':
        case 'deleteModel':
        case 'models.del':
        case 'models.delete':
        case 'cancelFineTune':
        case 'fine_tuning.jobs.cancel':
        case 'fine-tune.cancel':
          return { fine_tune_id: args[0] }
        case 'createImageEdit':
          return {
            file: args[0],
            prompt: args[1],
            // Note: order of prompt/mask in Node.js lib differs from public docs
            mask: args[2],
            n: args[3],
            size: args[4],
            response_format: args[5],
            user: args[6],
          }
        case 'createImageVariation':
          return {
            file: args[0],
            n: args[1],
            size: args[2],
            response_format: args[3],
            user: args[4],
          }
        case 'createTranscription':
        case 'createTranslation':
          return {
            file: args[0],
            model: args[1],
            prompt: args[2],
            response_format: args[3],
            temperature: args[4],
            language: args[5],
            // only used for createTranscription
          }
      }
      return args[0]
    }
    function defensiveArrayLength(maybeArray) {
      if (maybeArray) {
        return Array.isArray(maybeArray) ? maybeArray.length : 1
      }
    }
    module2.exports = OpenAiTracingPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/openai/utils.js
var require_utils8 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/openai/utils.js'(exports2, module2) {
    'use strict'
    var IMAGE_FALLBACK = '[image]'
    var FILE_FALLBACK = '[file]'
    var REGEX_SPECIAL_CHARS = /[.*+?^${}()|[\]\\]/g
    function extractChatTemplateFromInstructions(instructions, variables) {
      if (!Array.isArray(instructions) || !variables) return []
      const chatTemplate = []
      const valueToPlaceholder = {}
      for (const [varName, varValue] of Object.entries(variables)) {
        if (varValue && varValue !== IMAGE_FALLBACK && varValue !== FILE_FALLBACK) {
          valueToPlaceholder[varValue] = `{{${varName}}}`
        }
      }
      const sortedValues = Object.keys(valueToPlaceholder).sort((a, b) => b.length - a.length)
      for (const instruction of instructions) {
        const role = instruction.role
        if (!role) continue
        const contentItems = instruction.content
        if (!Array.isArray(contentItems)) continue
        const textParts = contentItems.map(extractTextFromContentItem).filter(Boolean)
        if (textParts.length === 0) continue
        let fullText = textParts.join('')
        for (const valueStr of sortedValues) {
          const placeholder = valueToPlaceholder[valueStr]
          const escapedValue = valueStr.replaceAll(REGEX_SPECIAL_CHARS, String.raw`\$&`)
          fullText = fullText.replaceAll(new RegExp(escapedValue, 'g'), placeholder)
        }
        chatTemplate.push({ role, content: fullText })
      }
      return chatTemplate
    }
    function extractTextFromContentItem(contentItem) {
      if (!contentItem) return null
      if (contentItem.text) {
        return contentItem.text
      }
      if (contentItem.type === 'input_image') {
        return contentItem.image_url || contentItem.file_id || IMAGE_FALLBACK
      }
      if (contentItem.type === 'input_file') {
        return contentItem.file_id || contentItem.file_url || contentItem.filename || FILE_FALLBACK
      }
      return null
    }
    function normalizePromptVariables(variables) {
      if (!variables) return {}
      return Object.fromEntries(
        Object.entries(variables).map(([key, value]) => [key, extractTextFromContentItem(value) ?? String(value ?? '')])
      )
    }
    module2.exports = {
      extractChatTemplateFromInstructions,
      normalizePromptVariables,
      extractTextFromContentItem,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/openai/index.js
var require_openai2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/plugins/openai/index.js'(exports2, module2) {
    'use strict'
    var LLMObsPlugin = require_base()
    var { extractChatTemplateFromInstructions, normalizePromptVariables, extractTextFromContentItem } = require_utils8()
    var allowedParamKeys = /* @__PURE__ */ new Set(['max_output_tokens', 'temperature', 'stream', 'reasoning'])
    function isIterable(obj) {
      if (obj == null) {
        return false
      }
      return typeof obj[Symbol.iterator] === 'function'
    }
    var OpenAiLLMObsPlugin = class extends LLMObsPlugin {
      static id = 'openai'
      static integration = 'openai'
      static prefix = 'tracing:apm:openai:request'
      getLLMObsSpanRegisterOptions(ctx) {
        const resource = ctx.methodName
        const methodName = gateResource(normalizeOpenAIResourceName(resource))
        if (!methodName) return
        const inputs = ctx.args[0]
        const operation = getOperation(methodName)
        const kind = operation === 'embedding' ? 'embedding' : 'llm'
        const { modelProvider, client } = this._getModelProviderAndClient(ctx.basePath)
        const name = `${client}.${methodName}`
        return {
          modelProvider,
          modelName: inputs.model,
          kind,
          name,
        }
      }
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span
        const resource = ctx.methodName
        const methodName = gateResource(normalizeOpenAIResourceName(resource))
        if (!methodName) return
        const inputs = ctx.args[0]
        const response = ctx.result?.data
        const error = !!span.context()._tags.error
        const operation = getOperation(methodName)
        if (operation === 'completion') {
          this._tagCompletion(span, inputs, response, error)
        } else if (operation === 'chat') {
          this._tagChatCompletion(span, inputs, response, error)
        } else if (operation === 'embedding') {
          this._tagEmbedding(span, inputs, response, error)
        } else if (operation === 'response') {
          this.#tagResponse(span, inputs, response, error)
        }
        if (!error) {
          const metrics = this._extractMetrics(response)
          this._tagger.tagMetrics(span, metrics)
          const responseModel = response.model
          if (responseModel) {
            this._tagger.tagModelName(span, responseModel)
          }
        }
      }
      _getModelProviderAndClient(baseUrl = '') {
        if (baseUrl.includes('azure')) {
          return { modelProvider: 'azure_openai', client: 'AzureOpenAI' }
        } else if (baseUrl.includes('deepseek')) {
          return { modelProvider: 'deepseek', client: 'DeepSeek' }
        }
        return { modelProvider: 'openai', client: 'OpenAI' }
      }
      _extractMetrics(response) {
        const metrics = {}
        const tokenUsage = response.usage
        if (tokenUsage) {
          const inputTokens = tokenUsage.input_tokens ?? tokenUsage.prompt_tokens ?? 0
          if (inputTokens !== void 0) metrics.inputTokens = inputTokens
          const outputTokens = tokenUsage.output_tokens ?? tokenUsage.completion_tokens ?? 0
          if (outputTokens !== void 0) metrics.outputTokens = outputTokens
          const totalTokens = tokenUsage.total_tokens || inputTokens + outputTokens
          if (totalTokens !== void 0) metrics.totalTokens = totalTokens
          if (tokenUsage.input_tokens_details) {
            const cacheReadTokens = tokenUsage.input_tokens_details.cached_tokens
            if (cacheReadTokens !== void 0) metrics.cacheReadTokens = cacheReadTokens
          } else if (tokenUsage.prompt_tokens_details) {
            const cacheReadTokens = tokenUsage.prompt_tokens_details.cached_tokens
            if (cacheReadTokens != null) {
              metrics.cacheReadTokens = cacheReadTokens
            }
          }
          const reasoningOutputObject = tokenUsage.output_tokens_details ?? tokenUsage.completion_tokens_details
          const reasoningOutputTokens = reasoningOutputObject?.reasoning_tokens ?? 0
          if (reasoningOutputTokens !== void 0) metrics.reasoningOutputTokens = reasoningOutputTokens
        }
        return metrics
      }
      _tagEmbedding(span, inputs, response, error) {
        const { model, ...parameters } = inputs
        const metadata = {
          encoding_format: parameters.encoding_format || 'float',
        }
        if (inputs.dimensions) metadata.dimensions = inputs.dimensions
        this._tagger.tagMetadata(span, metadata)
        let embeddingInputs = inputs.input
        if (!Array.isArray(embeddingInputs)) embeddingInputs = [embeddingInputs]
        const embeddingInput = embeddingInputs.map((input) => ({ text: input }))
        if (error) {
          this._tagger.tagEmbeddingIO(span, embeddingInput)
          return
        }
        const float = Array.isArray(response.data[0].embedding)
        let embeddingOutput
        if (float) {
          const embeddingDim = response.data[0].embedding.length
          embeddingOutput = `[${response.data.length} embedding(s) returned with size ${embeddingDim}]`
        } else {
          embeddingOutput = `[${response.data.length} embedding(s) returned]`
        }
        this._tagger.tagEmbeddingIO(span, embeddingInput, embeddingOutput)
      }
      _tagCompletion(span, inputs, response, error) {
        let { prompt, model, ...parameters } = inputs
        if (!Array.isArray(prompt)) prompt = [prompt]
        const completionInput = prompt.map((p) => ({ content: p }))
        const completionOutput = error
          ? [{ content: '' }]
          : response.choices.map((choice) => ({ content: choice.text }))
        this._tagger.tagLLMIO(span, completionInput, completionOutput)
        this._tagger.tagMetadata(span, parameters)
      }
      _tagChatCompletion(span, inputs, response, error) {
        const { messages, model, ...parameters } = inputs
        const metadata = Object.entries(parameters).reduce((obj, [key, value]) => {
          if (!['tools', 'functions'].includes(key)) {
            obj[key] = value
          }
          return obj
        }, {})
        this._tagger.tagMetadata(span, metadata)
        if (error) {
          this._tagger.tagLLMIO(span, messages, [{ content: '' }])
          return
        }
        const outputMessages = []
        const { choices } = response
        if (!isIterable(choices)) {
          this._tagger.tagLLMIO(span, messages, [{ content: '' }])
          return
        }
        for (const choice of choices) {
          const message = choice.message || choice.delta
          const content = message.content || ''
          const role = message.role
          if (message.function_call) {
            const functionCallInfo = {
              name: message.function_call.name,
              arguments: JSON.parse(message.function_call.arguments),
            }
            outputMessages.push({ content, role, toolCalls: [functionCallInfo] })
          } else if (message.tool_calls) {
            const toolCallsInfo = []
            for (const toolCall of message.tool_calls) {
              const toolCallInfo = {
                arguments: JSON.parse(toolCall.function.arguments),
                name: toolCall.function.name,
                toolId: toolCall.id,
                type: toolCall.type,
              }
              toolCallsInfo.push(toolCallInfo)
            }
            outputMessages.push({ content, role, toolCalls: toolCallsInfo })
          } else {
            outputMessages.push({ content, role })
          }
        }
        this._tagger.tagLLMIO(span, messages, outputMessages)
      }
      #tagResponse(span, inputs, response, error) {
        const { model, ...parameters } = inputs
        let input = inputs.input
        const inputMessages = []
        if (inputs.instructions) {
          inputMessages.push({ role: 'system', content: inputs.instructions })
        }
        if (!input && inputs.prompt && response?.instructions) {
          input = response.instructions
        }
        if (Array.isArray(input)) {
          for (const item of input) {
            if (item.type === 'message') {
              const role = item.role
              if (!role) continue
              let content = ''
              if (Array.isArray(item.content)) {
                const textParts = item.content.map(extractTextFromContentItem).filter(Boolean)
                content = textParts.join('')
              } else if (typeof item.content === 'string') {
                content = item.content
              }
              if (content) {
                inputMessages.push({ role, content })
              }
            } else if (item.type === 'function_call') {
              let parsedArgs = item.arguments
              if (typeof parsedArgs === 'string') {
                try {
                  parsedArgs = JSON.parse(parsedArgs)
                } catch {
                  parsedArgs = {}
                }
              }
              inputMessages.push({
                role: 'assistant',
                toolCalls: [
                  {
                    toolId: item.call_id,
                    name: item.name,
                    arguments: parsedArgs,
                    type: item.type,
                  },
                ],
              })
            } else if (item.type === 'function_call_output') {
              inputMessages.push({
                role: 'user',
                toolResults: [
                  {
                    toolId: item.call_id,
                    result: item.output,
                    name: item.name || '',
                    type: item.type,
                  },
                ],
              })
            } else if (item.role && item.content) {
              inputMessages.push({ role: item.role, content: item.content })
            }
          }
        } else {
          inputMessages.push({ role: 'user', content: input })
        }
        const inputMetadata = Object.entries(parameters).reduce((obj, [key, value]) => {
          if (allowedParamKeys.has(key)) {
            obj[key] = value
          }
          return obj
        }, {})
        this._tagger.tagMetadata(span, inputMetadata)
        if (error) {
          this._tagger.tagLLMIO(span, inputMessages, [{ content: '' }])
          return
        }
        const outputMessages = []
        if (typeof response.output === 'string') {
          outputMessages.push({ role: 'assistant', content: response.output })
        } else if (Array.isArray(response.output)) {
          for (const item of response.output) {
            if (item.type === 'reasoning') {
              outputMessages.push({
                role: 'reasoning',
                content: JSON.stringify({
                  summary: item.summary ?? [],
                  encrypted_content: item.encrypted_content ?? null,
                  id: item.id ?? '',
                }),
              })
            } else if (item.type === 'function_call') {
              let args = item.arguments
              if (typeof args === 'string') {
                try {
                  args = JSON.parse(args)
                } catch {
                  args = {}
                }
              }
              outputMessages.push({
                role: 'assistant',
                toolCalls: [
                  {
                    toolId: item.call_id,
                    name: item.name,
                    arguments: args,
                    type: item.type,
                  },
                ],
              })
            } else {
              const outputMsg = { role: item.role || 'assistant', content: '' }
              if (Array.isArray(item.content)) {
                const textParts = item.content.filter((c) => c.type === 'output_text').map((c) => c.text)
                outputMsg.content = textParts.join('')
              } else if (typeof item.content === 'string') {
                outputMsg.content = item.content
              }
              if (Array.isArray(item.tool_calls)) {
                outputMsg.toolCalls = item.tool_calls.map((tc) => {
                  let args = tc.function?.arguments || tc.arguments
                  if (typeof args === 'string') {
                    try {
                      args = JSON.parse(args)
                    } catch {
                      args = {}
                    }
                  }
                  return {
                    toolId: tc.id,
                    name: tc.function?.name || tc.name,
                    arguments: args,
                    type: tc.type || 'function_call',
                  }
                })
              }
              outputMessages.push(outputMsg)
            }
          }
        } else if (response.output_text) {
          outputMessages.push({ role: 'assistant', content: response.output_text })
        } else {
          outputMessages.push({ role: 'assistant', content: '' })
        }
        this._tagger.tagLLMIO(span, inputMessages, outputMessages)
        if (inputs.prompt && response?.prompt) {
          const { id, version } = response.prompt
          if (id && version) {
            const normalizedVariables = normalizePromptVariables(inputs.prompt.variables)
            const chatTemplate = extractChatTemplateFromInstructions(response.instructions, normalizedVariables)
            this._tagger._setTag(span, '_ml_obs.meta.input.prompt', {
              id,
              version,
              variables: normalizedVariables,
              chat_template: chatTemplate,
            })
          }
        }
        const outputMetadata = {}
        if (response.temperature !== void 0) outputMetadata.temperature = Number(response.temperature)
        if (response.top_p !== void 0) outputMetadata.top_p = Number(response.top_p)
        if (response.tool_choice !== void 0) outputMetadata.tool_choice = response.tool_choice
        if (response.truncation !== void 0) outputMetadata.truncation = response.truncation
        if (response.text !== void 0) outputMetadata.text = response.text
        this._tagger.tagMetadata(span, outputMetadata)
      }
    }
    function normalizeOpenAIResourceName(resource) {
      switch (resource) {
        // completions
        case 'completions.create':
          return 'createCompletion'
        // chat completions
        case 'chat.completions.create':
          return 'createChatCompletion'
        // embeddings
        case 'embeddings.create':
          return 'createEmbedding'
        // responses
        case 'responses.create':
          return 'createResponse'
        default:
          return resource
      }
    }
    function gateResource(resource) {
      return ['createCompletion', 'createChatCompletion', 'createEmbedding', 'createResponse'].includes(resource)
        ? resource
        : void 0
    }
    function getOperation(resource) {
      switch (resource) {
        case 'createCompletion':
          return 'completion'
        case 'createChatCompletion':
          return 'chat'
        case 'createEmbedding':
          return 'embedding'
        case 'createResponse':
          return 'response'
        default:
          return 'unknown'
      }
    }
    module2.exports = OpenAiLLMObsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-openai/src/index.js
var require_src63 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-openai/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var OpenAiTracingPlugin = require_tracing10()
    var OpenAiLLMObsPlugin = require_openai2()
    var OpenAiPlugin = class extends CompositePlugin {
      static id = 'openai'
      static get plugins() {
        return {
          llmobs: OpenAiLLMObsPlugin,
          tracing: OpenAiTracingPlugin,
        }
      }
    }
    module2.exports = OpenAiPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js
var require_src64 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY } = require_constants2()
    var DatabasePlugin = require_database()
    var PGPlugin = class extends DatabasePlugin {
      static id = 'pg'
      static operation = 'query'
      static system = 'postgres'
      bindStart(ctx) {
        const { params = {}, query, processId, stream } = ctx
        const service = this.serviceName({ pluginConfig: this.config, params })
        const originalStatement = this.maybeTruncate(query.text)
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            resource: originalStatement,
            type: 'sql',
            kind: 'client',
            meta: {
              'db.type': 'postgres',
              'db.pid': processId,
              'db.name': params.database,
              'db.user': params.user,
              'out.host': params.host,
              [CLIENT_PORT_KEY]: params.port,
            },
          },
          ctx
        )
        if (stream) {
          span.setTag('db.stream', 1)
        }
        query.__ddInjectableQuery = this.injectDbmQuery(span, query.text, service, !!query.name)
        return ctx.currentStore
      }
    }
    module2.exports = PGPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js
var require_src65 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js'(exports2, module2) {
    'use strict'
    var LogPlugin = require_log_plugin()
    var PinoPlugin = class extends LogPlugin {
      static id = 'pino'
    }
    module2.exports = PinoPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-protobufjs/src/schema_iterator.js
var require_schema_iterator2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-protobufjs/src/schema_iterator.js'(exports2, module2) {
    'use strict'
    var PROTOBUF = 'protobuf'
    var { SCHEMA_DEFINITION, SCHEMA_ID, SCHEMA_NAME, SCHEMA_OPERATION, SCHEMA_WEIGHT, SCHEMA_TYPE } =
      require_constants2()
    var log = require_log2()
    var { SchemaBuilder } = require_datastreams()
    var SchemaExtractor = class _SchemaExtractor {
      constructor(schema) {
        this.schema = schema
      }
      static getTypeAndFormat(type) {
        const typeFormatMapping = {
          int32: ['integer', 'int32'],
          int64: ['integer', 'int64'],
          uint32: ['integer', 'uint32'],
          uint64: ['integer', 'uint64'],
          sint32: ['integer', 'sint32'],
          sint64: ['integer', 'sint64'],
          fixed32: ['integer', 'fixed32'],
          fixed64: ['integer', 'fixed64'],
          sfixed32: ['integer', 'sfixed32'],
          sfixed64: ['integer', 'sfixed64'],
          float: ['number', 'float'],
          double: ['number', 'double'],
          bool: ['boolean', null],
          string: ['string', null],
          bytes: ['string', 'byte'],
          Enum: ['enum', null],
          Type: ['type', null],
          map: ['map', null],
          repeated: ['array', null],
        }
        return typeFormatMapping[type] || ['string', null]
      }
      static extractProperty(field, schemaName, fieldName, builder, depth) {
        let array = false
        let description
        let ref
        let enumValues
        const resolvedType = field.resolvedType ? field.resolvedType.constructor.name : field.type
        const isRepeatedField = field.rule === 'repeated'
        let typeFormat = this.getTypeAndFormat(isRepeatedField ? 'repeated' : resolvedType)
        let type = typeFormat[0]
        let format = typeFormat[1]
        if (type === 'array') {
          array = true
          typeFormat = this.getTypeAndFormat(resolvedType)
          type = typeFormat[0]
          format = typeFormat[1]
        }
        if (type === 'type') {
          format = null
          ref = `#/components/schemas/${removeLeadingPeriod(field.resolvedType.fullName)}`
          const originalSchemaExtractor = builder.iterator
          if (!this.extractSchema(field.resolvedType, builder, depth, this)) {
            return false
          }
          type = 'object'
          builder.iterator = originalSchemaExtractor
        } else if (type === 'enum') {
          enumValues = []
          let i = 0
          while (field.resolvedType.valuesById[i]) {
            enumValues.push(field.resolvedType.valuesById[i])
            i += 1
          }
        }
        return builder.addProperty(schemaName, fieldName, array, type, description, ref, format, enumValues)
      }
      static extractSchema(schema, builder, depth, extractor) {
        depth += 1
        const schemaName = removeLeadingPeriod(schema.resolvedType ? schema.resolvedType.fullName : schema.fullName)
        if (extractor) {
          const nestedSchemaExtractor = new _SchemaExtractor(schema)
          builder.iterator = nestedSchemaExtractor
          const nestedSchema = SchemaBuilder.getSchema(schemaName, nestedSchemaExtractor, builder)
          for (const nestedSubSchemaName in nestedSchema.components.schemas) {
            if (nestedSchema.components.schemas.hasOwnProperty(nestedSubSchemaName)) {
              builder.schema.components.schemas[nestedSubSchemaName] =
                nestedSchema.components.schemas[nestedSubSchemaName]
            }
          }
          return true
        }
        if (!builder.shouldExtractSchema(schemaName, depth)) {
          return false
        }
        for (const field of schema.fieldsArray) {
          if (!this.extractProperty(field, schemaName, field.name, builder, depth)) {
            log.warn('DSM: Unable to extract field with name: %s from Avro schema with name:', field.name, schemaName)
          }
        }
        return true
      }
      static extractSchemas(descriptor, dataStreamsProcessor) {
        const schemaName = removeLeadingPeriod(
          descriptor.resolvedType ? descriptor.resolvedType.fullName : descriptor.fullName
        )
        return dataStreamsProcessor.getSchema(schemaName, new _SchemaExtractor(descriptor))
      }
      iterateOverSchema(builder) {
        this.constructor.extractSchema(this.schema, builder, 0)
      }
      static attachSchemaOnSpan(args, span, operation, tracer2) {
        const { messageClass } = args
        const descriptor = messageClass.$type ?? messageClass
        if (!descriptor || !span) {
          return
        }
        if (span.context()._tags[SCHEMA_TYPE] && operation === 'serialization') {
          return
        }
        span.setTag(SCHEMA_TYPE, PROTOBUF)
        span.setTag(SCHEMA_NAME, removeLeadingPeriod(descriptor.fullName))
        span.setTag(SCHEMA_OPERATION, operation)
        if (!tracer2._dataStreamsProcessor.canSampleSchema(operation)) {
          return
        }
        if (!tracer2._prioritySampler.isSampled(span)) {
          return
        }
        const weight = tracer2._dataStreamsProcessor.trySampleSchema(operation)
        if (weight === 0) {
          return
        }
        const schemaData = SchemaBuilder.getSchemaDefinition(
          this.extractSchemas(descriptor, tracer2._dataStreamsProcessor)
        )
        span.setTag(SCHEMA_DEFINITION, schemaData.definition)
        span.setTag(SCHEMA_WEIGHT, weight)
        span.setTag(SCHEMA_ID, schemaData.id)
      }
    }
    function removeLeadingPeriod(str) {
      if (str.charAt(0) === '.') {
        return str.slice(1)
      }
      return str
    }
    module2.exports = SchemaExtractor
  },
})

// node_modules/dd-trace/packages/datadog-plugin-protobufjs/src/index.js
var require_src66 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-protobufjs/src/index.js'(exports2, module2) {
    'use strict'
    var SchemaPlugin = require_schema2()
    var SchemaExtractor = require_schema_iterator2()
    var ProtobufjsPlugin = class extends SchemaPlugin {
      static id = 'protobufjs'
      static schemaExtractor = SchemaExtractor
    }
    module2.exports = ProtobufjsPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js
var require_src67 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js'(exports2, module2) {
    'use strict'
    var RouterPlugin = require_src15()
    var web = require_web3()
    var RestifyPlugin = class extends RouterPlugin {
      static id = 'restify'
      constructor(...args) {
        super(...args)
        this.addSub('apm:restify:request:handle', ({ req }) => {
          this.setFramework(req, 'restify', this.config)
        })
        this.addSub('apm:restify:request:route', ({ req, route }) => {
          web.setRoute(req, route)
        })
      }
      configure(config) {
        return super.configure({
          ...config,
          middleware: false,
          // not supported
        })
      }
    }
    module2.exports = RestifyPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-rhea/src/producer.js
var require_producer9 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-rhea/src/producer.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY } = require_constants2()
    var ProducerPlugin = require_producer()
    var { getAmqpMessageSize, DsmPathwayCodec } = require_datastreams()
    var RheaProducerPlugin = class extends ProducerPlugin {
      static id = 'rhea'
      static operation = 'send'
      constructor(...args) {
        super(...args)
        this.addTraceSub('encode', this.encode.bind(this))
      }
      bindStart(ctx) {
        const { targetAddress, host, port } = ctx
        const name = targetAddress || 'amq.topic'
        this.startSpan(
          {
            resource: name,
            meta: {
              component: 'rhea',
              'amqp.link.target.address': name,
              'amqp.link.role': 'sender',
              'out.host': host,
              [CLIENT_PORT_KEY]: port,
            },
          },
          ctx
        )
        return ctx.currentStore
      }
      encode(msg) {
        addDeliveryAnnotations(msg, this.tracer, this.activeSpan)
      }
    }
    function addDeliveryAnnotations(msg, tracer2, span) {
      if (msg) {
        msg.delivery_annotations = msg.delivery_annotations || {}
        tracer2.inject(span, 'text_map', msg.delivery_annotations)
        if (tracer2._config.dsmEnabled) {
          const targetName = span.context()._tags['amqp.link.target.address']
          const payloadSize = getAmqpMessageSize({ content: msg.body, headers: msg.delivery_annotations })
          const dataStreamsContext = tracer2.setCheckpoint(
            ['direction:out', `exchange:${targetName}`, 'type:rabbitmq'],
            span,
            payloadSize
          )
          DsmPathwayCodec.encode(dataStreamsContext, msg.delivery_annotations)
        }
      }
    }
    module2.exports = RheaProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-rhea/src/consumer.js
var require_consumer7 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-rhea/src/consumer.js'(exports2, module2) {
    'use strict'
    var ConsumerPlugin = require_consumer()
    var { getAmqpMessageSize } = require_datastreams()
    var RheaConsumerPlugin = class extends ConsumerPlugin {
      static id = 'rhea'
      constructor(...args) {
        super(...args)
        this.addTraceSub('dispatch', (ctx) => {
          const span = ctx.currentStore.span
          span.setTag('amqp.delivery.state', ctx.state)
        })
      }
      bindStart(ctx) {
        const { msgObj } = ctx
        const name = getResourceNameFromMessage(msgObj)
        const childOf = extractTextMap(msgObj, this.tracer)
        const span = this.startSpan(
          {
            childOf,
            resource: name,
            type: 'worker',
            meta: {
              component: 'rhea',
              'amqp.link.source.address': name,
              'amqp.link.role': 'receiver',
            },
          },
          ctx
        )
        if (this.config.dsmEnabled && msgObj?.message?.delivery_annotations) {
          const payloadSize = getAmqpMessageSize({
            headers: msgObj.message.delivery_annotations,
            content: msgObj.message.body,
          })
          this.tracer.decodeDataStreamsContext(msgObj.message.delivery_annotations)
          this.tracer.setCheckpoint(['direction:in', `topic:${name}`, 'type:rabbitmq'], span, payloadSize)
        }
        return ctx.currentStore
      }
    }
    function getResourceNameFromMessage(msgObj) {
      let resourceName = 'amq.topic'
      let options = {}
      if (msgObj.receiver && msgObj.receiver.options) {
        options = msgObj.receiver.options
      }
      if (options.source && options.source.address) {
        resourceName = options.source.address
      }
      return resourceName
    }
    function extractTextMap(msgObj, tracer2) {
      if (msgObj.message) {
        return tracer2.extract('text_map', msgObj.message.delivery_annotations)
      }
    }
    module2.exports = RheaConsumerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js
var require_src68 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js'(exports2, module2) {
    'use strict'
    var ProducerPlugin = require_producer9()
    var ConsumerPlugin = require_consumer7()
    var CompositePlugin = require_composite()
    var RheaPlugin = class extends CompositePlugin {
      static id = 'rhea'
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
        }
      }
    }
    module2.exports = RheaPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-selenium/src/index.js
var require_src69 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-selenium/src/index.js'(exports2, module2) {
    'use strict'
    var CiPlugin = require_ci_plugin()
    var { storage } = require_datadog_core()
    var {
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      TEST_BROWSER_DRIVER_VERSION,
      TEST_BROWSER_NAME,
      TEST_BROWSER_VERSION,
      TEST_TYPE,
    } = require_test()
    var { SPAN_TYPE } = require_tags()
    function isTestSpan(span) {
      return span.context()._tags[SPAN_TYPE] === 'test'
    }
    function getTestSpanFromTrace(trace) {
      for (const span of trace.started) {
        if (isTestSpan(span)) {
          return span
        }
      }
      return null
    }
    var SeleniumPlugin = class extends CiPlugin {
      static id = 'selenium'
      constructor(...args) {
        super(...args)
        this.addSub(
          'ci:selenium:driver:get',
          ({ setTraceId, seleniumVersion, browserName, browserVersion, isRumActive }) => {
            const store = storage('legacy').getStore()
            const span = store?.span
            if (!span) {
              return
            }
            const testSpan = isTestSpan(span) ? span : getTestSpanFromTrace(span.context()._trace)
            if (!testSpan) {
              return
            }
            if (setTraceId) {
              setTraceId(testSpan.context().toTraceId())
            }
            if (isRumActive) {
              testSpan.setTag(TEST_IS_RUM_ACTIVE, 'true')
            }
            testSpan.setTag(TEST_BROWSER_DRIVER, 'selenium')
            testSpan.setTag(TEST_BROWSER_DRIVER_VERSION, seleniumVersion)
            testSpan.setTag(TEST_BROWSER_NAME, browserName)
            testSpan.setTag(TEST_BROWSER_VERSION, browserVersion)
            testSpan.setTag(TEST_TYPE, 'browser')
          }
        )
      }
    }
    module2.exports = SeleniumPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js
var require_src70 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js'(exports2, module2) {
    'use strict'
    var ServerPlugin = require_server5()
    var SharedbPlugin = class extends ServerPlugin {
      static id = 'sharedb'
      bindStart(ctx) {
        const { actionName, request } = ctx
        const span = this.startSpan(
          'sharedb.request',
          {
            service: this.config.service,
            resource: getReadableResourceName(actionName, request.c, request.q),
            kind: 'server',
            meta: {
              'sharedb.action': actionName,
            },
          },
          ctx
        )
        if (this.config.hooks && this.config.hooks.receive) {
          this.config.hooks.receive(span, request)
        }
        return ctx.currentStore
      }
      bindFinish(ctx) {
        const { request, res } = ctx
        const span = ctx.currentStore.span
        if (this.config.hooks && this.config.hooks.reply) {
          this.config.hooks.reply(span, request, res)
        }
        super.finish(ctx)
        return ctx.parentStore
      }
    }
    function getReadableResourceName(readableActionName, collection, query) {
      if (collection) {
        readableActionName += ' ' + collection
      }
      if (query) {
        readableActionName += ' ' + JSON.stringify(sanitize(query))
      }
      return readableActionName
    }
    function sanitize(input) {
      const output = {}
      if (!isObject(input) || Buffer.isBuffer(input)) return '?'
      for (const key in input) {
        if (typeof input[key] === 'function') continue
        output[key] = sanitize(input[key])
      }
      return output
    }
    function isObject(val) {
      return val !== null && typeof val === 'object' && !Array.isArray(val)
    }
    module2.exports = SharedbPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js
var require_src71 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js'(exports2, module2) {
    'use strict'
    var { CLIENT_PORT_KEY } = require_constants2()
    var DatabasePlugin = require_database()
    var TediousPlugin = class extends DatabasePlugin {
      static id = 'tedious'
      static operation = 'request'
      // TODO: change to match other database plugins
      static system = 'mssql'
      bindStart(ctx) {
        const service = this.serviceName({ pluginConfig: this.config, system: this.system })
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            resource: ctx.queryOrProcedure,
            type: 'sql',
            kind: 'client',
            meta: {
              'db.type': 'mssql',
              component: 'tedious',
              'out.host': ctx.connectionConfig.server,
              [CLIENT_PORT_KEY]: ctx.connectionConfig.options.port,
              'db.user': ctx.connectionConfig.userName || ctx.connectionConfig.authentication.options.userName,
              'db.name': ctx.connectionConfig.options.database,
              'db.instance': ctx.connectionConfig.options.instanceName,
            },
          },
          ctx
        )
        ctx.sql = this.injectDbmQuery(span, ctx.queryOrProcedure, service, true)
        return ctx.currentStore
      }
    }
    module2.exports = TediousPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-undici/src/index.js
var require_src72 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-undici/src/index.js'(exports2, module2) {
    'use strict'
    var FetchPlugin = require_src40()
    var UndiciPlugin = class extends FetchPlugin {
      static id = 'undici'
      static prefix = 'tracing:apm:undici:fetch'
    }
    module2.exports = UndiciPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js
var require_src73 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js'(exports2, module2) {
    'use strict'
    var LogPlugin = require_log_plugin()
    var WinstonPlugin = class extends LogPlugin {
      static id = 'winston'
    }
    module2.exports = WinstonPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ws/src/server.js
var require_server10 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ws/src/server.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var tags = require_tags()
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE
    var WSServerPlugin = class extends TracingPlugin {
      static get id() {
        return 'ws'
      }
      static get prefix() {
        return 'tracing:ws:server:connect'
      }
      static get type() {
        return 'websocket'
      }
      static get kind() {
        return 'request'
      }
      bindStart(ctx) {
        const req = ctx.req
        const options = {}
        const headers = Object.entries(req.headers)
        options.headers = Object.fromEntries(headers)
        options.method = req.method
        const protocol = `${getRequestProtocol(req)}:`
        const host = options.headers.host
        const url = req.url
        const indexOfParam = url.indexOf('?')
        const route = indexOfParam === -1 ? url : url.slice(0, indexOfParam)
        const uri = `${protocol}//${host}${route}`
        ctx.args = { options }
        const service = this.serviceName({ pluginConfig: this.config })
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            meta: {
              'span.type': 'websocket',
              'http.upgraded': 'websocket',
              'http.method': options.method,
              'http.url': uri,
              'resource.name': `${options.method} ${route}`,
              'span.kind': 'server',
            },
          },
          ctx
        )
        ctx.span = span
        ctx.socket.spanContext = ctx.span._spanContext
        ctx.socket.spanContext.spanTags = ctx.span._spanContext._tags
        return ctx.currentStore
      }
      bindAsyncStart(ctx) {
        ctx.span.setTag(HTTP_STATUS_CODE, ctx.req.resStatus)
        return ctx.parentStore
      }
      asyncStart(ctx) {
        ctx.span.finish()
      }
    }
    function getRequestProtocol(req, fallback = 'ws') {
      if (req.socket && req.socket.encrypted) {
        return 'wss'
      }
      if (req.headers && req.headers['x-forwarded-proto']) {
        const proto = req.headers['x-forwarded-proto'].split(',')[0].trim()
        if (proto === 'https') return 'wss'
        if (proto === 'http') return 'ws'
      }
      return fallback
    }
    module2.exports = WSServerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ws/src/producer.js
var require_producer10 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ws/src/producer.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var WSProducerPlugin = class extends TracingPlugin {
      static get id() {
        return 'ws'
      }
      static get prefix() {
        return 'tracing:ws:send'
      }
      static get type() {
        return 'websocket'
      }
      static get kind() {
        return 'producer'
      }
      bindStart(ctx) {
        const messagesEnabled = this.config.traceWebsocketMessagesEnabled
        if (!messagesEnabled) return
        const { byteLength, socket, binary } = ctx
        if (!socket.spanContext) return
        const spanTags = socket.spanContext.spanTags
        const path = spanTags['resource.name'].split(' ')[1]
        const opCode = binary ? 'binary' : 'text'
        const service = this.serviceName({ pluginConfig: this.config })
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            meta: {
              'span.type': 'websocket',
              'span.kind': 'producer',
              'resource.name': `websocket ${path}`,
              'websocket.message.type': opCode,
            },
            metrics: {
              'websocket.message.length': byteLength,
            },
          },
          ctx
        )
        ctx.span = span
        return ctx.currentStore
      }
      bindAsyncStart(ctx) {
        ctx.span.finish()
        return ctx.parentStore
      }
      asyncStart(ctx) {
        ctx.span.finish()
      }
      end(ctx) {
        if (!Object.hasOwn(ctx, 'result') || !ctx.span) return
        if (ctx.socket.spanContext) {
          ctx.span.addLink({
            context: ctx.socket.spanContext,
            attributes: { 'dd.kind': 'resuming' },
          })
        }
        ctx.span.finish()
        return ctx.parentStore
      }
    }
    module2.exports = WSProducerPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ws/src/receiver.js
var require_receiver = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ws/src/receiver.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var WSReceiverPlugin = class extends TracingPlugin {
      static get id() {
        return 'ws'
      }
      static get prefix() {
        return 'tracing:ws:receive'
      }
      static get type() {
        return 'websocket'
      }
      static get kind() {
        return 'consumer'
      }
      bindStart(ctx) {
        const {
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces,
        } = this.config
        if (!traceWebsocketMessagesEnabled) return
        const { byteLength, socket, binary } = ctx
        if (!socket.spanContext) return
        const spanTags = socket.spanContext.spanTags
        const path = spanTags['resource.name'].split(' ')[1]
        const opCode = binary ? 'binary' : 'text'
        const service = this.serviceName({ pluginConfig: this.config })
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            meta: {
              'span.type': 'websocket',
              'span.kind': 'consumer',
              'resource.name': `websocket ${path}`,
              'websocket.duration.style': 'handler',
              'websocket.message.type': opCode,
            },
            metrics: {
              'websocket.message.length': byteLength,
            },
          },
          ctx
        )
        if (traceWebsocketMessagesInheritSampling && traceWebsocketMessagesSeparateTraces) {
          span.setTag('_dd.dm.service', spanTags['service.name'] || service)
          span.setTag('_dd.dm.resource', spanTags['resource.name'] || `websocket ${path}`)
          span.setTag('_dd.dm.inherited', 1)
        }
        ctx.span = span
        return ctx.currentStore
      }
      bindAsyncStart(ctx) {
        return ctx.parentStore
      }
      asyncStart(ctx) {
        ctx.span.finish()
      }
      end(ctx) {
        if (!Object.hasOwn(ctx, 'result') || !ctx.span) return
        if (ctx.socket.spanContext) {
          ctx.span.addLink({
            context: ctx.socket.spanContext,
            attributes: { 'dd.kind': 'executed_by' },
          })
        }
        ctx.span.finish()
        return ctx.parentStore
      }
    }
    module2.exports = WSReceiverPlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ws/src/close.js
var require_close = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ws/src/close.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var WSClosePlugin = class extends TracingPlugin {
      static get id() {
        return 'ws'
      }
      static get prefix() {
        return 'tracing:ws:close'
      }
      static get type() {
        return 'websocket'
      }
      static get kind() {
        return 'close'
      }
      bindStart(ctx) {
        const {
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces,
        } = this.config
        if (!traceWebsocketMessagesEnabled) return
        const { code, data, socket, isPeerClose } = ctx
        if (!socket?.spanContext) return
        const spanKind = isPeerClose ? 'consumer' : 'producer'
        const spanTags = socket.spanContext.spanTags
        const path = spanTags['resource.name'].split(' ')[1]
        const service = this.serviceName({ pluginConfig: this.config })
        const span = this.startSpan(
          this.operationName(),
          {
            service,
            meta: {
              'resource.name': `websocket ${path}`,
              'span.type': 'websocket',
              'span.kind': spanKind,
              'websocket.close.code': code,
            },
          },
          ctx
        )
        if (data?.toString().length > 0) {
          span.setTag('websocket.close.reason', data.toString())
        }
        if (isPeerClose && traceWebsocketMessagesInheritSampling && traceWebsocketMessagesSeparateTraces) {
          span.setTag('_dd.dm.service', spanTags['service.name'] || service)
          span.setTag('_dd.dm.resource', spanTags['resource.name'] || `websocket ${path}`)
          span.setTag('_dd.dm.inherited', 1)
        }
        ctx.span = span
        return ctx.currentStore
      }
      bindAsyncStart(ctx) {
        if (!ctx.isPeerClose) ctx.span.finish()
        return ctx.parentStore
      }
      asyncStart(ctx) {
        ctx.span.finish()
      }
      end(ctx) {
        if (!Object.hasOwn(ctx, 'result') || !ctx.span) return
        if (ctx.socket.spanContext) ctx.span.addLink({ context: ctx.socket.spanContext })
        ctx.span.finish()
      }
    }
    module2.exports = WSClosePlugin
  },
})

// node_modules/dd-trace/packages/datadog-plugin-ws/src/index.js
var require_src74 = __commonJS({
  'node_modules/dd-trace/packages/datadog-plugin-ws/src/index.js'(exports2, module2) {
    'use strict'
    var CompositePlugin = require_composite()
    var WSServerPlugin = require_server10()
    var WSProducerPlugin = require_producer10()
    var WSReceiverPlugin = require_receiver()
    var WSClosePlugin = require_close()
    var WSPlugin = class extends CompositePlugin {
      static get id() {
        return 'ws'
      }
      static get plugins() {
        return {
          server: WSServerPlugin,
          producer: WSProducerPlugin,
          receiver: WSReceiverPlugin,
          close: WSClosePlugin,
        }
      }
      configure(config) {
        return super.configure(config)
      }
    }
    module2.exports = WSPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugins/index.js
var require_plugins = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugins/index.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      get '@anthropic-ai/sdk'() {
        return require_src()
      },
      get '@apollo/gateway'() {
        return require_src2()
      },
      get '@aws-sdk/smithy-client'() {
        return require_src3()
      },
      get '@azure/event-hubs'() {
        return require_src4()
      },
      get '@azure/functions'() {
        return require_src5()
      },
      get '@azure/service-bus'() {
        return require_src6()
      },
      get '@cucumber/cucumber'() {
        return require_src7()
      },
      get '@playwright/test'() {
        return require_src8()
      },
      get '@elastic/elasticsearch'() {
        return require_src9()
      },
      get '@elastic/transport'() {
        return require_src9()
      },
      get '@google-cloud/pubsub'() {
        return require_src10()
      },
      get '@google-cloud/vertexai'() {
        return require_src11()
      },
      get '@google/genai'() {
        return require_src12()
      },
      get '@grpc/grpc-js'() {
        return require_src13()
      },
      get '@hapi/hapi'() {
        return require_src16()
      },
      get '@happy-dom/jest-environment'() {
        return require_src17()
      },
      get '@jest/core'() {
        return require_src17()
      },
      get '@jest/test-sequencer'() {
        return require_src17()
      },
      get '@jest/transform'() {
        return require_src17()
      },
      get '@koa/router'() {
        return require_src18()
      },
      get '@langchain/core'() {
        return require_src19()
      },
      get '@langchain/openai'() {
        return require_src19()
      },
      get '@node-redis/client'() {
        return require_src20()
      },
      get '@opensearch-project/opensearch'() {
        return require_src21()
      },
      get '@prisma/client'() {
        return require_src22()
      },
      get '@redis/client'() {
        return require_src20()
      },
      get '@smithy/smithy-client'() {
        return require_src3()
      },
      get '@vitest/runner'() {
        return require_src23()
      },
      get aerospike() {
        return require_src24()
      },
      get ai() {
        return require_src25()
      },
      get amqp10() {
        return require_src26()
      },
      get amqplib() {
        return require_src27()
      },
      get avsc() {
        return require_src28()
      },
      get 'aws-sdk'() {
        return require_src3()
      },
      get bunyan() {
        return require_src29()
      },
      get 'cassandra-driver'() {
        return require_src30()
      },
      get child_process() {
        return require_src31()
      },
      get connect() {
        return require_src32()
      },
      get couchbase() {
        return require_src33()
      },
      get cypress() {
        return require_src34()
      },
      get dns() {
        return require_src35()
      },
      get 'dd-trace-api'() {
        return require_src36()
      },
      get elasticsearch() {
        return require_src9()
      },
      get express() {
        return require_src37()
      },
      get fastify() {
        return require_src38()
      },
      get 'find-my-way'() {
        return require_src39()
      },
      get 'global:fetch'() {
        return require_src40()
      },
      get graphql() {
        return require_src41()
      },
      get grpc() {
        return require_src13()
      },
      get hapi() {
        return require_src16()
      },
      get hono() {
        return require_src42()
      },
      get http() {
        return require_src43()
      },
      get http2() {
        return require_src44()
      },
      get https() {
        return require_src43()
      },
      get ioredis() {
        return require_src45()
      },
      get iovalkey() {
        return require_src46()
      },
      get 'jest-circus'() {
        return require_src17()
      },
      get 'jest-config'() {
        return require_src17()
      },
      get 'jest-environment-node'() {
        return require_src17()
      },
      get 'jest-environment-jsdom'() {
        return require_src17()
      },
      get 'jest-runtime'() {
        return require_src17()
      },
      get 'jest-worker'() {
        return require_src17()
      },
      get koa() {
        return require_src18()
      },
      get 'koa-router'() {
        return require_src18()
      },
      get kafkajs() {
        return require_src47()
      },
      get '@confluentinc/kafka-javascript'() {
        return require_src48()
      },
      get langchain() {
        return require_src19()
      },
      get mariadb() {
        return require_src50()
      },
      get memcached() {
        return require_src51()
      },
      get 'microgateway-core'() {
        return require_src52()
      },
      get mocha() {
        return require_src53()
      },
      get 'mocha-each'() {
        return require_src53()
      },
      get vitest() {
        return require_src23()
      },
      get workerpool() {
        return require_src53()
      },
      get tinypool() {
        return require_src23()
      },
      get moleculer() {
        return require_src54()
      },
      get mongodb() {
        return require_src55()
      },
      get 'mongodb-core'() {
        return require_src55()
      },
      get mongoose() {
        return require_src56()
      },
      get mysql() {
        return require_src49()
      },
      get mysql2() {
        return require_src57()
      },
      get net() {
        return require_src58()
      },
      get next() {
        return require_src59()
      },
      get 'node:dns'() {
        return require_src35()
      },
      get 'node:http'() {
        return require_src43()
      },
      get 'node:http2'() {
        return require_src44()
      },
      get 'node:https'() {
        return require_src43()
      },
      get 'node:net'() {
        return require_src58()
      },
      get nyc() {
        return require_src60()
      },
      get oracledb() {
        return require_src61()
      },
      get openai() {
        return require_src63()
      },
      get pg() {
        return require_src64()
      },
      get pino() {
        return require_src65()
      },
      get 'pino-pretty'() {
        return require_src65()
      },
      get playwright() {
        return require_src8()
      },
      get protobufjs() {
        return require_src66()
      },
      get redis() {
        return require_src20()
      },
      get restify() {
        return require_src67()
      },
      get rhea() {
        return require_src68()
      },
      get router() {
        return require_src15()
      },
      get 'selenium-webdriver'() {
        return require_src69()
      },
      get sharedb() {
        return require_src70()
      },
      get tedious() {
        return require_src71()
      },
      get undici() {
        return require_src72()
      },
      get winston() {
        return require_src73()
      },
      get ws() {
        return require_src74()
      },
    }
  },
})

// node_modules/module-details-from-path/index.js
var require_module_details_from_path2 = __commonJS({
  'node_modules/module-details-from-path/index.js'(exports2, module2) {
    'use strict'
    var sep = require('path').sep
    module2.exports = function (file) {
      var segments = file.split(sep)
      var index = segments.lastIndexOf('node_modules')
      if (index === -1) return
      if (!segments[index + 1]) return
      var scoped = segments[index + 1][0] === '@'
      var name = scoped ? segments[index + 1] + '/' + segments[index + 2] : segments[index + 1]
      var offset = scoped ? 3 : 2
      var basedir = ''
      var lastBaseDirSegmentIndex = index + offset - 1
      for (var i = 0; i <= lastBaseDirSegmentIndex; i++) {
        if (i === lastBaseDirSegmentIndex) {
          basedir += segments[i]
        } else {
          basedir += segments[i] + sep
        }
      }
      var path = ''
      var lastSegmentIndex = segments.length - 1
      for (var i2 = index + offset; i2 <= lastSegmentIndex; i2++) {
        if (i2 === lastSegmentIndex) {
          path += segments[i2]
        } else {
          path += segments[i2] + sep
        }
      }
      return {
        name,
        basedir,
        path,
      }
    }
  },
})

// node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS({
  'node_modules/import-in-the-middle/lib/register.js'(exports2) {
    var importHooks = []
    var setters = /* @__PURE__ */ new WeakMap()
    var getters = /* @__PURE__ */ new WeakMap()
    var specifiers = /* @__PURE__ */ new Map()
    var toHook = []
    var proxyHandler = {
      set(target, name, value) {
        return setters.get(target)[name](value)
      },
      get(target, name) {
        if (name === Symbol.toStringTag) {
          return 'Module'
        }
        const getter = getters.get(target)[name]
        if (typeof getter === 'function') {
          return getter()
        }
      },
      defineProperty(target, property, descriptor) {
        if (!('value' in descriptor)) {
          throw new Error('Getters/setters are not supported for exports property descriptors.')
        }
        return setters.get(target)[property](descriptor.value)
      },
    }
    function register(name, namespace, set, get, specifier) {
      specifiers.set(name, specifier)
      setters.set(namespace, set)
      getters.set(namespace, get)
      const proxy = new Proxy(namespace, proxyHandler)
      importHooks.forEach((hook) => hook(name, proxy))
      toHook.push([name, proxy])
    }
    var experimentalPatchInternals = false
    function getExperimentalPatchInternals() {
      return experimentalPatchInternals
    }
    function setExperimentalPatchInternals(value) {
      experimentalPatchInternals = value
    }
    exports2.register = register
    exports2.importHooks = importHooks
    exports2.specifiers = specifiers
    exports2.toHook = toHook
    exports2.getExperimentalPatchInternals = getExperimentalPatchInternals
    exports2.setExperimentalPatchInternals = setExperimentalPatchInternals
  },
})

// node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS({
  'node_modules/import-in-the-middle/index.js'(exports2, module2) {
    var path = require('path')
    var parse = require_module_details_from_path2()
    var { fileURLToPath } = require('url')
    var { MessageChannel: MessageChannel2 } = require('worker_threads')
    var { importHooks, specifiers, toHook, getExperimentalPatchInternals } = require_register()
    function addHook(hook) {
      importHooks.push(hook)
      toHook.forEach(([name, namespace]) => hook(name, namespace))
    }
    function removeHook(hook) {
      const index = importHooks.indexOf(hook)
      if (index > -1) {
        importHooks.splice(index, 1)
      }
    }
    function callHookFn(hookFn, namespace, name, baseDir) {
      const newDefault = hookFn(namespace, name, baseDir)
      if (newDefault && newDefault !== namespace) {
        namespace.default = newDefault
      }
    }
    var sendModulesToLoader
    function createAddHookMessageChannel() {
      const { port1, port2 } = new MessageChannel2()
      let pendingAckCount = 0
      let resolveFn
      sendModulesToLoader = (modules) => {
        pendingAckCount++
        port1.postMessage(modules)
      }
      port1
        .on('message', () => {
          pendingAckCount--
          if (resolveFn && pendingAckCount <= 0) {
            resolveFn()
          }
        })
        .unref()
      function waitForAllMessagesAcknowledged() {
        const timer = setInterval(() => {}, 1e3)
        const promise = new Promise((resolve) => {
          resolveFn = resolve
        }).then(() => {
          clearInterval(timer)
        })
        if (pendingAckCount === 0) {
          resolveFn()
        }
        return promise
      }
      const addHookMessagePort = port2
      const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] }
      return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged }
    }
    function Hook(modules, options, hookFn) {
      if (this instanceof Hook === false) return new Hook(modules, options, hookFn)
      if (typeof modules === 'function') {
        hookFn = modules
        modules = null
        options = null
      } else if (typeof options === 'function') {
        hookFn = options
        options = null
      }
      const internals = options ? options.internals === true : false
      if (sendModulesToLoader && Array.isArray(modules)) {
        sendModulesToLoader(modules)
      }
      this._iitmHook = (name, namespace) => {
        const filename = name
        const isBuiltin = name.startsWith('node:')
        let baseDir
        if (isBuiltin) {
          name = name.replace(/^node:/, '')
        } else {
          if (name.startsWith('file://')) {
            try {
              name = fileURLToPath(name)
            } catch (e) {}
          }
          const details = parse(name)
          if (details) {
            name = details.name
            baseDir = details.basedir
          }
        }
        if (modules) {
          for (const moduleName2 of modules) {
            if (moduleName2 === name) {
              if (baseDir) {
                if (internals) {
                  name = name + path.sep + path.relative(baseDir, fileURLToPath(filename))
                } else {
                  if (!getExperimentalPatchInternals() && !baseDir.endsWith(specifiers.get(filename))) continue
                }
              }
              callHookFn(hookFn, namespace, name, baseDir)
            }
          }
        } else {
          callHookFn(hookFn, namespace, name, baseDir)
        }
      }
      addHook(this._iitmHook)
    }
    Hook.prototype.unhook = function () {
      removeHook(this._iitmHook)
    }
    module2.exports = Hook
    module2.exports.Hook = Hook
    module2.exports.addHook = addHook
    module2.exports.removeHook = removeHook
    module2.exports.createAddHookMessageChannel = createAddHookMessageChannel
  },
})

// node_modules/dd-trace/packages/dd-trace/src/iitm.js
var require_iitm = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/iitm.js'(exports2, module2) {
    'use strict'
    var { addHook } = require_import_in_the_middle()
    var dc = require_dc_polyfill()
    var moduleLoadStartChannel = dc.channel('dd-trace:moduleLoadStart')
    addHook((name, namespace) => {
      if (moduleLoadStartChannel.hasSubscribers) {
        moduleLoadStartChannel.publish({
          filename: name,
          module: namespace,
        })
      }
    })
    module2.exports = require_import_in_the_middle()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ritm.js
var require_ritm = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ritm.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var Module = require('module')
    var parse = require_module_details_from_path()
    var dc = require_dc_polyfill()
    var { getEnvironmentVariable } = require_config_helper()
    var origRequire = Module.prototype.require
    module2.exports = Hook
    var moduleHooks = /* @__PURE__ */ Object.create(null)
    var cache = /* @__PURE__ */ Object.create(null)
    var patching = /* @__PURE__ */ Object.create(null)
    var patchedRequire = null
    var moduleLoadStartChannel = dc.channel('dd-trace:moduleLoadStart')
    var moduleLoadEndChannel = dc.channel('dd-trace:moduleLoadEnd')
    function Hook(modules, options, onrequire) {
      if (!(this instanceof Hook)) return new Hook(modules, options, onrequire)
      if (typeof modules === 'function') {
        onrequire = modules
        modules = null
        options = {}
      } else if (typeof options === 'function') {
        onrequire = options
        options = {}
      }
      modules = modules || []
      options = options || {}
      this.modules = modules
      this.options = options
      this.onrequire = onrequire
      if (Array.isArray(modules)) {
        for (const mod2 of modules) {
          const hooks = moduleHooks[mod2]
          if (hooks) {
            hooks.push(onrequire)
          } else {
            moduleHooks[mod2] = [onrequire]
          }
        }
      }
      if (patchedRequire) return
      const _origRequire = Module.prototype.require
      patchedRequire = Module.prototype.require = function (request) {
        let filename
        try {
          filename = Module._resolveFilename(request, this)
        } catch {
          return _origRequire.apply(this, arguments)
        }
        const core = !filename.includes(path.sep)
        let name, basedir, hooks
        if (cache[filename]) {
          if (require.cache[filename] && require.cache[filename].exports !== cache[filename].original) {
            return require.cache[filename].exports
          }
          return cache[filename].exports
        }
        const patched = patching[filename]
        if (patched) {
          return origRequire.apply(this, arguments)
        }
        patching[filename] = true
        const payload = {
          filename,
          request,
        }
        if (moduleLoadStartChannel.hasSubscribers) {
          moduleLoadStartChannel.publish(payload)
        }
        let exports3 = origRequire.apply(this, arguments)
        payload.module = exports3
        if (moduleLoadEndChannel.hasSubscribers) {
          moduleLoadEndChannel.publish(payload)
          exports3 = payload.module
        }
        delete patching[filename]
        if (core) {
          hooks = moduleHooks[filename]
          if (!hooks) return exports3
          name = filename
        } else {
          const inAWSLambda = getEnvironmentVariable('AWS_LAMBDA_FUNCTION_NAME') !== void 0
          const hasLambdaHandler = getEnvironmentVariable('DD_LAMBDA_HANDLER') !== void 0
          const segments = filename.split(path.sep)
          const filenameFromNodeModule = segments.includes('node_modules')
          const stat = inAWSLambda && hasLambdaHandler && !filenameFromNodeModule ? { name: filename } : parse(filename)
          if (!stat) return exports3
          name = stat.name
          basedir = stat.basedir
          hooks = moduleHooks[name]
          if (!hooks) return exports3
          const paths = Module._resolveLookupPaths(name, this, true)
          if (!paths) {
            return exports3
          }
          let res
          try {
            res = Module._findPath(name, [basedir, ...paths])
          } catch {}
          if (!res || res !== filename) {
            name = name + path.sep + path.relative(basedir, filename)
          }
        }
        cache[filename] = { exports: exports3 }
        cache[filename].original = exports3
        for (const hook of hooks) {
          cache[filename].exports = hook(cache[filename].exports, name, basedir)
        }
        return cache[filename].exports
      }
    }
    Hook.reset = function () {
      Module.prototype.require = origRequire
      patchedRequire = null
      patching = /* @__PURE__ */ Object.create(null)
      cache = /* @__PURE__ */ Object.create(null)
      moduleHooks = /* @__PURE__ */ Object.create(null)
    }
    Hook.prototype.unhook = function () {
      for (const mod2 of this.modules) {
        const hooks = (moduleHooks[mod2] || []).filter((hook) => hook !== this.onrequire)
        if (hooks.length > 0) {
          moduleHooks[mod2] = hooks
        } else {
          delete moduleHooks[mod2]
        }
      }
      if (Object.keys(moduleHooks).length === 0) {
        Hook.reset()
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js
var require_hook = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js'(exports2, module2) {
    'use strict'
    var iitm = require_iitm()
    var path = require('path')
    var ritm = require_ritm()
    function Hook(modules, hookOptions, onrequire) {
      if (!(this instanceof Hook)) return new Hook(modules, hookOptions, onrequire)
      if (typeof hookOptions === 'function') {
        onrequire = hookOptions
        hookOptions = {}
      }
      this._patched = /* @__PURE__ */ Object.create(null)
      const patched = /* @__PURE__ */ new WeakMap()
      const safeHook = (moduleExports, moduleName2, moduleBaseDir, moduleVersion, isIitm) => {
        const parts = [moduleBaseDir, moduleName2].filter(Boolean)
        const filename = path.join(...parts)
        if (this._patched[filename] && patched.has(moduleExports)) {
          return patched.get(moduleExports)
        }
        let defaultWrapResult
        if (
          isIitm &&
          moduleExports.default &&
          (typeof moduleExports.default === 'object' || typeof moduleExports.default === 'function')
        ) {
          defaultWrapResult = onrequire(moduleExports.default, moduleName2, moduleBaseDir, moduleVersion, isIitm)
        }
        const newExports = onrequire(moduleExports, moduleName2, moduleBaseDir, moduleVersion, isIitm)
        if (defaultWrapResult) newExports.default = defaultWrapResult
        this._patched[filename] = true
        if (newExports && (typeof newExports === 'object' || typeof newExports === 'function')) {
          patched.set(moduleExports, newExports)
        }
        return newExports
      }
      this._ritmHook = ritm(modules, {}, safeHook)
      this._iitmHook = iitm(modules, hookOptions, (moduleExports, moduleName2, moduleBaseDir) => {
        return safeHook(moduleExports, moduleName2, moduleBaseDir, null, true)
      })
    }
    Hook.prototype.unhook = function () {
      this._ritmHook.unhook()
      this._iitmHook.unhook()
      this._patched = /* @__PURE__ */ Object.create(null)
    }
    module2.exports = Hook
  },
})

// node_modules/dd-trace/packages/dd-trace/src/guardrails/util.js
var require_util13 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/guardrails/util.js'(exports2, module2) {
    'use strict'
    function isTrue(str) {
      str = String(str).toLowerCase()
      return str === 'true' || str === '1'
    }
    module2.exports = { isTrue }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/guardrails/log.js
var require_log5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/guardrails/log.js'(exports2, module2) {
    'use strict'
    var isTrue = require_util13().isTrue
    var DD_TRACE_DEBUG = process.env.DD_TRACE_DEBUG
    var DD_TRACE_LOG_LEVEL = process.env.DD_TRACE_LOG_LEVEL
    var logLevels = {
      trace: 20,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      critical: 50,
      off: 100,
    }
    var logLevel = isTrue(DD_TRACE_DEBUG) ? Number(DD_TRACE_LOG_LEVEL) || logLevels.debug : logLevels.off
    var log = {
      /* eslint n/no-unsupported-features/node-builtins: ['error', { ignores: ['console.debug'] }] */
      debug: logLevel <= 20 ? (console.debug || console.log).bind(console) : function () {},
      info: logLevel <= 30 ? console.info.bind(console) : function () {},
      warn: logLevel <= 40 ? console.warn.bind(console) : function () {},
      error: logLevel <= 50 ? console.error.bind(console) : function () {},
    }
    module2.exports = log
  },
})

// node_modules/dd-trace/packages/dd-trace/src/guardrails/telemetry.js
var require_telemetry5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/guardrails/telemetry.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var spawn = require('child_process').spawn
    var tracerVersion = require_package().version
    var log = require_log5()
    module2.exports = sendTelemetry
    if (!process.env.DD_INJECTION_ENABLED) {
      module2.exports = function noop() {}
    }
    var telemetryForwarderPath = process.env.DD_TELEMETRY_FORWARDER_PATH
    if (typeof telemetryForwarderPath !== 'string' || !fs.existsSync(telemetryForwarderPath)) {
      module2.exports = function noop() {}
    }
    var metadata = {
      language_name: 'nodejs',
      language_version: process.versions.node,
      runtime_name: 'nodejs',
      runtime_version: process.versions.node,
      tracer_version: tracerVersion,
      pid: process.pid,
      result: 'unknown',
      result_reason: 'unknown',
      result_class: 'unknown',
    }
    var seen = {}
    function shouldSend(point) {
      if (point.name === 'abort') {
        if (seen.abort) {
          return false
        }
        seen.abort = true
      } else if (point.name === 'abort.integration') {
        var compiledPoint = point.name + point.tags.join('')
        if (seen[compiledPoint]) {
          return false
        }
        seen[compiledPoint] = true
      }
      return true
    }
    function sendTelemetry(name, tags, resultMetadata) {
      var points = name
      if (typeof name === 'string') {
        points = [{ name, tags: tags || [] }]
      }
      if (['1', 'true', 'True'].indexOf(process.env.DD_INJECT_FORCE) !== -1) {
        points = points.filter(function (p) {
          return ['error', 'complete'].indexOf(p.name) !== -1
        })
      }
      points = points.filter(function (p) {
        return shouldSend(p)
      })
      for (var i = 0; i < points.length; i++) {
        points[i].name = 'library_entrypoint.' + points[i].name
      }
      if (points.length === 0) {
        return
      }
      var currentMetadata = {}
      for (var key in metadata) {
        currentMetadata[key] = metadata[key]
      }
      if (resultMetadata) {
        for (var resultKey in resultMetadata) {
          currentMetadata[resultKey] = resultMetadata[resultKey]
        }
      }
      var proc = spawn(process.env.DD_TELEMETRY_FORWARDER_PATH, ['library_entrypoint'], {
        stdio: 'pipe',
      })
      proc.on('error', function () {
        log.error('Failed to spawn telemetry forwarder')
      })
      proc.on('exit', function (code) {
        if (code !== 0) {
          log.error('Telemetry forwarder exited with code', code)
        }
      })
      proc.stdin.on('error', function () {
        log.error('Failed to write telemetry data to telemetry forwarder')
      })
      proc.stdin.end(JSON.stringify({ metadata: currentMetadata, points }))
    }
  },
})

// node_modules/dd-trace/vendor/dist/meriyah/index.js
var require_meriyah = __commonJS({
  'node_modules/dd-trace/vendor/dist/meriyah/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e,
        t,
        r,
        n,
        o = {}
      ;((o.d = (e10, t2) => {
        for (var r2 in t2)
          o.o(t2, r2) && !o.o(e10, r2) && Object.defineProperty(e10, r2, { enumerable: true, get: t2[r2] })
      }),
        (o.o = (e10, t2) => Object.prototype.hasOwnProperty.call(e10, t2)),
        (o.r = (e10) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e10, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(e10, '__esModule', { value: true }))
        }))
      var a = {}
      ;(o.r(a), o.d(a, { parse: () => td, parseModule: () => tu, parseScript: () => tc, version: () => tl }))
      let i = ((e10, t2) => {
          let r2 = new Uint32Array(69632),
            n2 = 0,
            o2 = 0
          for (; n2 < 2571; ) {
            let a2 = e10[n2++]
            if (a2 < 0) o2 -= a2
            else {
              let i2 = e10[n2++]
              ;(2 & a2 && (i2 = t2[i2]), 1 & a2 ? r2.fill(i2, o2, (o2 += e10[n2++])) : (r2[o2++] = i2))
            }
          }
          return r2
        })(
          [
            -1, 2, 26, 2, 27, 2, 5, -1, 0, 77595648, 3, 44, 2, 3, 0, 14, 2, 63, 2, 64, 3, 0, 3, 0, 3168796671, 0,
            4294956992, 2, 1, 2, 0, 2, 41, 3, 0, 4, 0, 4294966523, 3, 0, 4, 2, 16, 2, 65, 2, 0, 0, 4294836735, 0,
            3221225471, 0, 4294901942, 2, 66, 0, 134152192, 3, 0, 2, 0, 4294951935, 3, 0, 2, 0, 2683305983, 0,
            2684354047, 2, 18, 2, 0, 0, 4294961151, 3, 0, 2, 2, 19, 2, 0, 0, 608174079, 2, 0, 2, 60, 2, 7, 2, 6, 0,
            4286611199, 3, 0, 2, 2, 1, 3, 0, 3, 0, 4294901711, 2, 40, 0, 4089839103, 0, 2961209759, 0, 1342439375, 0,
            4294543342, 0, 3547201023, 0, 1577204103, 0, 4194240, 0, 4294688750, 2, 2, 0, 80831, 0, 4261478351, 0,
            4294549486, 2, 2, 0, 2967484831, 0, 196559, 0, 3594373100, 0, 3288319768, 0, 8469959, 0, 65472, 2, 3, 0,
            4093640191, 0, 660618719, 0, 65487, 0, 4294828015, 0, 4092591615, 0, 1616920031, 0, 982991, 2, 3, 2, 0, 0,
            2163244511, 0, 4227923919, 0, 4236247022, 2, 71, 0, 4284449919, 0, 851904, 2, 4, 2, 12, 0, 67076095, -1, 2,
            72, 0, 1073741743, 0, 4093607775, -1, 0, 50331649, 0, 3265266687, 2, 33, 0, 4294844415, 0, 4278190047, 2,
            20, 2, 137, -1, 3, 0, 2, 2, 23, 2, 0, 2, 10, 2, 0, 2, 15, 2, 22, 3, 0, 10, 2, 74, 2, 0, 2, 75, 2, 76, 2, 77,
            2, 0, 2, 78, 2, 0, 2, 11, 0, 261632, 2, 25, 3, 0, 2, 2, 13, 2, 4, 3, 0, 18, 2, 79, 2, 5, 3, 0, 2, 2, 80, 0,
            2151677951, 2, 29, 2, 9, 0, 909311, 3, 0, 2, 0, 814743551, 2, 49, 0, 67090432, 3, 0, 2, 2, 42, 2, 0, 2, 6,
            2, 0, 2, 30, 2, 8, 0, 268374015, 2, 110, 2, 51, 2, 0, 2, 81, 0, 134153215, -1, 2, 7, 2, 0, 2, 8, 0,
            2684354559, 0, 67044351, 0, 3221160064, 2, 17, -1, 3, 0, 2, 2, 53, 0, 1046528, 3, 0, 3, 2, 9, 2, 0, 2, 54,
            0, 4294960127, 2, 10, 2, 6, 2, 11, 0, 4294377472, 2, 12, 3, 0, 16, 2, 13, 2, 0, 2, 82, 2, 10, 2, 0, 2, 83,
            2, 84, 2, 85, 0, 12288, 2, 55, 0, 1048577, 2, 86, 2, 14, -1, 2, 14, 0, 131042, 2, 87, 2, 88, 2, 89, 2, 0, 2,
            34, -83, 3, 0, 7, 0, 1046559, 2, 0, 2, 15, 2, 0, 0, 2147516671, 2, 21, 3, 90, 2, 2, 0, -16, 2, 91, 0,
            524222462, 2, 4, 2, 0, 0, 4269801471, 2, 4, 3, 0, 2, 2, 28, 2, 16, 3, 0, 2, 2, 17, 2, 0, -1, 2, 18, -16, 3,
            0, 206, -2, 3, 0, 692, 2, 73, -1, 2, 18, 2, 10, 3, 0, 8, 2, 93, 2, 133, 2, 0, 0, 3220242431, 3, 0, 3, 2, 19,
            2, 94, 2, 95, 3, 0, 2, 2, 96, 2, 0, 2, 97, 2, 46, 2, 0, 0, 4351, 2, 0, 2, 9, 3, 0, 2, 0, 67043391, 0,
            3909091327, 2, 0, 2, 24, 2, 9, 2, 20, 3, 0, 2, 0, 67076097, 2, 8, 2, 0, 2, 21, 0, 67059711, 0, 4236247039,
            3, 0, 2, 0, 939524103, 0, 8191999, 2, 101, 2, 102, 2, 22, 2, 23, 3, 0, 3, 0, 67057663, 3, 0, 349, 2, 103, 2,
            104, 2, 7, -264, 3, 0, 11, 2, 24, 3, 0, 2, 2, 32, -1, 0, 3774349439, 2, 105, 2, 106, 3, 0, 2, 2, 19, 2, 107,
            3, 0, 10, 2, 10, 2, 18, 2, 0, 2, 47, 2, 0, 2, 31, 2, 108, 2, 25, 0, 1638399, 0, 57344, 2, 109, 3, 0, 3, 2,
            20, 2, 26, 2, 27, 2, 5, 2, 28, 2, 0, 2, 8, 2, 111, -1, 2, 112, 2, 113, 2, 114, -1, 3, 0, 3, 2, 12, -2, 2, 0,
            2, 29, -3, 0, 536870912, -4, 2, 20, 2, 0, 2, 36, 0, 1, 2, 0, 2, 67, 2, 6, 2, 12, 2, 10, 2, 0, 2, 115, -1, 3,
            0, 4, 2, 10, 2, 23, 2, 116, 2, 7, 2, 0, 2, 117, 2, 0, 2, 118, 2, 119, 2, 120, 2, 0, 2, 9, 3, 0, 9, 2, 21, 2,
            30, 2, 31, 2, 121, 2, 122, -2, 2, 123, 2, 124, 2, 30, 2, 21, 2, 8, -2, 2, 125, 2, 30, 2, 32, -2, 2, 0, 2,
            39, -2, 0, 4277137519, 0, 2269118463, -1, 3, 20, 2, -1, 2, 33, 2, 38, 2, 0, 3, 30, 2, 2, 35, 2, 19, -3, 3,
            0, 2, 2, 34, -1, 2, 0, 2, 35, 2, 0, 2, 35, 2, 0, 2, 48, 2, 0, 0, 4294950463, 2, 37, -7, 2, 0, 0, 203775, 2,
            57, 0, 4026531840, 2, 20, 2, 43, 2, 36, 2, 18, 2, 37, 2, 18, 2, 126, 2, 21, 3, 0, 2, 2, 38, 0, 2151677888,
            2, 0, 2, 12, 0, 4294901764, 2, 144, 2, 0, 2, 58, 2, 56, 0, 5242879, 3, 0, 2, 0, 402644511, -1, 2, 128, 2,
            39, 0, 3, -1, 2, 129, 2, 130, 2, 0, 0, 67045375, 2, 40, 0, 4226678271, 0, 3766565279, 0, 2039759, 2, 132, 2,
            41, 0, 1046437, 0, 6, 3, 0, 2, 0, 3288270847, 0, 3, 3, 0, 2, 0, 67043519, -5, 2, 0, 0, 4282384383, 0,
            1056964609, -1, 3, 0, 2, 0, 67043345, -1, 2, 0, 2, 42, 2, 23, 2, 50, 2, 11, 2, 61, 2, 38, -5, 2, 0, 2, 12,
            -3, 3, 0, 2, 0, 2147484671, 2, 134, 0, 4190109695, 2, 52, -2, 2, 135, 0, 4244635647, 0, 27, 2, 0, 2, 8, 2,
            43, 2, 0, 2, 68, 2, 18, 2, 0, 2, 42, -6, 2, 0, 2, 45, 2, 59, 2, 44, 2, 45, 2, 46, 2, 47, 0, 8388351, -2, 2,
            136, 0, 3028287487, 2, 48, 2, 138, 0, 33259519, 2, 49, -9, 2, 21, 0, 4294836223, 0, 3355443199, 0,
            134152199, -2, 2, 69, -2, 3, 0, 28, 2, 32, -3, 3, 0, 3, 2, 17, 3, 0, 6, 2, 50, -81, 2, 18, 3, 0, 2, 2, 36,
            3, 0, 33, 2, 25, 2, 30, 3, 0, 124, 2, 12, 3, 0, 18, 2, 38, -213, 2, 0, 2, 32, -54, 3, 0, 17, 2, 42, 2, 8, 2,
            23, 2, 0, 2, 8, 2, 23, 2, 51, 2, 0, 2, 21, 2, 52, 2, 139, 2, 25, -13, 2, 0, 2, 53, -6, 3, 0, 2, -4, 3, 0, 2,
            0, 4294936575, 2, 0, 0, 4294934783, -2, 0, 196635, 3, 0, 191, 2, 54, 3, 0, 38, 2, 30, 2, 55, 2, 34, -278, 2,
            140, 3, 0, 9, 2, 141, 2, 142, 2, 56, 3, 0, 11, 2, 7, -72, 3, 0, 3, 2, 143, 0, 1677656575, -130, 2, 26, -16,
            2, 0, 2, 24, 2, 38, -16, 0, 4161266656, 0, 4071, 0, 15360, -4, 2, 57, -13, 3, 0, 2, 2, 58, 2, 0, 2, 145, 2,
            146, 2, 62, 2, 0, 2, 147, 2, 148, 2, 149, 3, 0, 10, 2, 150, 2, 151, 2, 22, 3, 58, 2, 3, 152, 2, 3, 59, 2, 0,
            4294954999, 2, 0, -16, 2, 0, 2, 92, 2, 0, 0, 2105343, 0, 4160749584, 0, 65534, -34, 2, 8, 2, 154, -6, 0,
            4194303871, 0, 4294903771, 2, 0, 2, 60, 2, 100, -3, 2, 0, 0, 1073684479, 0, 17407, -9, 2, 18, 2, 17, 2, 0,
            2, 32, -14, 2, 18, 2, 32, -6, 2, 18, 2, 12, -15, 2, 155, 3, 0, 6, 0, 8323103, -1, 3, 0, 2, 2, 61, -37, 2,
            62, 2, 156, 2, 157, 2, 158, 2, 159, 2, 160, -105, 2, 26, -32, 3, 0, 1335, -1, 3, 0, 129, 2, 32, 3, 0, 6, 2,
            10, 3, 0, 180, 2, 161, 3, 0, 233, 2, 162, 3, 0, 18, 2, 10, -77, 3, 0, 16, 2, 10, -47, 3, 0, 154, 2, 6, 3, 0,
            130, 2, 25, -22250, 3, 0, 7, 2, 25, -6130, 3, 5, 2, -1, 0, 69207040, 3, 44, 2, 3, 0, 14, 2, 63, 2, 64, -3,
            0, 3168731136, 0, 4294956864, 2, 1, 2, 0, 2, 41, 3, 0, 4, 0, 4294966275, 3, 0, 4, 2, 16, 2, 65, 2, 0, 2, 34,
            -1, 2, 18, 2, 66, -1, 2, 0, 0, 2047, 0, 4294885376, 3, 0, 2, 0, 3145727, 0, 2617294944, 0, 4294770688, 2,
            25, 2, 67, 3, 0, 2, 0, 131135, 2, 98, 0, 70256639, 0, 71303167, 0, 272, 2, 42, 2, 6, 0, 32511, 2, 0, 2, 49,
            -1, 2, 99, 2, 68, 0, 4278255616, 0, 4294836227, 0, 4294549473, 0, 600178175, 0, 2952806400, 0, 268632067, 0,
            4294543328, 0, 57540095, 0, 1577058304, 0, 1835008, 0, 4294688736, 2, 70, 2, 69, 0, 33554435, 2, 131, 2, 70,
            0, 2952790016, 0, 131075, 0, 3594373096, 0, 67094296, 2, 69, -1, 0, 4294828e3, 0, 603979263, 0, 654311424,
            0, 3, 0, 4294828001, 0, 602930687, 0, 1610612736, 0, 393219, 0, 4294828016, 0, 671088639, 0, 2154840064, 0,
            4227858435, 0, 4236247008, 2, 71, 2, 38, -1, 2, 4, 0, 917503, 2, 38, -1, 2, 72, 0, 537788335, 0, 4026531935,
            -1, 0, 1, -1, 2, 33, 2, 73, 0, 7936, -3, 2, 0, 0, 2147485695, 0, 1010761728, 0, 4292984930, 0, 16387, 2, 0,
            2, 15, 2, 22, 3, 0, 10, 2, 74, 2, 0, 2, 75, 2, 76, 2, 77, 2, 0, 2, 78, 2, 0, 2, 12, -1, 2, 25, 3, 0, 2, 2,
            13, 2, 4, 3, 0, 18, 2, 79, 2, 5, 3, 0, 2, 2, 80, 0, 2147745791, 3, 19, 2, 0, 122879, 2, 0, 2, 9, 0,
            276824064, -2, 3, 0, 2, 2, 42, 2, 0, 0, 4294903295, 2, 0, 2, 30, 2, 8, -1, 2, 18, 2, 51, 2, 0, 2, 81, 2, 49,
            -1, 2, 21, 2, 0, 2, 29, -2, 0, 128, -2, 2, 28, 2, 9, 0, 8160, -1, 2, 127, 0, 4227907585, 2, 0, 2, 37, 2, 0,
            2, 50, 0, 4227915776, 2, 10, 2, 6, 2, 11, -1, 0, 74440192, 3, 0, 6, -2, 3, 0, 8, 2, 13, 2, 0, 2, 82, 2, 10,
            2, 0, 2, 83, 2, 84, 2, 85, -3, 2, 86, 2, 14, -3, 2, 87, 2, 88, 2, 89, 2, 0, 2, 34, -83, 3, 0, 7, 0, 817183,
            2, 0, 2, 15, 2, 0, 0, 33023, 2, 21, 3, 90, 2, -17, 2, 91, 0, 524157950, 2, 4, 2, 0, 2, 92, 2, 4, 2, 0, 2,
            22, 2, 28, 2, 16, 3, 0, 2, 2, 17, 2, 0, -1, 2, 18, -16, 3, 0, 206, -2, 3, 0, 692, 2, 73, -1, 2, 18, 2, 10,
            3, 0, 8, 2, 93, 0, 3072, 2, 0, 0, 2147516415, 2, 10, 3, 0, 2, 2, 25, 2, 94, 2, 95, 3, 0, 2, 2, 96, 2, 0, 2,
            97, 2, 46, 0, 4294965179, 0, 7, 2, 0, 2, 9, 2, 95, 2, 9, -1, 0, 1761345536, 2, 98, 0, 4294901823, 2, 38, 2,
            20, 2, 99, 2, 35, 2, 100, 0, 2080440287, 2, 0, 2, 34, 2, 153, 0, 3296722943, 2, 0, 0, 1046675455, 0,
            939524101, 0, 1837055, 2, 101, 2, 102, 2, 22, 2, 23, 3, 0, 3, 0, 7, 3, 0, 349, 2, 103, 2, 104, 2, 7, -264,
            3, 0, 11, 2, 24, 3, 0, 2, 2, 32, -1, 0, 2700607615, 2, 105, 2, 106, 3, 0, 2, 2, 19, 2, 107, 3, 0, 10, 2, 10,
            2, 18, 2, 0, 2, 47, 2, 0, 2, 31, 2, 108, -3, 2, 109, 3, 0, 3, 2, 20, -1, 3, 5, 2, 2, 110, 2, 0, 2, 8, 2,
            111, -1, 2, 112, 2, 113, 2, 114, -1, 3, 0, 3, 2, 12, -2, 2, 0, 2, 29, -8, 2, 20, 2, 0, 2, 36, -1, 2, 0, 2,
            67, 2, 6, 2, 30, 2, 10, 2, 0, 2, 115, -1, 3, 0, 4, 2, 10, 2, 18, 2, 116, 2, 7, 2, 0, 2, 117, 2, 0, 2, 118,
            2, 119, 2, 120, 2, 0, 2, 9, 3, 0, 9, 2, 21, 2, 30, 2, 31, 2, 121, 2, 122, -2, 2, 123, 2, 124, 2, 30, 2, 21,
            2, 8, -2, 2, 125, 2, 30, 2, 32, -2, 2, 0, 2, 39, -2, 0, 4277075969, 2, 30, -1, 3, 20, 2, -1, 2, 33, 2, 126,
            2, 0, 3, 30, 2, 2, 35, 2, 19, -3, 3, 0, 2, 2, 34, -1, 2, 0, 2, 35, 2, 0, 2, 35, 2, 0, 2, 50, 2, 98, 0,
            4294934591, 2, 37, -7, 2, 0, 0, 197631, 2, 57, -1, 2, 20, 2, 43, 2, 37, 2, 18, 0, 3, 2, 18, 2, 126, 2, 21,
            2, 127, 2, 54, -1, 0, 2490368, 2, 127, 2, 25, 2, 18, 2, 34, 2, 127, 2, 38, 0, 4294901904, 0, 4718591, 2,
            127, 2, 35, 0, 335544350, -1, 2, 128, 0, 2147487743, 0, 1, -1, 2, 129, 2, 130, 2, 8, -1, 2, 131, 2, 70, 0,
            3758161920, 0, 3, 2, 132, 0, 12582911, 0, 655360, -1, 2, 0, 2, 29, 0, 2147485568, 0, 3, 2, 0, 2, 25, 0, 176,
            -5, 2, 0, 2, 17, 0, 251658240, -1, 2, 0, 2, 25, 0, 16, -1, 2, 0, 0, 16779263, -2, 2, 12, -1, 2, 38, -5, 2,
            0, 2, 133, -3, 3, 0, 2, 2, 55, 2, 134, 0, 2147549183, 0, 2, -2, 2, 135, 2, 36, 0, 10, 0, 4294965249, 0,
            67633151, 0, 4026597376, 2, 0, 0, 536871935, 2, 18, 2, 0, 2, 42, -6, 2, 0, 0, 1, 2, 59, 2, 17, 0, 1, 2, 46,
            2, 25, -3, 2, 136, 2, 36, 2, 137, 2, 138, 0, 16778239, -10, 2, 35, 0, 4294836212, 2, 9, -3, 2, 69, -2, 3, 0,
            28, 2, 32, -3, 3, 0, 3, 2, 17, 3, 0, 6, 2, 50, -81, 2, 18, 3, 0, 2, 2, 36, 3, 0, 33, 2, 25, 0, 126, 3, 0,
            124, 2, 12, 3, 0, 18, 2, 38, -213, 2, 10, -55, 3, 0, 17, 2, 42, 2, 8, 2, 18, 2, 0, 2, 8, 2, 18, 2, 60, 2, 0,
            2, 25, 2, 50, 2, 139, 2, 25, -13, 2, 0, 2, 73, -6, 3, 0, 2, -4, 3, 0, 2, 0, 67583, -1, 2, 107, -2, 0, 11, 3,
            0, 191, 2, 54, 3, 0, 38, 2, 30, 2, 55, 2, 34, -278, 2, 140, 3, 0, 9, 2, 141, 2, 142, 2, 56, 3, 0, 11, 2, 7,
            -72, 3, 0, 3, 2, 143, 2, 144, -187, 3, 0, 2, 2, 58, 2, 0, 2, 145, 2, 146, 2, 62, 2, 0, 2, 147, 2, 148, 2,
            149, 3, 0, 10, 2, 150, 2, 151, 2, 22, 3, 58, 2, 3, 152, 2, 3, 59, 2, 2, 153, -57, 2, 8, 2, 154, -7, 2, 18,
            2, 0, 2, 60, -4, 2, 0, 0, 1065361407, 0, 16384, -9, 2, 18, 2, 60, 2, 0, 2, 133, -14, 2, 18, 2, 133, -6, 2,
            18, 0, 81919, -15, 2, 155, 3, 0, 6, 2, 126, -1, 3, 0, 2, 0, 2063, -37, 2, 62, 2, 156, 2, 157, 2, 158, 2,
            159, 2, 160, -138, 3, 0, 1335, -1, 3, 0, 129, 2, 32, 3, 0, 6, 2, 10, 3, 0, 180, 2, 161, 3, 0, 233, 2, 162,
            3, 0, 18, 2, 10, -77, 3, 0, 16, 2, 10, -47, 3, 0, 154, 2, 6, 3, 0, 130, 2, 25, -28386,
          ],
          [
            4294967295, 4294967291, 4092460543, 4294828031, 4294967294, 134217726, 4294903807, 268435455, 2147483647,
            1048575, 1073741823, 3892314111, 134217727, 1061158911, 536805376, 4294910143, 4294901759, 32767,
            4294901760, 262143, 536870911, 8388607, 4160749567, 4294902783, 4294918143, 65535, 67043328, 2281701374,
            4294967264, 2097151, 4194303, 255, 67108863, 4294967039, 511, 524287, 131071, 63, 127, 3238002687,
            4294549487, 4290772991, 33554431, 4294901888, 4286578687, 67043329, 4294705152, 4294770687, 67043583, 1023,
            15, 2047999, 67043343, 67051519, 16777215, 2147483648, 4294902e3, 28, 4292870143, 4294966783, 16383,
            67047423, 4294967279, 262083, 20511, 41943039, 493567, 4294959104, 603979775, 65536, 602799615, 805044223,
            4294965206, 8191, 1031749119, 4294917631, 2134769663, 4286578493, 4282253311, 4294942719, 33540095,
            4294905855, 2868854591, 1608515583, 265232348, 534519807, 2147614720, 1060109444, 4093640016, 17376,
            2139062143, 224, 4169138175, 4294909951, 4286578688, 4294967292, 4294965759, 535511039, 4294966272,
            4294967280, 32768, 8289918, 4294934399, 4294901775, 4294965375, 1602223615, 4294967259, 4294443008,
            268369920, 4292804608, 4294967232, 486341884, 4294963199, 3087007615, 1073692671, 4128527, 4279238655,
            4294902015, 4160684047, 4290246655, 469499899, 4294967231, 134086655, 4294966591, 2445279231, 3670015, 31,
            4294967288, 4294705151, 3221208447, 4294902271, 4294549472, 4294921215, 4095, 4285526655, 4294966527,
            4294966143, 64, 4294966719, 3774873592, 1877934080, 262151, 2555904, 536807423, 67043839, 3758096383,
            3959414372, 3755993023, 2080374783, 4294835295, 4294967103, 4160749565, 4294934527, 4087, 2016, 2147446655,
            184024726, 2862017156, 1593309078, 268434431, 268434414, 4294901763, 4294901761,
          ]
        ),
        s = (e10) => ((i[(e10 >>> 5) + 34816] >>> e10) & 1) != 0
      function f(e10) {
        return (e10.column++, (e10.currentChar = e10.source.charCodeAt(++e10.index)))
      }
      function l(e10) {
        let t2 = e10.currentChar
        if ((64512 & t2) != 55296) return 0
        let r2 = e10.source.charCodeAt(e10.index + 1)
        return (64512 & r2) != 56320 ? 0 : 65536 + ((1023 & t2) << 10) + (1023 & r2)
      }
      function c(e10, t2) {
        ;((e10.currentChar = e10.source.charCodeAt(++e10.index)),
          (e10.flags |= 1),
          (4 & t2) == 0 && ((e10.column = 0), e10.line++))
      }
      function u(e10) {
        ;((e10.flags |= 1), (e10.currentChar = e10.source.charCodeAt(++e10.index)), (e10.column = 0), e10.line++)
      }
      function d(e10) {
        return e10 < 65 ? e10 - 48 : (e10 - 65 + 10) & 15
      }
      let p = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1032, 0, 0, 2056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          8192, 0, 3, 0, 0, 8192, 0, 0, 0, 256, 0, 33024, 0, 0, 242, 242, 114, 114, 114, 114, 114, 114, 594, 594, 0, 0,
          16384, 0, 0, 0, 0, 67, 67, 67, 67, 67, 67, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 1,
          0, 0, 4099, 0, 71, 71, 71, 71, 71, 71, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 16384, 0,
          0, 0, 0,
        ],
        g = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        ],
        x = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        ]
      function k(e10) {
        return e10 <= 127 ? g[e10] > 0 : s(e10)
      }
      function h(e10) {
        return e10 <= 127 ? x[e10] > 0 : ((i[(e10 >>> 5) + 0] >>> e10) & 1) != 0 || 8204 === e10 || 8205 === e10
      }
      let b = ['SingleLine', 'MultiLine', 'HTMLOpen', 'HTMLClose', 'HashbangComment']
      function m(e10, t2, r2, n2, o2, a2) {
        return (2 & n2 && e10.report(0), T(e10, t2, r2, o2, a2))
      }
      function T(e10, t2, r2, n2, o2) {
        let { index: a2 } = e10
        for (
          e10.tokenIndex = e10.index, e10.tokenLine = e10.line, e10.tokenColumn = e10.column;
          e10.index < e10.end;
        ) {
          if (8 & p[e10.currentChar]) {
            let r3 = 13 === e10.currentChar
            ;(u(e10),
              r3 && e10.index < e10.end && 10 === e10.currentChar && (e10.currentChar = t2.charCodeAt(++e10.index)))
            break
          }
          if ((8232 ^ e10.currentChar) <= 1) {
            u(e10)
            break
          }
          ;(f(e10), (e10.tokenIndex = e10.index), (e10.tokenLine = e10.line), (e10.tokenColumn = e10.column))
        }
        if (e10.options.onComment) {
          let r3 = {
            start: { line: o2.line, column: o2.column },
            end: { line: e10.tokenLine, column: e10.tokenColumn },
          }
          e10.options.onComment(b[255 & n2], t2.slice(a2, e10.tokenIndex), o2.index, e10.tokenIndex, r3)
        }
        return 1 | r2
      }
      function y(e10, t2, r2, n2 = 0) {
        switch (r2) {
          case 98:
            return 8
          case 102:
            return 12
          case 114:
            return 13
          case 110:
            return 10
          case 116:
            return 9
          case 118:
            return 11
          case 13:
            if (e10.index < e10.end) {
              let t3 = e10.source.charCodeAt(e10.index + 1)
              10 === t3 && ((e10.index = e10.index + 1), (e10.currentChar = t3))
            }
          case 10:
          case 8232:
          case 8233:
            return ((e10.column = -1), e10.line++, -1)
          case 48:
          case 49:
          case 50:
          case 51: {
            let o2 = r2 - 48,
              a2 = e10.index + 1,
              i2 = e10.column + 1
            if (a2 < e10.end) {
              let r3 = e10.source.charCodeAt(a2)
              if ((32 & p[r3]) == 0) {
                if (0 !== o2 || 512 & p[r3]) {
                  if (1 & t2 || n2) return -2
                  e10.flags |= 64
                }
              } else {
                if (1 & t2 || n2) return -2
                if (((e10.currentChar = r3), (o2 = (o2 << 3) | (r3 - 48)), a2++, i2++, a2 < e10.end)) {
                  let t3 = e10.source.charCodeAt(a2)
                  32 & p[t3] && ((e10.currentChar = t3), (o2 = (o2 << 3) | (t3 - 48)), a2++, i2++)
                }
                e10.flags |= 64
              }
              ;((e10.index = a2 - 1), (e10.column = i2 - 1))
            }
            return o2
          }
          case 52:
          case 53:
          case 54:
          case 55: {
            if (n2 || 1 & t2) return -2
            let o2 = r2 - 48,
              a2 = e10.index + 1,
              i2 = e10.column + 1
            if (a2 < e10.end) {
              let t3 = e10.source.charCodeAt(a2)
              32 & p[t3] && ((o2 = (o2 << 3) | (t3 - 48)), (e10.currentChar = t3), (e10.index = a2), (e10.column = i2))
            }
            return ((e10.flags |= 64), o2)
          }
          case 120: {
            let t3 = f(e10)
            if ((64 & p[t3]) == 0) return -4
            let r3 = d(t3),
              n3 = f(e10)
            if ((64 & p[n3]) == 0) return -4
            return (r3 << 4) | d(n3)
          }
          case 117: {
            let t3 = f(e10)
            if (123 === e10.currentChar) {
              let t4 = 0
              for (; (64 & p[f(e10)]) != 0; ) if ((t4 = (t4 << 4) | d(e10.currentChar)) > 1114111) return -5
              if (e10.currentChar < 1 || 125 !== e10.currentChar) return -4
              return t4
            }
            {
              if ((64 & p[t3]) == 0) return -4
              let r3 = e10.source.charCodeAt(e10.index + 1)
              if ((64 & p[r3]) == 0) return -4
              let n3 = e10.source.charCodeAt(e10.index + 2)
              if ((64 & p[n3]) == 0) return -4
              let o2 = e10.source.charCodeAt(e10.index + 3)
              if ((64 & p[o2]) == 0) return -4
              return (
                (e10.index += 3),
                (e10.column += 3),
                (e10.currentChar = e10.source.charCodeAt(e10.index)),
                (d(t3) << 12) | (d(r3) << 8) | (d(n3) << 4) | d(o2)
              )
            }
          }
          case 56:
          case 57:
            if (n2 || !e10.options.webcompat || 1 & t2) return -3
            e10.flags |= 4096
          default:
            return r2
        }
      }
      function w(e10, t2, r2) {
        switch (t2) {
          case -1:
            return
          case -2:
            e10.report(r2 ? 2 : 1)
          case -3:
            e10.report(r2 ? 3 : 14)
          case -4:
            e10.report(7)
          case -5:
            e10.report(104)
        }
      }
      function S(e10, t2) {
        let { index: r2 } = e10,
          n2 = 67174409,
          o2 = '',
          a2 = f(e10)
        for (; 96 !== a2; ) {
          if (36 === a2 && 123 === e10.source.charCodeAt(e10.index + 1)) {
            ;(f(e10), (n2 = 67174408))
            break
          }
          if (92 === a2)
            if ((a2 = f(e10)) > 126) o2 += String.fromCodePoint(a2)
            else {
              let { index: r3, line: i2, column: s2 } = e10,
                l2 = y(e10, 1 | t2, a2, 1)
              if (l2 >= 0) o2 += String.fromCodePoint(l2)
              else if (-1 !== l2 && 64 & t2) {
                ;((e10.index = r3),
                  (e10.line = i2),
                  (e10.column = s2),
                  (o2 = null),
                  (a2 = (function (e11, t3) {
                    for (; 96 !== t3; ) {
                      switch (t3) {
                        case 36: {
                          let r4 = e11.index + 1
                          if (r4 < e11.end && 123 === e11.source.charCodeAt(r4))
                            return ((e11.index = r4), e11.column++, -t3)
                          break
                        }
                        case 10:
                        case 8232:
                        case 8233:
                          ;((e11.column = -1), e11.line++)
                      }
                      ;(e11.index >= e11.end && e11.report(17), (t3 = f(e11)))
                    }
                    return t3
                  })(e10, a2)) < 0 && (n2 = 67174408))
                break
              } else w(e10, l2, 1)
            }
          else
            e10.index < e10.end &&
              (13 === a2 &&
                10 === e10.source.charCodeAt(e10.index) &&
                ((o2 += String.fromCodePoint(a2)), (e10.currentChar = e10.source.charCodeAt(++e10.index))),
              (((83 & a2) < 3 && 10 === a2) || (8232 ^ a2) <= 1) && ((e10.column = -1), e10.line++),
              (o2 += String.fromCodePoint(a2)))
          ;(e10.index >= e10.end && e10.report(17), (a2 = f(e10)))
        }
        return (
          f(e10),
          (e10.tokenValue = o2),
          (e10.tokenRaw = e10.source.slice(r2 + 1, e10.index - (67174409 === n2 ? 1 : 2))),
          n2
        )
      }
      ;(((e = r || (r = {}))[(e.Empty = 0)] = 'Empty'),
        (e[(e.Escape = 1)] = 'Escape'),
        (e[(e.Class = 2)] = 'Class'),
        ((t = n || (n = {}))[(t.Empty = 0)] = 'Empty'),
        (t[(t.IgnoreCase = 1)] = 'IgnoreCase'),
        (t[(t.Global = 2)] = 'Global'),
        (t[(t.Multiline = 4)] = 'Multiline'),
        (t[(t.Unicode = 16)] = 'Unicode'),
        (t[(t.Sticky = 8)] = 'Sticky'),
        (t[(t.DotAll = 32)] = 'DotAll'),
        (t[(t.Indices = 64)] = 'Indices'),
        (t[(t.UnicodeSets = 128)] = 'UnicodeSets'))
      let v = {
        0: 'Unexpected token',
        30: "Unexpected token: '%0'",
        1: 'Octal escape sequences are not allowed in strict mode',
        2: 'Octal escape sequences are not allowed in template strings',
        3: '\\8 and \\9 are not allowed in template strings',
        4: 'Private identifier #%0 is not defined',
        5: 'Illegal Unicode escape sequence',
        6: 'Invalid code point %0',
        7: 'Invalid hexadecimal escape sequence',
        9: 'Octal literals are not allowed in strict mode',
        8: 'Decimal integer literals with a leading zero are forbidden in strict mode',
        10: 'Expected number in radix %0',
        151: 'Invalid left-hand side assignment to a destructible right-hand side',
        11: 'Non-number found after exponent indicator',
        12: 'Invalid BigIntLiteral',
        13: 'No identifiers allowed directly after numeric literal',
        14: 'Escapes \\8 or \\9 are not syntactically valid escapes',
        15: 'Escapes \\8 or \\9 are not allowed in strict mode',
        16: 'Unterminated string literal',
        17: 'Unterminated template literal',
        18: 'Multiline comment was not closed properly',
        19: 'The identifier contained dynamic unicode escape that was not closed',
        20: "Illegal character '%0'",
        21: 'Missing hexadecimal digits',
        22: 'Invalid implicit octal',
        23: 'Invalid line break in string literal',
        24: 'Only unicode escapes are legal in identifier names',
        25: "Expected '%0'",
        26: 'Invalid left-hand side in assignment',
        27: 'Invalid left-hand side in async arrow',
        28: 'Calls to super must be in the "constructor" method of a class expression or class declaration that has a superclass',
        29: 'Member access on super must be in a method',
        31: 'Await expression not allowed in formal parameter',
        32: 'Yield expression not allowed in formal parameter',
        95: "Unexpected token: 'escaped keyword'",
        33: 'Unary expressions as the left operand of an exponentiation expression must be disambiguated with parentheses',
        123: 'Async functions can only be declared at the top level or inside a block',
        34: 'Unterminated regular expression',
        35: 'Unexpected regular expression flag',
        36: "Duplicate regular expression flag '%0'",
        37: '%0 functions must have exactly %1 argument%2',
        38: 'Setter function argument must not be a rest parameter',
        39: '%0 declaration must have a name in this context',
        40: 'Function name may not contain any reserved words or be eval or arguments in strict mode',
        41: 'The rest operator is missing an argument',
        42: 'A getter cannot be a generator',
        43: 'A setter cannot be a generator',
        44: 'A computed property name must be followed by a colon or paren',
        134: 'Object literal keys that are strings or numbers must be a method or have a colon',
        46: 'Found `* async x(){}` but this should be `async * x(){}`',
        45: 'Getters and setters can not be generators',
        47: "'%0' can not be generator method",
        48: "No line break is allowed after '=>'",
        49: 'The left-hand side of the arrow can only be destructed through assignment',
        50: 'The binding declaration is not destructible',
        51: 'Async arrow can not be followed by new expression',
        52: "Classes may not have a static property named 'prototype'",
        53: 'Class constructor may not be a %0',
        54: 'Duplicate constructor method in class',
        55: 'Invalid increment/decrement operand',
        56: 'Invalid use of `new` keyword on an increment/decrement expression',
        57: '`=>` is an invalid assignment target',
        58: 'Rest element may not have a trailing comma',
        59: 'Missing initializer in %0 declaration',
        60: "'for-%0' loop head declarations can not have an initializer",
        61: 'Invalid left-hand side in for-%0 loop: Must have a single binding',
        62: 'Invalid shorthand property initializer',
        63: 'Property name __proto__ appears more than once in object literal',
        64: 'Let is disallowed as a lexically bound name',
        65: "Invalid use of '%0' inside new expression",
        66: "Illegal 'use strict' directive in function with non-simple parameter list",
        67: 'Identifier "let" disallowed as left-hand side expression in strict mode',
        68: 'Illegal continue statement',
        69: 'Illegal break statement',
        70: 'Cannot have `let[...]` as a var name in strict mode',
        71: 'Invalid destructuring assignment target',
        72: 'Rest parameter may not have a default initializer',
        73: 'The rest argument must the be last parameter',
        74: 'Invalid rest argument',
        76: 'In strict mode code, functions can only be declared at top level or inside a block',
        77: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement',
        78: 'Without web compatibility enabled functions can not be declared at top level, inside a block, or as the body of an if statement',
        79: "Class declaration can't appear in single-statement context",
        80: 'Invalid left-hand side in for-%0',
        81: 'Invalid assignment in for-%0',
        82: 'for await (... of ...) is only valid in async functions and async generators',
        83: 'The first token after the template expression should be a continuation of the template',
        85: '`let` declaration not allowed here and `let` cannot be a regular var name in strict mode',
        84: '`let \n [` is a restricted production at the start of a statement',
        86: 'Catch clause requires exactly one parameter, not more (and no trailing comma)',
        87: 'Catch clause parameter does not support default values',
        88: 'Missing catch or finally after try',
        89: 'More than one default clause in switch statement',
        90: 'Illegal newline after throw',
        91: 'Strict mode code may not include a with statement',
        92: 'Illegal return statement',
        93: 'The left hand side of the for-header binding declaration is not destructible',
        94: 'new.target only allowed within functions or static blocks',
        96: "'#' not followed by identifier",
        102: 'Invalid keyword',
        101: "Can not use 'let' as a class name",
        100: "'A lexical declaration can't define a 'let' binding",
        99: 'Can not use `let` as variable name in strict mode',
        97: "'%0' may not be used as an identifier in this context",
        98: 'Await is only valid in async functions',
        103: 'The %0 keyword can only be used with the module goal',
        104: 'Unicode codepoint must not be greater than 0x10FFFF',
        105: '%0 source must be string',
        106: 'Only a identifier or string can be used to indicate alias',
        107: "Only '*' or '{...}' can be imported after default",
        108: 'Trailing decorator may be followed by method',
        109: "Decorators can't be used with a constructor",
        110: 'Can not use `await` as identifier in module or async func',
        111: 'Can not use `await` as identifier in module',
        112: 'HTML comments are only allowed with web compatibility (Annex B)',
        113: "The identifier 'let' must not be in expression position in strict mode",
        114: 'Cannot assign to `eval` and `arguments` in strict mode',
        115: "The left-hand side of a for-of loop may not start with 'let'",
        116: 'Block body arrows can not be immediately invoked without a group',
        117: 'Block body arrows can not be immediately accessed without a group',
        118: 'Unexpected strict mode reserved word',
        119: 'Unexpected eval or arguments in strict mode',
        120: 'Decorators must not be followed by a semicolon',
        121: 'Calling delete on expression not allowed in strict mode',
        122: 'Pattern can not have a tail',
        124: 'Can not have a `yield` expression on the left side of a ternary',
        125: 'An arrow function can not have a postfix update operator',
        126: 'Invalid object literal key character after generator star',
        127: 'Private fields can not be deleted',
        129: 'Classes may not have a field called constructor',
        128: 'Classes may not have a private element named constructor',
        130: 'A class field initializer or static block may not contain arguments',
        131: 'Generators can only be declared at the top level or inside a block',
        132: 'Async methods are a restricted production and cannot have a newline following it',
        133: 'Unexpected character after object literal property name',
        135: 'Invalid key token',
        136: "Label '%0' has already been declared",
        137: 'continue statement must be nested within an iteration statement',
        138: "Undefined label '%0'",
        139: 'Trailing comma is disallowed inside import(...) arguments',
        140: 'Invalid binding in JSON import',
        141: 'import() requires exactly one argument',
        142: 'Cannot use new with import(...)',
        143: '... is not allowed in import()',
        144: "Expected '=>'",
        145: "Duplicate binding '%0'",
        146: 'Duplicate private identifier #%0',
        147: "Cannot export a duplicate name '%0'",
        150: 'Duplicate %0 for-binding',
        148: "Exported binding '%0' needs to refer to a top-level declared variable",
        149: 'Unexpected private field',
        153: 'Numeric separators are not allowed at the end of numeric literals',
        152: 'Only one underscore is allowed as numeric separator',
        154: 'JSX value should be either an expression or a quoted JSX text',
        155: 'Expected corresponding JSX closing tag for %0',
        156: 'Adjacent JSX elements must be wrapped in an enclosing tag',
        157: "JSX attributes must only be assigned a non-empty 'expression'",
        158: "'%0' has already been declared",
        159: "'%0' shadowed a catch clause binding",
        160: 'Dot property must be an identifier',
        161: 'Encountered invalid input after spread/rest argument',
        162: 'Catch without try',
        163: 'Finally without try',
        164: 'Expected corresponding closing tag for JSX fragment',
        165: 'Coalescing and logical operators used together in the same expression must be disambiguated with parentheses',
        166: 'Invalid tagged template on optional chain',
        167: 'Invalid optional chain from super property',
        168: 'Invalid optional chain from new expression',
        169: 'Cannot use "import.meta" outside a module',
        170: 'Leading decorators must be attached to a class declaration',
        171: 'An export name cannot include a lone surrogate, found %0',
        172: 'A string literal cannot be used as an exported binding without `from`',
        173: "Private fields can't be accessed on super",
        174: "The only valid meta property for import is 'import.meta'",
        175: "'import.meta' must not contain escaped characters",
        176: 'cannot use "await" as identifier inside an async function',
        177: 'cannot use "await" in static blocks',
      }
      class C extends SyntaxError {
        start
        end
        range
        loc
        description
        constructor(e10, t2, r2, ...n2) {
          const o2 = v[r2].replace(/%(\d+)/g, (e11, t3) => n2[t3])
          ;(super('[' + e10.line + ':' + e10.column + '-' + t2.line + ':' + t2.column + ']: ' + o2),
            (this.start = e10.index),
            (this.end = t2.index),
            (this.range = [e10.index, t2.index]),
            (this.loc = { start: { line: e10.line, column: e10.column }, end: { line: t2.line, column: t2.column } }),
            (this.description = o2))
        }
      }
      function q(e10, t2, r2) {
        let n2 = e10.currentChar,
          o2 = 0,
          a2 = 9,
          i2 = 64 & r2 ? 0 : 1,
          s2 = 0,
          l2 = 0
        if (64 & r2) ((o2 = '.' + E(e10, n2)), 110 === (n2 = e10.currentChar) && e10.report(12))
        else {
          if (48 === n2)
            if ((32 | (n2 = f(e10))) == 120) {
              for (r2 = 136, n2 = f(e10); 4160 & p[n2]; ) {
                if (95 === n2) {
                  ;(l2 || e10.report(152), (l2 = 0), (n2 = f(e10)))
                  continue
                }
                ;((l2 = 1), (o2 = 16 * o2 + d(n2)), s2++, (n2 = f(e10)))
              }
              ;(0 !== s2 && l2) || e10.report(0 === s2 ? 21 : 153)
            } else if ((32 | n2) == 111) {
              for (r2 = 132, n2 = f(e10); 4128 & p[n2]; ) {
                if (95 === n2) {
                  ;(l2 || e10.report(152), (l2 = 0), (n2 = f(e10)))
                  continue
                }
                ;((l2 = 1), (o2 = 8 * o2 + (n2 - 48)), s2++, (n2 = f(e10)))
              }
              ;(0 !== s2 && l2) || e10.report(153 * (0 !== s2))
            } else if ((32 | n2) == 98) {
              for (r2 = 130, n2 = f(e10); 4224 & p[n2]; ) {
                if (95 === n2) {
                  ;(l2 || e10.report(152), (l2 = 0), (n2 = f(e10)))
                  continue
                }
                ;((l2 = 1), (o2 = 2 * o2 + (n2 - 48)), s2++, (n2 = f(e10)))
              }
              ;(0 !== s2 && l2) || e10.report(153 * (0 !== s2))
            } else if (32 & p[n2])
              for (1 & t2 && e10.report(1), r2 = 1; 16 & p[n2]; ) {
                if (512 & p[n2]) {
                  ;((r2 = 32), (i2 = 0))
                  break
                }
                ;((o2 = 8 * o2 + (n2 - 48)), (n2 = f(e10)))
              }
            else 512 & p[n2] ? (1 & t2 && e10.report(1), (e10.flags |= 64), (r2 = 32)) : 95 === n2 && e10.report(0)
          if (48 & r2) {
            if (i2) {
              for (; a2 >= 0 && 4112 & p[n2]; ) {
                if (95 === n2) {
                  if (95 === (n2 = f(e10)) || 32 & r2)
                    throw new C(e10.currentLocation, { index: e10.index + 1, line: e10.line, column: e10.column }, 152)
                  l2 = 1
                  continue
                }
                ;((l2 = 0), (o2 = 10 * o2 + (n2 - 48)), (n2 = f(e10)), --a2)
              }
              if (l2)
                throw new C(e10.currentLocation, { index: e10.index + 1, line: e10.line, column: e10.column }, 153)
              if (a2 >= 0 && !k(n2) && 46 !== n2)
                return (
                  (e10.tokenValue = o2),
                  e10.options.raw && (e10.tokenRaw = e10.source.slice(e10.tokenIndex, e10.index)),
                  134283266
                )
            }
            ;((o2 += E(e10, n2)),
              46 === (n2 = e10.currentChar) &&
                (95 === f(e10) && e10.report(0),
                (r2 = 64),
                (o2 += '.' + E(e10, e10.currentChar)),
                (n2 = e10.currentChar)))
          }
        }
        let c2 = e10.index,
          u2 = 0
        if (110 === n2 && 128 & r2) ((u2 = 1), (n2 = f(e10)))
        else if ((32 | n2) == 101) {
          256 & p[(n2 = f(e10))] && (n2 = f(e10))
          let { index: t3 } = e10
          ;((16 & p[n2]) == 0 && e10.report(11),
            (o2 += e10.source.substring(c2, t3) + E(e10, n2)),
            (n2 = e10.currentChar))
        }
        return (((e10.index < e10.end && 16 & p[n2]) || k(n2)) && e10.report(13), u2)
          ? ((e10.tokenRaw = e10.source.slice(e10.tokenIndex, e10.index)),
            (e10.tokenValue = BigInt(e10.tokenRaw.slice(0, -1).replaceAll('_', ''))),
            134283388)
          : ((e10.tokenValue =
              15 & r2 ? o2 : 32 & r2 ? parseFloat(e10.source.substring(e10.tokenIndex, e10.index)) : +o2),
            e10.options.raw && (e10.tokenRaw = e10.source.slice(e10.tokenIndex, e10.index)),
            134283266)
      }
      function E(e10, t2) {
        let r2 = 0,
          n2 = e10.index,
          o2 = ''
        for (; 4112 & p[t2]; ) {
          if (95 === t2) {
            let { index: a2 } = e10
            if (95 === (t2 = f(e10)))
              throw new C(e10.currentLocation, { index: e10.index + 1, line: e10.line, column: e10.column }, 152)
            ;((r2 = 1), (o2 += e10.source.substring(n2, a2)), (n2 = e10.index))
            continue
          }
          ;((r2 = 0), (t2 = f(e10)))
        }
        if (r2) throw new C(e10.currentLocation, { index: e10.index + 1, line: e10.line, column: e10.column }, 153)
        return o2 + e10.source.substring(n2, e10.index)
      }
      let N = [
          'end of source',
          'identifier',
          'number',
          'string',
          'regular expression',
          'false',
          'true',
          'null',
          'template continuation',
          'template tail',
          '=>',
          '(',
          '{',
          '.',
          '...',
          '}',
          ')',
          ';',
          ',',
          '[',
          ']',
          ':',
          '?',
          "'",
          '"',
          '++',
          '--',
          '=',
          '<<=',
          '>>=',
          '>>>=',
          '**=',
          '+=',
          '-=',
          '*=',
          '/=',
          '%=',
          '^=',
          '|=',
          '&=',
          '||=',
          '&&=',
          '??=',
          'typeof',
          'delete',
          'void',
          '!',
          '~',
          '+',
          '-',
          'in',
          'instanceof',
          '*',
          '%',
          '/',
          '**',
          '&&',
          '||',
          '===',
          '!==',
          '==',
          '!=',
          '<=',
          '>=',
          '<',
          '>',
          '<<',
          '>>',
          '>>>',
          '&',
          '|',
          '^',
          'var',
          'let',
          'const',
          'break',
          'case',
          'catch',
          'class',
          'continue',
          'debugger',
          'default',
          'do',
          'else',
          'export',
          'extends',
          'finally',
          'for',
          'function',
          'if',
          'import',
          'new',
          'return',
          'super',
          'switch',
          'this',
          'throw',
          'try',
          'while',
          'with',
          'implements',
          'interface',
          'package',
          'private',
          'protected',
          'public',
          'static',
          'yield',
          'as',
          'async',
          'await',
          'constructor',
          'get',
          'set',
          'accessor',
          'from',
          'of',
          'enum',
          'eval',
          'arguments',
          'escaped keyword',
          'escaped future reserved keyword',
          'reserved if strict',
          '#',
          'BigIntLiteral',
          '??',
          '?.',
          'WhiteSpace',
          'Illegal',
          'LineTerminator',
          'PrivateField',
          'Template',
          '@',
          'target',
          'meta',
          'LineFeed',
          'Escaped',
          'JSXText',
        ],
        L = {
          this: 86111,
          function: 86104,
          if: 20569,
          return: 20572,
          var: 86088,
          else: 20563,
          for: 20567,
          new: 86107,
          in: 8673330,
          typeof: 16863275,
          while: 20578,
          case: 20556,
          break: 20555,
          try: 20577,
          catch: 20557,
          delete: 16863276,
          throw: 86112,
          switch: 86110,
          continue: 20559,
          default: 20561,
          instanceof: 8411187,
          do: 20562,
          void: 16863277,
          finally: 20566,
          async: 209005,
          await: 209006,
          class: 86094,
          const: 86090,
          constructor: 12399,
          debugger: 20560,
          export: 20564,
          extends: 20565,
          false: 86021,
          from: 209011,
          get: 209008,
          implements: 36964,
          import: 86106,
          interface: 36965,
          let: 241737,
          null: 86023,
          of: 471156,
          package: 36966,
          private: 36967,
          protected: 36968,
          public: 36969,
          set: 209009,
          static: 36970,
          super: 86109,
          true: 86022,
          with: 20579,
          yield: 241771,
          enum: 86133,
          eval: 537079926,
          as: 77932,
          arguments: 537079927,
          target: 209029,
          meta: 209030,
          accessor: 12402,
        }
      function A(e10, t2) {
        ;((1 & e10.flags) == 0 && (1048576 & e10.getToken()) != 1048576 && e10.report(30, N[255 & e10.getToken()]),
          V(e10, t2, 1074790417) || e10.options.onInsertedSemicolon?.(e10.startIndex))
      }
      function I(e10, t2, r2, n2) {
        return t2 - r2 < 13 && 'use strict' === n2 && ((1048576 & e10.getToken()) == 1048576 || 1 & e10.flags) ? 1 : 0
      }
      function D(e10, t2, r2) {
        return e10.getToken() !== r2 ? 0 : ($(e10, t2), 1)
      }
      function V(e10, t2, r2) {
        return e10.getToken() === r2 && ($(e10, t2), true)
      }
      function R(e10, t2, r2) {
        ;(e10.getToken() !== r2 && e10.report(25, N[255 & r2]), $(e10, t2))
      }
      function P(e10, t2) {
        switch (t2.type) {
          case 'ArrayExpression': {
            t2.type = 'ArrayPattern'
            let { elements: r2 } = t2
            for (let t3 = 0, n2 = r2.length; t3 < n2; ++t3) {
              let n3 = r2[t3]
              n3 && P(e10, n3)
            }
            return
          }
          case 'ObjectExpression': {
            t2.type = 'ObjectPattern'
            let { properties: r2 } = t2
            for (let t3 = 0, n2 = r2.length; t3 < n2; ++t3) P(e10, r2[t3])
            return
          }
          case 'AssignmentExpression':
            ;((t2.type = 'AssignmentPattern'),
              '=' !== t2.operator && e10.report(71),
              delete t2.operator,
              P(e10, t2.left))
            return
          case 'Property':
            P(e10, t2.value)
            return
          case 'SpreadElement':
            ;((t2.type = 'RestElement'), P(e10, t2.argument))
        }
      }
      function U(e10, t2, r2, n2, o2) {
        ;(1 & t2 && ((36864 & n2) == 36864 && e10.report(118), o2 || (537079808 & n2) != 537079808 || e10.report(119)),
          ((20480 & n2) == 20480 || -2147483528 === n2) && e10.report(102),
          24 & r2 && (255 & n2) == 73 && e10.report(100),
          2050 & t2 && 209006 === n2 && e10.report(110),
          1025 & t2 && 241771 === n2 && e10.report(97, 'yield'))
      }
      function B(e10, t2, r2) {
        ;(1 & t2 &&
          ((36864 & r2) == 36864 && e10.report(118),
          (537079808 & r2) == 537079808 && e10.report(119),
          -2147483527 === r2 && e10.report(95),
          -2147483528 === r2 && e10.report(95)),
          (20480 & r2) == 20480 && e10.report(102),
          2050 & t2 && 209006 === r2 && e10.report(110),
          1025 & t2 && 241771 === r2 && e10.report(97, 'yield'))
      }
      function O(e10, t2, r2) {
        return (
          209006 === r2 && (2050 & t2 && e10.report(110), (e10.destructible |= 128)),
          241771 === r2 && 1024 & t2 && e10.report(97, 'yield'),
          (20480 & r2) == 20480 || (36864 & r2) == 36864 || -2147483527 == r2
        )
      }
      function G(e10, t2, r2, n2) {
        for (; t2; ) {
          if (t2['$' + r2]) return (n2 && e10.report(137), 1)
          ;(n2 && t2.loop && (n2 = 0), (t2 = t2.$))
        }
        return 0
      }
      function j(e10) {
        switch (e10.type) {
          case 'JSXIdentifier':
            return e10.name
          case 'JSXNamespacedName':
            return e10.namespace + ':' + e10.name
          case 'JSXMemberExpression':
            return j(e10.object) + '.' + j(e10.property)
        }
      }
      function M(e10, t2) {
        return 1025 & e10
          ? (!(2 & e10) || 209006 !== t2) && (!(1024 & e10) || 241771 !== t2) && (12288 & t2) == 12288
          : (12288 & t2) == 12288 || (36864 & t2) == 36864
      }
      function J(e10, t2, r2) {
        ;((537079808 & r2) == 537079808 && (1 & t2 && e10.report(119), (e10.flags |= 512)), M(t2, r2) || e10.report(0))
      }
      function F(e10, t2) {
        return Object.hasOwn(e10, t2) ? e10[t2] : void 0
      }
      function H(e10, t2, r2) {
        for (; x[f(e10)]; );
        return (
          (e10.tokenValue = e10.source.slice(e10.tokenIndex, e10.index)),
          92 !== e10.currentChar && e10.currentChar <= 126 ? (F(L, e10.tokenValue) ?? 208897) : z(e10, t2, 0, r2)
        )
      }
      function z(e10, t2, r2, n2) {
        let o2 = e10.index
        for (; e10.index < e10.end; )
          if (92 === e10.currentChar) {
            ;((e10.tokenValue += e10.source.slice(o2, e10.index)), (r2 = 1))
            let t3 = X(e10)
            ;(h(t3) || e10.report(5),
              (n2 = n2 && 4 & p[t3]),
              (e10.tokenValue += String.fromCodePoint(t3)),
              (o2 = e10.index))
          } else {
            let t3 = l(e10)
            if (t3 > 0)
              (h(t3) || e10.report(20, String.fromCodePoint(t3)), (e10.currentChar = t3), e10.index++, e10.column++)
            else if (!h(e10.currentChar)) break
            f(e10)
          }
        e10.index <= e10.end && (e10.tokenValue += e10.source.slice(o2, e10.index))
        let { length: a2 } = e10.tokenValue
        if (n2 && a2 >= 2 && a2 <= 11) {
          let n3 = F(L, e10.tokenValue)
          if (void 0 === n3) return 208897 | (r2 ? -2147483648 : 0)
          if (!r2) return n3
          if (209006 === n3) return (2050 & t2) == 0 ? -2147483648 | n3 : -2147483528
          if (1 & t2) {
            if (36970 === n3 || (36864 & n3) == 36864) return -2147483527
            if ((20480 & n3) == 20480)
              if (262144 & t2 && (8 & t2) == 0) return -2147483648 | n3
              else return -2147483528
            return -2147274630
          }
          return 262144 & t2 && (8 & t2) == 0 && (20480 & n3) == 20480
            ? -2147483648 | n3
            : 241771 === n3
              ? 262144 & t2
                ? -2147274630
                : 1024 & t2
                  ? -2147483528
                  : -2147483648 | n3
              : 209005 === n3
                ? -2147274630
                : (36864 & n3) == 36864
                  ? 12288 | n3 | -2147483648
                  : -2147483528
        }
        return 208897 | (r2 ? -2147483648 : 0)
      }
      function X(e10) {
        return (
          117 !== e10.source.charCodeAt(e10.index + 1) && e10.report(5),
          (e10.currentChar = e10.source.charCodeAt((e10.index += 2))),
          (e10.column += 2),
          (function (e11) {
            let t2 = 0,
              r2 = e11.currentChar
            if (123 === r2) {
              let r3 = e11.index - 2
              for (; 64 & p[f(e11)]; )
                if ((t2 = (t2 << 4) | d(e11.currentChar)) > 1114111)
                  throw new C({ index: r3, line: e11.line, column: e11.column }, e11.currentLocation, 104)
              if (125 !== e11.currentChar)
                throw new C({ index: r3, line: e11.line, column: e11.column }, e11.currentLocation, 7)
              return (f(e11), t2)
            }
            ;(64 & p[r2]) == 0 && e11.report(7)
            let n2 = e11.source.charCodeAt(e11.index + 1)
            ;(64 & p[n2]) == 0 && e11.report(7)
            let o2 = e11.source.charCodeAt(e11.index + 2)
            ;(64 & p[o2]) == 0 && e11.report(7)
            let a2 = e11.source.charCodeAt(e11.index + 3)
            return (
              (64 & p[a2]) == 0 && e11.report(7),
              (t2 = (d(r2) << 12) | (d(n2) << 8) | (d(o2) << 4) | d(a2)),
              (e11.currentChar = e11.source.charCodeAt((e11.index += 4))),
              (e11.column += 4),
              t2
            )
          })(e10)
        )
      }
      let _ = [
        128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 135, 127, 127, 129, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 16842798, 134283267, 130, 208897, 8391477, 8390213,
        134283267, 67174411, 16, 8391476, 25233968, 18, 25233969, 67108877, 8457014, 134283266, 134283266, 134283266,
        134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 21, 1074790417, 8456256,
        1077936155, 8390721, 22, 132, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897,
        208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897,
        208897, 208897, 69271571, 136, 20, 8389959, 208897, 131, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 208897, 4096,
        208897, 208897, 4096, 208897, 4096, 208897, 4096, 208897, 4096, 4096, 4096, 208897, 4096, 4096, 208897, 4096,
        4096, 2162700, 8389702, 1074790415, 16842799, 128,
      ]
      function $(e10, t2) {
        ;((e10.flags = (1 | e10.flags) ^ 1),
          (e10.startIndex = e10.index),
          (e10.startColumn = e10.column),
          (e10.startLine = e10.line),
          e10.setToken(Y(e10, t2, 0)))
      }
      function Y(e10, t2, o2) {
        let a2 = 0 === e10.index,
          { source: i2 } = e10,
          d2 = e10.currentLocation
        for (; e10.index < e10.end; ) {
          ;((e10.tokenIndex = e10.index), (e10.tokenColumn = e10.column), (e10.tokenLine = e10.line))
          let x2 = e10.currentChar
          if (x2 <= 126) {
            let s2 = _[x2]
            switch (s2) {
              case 67174411:
              case 16:
              case 2162700:
              case 1074790415:
              case 69271571:
              case 20:
              case 21:
              case 1074790417:
              case 18:
              case 16842799:
              case 132:
              case 128:
                return (f(e10), s2)
              case 208897:
                return H(e10, t2, 0)
              case 4096:
                return H(e10, t2, 1)
              case 134283266:
                return q(e10, t2, 144)
              case 134283267:
                return (function (e11, t3, r2) {
                  let { index: n2 } = e11,
                    o3 = '',
                    a3 = f(e11),
                    i3 = e11.index
                  for (; (8 & p[a3]) == 0; ) {
                    if (a3 === r2)
                      return (
                        (o3 += e11.source.slice(i3, e11.index)),
                        f(e11),
                        e11.options.raw && (e11.tokenRaw = e11.source.slice(n2, e11.index)),
                        (e11.tokenValue = o3),
                        134283267
                      )
                    if ((8 & a3) == 8 && 92 === a3) {
                      if (
                        ((o3 += e11.source.slice(i3, e11.index)), (a3 = f(e11)) < 127 || 8232 === a3 || 8233 === a3)
                      ) {
                        let r3 = y(e11, t3, a3)
                        r3 >= 0 ? (o3 += String.fromCodePoint(r3)) : w(e11, r3, 0)
                      } else o3 += String.fromCodePoint(a3)
                      i3 = e11.index + 1
                    } else (8232 === a3 || 8233 === a3) && ((e11.column = -1), e11.line++)
                    ;(e11.index >= e11.end && e11.report(16), (a3 = f(e11)))
                  }
                  e11.report(16)
                })(e10, t2, x2)
              case 131:
                return S(e10, t2)
              case 136:
                return (function (e11, t3) {
                  let r2 = X(e11)
                  return (k(r2) || e11.report(5), (e11.tokenValue = String.fromCodePoint(r2)), z(e11, t3, 1, 4 & p[r2]))
                })(e10, t2)
              case 130:
                return (function (e11) {
                  let t3 = f(e11)
                  if (92 === t3) return 130
                  let r2 = l(e11)
                  return (r2 && (t3 = r2), k(t3) || e11.report(96), 130)
                })(e10)
              case 127:
                f(e10)
                break
              case 129:
                ;((o2 |= 5), u(e10))
                break
              case 135:
                ;(c(e10, o2), (o2 = (-5 & o2) | 1))
                break
              case 8456256: {
                let r2 = f(e10)
                if (e10.index < e10.end) {
                  if (60 === r2) {
                    if (e10.index < e10.end && 61 === f(e10)) return (f(e10), 4194332)
                    return 8390978
                  }
                  if (61 === r2) return (f(e10), 8390718)
                  if (33 === r2) {
                    let r3 = e10.index + 1
                    if (r3 + 1 < e10.end && 45 === i2.charCodeAt(r3) && 45 == i2.charCodeAt(r3 + 1)) {
                      ;((e10.column += 3),
                        (e10.currentChar = i2.charCodeAt((e10.index += 3))),
                        (o2 = m(e10, i2, o2, t2, 2, e10.tokenStart)),
                        (d2 = e10.tokenStart))
                      continue
                    }
                  }
                }
                return 8456256
              }
              case 1077936155: {
                f(e10)
                let t3 = e10.currentChar
                if (61 === t3) {
                  if (61 === f(e10)) return (f(e10), 8390458)
                  return 8390460
                }
                if (62 === t3) return (f(e10), 10)
                return 1077936155
              }
              case 16842798:
                if (61 !== f(e10)) return 16842798
                if (61 !== f(e10)) return 8390461
                return (f(e10), 8390459)
              case 8391477:
                if (61 !== f(e10)) return 8391477
                return (f(e10), 4194340)
              case 8391476: {
                if ((f(e10), e10.index >= e10.end)) return 8391476
                let t3 = e10.currentChar
                if (61 === t3) return (f(e10), 4194338)
                if (42 !== t3) return 8391476
                if (61 !== f(e10)) return 8391735
                return (f(e10), 4194335)
              }
              case 8389959:
                if (61 !== f(e10)) return 8389959
                return (f(e10), 4194341)
              case 25233968: {
                f(e10)
                let t3 = e10.currentChar
                if (43 === t3) return (f(e10), 33619993)
                if (61 === t3) return (f(e10), 4194336)
                return 25233968
              }
              case 25233969: {
                f(e10)
                let r2 = e10.currentChar
                if (45 === r2) {
                  if ((f(e10), (1 & o2 || a2) && 62 === e10.currentChar)) {
                    ;(e10.options.webcompat || e10.report(112),
                      f(e10),
                      (o2 = m(e10, i2, o2, t2, 3, d2)),
                      (d2 = e10.tokenStart))
                    continue
                  }
                  return 33619994
                }
                if (61 === r2) return (f(e10), 4194337)
                return 25233969
              }
              case 8457014:
                if ((f(e10), e10.index < e10.end)) {
                  let a3 = e10.currentChar
                  if (47 === a3) {
                    ;(f(e10), (o2 = T(e10, i2, o2, 0, e10.tokenStart)), (d2 = e10.tokenStart))
                    continue
                  }
                  if (42 === a3) {
                    ;(f(e10),
                      (o2 = (function (e11, t3, r2) {
                        let { index: n2 } = e11
                        for (; e11.index < e11.end; )
                          if (e11.currentChar < 43) {
                            let o3 = false
                            for (; 42 === e11.currentChar; )
                              if ((o3 || ((r2 &= -5), (o3 = true)), 47 === f(e11))) {
                                if ((f(e11), e11.options.onComment)) {
                                  let r3 = {
                                    start: { line: e11.tokenLine, column: e11.tokenColumn },
                                    end: { line: e11.line, column: e11.column },
                                  }
                                  e11.options.onComment(b[1], t3.slice(n2, e11.index - 2), n2 - 2, e11.index, r3)
                                }
                                return (
                                  (e11.tokenIndex = e11.index),
                                  (e11.tokenLine = e11.line),
                                  (e11.tokenColumn = e11.column),
                                  r2
                                )
                              }
                            if (o3) continue
                            8 & p[e11.currentChar]
                              ? 13 === e11.currentChar
                                ? ((r2 |= 5), u(e11))
                                : (c(e11, r2), (r2 = (-5 & r2) | 1))
                              : f(e11)
                          } else (8232 ^ e11.currentChar) <= 1 ? ((r2 = (-5 & r2) | 1), u(e11)) : ((r2 &= -5), f(e11))
                        e11.report(18)
                      })(e10, i2, o2)),
                      (d2 = e10.tokenStart))
                    continue
                  }
                  if (32 & t2)
                    return (function (e11) {
                      let t3 = e11.index,
                        o3 = r.Empty
                      e: for (;;) {
                        let t4 = e11.currentChar
                        if ((f(e11), o3 & r.Escape)) o3 &= ~r.Escape
                        else
                          switch (t4) {
                            case 47:
                              if (o3) break
                              break e
                            case 92:
                              o3 |= r.Escape
                              break
                            case 91:
                              o3 |= r.Class
                              break
                            case 93:
                              o3 &= r.Escape
                          }
                        if (
                          ((13 === t4 || 10 === t4 || 8232 === t4 || 8233 === t4) && e11.report(34),
                          e11.index >= e11.source.length)
                        )
                          return e11.report(34)
                      }
                      let a4 = e11.index - 1,
                        i3 = n.Empty,
                        s3 = e11.currentChar,
                        { index: l2 } = e11
                      for (; h(s3); ) {
                        switch (s3) {
                          case 103:
                            ;(i3 & n.Global && e11.report(36, 'g'), (i3 |= n.Global))
                            break
                          case 105:
                            ;(i3 & n.IgnoreCase && e11.report(36, 'i'), (i3 |= n.IgnoreCase))
                            break
                          case 109:
                            ;(i3 & n.Multiline && e11.report(36, 'm'), (i3 |= n.Multiline))
                            break
                          case 117:
                            ;(i3 & n.Unicode && e11.report(36, 'u'),
                              i3 & n.UnicodeSets && e11.report(36, 'vu'),
                              (i3 |= n.Unicode))
                            break
                          case 118:
                            ;(i3 & n.Unicode && e11.report(36, 'uv'),
                              i3 & n.UnicodeSets && e11.report(36, 'v'),
                              (i3 |= n.UnicodeSets))
                            break
                          case 121:
                            ;(i3 & n.Sticky && e11.report(36, 'y'), (i3 |= n.Sticky))
                            break
                          case 115:
                            ;(i3 & n.DotAll && e11.report(36, 's'), (i3 |= n.DotAll))
                            break
                          case 100:
                            ;(i3 & n.Indices && e11.report(36, 'd'), (i3 |= n.Indices))
                            break
                          default:
                            e11.report(35)
                        }
                        s3 = f(e11)
                      }
                      let c2 = e11.source.slice(l2, e11.index),
                        u2 = e11.source.slice(t3, a4)
                      return (
                        (e11.tokenRegExp = { pattern: u2, flags: c2 }),
                        e11.options.raw && (e11.tokenRaw = e11.source.slice(e11.tokenIndex, e11.index)),
                        (e11.tokenValue = (function (e12, t4, r2) {
                          try {
                            return new RegExp(t4, r2)
                          } catch {
                            try {
                              return (new RegExp(t4, r2), null)
                            } catch {
                              e12.report(34)
                            }
                          }
                        })(e11, u2, c2)),
                        65540
                      )
                    })(e10)
                  if (61 === a3) return (f(e10), 4259875)
                }
                return 8457014
              case 67108877: {
                let r2 = f(e10)
                if (r2 >= 48 && r2 <= 57) return q(e10, t2, 80)
                if (46 === r2) {
                  let t3 = e10.index + 1
                  if (t3 < e10.end && 46 === i2.charCodeAt(t3))
                    return ((e10.column += 2), (e10.currentChar = i2.charCodeAt((e10.index += 2))), 14)
                }
                return 67108877
              }
              case 8389702: {
                f(e10)
                let t3 = e10.currentChar
                if (124 === t3) {
                  if ((f(e10), 61 === e10.currentChar)) return (f(e10), 4194344)
                  return 8913465
                }
                if (61 === t3) return (f(e10), 4194342)
                return 8389702
              }
              case 8390721: {
                f(e10)
                let t3 = e10.currentChar
                if (61 === t3) return (f(e10), 8390719)
                if (62 !== t3) return 8390721
                if ((f(e10), e10.index < e10.end)) {
                  let t4 = e10.currentChar
                  if (62 === t4) {
                    if (61 === f(e10)) return (f(e10), 4194334)
                    return 8390980
                  }
                  if (61 === t4) return (f(e10), 4194333)
                }
                return 8390979
              }
              case 8390213: {
                f(e10)
                let t3 = e10.currentChar
                if (38 === t3) {
                  if ((f(e10), 61 === e10.currentChar)) return (f(e10), 4194345)
                  return 8913720
                }
                if (61 === t3) return (f(e10), 4194343)
                return 8390213
              }
              case 22: {
                let t3 = f(e10)
                if (63 === t3) {
                  if ((f(e10), 61 === e10.currentChar)) return (f(e10), 4194346)
                  return 276824445
                }
                if (46 === t3) {
                  let r2 = e10.index + 1
                  if (r2 < e10.end && !((t3 = i2.charCodeAt(r2)) >= 48 && t3 <= 57)) return (f(e10), 67108990)
                }
                return 22
              }
            }
          } else {
            var g2
            if ((8232 ^ x2) <= 1) {
              ;((o2 = (-5 & o2) | 1), u(e10))
              continue
            }
            let r2 = l(e10)
            if ((r2 > 0 && (x2 = r2), s(x2))) return ((e10.tokenValue = ''), z(e10, t2, 0, 0))
            if (
              160 === (g2 = x2) ||
              65279 === g2 ||
              133 === g2 ||
              5760 === g2 ||
              (g2 >= 8192 && g2 <= 8203) ||
              8239 === g2 ||
              8287 === g2 ||
              12288 === g2 ||
              8201 === g2 ||
              65519 === g2
            ) {
              f(e10)
              continue
            }
            e10.report(20, String.fromCodePoint(x2))
          }
        }
        return 1048576
      }
      let Z = {
          AElig: '\xC6',
          AMP: '&',
          Aacute: '\xC1',
          Abreve: '\u0102',
          Acirc: '\xC2',
          Acy: '\u0410',
          Afr: '\u{1D504}',
          Agrave: '\xC0',
          Alpha: '\u0391',
          Amacr: '\u0100',
          And: '\u2A53',
          Aogon: '\u0104',
          Aopf: '\u{1D538}',
          ApplyFunction: '\u2061',
          Aring: '\xC5',
          Ascr: '\u{1D49C}',
          Assign: '\u2254',
          Atilde: '\xC3',
          Auml: '\xC4',
          Backslash: '\u2216',
          Barv: '\u2AE7',
          Barwed: '\u2306',
          Bcy: '\u0411',
          Because: '\u2235',
          Bernoullis: '\u212C',
          Beta: '\u0392',
          Bfr: '\u{1D505}',
          Bopf: '\u{1D539}',
          Breve: '\u02D8',
          Bscr: '\u212C',
          Bumpeq: '\u224E',
          CHcy: '\u0427',
          COPY: '\xA9',
          Cacute: '\u0106',
          Cap: '\u22D2',
          CapitalDifferentialD: '\u2145',
          Cayleys: '\u212D',
          Ccaron: '\u010C',
          Ccedil: '\xC7',
          Ccirc: '\u0108',
          Cconint: '\u2230',
          Cdot: '\u010A',
          Cedilla: '\xB8',
          CenterDot: '\xB7',
          Cfr: '\u212D',
          Chi: '\u03A7',
          CircleDot: '\u2299',
          CircleMinus: '\u2296',
          CirclePlus: '\u2295',
          CircleTimes: '\u2297',
          ClockwiseContourIntegral: '\u2232',
          CloseCurlyDoubleQuote: '\u201D',
          CloseCurlyQuote: '\u2019',
          Colon: '\u2237',
          Colone: '\u2A74',
          Congruent: '\u2261',
          Conint: '\u222F',
          ContourIntegral: '\u222E',
          Copf: '\u2102',
          Coproduct: '\u2210',
          CounterClockwiseContourIntegral: '\u2233',
          Cross: '\u2A2F',
          Cscr: '\u{1D49E}',
          Cup: '\u22D3',
          CupCap: '\u224D',
          DD: '\u2145',
          DDotrahd: '\u2911',
          DJcy: '\u0402',
          DScy: '\u0405',
          DZcy: '\u040F',
          Dagger: '\u2021',
          Darr: '\u21A1',
          Dashv: '\u2AE4',
          Dcaron: '\u010E',
          Dcy: '\u0414',
          Del: '\u2207',
          Delta: '\u0394',
          Dfr: '\u{1D507}',
          DiacriticalAcute: '\xB4',
          DiacriticalDot: '\u02D9',
          DiacriticalDoubleAcute: '\u02DD',
          DiacriticalGrave: '`',
          DiacriticalTilde: '\u02DC',
          Diamond: '\u22C4',
          DifferentialD: '\u2146',
          Dopf: '\u{1D53B}',
          Dot: '\xA8',
          DotDot: '\u20DC',
          DotEqual: '\u2250',
          DoubleContourIntegral: '\u222F',
          DoubleDot: '\xA8',
          DoubleDownArrow: '\u21D3',
          DoubleLeftArrow: '\u21D0',
          DoubleLeftRightArrow: '\u21D4',
          DoubleLeftTee: '\u2AE4',
          DoubleLongLeftArrow: '\u27F8',
          DoubleLongLeftRightArrow: '\u27FA',
          DoubleLongRightArrow: '\u27F9',
          DoubleRightArrow: '\u21D2',
          DoubleRightTee: '\u22A8',
          DoubleUpArrow: '\u21D1',
          DoubleUpDownArrow: '\u21D5',
          DoubleVerticalBar: '\u2225',
          DownArrow: '\u2193',
          DownArrowBar: '\u2913',
          DownArrowUpArrow: '\u21F5',
          DownBreve: '\u0311',
          DownLeftRightVector: '\u2950',
          DownLeftTeeVector: '\u295E',
          DownLeftVector: '\u21BD',
          DownLeftVectorBar: '\u2956',
          DownRightTeeVector: '\u295F',
          DownRightVector: '\u21C1',
          DownRightVectorBar: '\u2957',
          DownTee: '\u22A4',
          DownTeeArrow: '\u21A7',
          Downarrow: '\u21D3',
          Dscr: '\u{1D49F}',
          Dstrok: '\u0110',
          ENG: '\u014A',
          ETH: '\xD0',
          Eacute: '\xC9',
          Ecaron: '\u011A',
          Ecirc: '\xCA',
          Ecy: '\u042D',
          Edot: '\u0116',
          Efr: '\u{1D508}',
          Egrave: '\xC8',
          Element: '\u2208',
          Emacr: '\u0112',
          EmptySmallSquare: '\u25FB',
          EmptyVerySmallSquare: '\u25AB',
          Eogon: '\u0118',
          Eopf: '\u{1D53C}',
          Epsilon: '\u0395',
          Equal: '\u2A75',
          EqualTilde: '\u2242',
          Equilibrium: '\u21CC',
          Escr: '\u2130',
          Esim: '\u2A73',
          Eta: '\u0397',
          Euml: '\xCB',
          Exists: '\u2203',
          ExponentialE: '\u2147',
          Fcy: '\u0424',
          Ffr: '\u{1D509}',
          FilledSmallSquare: '\u25FC',
          FilledVerySmallSquare: '\u25AA',
          Fopf: '\u{1D53D}',
          ForAll: '\u2200',
          Fouriertrf: '\u2131',
          Fscr: '\u2131',
          GJcy: '\u0403',
          GT: '>',
          Gamma: '\u0393',
          Gammad: '\u03DC',
          Gbreve: '\u011E',
          Gcedil: '\u0122',
          Gcirc: '\u011C',
          Gcy: '\u0413',
          Gdot: '\u0120',
          Gfr: '\u{1D50A}',
          Gg: '\u22D9',
          Gopf: '\u{1D53E}',
          GreaterEqual: '\u2265',
          GreaterEqualLess: '\u22DB',
          GreaterFullEqual: '\u2267',
          GreaterGreater: '\u2AA2',
          GreaterLess: '\u2277',
          GreaterSlantEqual: '\u2A7E',
          GreaterTilde: '\u2273',
          Gscr: '\u{1D4A2}',
          Gt: '\u226B',
          HARDcy: '\u042A',
          Hacek: '\u02C7',
          Hat: '^',
          Hcirc: '\u0124',
          Hfr: '\u210C',
          HilbertSpace: '\u210B',
          Hopf: '\u210D',
          HorizontalLine: '\u2500',
          Hscr: '\u210B',
          Hstrok: '\u0126',
          HumpDownHump: '\u224E',
          HumpEqual: '\u224F',
          IEcy: '\u0415',
          IJlig: '\u0132',
          IOcy: '\u0401',
          Iacute: '\xCD',
          Icirc: '\xCE',
          Icy: '\u0418',
          Idot: '\u0130',
          Ifr: '\u2111',
          Igrave: '\xCC',
          Im: '\u2111',
          Imacr: '\u012A',
          ImaginaryI: '\u2148',
          Implies: '\u21D2',
          Int: '\u222C',
          Integral: '\u222B',
          Intersection: '\u22C2',
          InvisibleComma: '\u2063',
          InvisibleTimes: '\u2062',
          Iogon: '\u012E',
          Iopf: '\u{1D540}',
          Iota: '\u0399',
          Iscr: '\u2110',
          Itilde: '\u0128',
          Iukcy: '\u0406',
          Iuml: '\xCF',
          Jcirc: '\u0134',
          Jcy: '\u0419',
          Jfr: '\u{1D50D}',
          Jopf: '\u{1D541}',
          Jscr: '\u{1D4A5}',
          Jsercy: '\u0408',
          Jukcy: '\u0404',
          KHcy: '\u0425',
          KJcy: '\u040C',
          Kappa: '\u039A',
          Kcedil: '\u0136',
          Kcy: '\u041A',
          Kfr: '\u{1D50E}',
          Kopf: '\u{1D542}',
          Kscr: '\u{1D4A6}',
          LJcy: '\u0409',
          LT: '<',
          Lacute: '\u0139',
          Lambda: '\u039B',
          Lang: '\u27EA',
          Laplacetrf: '\u2112',
          Larr: '\u219E',
          Lcaron: '\u013D',
          Lcedil: '\u013B',
          Lcy: '\u041B',
          LeftAngleBracket: '\u27E8',
          LeftArrow: '\u2190',
          LeftArrowBar: '\u21E4',
          LeftArrowRightArrow: '\u21C6',
          LeftCeiling: '\u2308',
          LeftDoubleBracket: '\u27E6',
          LeftDownTeeVector: '\u2961',
          LeftDownVector: '\u21C3',
          LeftDownVectorBar: '\u2959',
          LeftFloor: '\u230A',
          LeftRightArrow: '\u2194',
          LeftRightVector: '\u294E',
          LeftTee: '\u22A3',
          LeftTeeArrow: '\u21A4',
          LeftTeeVector: '\u295A',
          LeftTriangle: '\u22B2',
          LeftTriangleBar: '\u29CF',
          LeftTriangleEqual: '\u22B4',
          LeftUpDownVector: '\u2951',
          LeftUpTeeVector: '\u2960',
          LeftUpVector: '\u21BF',
          LeftUpVectorBar: '\u2958',
          LeftVector: '\u21BC',
          LeftVectorBar: '\u2952',
          Leftarrow: '\u21D0',
          Leftrightarrow: '\u21D4',
          LessEqualGreater: '\u22DA',
          LessFullEqual: '\u2266',
          LessGreater: '\u2276',
          LessLess: '\u2AA1',
          LessSlantEqual: '\u2A7D',
          LessTilde: '\u2272',
          Lfr: '\u{1D50F}',
          Ll: '\u22D8',
          Lleftarrow: '\u21DA',
          Lmidot: '\u013F',
          LongLeftArrow: '\u27F5',
          LongLeftRightArrow: '\u27F7',
          LongRightArrow: '\u27F6',
          Longleftarrow: '\u27F8',
          Longleftrightarrow: '\u27FA',
          Longrightarrow: '\u27F9',
          Lopf: '\u{1D543}',
          LowerLeftArrow: '\u2199',
          LowerRightArrow: '\u2198',
          Lscr: '\u2112',
          Lsh: '\u21B0',
          Lstrok: '\u0141',
          Lt: '\u226A',
          Map: '\u2905',
          Mcy: '\u041C',
          MediumSpace: '\u205F',
          Mellintrf: '\u2133',
          Mfr: '\u{1D510}',
          MinusPlus: '\u2213',
          Mopf: '\u{1D544}',
          Mscr: '\u2133',
          Mu: '\u039C',
          NJcy: '\u040A',
          Nacute: '\u0143',
          Ncaron: '\u0147',
          Ncedil: '\u0145',
          Ncy: '\u041D',
          NegativeMediumSpace: '\u200B',
          NegativeThickSpace: '\u200B',
          NegativeThinSpace: '\u200B',
          NegativeVeryThinSpace: '\u200B',
          NestedGreaterGreater: '\u226B',
          NestedLessLess: '\u226A',
          NewLine: '\n',
          Nfr: '\u{1D511}',
          NoBreak: '\u2060',
          NonBreakingSpace: '\xA0',
          Nopf: '\u2115',
          Not: '\u2AEC',
          NotCongruent: '\u2262',
          NotCupCap: '\u226D',
          NotDoubleVerticalBar: '\u2226',
          NotElement: '\u2209',
          NotEqual: '\u2260',
          NotEqualTilde: '\u2242\u0338',
          NotExists: '\u2204',
          NotGreater: '\u226F',
          NotGreaterEqual: '\u2271',
          NotGreaterFullEqual: '\u2267\u0338',
          NotGreaterGreater: '\u226B\u0338',
          NotGreaterLess: '\u2279',
          NotGreaterSlantEqual: '\u2A7E\u0338',
          NotGreaterTilde: '\u2275',
          NotHumpDownHump: '\u224E\u0338',
          NotHumpEqual: '\u224F\u0338',
          NotLeftTriangle: '\u22EA',
          NotLeftTriangleBar: '\u29CF\u0338',
          NotLeftTriangleEqual: '\u22EC',
          NotLess: '\u226E',
          NotLessEqual: '\u2270',
          NotLessGreater: '\u2278',
          NotLessLess: '\u226A\u0338',
          NotLessSlantEqual: '\u2A7D\u0338',
          NotLessTilde: '\u2274',
          NotNestedGreaterGreater: '\u2AA2\u0338',
          NotNestedLessLess: '\u2AA1\u0338',
          NotPrecedes: '\u2280',
          NotPrecedesEqual: '\u2AAF\u0338',
          NotPrecedesSlantEqual: '\u22E0',
          NotReverseElement: '\u220C',
          NotRightTriangle: '\u22EB',
          NotRightTriangleBar: '\u29D0\u0338',
          NotRightTriangleEqual: '\u22ED',
          NotSquareSubset: '\u228F\u0338',
          NotSquareSubsetEqual: '\u22E2',
          NotSquareSuperset: '\u2290\u0338',
          NotSquareSupersetEqual: '\u22E3',
          NotSubset: '\u2282\u20D2',
          NotSubsetEqual: '\u2288',
          NotSucceeds: '\u2281',
          NotSucceedsEqual: '\u2AB0\u0338',
          NotSucceedsSlantEqual: '\u22E1',
          NotSucceedsTilde: '\u227F\u0338',
          NotSuperset: '\u2283\u20D2',
          NotSupersetEqual: '\u2289',
          NotTilde: '\u2241',
          NotTildeEqual: '\u2244',
          NotTildeFullEqual: '\u2247',
          NotTildeTilde: '\u2249',
          NotVerticalBar: '\u2224',
          Nscr: '\u{1D4A9}',
          Ntilde: '\xD1',
          Nu: '\u039D',
          OElig: '\u0152',
          Oacute: '\xD3',
          Ocirc: '\xD4',
          Ocy: '\u041E',
          Odblac: '\u0150',
          Ofr: '\u{1D512}',
          Ograve: '\xD2',
          Omacr: '\u014C',
          Omega: '\u03A9',
          Omicron: '\u039F',
          Oopf: '\u{1D546}',
          OpenCurlyDoubleQuote: '\u201C',
          OpenCurlyQuote: '\u2018',
          Or: '\u2A54',
          Oscr: '\u{1D4AA}',
          Oslash: '\xD8',
          Otilde: '\xD5',
          Otimes: '\u2A37',
          Ouml: '\xD6',
          OverBar: '\u203E',
          OverBrace: '\u23DE',
          OverBracket: '\u23B4',
          OverParenthesis: '\u23DC',
          PartialD: '\u2202',
          Pcy: '\u041F',
          Pfr: '\u{1D513}',
          Phi: '\u03A6',
          Pi: '\u03A0',
          PlusMinus: '\xB1',
          Poincareplane: '\u210C',
          Popf: '\u2119',
          Pr: '\u2ABB',
          Precedes: '\u227A',
          PrecedesEqual: '\u2AAF',
          PrecedesSlantEqual: '\u227C',
          PrecedesTilde: '\u227E',
          Prime: '\u2033',
          Product: '\u220F',
          Proportion: '\u2237',
          Proportional: '\u221D',
          Pscr: '\u{1D4AB}',
          Psi: '\u03A8',
          QUOT: '"',
          Qfr: '\u{1D514}',
          Qopf: '\u211A',
          Qscr: '\u{1D4AC}',
          RBarr: '\u2910',
          REG: '\xAE',
          Racute: '\u0154',
          Rang: '\u27EB',
          Rarr: '\u21A0',
          Rarrtl: '\u2916',
          Rcaron: '\u0158',
          Rcedil: '\u0156',
          Rcy: '\u0420',
          Re: '\u211C',
          ReverseElement: '\u220B',
          ReverseEquilibrium: '\u21CB',
          ReverseUpEquilibrium: '\u296F',
          Rfr: '\u211C',
          Rho: '\u03A1',
          RightAngleBracket: '\u27E9',
          RightArrow: '\u2192',
          RightArrowBar: '\u21E5',
          RightArrowLeftArrow: '\u21C4',
          RightCeiling: '\u2309',
          RightDoubleBracket: '\u27E7',
          RightDownTeeVector: '\u295D',
          RightDownVector: '\u21C2',
          RightDownVectorBar: '\u2955',
          RightFloor: '\u230B',
          RightTee: '\u22A2',
          RightTeeArrow: '\u21A6',
          RightTeeVector: '\u295B',
          RightTriangle: '\u22B3',
          RightTriangleBar: '\u29D0',
          RightTriangleEqual: '\u22B5',
          RightUpDownVector: '\u294F',
          RightUpTeeVector: '\u295C',
          RightUpVector: '\u21BE',
          RightUpVectorBar: '\u2954',
          RightVector: '\u21C0',
          RightVectorBar: '\u2953',
          Rightarrow: '\u21D2',
          Ropf: '\u211D',
          RoundImplies: '\u2970',
          Rrightarrow: '\u21DB',
          Rscr: '\u211B',
          Rsh: '\u21B1',
          RuleDelayed: '\u29F4',
          SHCHcy: '\u0429',
          SHcy: '\u0428',
          SOFTcy: '\u042C',
          Sacute: '\u015A',
          Sc: '\u2ABC',
          Scaron: '\u0160',
          Scedil: '\u015E',
          Scirc: '\u015C',
          Scy: '\u0421',
          Sfr: '\u{1D516}',
          ShortDownArrow: '\u2193',
          ShortLeftArrow: '\u2190',
          ShortRightArrow: '\u2192',
          ShortUpArrow: '\u2191',
          Sigma: '\u03A3',
          SmallCircle: '\u2218',
          Sopf: '\u{1D54A}',
          Sqrt: '\u221A',
          Square: '\u25A1',
          SquareIntersection: '\u2293',
          SquareSubset: '\u228F',
          SquareSubsetEqual: '\u2291',
          SquareSuperset: '\u2290',
          SquareSupersetEqual: '\u2292',
          SquareUnion: '\u2294',
          Sscr: '\u{1D4AE}',
          Star: '\u22C6',
          Sub: '\u22D0',
          Subset: '\u22D0',
          SubsetEqual: '\u2286',
          Succeeds: '\u227B',
          SucceedsEqual: '\u2AB0',
          SucceedsSlantEqual: '\u227D',
          SucceedsTilde: '\u227F',
          SuchThat: '\u220B',
          Sum: '\u2211',
          Sup: '\u22D1',
          Superset: '\u2283',
          SupersetEqual: '\u2287',
          Supset: '\u22D1',
          THORN: '\xDE',
          TRADE: '\u2122',
          TSHcy: '\u040B',
          TScy: '\u0426',
          Tab: '	',
          Tau: '\u03A4',
          Tcaron: '\u0164',
          Tcedil: '\u0162',
          Tcy: '\u0422',
          Tfr: '\u{1D517}',
          Therefore: '\u2234',
          Theta: '\u0398',
          ThickSpace: '\u205F\u200A',
          ThinSpace: '\u2009',
          Tilde: '\u223C',
          TildeEqual: '\u2243',
          TildeFullEqual: '\u2245',
          TildeTilde: '\u2248',
          Topf: '\u{1D54B}',
          TripleDot: '\u20DB',
          Tscr: '\u{1D4AF}',
          Tstrok: '\u0166',
          Uacute: '\xDA',
          Uarr: '\u219F',
          Uarrocir: '\u2949',
          Ubrcy: '\u040E',
          Ubreve: '\u016C',
          Ucirc: '\xDB',
          Ucy: '\u0423',
          Udblac: '\u0170',
          Ufr: '\u{1D518}',
          Ugrave: '\xD9',
          Umacr: '\u016A',
          UnderBar: '_',
          UnderBrace: '\u23DF',
          UnderBracket: '\u23B5',
          UnderParenthesis: '\u23DD',
          Union: '\u22C3',
          UnionPlus: '\u228E',
          Uogon: '\u0172',
          Uopf: '\u{1D54C}',
          UpArrow: '\u2191',
          UpArrowBar: '\u2912',
          UpArrowDownArrow: '\u21C5',
          UpDownArrow: '\u2195',
          UpEquilibrium: '\u296E',
          UpTee: '\u22A5',
          UpTeeArrow: '\u21A5',
          Uparrow: '\u21D1',
          Updownarrow: '\u21D5',
          UpperLeftArrow: '\u2196',
          UpperRightArrow: '\u2197',
          Upsi: '\u03D2',
          Upsilon: '\u03A5',
          Uring: '\u016E',
          Uscr: '\u{1D4B0}',
          Utilde: '\u0168',
          Uuml: '\xDC',
          VDash: '\u22AB',
          Vbar: '\u2AEB',
          Vcy: '\u0412',
          Vdash: '\u22A9',
          Vdashl: '\u2AE6',
          Vee: '\u22C1',
          Verbar: '\u2016',
          Vert: '\u2016',
          VerticalBar: '\u2223',
          VerticalLine: '|',
          VerticalSeparator: '\u2758',
          VerticalTilde: '\u2240',
          VeryThinSpace: '\u200A',
          Vfr: '\u{1D519}',
          Vopf: '\u{1D54D}',
          Vscr: '\u{1D4B1}',
          Vvdash: '\u22AA',
          Wcirc: '\u0174',
          Wedge: '\u22C0',
          Wfr: '\u{1D51A}',
          Wopf: '\u{1D54E}',
          Wscr: '\u{1D4B2}',
          Xfr: '\u{1D51B}',
          Xi: '\u039E',
          Xopf: '\u{1D54F}',
          Xscr: '\u{1D4B3}',
          YAcy: '\u042F',
          YIcy: '\u0407',
          YUcy: '\u042E',
          Yacute: '\xDD',
          Ycirc: '\u0176',
          Ycy: '\u042B',
          Yfr: '\u{1D51C}',
          Yopf: '\u{1D550}',
          Yscr: '\u{1D4B4}',
          Yuml: '\u0178',
          ZHcy: '\u0416',
          Zacute: '\u0179',
          Zcaron: '\u017D',
          Zcy: '\u0417',
          Zdot: '\u017B',
          ZeroWidthSpace: '\u200B',
          Zeta: '\u0396',
          Zfr: '\u2128',
          Zopf: '\u2124',
          Zscr: '\u{1D4B5}',
          aacute: '\xE1',
          abreve: '\u0103',
          ac: '\u223E',
          acE: '\u223E\u0333',
          acd: '\u223F',
          acirc: '\xE2',
          acute: '\xB4',
          acy: '\u0430',
          aelig: '\xE6',
          af: '\u2061',
          afr: '\u{1D51E}',
          agrave: '\xE0',
          alefsym: '\u2135',
          aleph: '\u2135',
          alpha: '\u03B1',
          amacr: '\u0101',
          amalg: '\u2A3F',
          amp: '&',
          and: '\u2227',
          andand: '\u2A55',
          andd: '\u2A5C',
          andslope: '\u2A58',
          andv: '\u2A5A',
          ang: '\u2220',
          ange: '\u29A4',
          angle: '\u2220',
          angmsd: '\u2221',
          angmsdaa: '\u29A8',
          angmsdab: '\u29A9',
          angmsdac: '\u29AA',
          angmsdad: '\u29AB',
          angmsdae: '\u29AC',
          angmsdaf: '\u29AD',
          angmsdag: '\u29AE',
          angmsdah: '\u29AF',
          angrt: '\u221F',
          angrtvb: '\u22BE',
          angrtvbd: '\u299D',
          angsph: '\u2222',
          angst: '\xC5',
          angzarr: '\u237C',
          aogon: '\u0105',
          aopf: '\u{1D552}',
          ap: '\u2248',
          apE: '\u2A70',
          apacir: '\u2A6F',
          ape: '\u224A',
          apid: '\u224B',
          apos: "'",
          approx: '\u2248',
          approxeq: '\u224A',
          aring: '\xE5',
          ascr: '\u{1D4B6}',
          ast: '*',
          asymp: '\u2248',
          asympeq: '\u224D',
          atilde: '\xE3',
          auml: '\xE4',
          awconint: '\u2233',
          awint: '\u2A11',
          bNot: '\u2AED',
          backcong: '\u224C',
          backepsilon: '\u03F6',
          backprime: '\u2035',
          backsim: '\u223D',
          backsimeq: '\u22CD',
          barvee: '\u22BD',
          barwed: '\u2305',
          barwedge: '\u2305',
          bbrk: '\u23B5',
          bbrktbrk: '\u23B6',
          bcong: '\u224C',
          bcy: '\u0431',
          bdquo: '\u201E',
          becaus: '\u2235',
          because: '\u2235',
          bemptyv: '\u29B0',
          bepsi: '\u03F6',
          bernou: '\u212C',
          beta: '\u03B2',
          beth: '\u2136',
          between: '\u226C',
          bfr: '\u{1D51F}',
          bigcap: '\u22C2',
          bigcirc: '\u25EF',
          bigcup: '\u22C3',
          bigodot: '\u2A00',
          bigoplus: '\u2A01',
          bigotimes: '\u2A02',
          bigsqcup: '\u2A06',
          bigstar: '\u2605',
          bigtriangledown: '\u25BD',
          bigtriangleup: '\u25B3',
          biguplus: '\u2A04',
          bigvee: '\u22C1',
          bigwedge: '\u22C0',
          bkarow: '\u290D',
          blacklozenge: '\u29EB',
          blacksquare: '\u25AA',
          blacktriangle: '\u25B4',
          blacktriangledown: '\u25BE',
          blacktriangleleft: '\u25C2',
          blacktriangleright: '\u25B8',
          blank: '\u2423',
          blk12: '\u2592',
          blk14: '\u2591',
          blk34: '\u2593',
          block: '\u2588',
          bne: '=\u20E5',
          bnequiv: '\u2261\u20E5',
          bnot: '\u2310',
          bopf: '\u{1D553}',
          bot: '\u22A5',
          bottom: '\u22A5',
          bowtie: '\u22C8',
          boxDL: '\u2557',
          boxDR: '\u2554',
          boxDl: '\u2556',
          boxDr: '\u2553',
          boxH: '\u2550',
          boxHD: '\u2566',
          boxHU: '\u2569',
          boxHd: '\u2564',
          boxHu: '\u2567',
          boxUL: '\u255D',
          boxUR: '\u255A',
          boxUl: '\u255C',
          boxUr: '\u2559',
          boxV: '\u2551',
          boxVH: '\u256C',
          boxVL: '\u2563',
          boxVR: '\u2560',
          boxVh: '\u256B',
          boxVl: '\u2562',
          boxVr: '\u255F',
          boxbox: '\u29C9',
          boxdL: '\u2555',
          boxdR: '\u2552',
          boxdl: '\u2510',
          boxdr: '\u250C',
          boxh: '\u2500',
          boxhD: '\u2565',
          boxhU: '\u2568',
          boxhd: '\u252C',
          boxhu: '\u2534',
          boxminus: '\u229F',
          boxplus: '\u229E',
          boxtimes: '\u22A0',
          boxuL: '\u255B',
          boxuR: '\u2558',
          boxul: '\u2518',
          boxur: '\u2514',
          boxv: '\u2502',
          boxvH: '\u256A',
          boxvL: '\u2561',
          boxvR: '\u255E',
          boxvh: '\u253C',
          boxvl: '\u2524',
          boxvr: '\u251C',
          bprime: '\u2035',
          breve: '\u02D8',
          brvbar: '\xA6',
          bscr: '\u{1D4B7}',
          bsemi: '\u204F',
          bsim: '\u223D',
          bsime: '\u22CD',
          bsol: '\\',
          bsolb: '\u29C5',
          bsolhsub: '\u27C8',
          bull: '\u2022',
          bullet: '\u2022',
          bump: '\u224E',
          bumpE: '\u2AAE',
          bumpe: '\u224F',
          bumpeq: '\u224F',
          cacute: '\u0107',
          cap: '\u2229',
          capand: '\u2A44',
          capbrcup: '\u2A49',
          capcap: '\u2A4B',
          capcup: '\u2A47',
          capdot: '\u2A40',
          caps: '\u2229\uFE00',
          caret: '\u2041',
          caron: '\u02C7',
          ccaps: '\u2A4D',
          ccaron: '\u010D',
          ccedil: '\xE7',
          ccirc: '\u0109',
          ccups: '\u2A4C',
          ccupssm: '\u2A50',
          cdot: '\u010B',
          cedil: '\xB8',
          cemptyv: '\u29B2',
          cent: '\xA2',
          centerdot: '\xB7',
          cfr: '\u{1D520}',
          chcy: '\u0447',
          check: '\u2713',
          checkmark: '\u2713',
          chi: '\u03C7',
          cir: '\u25CB',
          cirE: '\u29C3',
          circ: '\u02C6',
          circeq: '\u2257',
          circlearrowleft: '\u21BA',
          circlearrowright: '\u21BB',
          circledR: '\xAE',
          circledS: '\u24C8',
          circledast: '\u229B',
          circledcirc: '\u229A',
          circleddash: '\u229D',
          cire: '\u2257',
          cirfnint: '\u2A10',
          cirmid: '\u2AEF',
          cirscir: '\u29C2',
          clubs: '\u2663',
          clubsuit: '\u2663',
          colon: ':',
          colone: '\u2254',
          coloneq: '\u2254',
          comma: ',',
          commat: '@',
          comp: '\u2201',
          compfn: '\u2218',
          complement: '\u2201',
          complexes: '\u2102',
          cong: '\u2245',
          congdot: '\u2A6D',
          conint: '\u222E',
          copf: '\u{1D554}',
          coprod: '\u2210',
          copy: '\xA9',
          copysr: '\u2117',
          crarr: '\u21B5',
          cross: '\u2717',
          cscr: '\u{1D4B8}',
          csub: '\u2ACF',
          csube: '\u2AD1',
          csup: '\u2AD0',
          csupe: '\u2AD2',
          ctdot: '\u22EF',
          cudarrl: '\u2938',
          cudarrr: '\u2935',
          cuepr: '\u22DE',
          cuesc: '\u22DF',
          cularr: '\u21B6',
          cularrp: '\u293D',
          cup: '\u222A',
          cupbrcap: '\u2A48',
          cupcap: '\u2A46',
          cupcup: '\u2A4A',
          cupdot: '\u228D',
          cupor: '\u2A45',
          cups: '\u222A\uFE00',
          curarr: '\u21B7',
          curarrm: '\u293C',
          curlyeqprec: '\u22DE',
          curlyeqsucc: '\u22DF',
          curlyvee: '\u22CE',
          curlywedge: '\u22CF',
          curren: '\xA4',
          curvearrowleft: '\u21B6',
          curvearrowright: '\u21B7',
          cuvee: '\u22CE',
          cuwed: '\u22CF',
          cwconint: '\u2232',
          cwint: '\u2231',
          cylcty: '\u232D',
          dArr: '\u21D3',
          dHar: '\u2965',
          dagger: '\u2020',
          daleth: '\u2138',
          darr: '\u2193',
          dash: '\u2010',
          dashv: '\u22A3',
          dbkarow: '\u290F',
          dblac: '\u02DD',
          dcaron: '\u010F',
          dcy: '\u0434',
          dd: '\u2146',
          ddagger: '\u2021',
          ddarr: '\u21CA',
          ddotseq: '\u2A77',
          deg: '\xB0',
          delta: '\u03B4',
          demptyv: '\u29B1',
          dfisht: '\u297F',
          dfr: '\u{1D521}',
          dharl: '\u21C3',
          dharr: '\u21C2',
          diam: '\u22C4',
          diamond: '\u22C4',
          diamondsuit: '\u2666',
          diams: '\u2666',
          die: '\xA8',
          digamma: '\u03DD',
          disin: '\u22F2',
          div: '\xF7',
          divide: '\xF7',
          divideontimes: '\u22C7',
          divonx: '\u22C7',
          djcy: '\u0452',
          dlcorn: '\u231E',
          dlcrop: '\u230D',
          dollar: '$',
          dopf: '\u{1D555}',
          dot: '\u02D9',
          doteq: '\u2250',
          doteqdot: '\u2251',
          dotminus: '\u2238',
          dotplus: '\u2214',
          dotsquare: '\u22A1',
          doublebarwedge: '\u2306',
          downarrow: '\u2193',
          downdownarrows: '\u21CA',
          downharpoonleft: '\u21C3',
          downharpoonright: '\u21C2',
          drbkarow: '\u2910',
          drcorn: '\u231F',
          drcrop: '\u230C',
          dscr: '\u{1D4B9}',
          dscy: '\u0455',
          dsol: '\u29F6',
          dstrok: '\u0111',
          dtdot: '\u22F1',
          dtri: '\u25BF',
          dtrif: '\u25BE',
          duarr: '\u21F5',
          duhar: '\u296F',
          dwangle: '\u29A6',
          dzcy: '\u045F',
          dzigrarr: '\u27FF',
          eDDot: '\u2A77',
          eDot: '\u2251',
          eacute: '\xE9',
          easter: '\u2A6E',
          ecaron: '\u011B',
          ecir: '\u2256',
          ecirc: '\xEA',
          ecolon: '\u2255',
          ecy: '\u044D',
          edot: '\u0117',
          ee: '\u2147',
          efDot: '\u2252',
          efr: '\u{1D522}',
          eg: '\u2A9A',
          egrave: '\xE8',
          egs: '\u2A96',
          egsdot: '\u2A98',
          el: '\u2A99',
          elinters: '\u23E7',
          ell: '\u2113',
          els: '\u2A95',
          elsdot: '\u2A97',
          emacr: '\u0113',
          empty: '\u2205',
          emptyset: '\u2205',
          emptyv: '\u2205',
          emsp13: '\u2004',
          emsp14: '\u2005',
          emsp: '\u2003',
          eng: '\u014B',
          ensp: '\u2002',
          eogon: '\u0119',
          eopf: '\u{1D556}',
          epar: '\u22D5',
          eparsl: '\u29E3',
          eplus: '\u2A71',
          epsi: '\u03B5',
          epsilon: '\u03B5',
          epsiv: '\u03F5',
          eqcirc: '\u2256',
          eqcolon: '\u2255',
          eqsim: '\u2242',
          eqslantgtr: '\u2A96',
          eqslantless: '\u2A95',
          equals: '=',
          equest: '\u225F',
          equiv: '\u2261',
          equivDD: '\u2A78',
          eqvparsl: '\u29E5',
          erDot: '\u2253',
          erarr: '\u2971',
          escr: '\u212F',
          esdot: '\u2250',
          esim: '\u2242',
          eta: '\u03B7',
          eth: '\xF0',
          euml: '\xEB',
          euro: '\u20AC',
          excl: '!',
          exist: '\u2203',
          expectation: '\u2130',
          exponentiale: '\u2147',
          fallingdotseq: '\u2252',
          fcy: '\u0444',
          female: '\u2640',
          ffilig: '\uFB03',
          fflig: '\uFB00',
          ffllig: '\uFB04',
          ffr: '\u{1D523}',
          filig: '\uFB01',
          fjlig: 'fj',
          flat: '\u266D',
          fllig: '\uFB02',
          fltns: '\u25B1',
          fnof: '\u0192',
          fopf: '\u{1D557}',
          forall: '\u2200',
          fork: '\u22D4',
          forkv: '\u2AD9',
          fpartint: '\u2A0D',
          frac12: '\xBD',
          frac13: '\u2153',
          frac14: '\xBC',
          frac15: '\u2155',
          frac16: '\u2159',
          frac18: '\u215B',
          frac23: '\u2154',
          frac25: '\u2156',
          frac34: '\xBE',
          frac35: '\u2157',
          frac38: '\u215C',
          frac45: '\u2158',
          frac56: '\u215A',
          frac58: '\u215D',
          frac78: '\u215E',
          frasl: '\u2044',
          frown: '\u2322',
          fscr: '\u{1D4BB}',
          gE: '\u2267',
          gEl: '\u2A8C',
          gacute: '\u01F5',
          gamma: '\u03B3',
          gammad: '\u03DD',
          gap: '\u2A86',
          gbreve: '\u011F',
          gcirc: '\u011D',
          gcy: '\u0433',
          gdot: '\u0121',
          ge: '\u2265',
          gel: '\u22DB',
          geq: '\u2265',
          geqq: '\u2267',
          geqslant: '\u2A7E',
          ges: '\u2A7E',
          gescc: '\u2AA9',
          gesdot: '\u2A80',
          gesdoto: '\u2A82',
          gesdotol: '\u2A84',
          gesl: '\u22DB\uFE00',
          gesles: '\u2A94',
          gfr: '\u{1D524}',
          gg: '\u226B',
          ggg: '\u22D9',
          gimel: '\u2137',
          gjcy: '\u0453',
          gl: '\u2277',
          glE: '\u2A92',
          gla: '\u2AA5',
          glj: '\u2AA4',
          gnE: '\u2269',
          gnap: '\u2A8A',
          gnapprox: '\u2A8A',
          gne: '\u2A88',
          gneq: '\u2A88',
          gneqq: '\u2269',
          gnsim: '\u22E7',
          gopf: '\u{1D558}',
          grave: '`',
          gscr: '\u210A',
          gsim: '\u2273',
          gsime: '\u2A8E',
          gsiml: '\u2A90',
          gt: '>',
          gtcc: '\u2AA7',
          gtcir: '\u2A7A',
          gtdot: '\u22D7',
          gtlPar: '\u2995',
          gtquest: '\u2A7C',
          gtrapprox: '\u2A86',
          gtrarr: '\u2978',
          gtrdot: '\u22D7',
          gtreqless: '\u22DB',
          gtreqqless: '\u2A8C',
          gtrless: '\u2277',
          gtrsim: '\u2273',
          gvertneqq: '\u2269\uFE00',
          gvnE: '\u2269\uFE00',
          hArr: '\u21D4',
          hairsp: '\u200A',
          half: '\xBD',
          hamilt: '\u210B',
          hardcy: '\u044A',
          harr: '\u2194',
          harrcir: '\u2948',
          harrw: '\u21AD',
          hbar: '\u210F',
          hcirc: '\u0125',
          hearts: '\u2665',
          heartsuit: '\u2665',
          hellip: '\u2026',
          hercon: '\u22B9',
          hfr: '\u{1D525}',
          hksearow: '\u2925',
          hkswarow: '\u2926',
          hoarr: '\u21FF',
          homtht: '\u223B',
          hookleftarrow: '\u21A9',
          hookrightarrow: '\u21AA',
          hopf: '\u{1D559}',
          horbar: '\u2015',
          hscr: '\u{1D4BD}',
          hslash: '\u210F',
          hstrok: '\u0127',
          hybull: '\u2043',
          hyphen: '\u2010',
          iacute: '\xED',
          ic: '\u2063',
          icirc: '\xEE',
          icy: '\u0438',
          iecy: '\u0435',
          iexcl: '\xA1',
          iff: '\u21D4',
          ifr: '\u{1D526}',
          igrave: '\xEC',
          ii: '\u2148',
          iiiint: '\u2A0C',
          iiint: '\u222D',
          iinfin: '\u29DC',
          iiota: '\u2129',
          ijlig: '\u0133',
          imacr: '\u012B',
          image: '\u2111',
          imagline: '\u2110',
          imagpart: '\u2111',
          imath: '\u0131',
          imof: '\u22B7',
          imped: '\u01B5',
          in: '\u2208',
          incare: '\u2105',
          infin: '\u221E',
          infintie: '\u29DD',
          inodot: '\u0131',
          int: '\u222B',
          intcal: '\u22BA',
          integers: '\u2124',
          intercal: '\u22BA',
          intlarhk: '\u2A17',
          intprod: '\u2A3C',
          iocy: '\u0451',
          iogon: '\u012F',
          iopf: '\u{1D55A}',
          iota: '\u03B9',
          iprod: '\u2A3C',
          iquest: '\xBF',
          iscr: '\u{1D4BE}',
          isin: '\u2208',
          isinE: '\u22F9',
          isindot: '\u22F5',
          isins: '\u22F4',
          isinsv: '\u22F3',
          isinv: '\u2208',
          it: '\u2062',
          itilde: '\u0129',
          iukcy: '\u0456',
          iuml: '\xEF',
          jcirc: '\u0135',
          jcy: '\u0439',
          jfr: '\u{1D527}',
          jmath: '\u0237',
          jopf: '\u{1D55B}',
          jscr: '\u{1D4BF}',
          jsercy: '\u0458',
          jukcy: '\u0454',
          kappa: '\u03BA',
          kappav: '\u03F0',
          kcedil: '\u0137',
          kcy: '\u043A',
          kfr: '\u{1D528}',
          kgreen: '\u0138',
          khcy: '\u0445',
          kjcy: '\u045C',
          kopf: '\u{1D55C}',
          kscr: '\u{1D4C0}',
          lAarr: '\u21DA',
          lArr: '\u21D0',
          lAtail: '\u291B',
          lBarr: '\u290E',
          lE: '\u2266',
          lEg: '\u2A8B',
          lHar: '\u2962',
          lacute: '\u013A',
          laemptyv: '\u29B4',
          lagran: '\u2112',
          lambda: '\u03BB',
          lang: '\u27E8',
          langd: '\u2991',
          langle: '\u27E8',
          lap: '\u2A85',
          laquo: '\xAB',
          larr: '\u2190',
          larrb: '\u21E4',
          larrbfs: '\u291F',
          larrfs: '\u291D',
          larrhk: '\u21A9',
          larrlp: '\u21AB',
          larrpl: '\u2939',
          larrsim: '\u2973',
          larrtl: '\u21A2',
          lat: '\u2AAB',
          latail: '\u2919',
          late: '\u2AAD',
          lates: '\u2AAD\uFE00',
          lbarr: '\u290C',
          lbbrk: '\u2772',
          lbrace: '{',
          lbrack: '[',
          lbrke: '\u298B',
          lbrksld: '\u298F',
          lbrkslu: '\u298D',
          lcaron: '\u013E',
          lcedil: '\u013C',
          lceil: '\u2308',
          lcub: '{',
          lcy: '\u043B',
          ldca: '\u2936',
          ldquo: '\u201C',
          ldquor: '\u201E',
          ldrdhar: '\u2967',
          ldrushar: '\u294B',
          ldsh: '\u21B2',
          le: '\u2264',
          leftarrow: '\u2190',
          leftarrowtail: '\u21A2',
          leftharpoondown: '\u21BD',
          leftharpoonup: '\u21BC',
          leftleftarrows: '\u21C7',
          leftrightarrow: '\u2194',
          leftrightarrows: '\u21C6',
          leftrightharpoons: '\u21CB',
          leftrightsquigarrow: '\u21AD',
          leftthreetimes: '\u22CB',
          leg: '\u22DA',
          leq: '\u2264',
          leqq: '\u2266',
          leqslant: '\u2A7D',
          les: '\u2A7D',
          lescc: '\u2AA8',
          lesdot: '\u2A7F',
          lesdoto: '\u2A81',
          lesdotor: '\u2A83',
          lesg: '\u22DA\uFE00',
          lesges: '\u2A93',
          lessapprox: '\u2A85',
          lessdot: '\u22D6',
          lesseqgtr: '\u22DA',
          lesseqqgtr: '\u2A8B',
          lessgtr: '\u2276',
          lesssim: '\u2272',
          lfisht: '\u297C',
          lfloor: '\u230A',
          lfr: '\u{1D529}',
          lg: '\u2276',
          lgE: '\u2A91',
          lhard: '\u21BD',
          lharu: '\u21BC',
          lharul: '\u296A',
          lhblk: '\u2584',
          ljcy: '\u0459',
          ll: '\u226A',
          llarr: '\u21C7',
          llcorner: '\u231E',
          llhard: '\u296B',
          lltri: '\u25FA',
          lmidot: '\u0140',
          lmoust: '\u23B0',
          lmoustache: '\u23B0',
          lnE: '\u2268',
          lnap: '\u2A89',
          lnapprox: '\u2A89',
          lne: '\u2A87',
          lneq: '\u2A87',
          lneqq: '\u2268',
          lnsim: '\u22E6',
          loang: '\u27EC',
          loarr: '\u21FD',
          lobrk: '\u27E6',
          longleftarrow: '\u27F5',
          longleftrightarrow: '\u27F7',
          longmapsto: '\u27FC',
          longrightarrow: '\u27F6',
          looparrowleft: '\u21AB',
          looparrowright: '\u21AC',
          lopar: '\u2985',
          lopf: '\u{1D55D}',
          loplus: '\u2A2D',
          lotimes: '\u2A34',
          lowast: '\u2217',
          lowbar: '_',
          loz: '\u25CA',
          lozenge: '\u25CA',
          lozf: '\u29EB',
          lpar: '(',
          lparlt: '\u2993',
          lrarr: '\u21C6',
          lrcorner: '\u231F',
          lrhar: '\u21CB',
          lrhard: '\u296D',
          lrm: '\u200E',
          lrtri: '\u22BF',
          lsaquo: '\u2039',
          lscr: '\u{1D4C1}',
          lsh: '\u21B0',
          lsim: '\u2272',
          lsime: '\u2A8D',
          lsimg: '\u2A8F',
          lsqb: '[',
          lsquo: '\u2018',
          lsquor: '\u201A',
          lstrok: '\u0142',
          lt: '<',
          ltcc: '\u2AA6',
          ltcir: '\u2A79',
          ltdot: '\u22D6',
          lthree: '\u22CB',
          ltimes: '\u22C9',
          ltlarr: '\u2976',
          ltquest: '\u2A7B',
          ltrPar: '\u2996',
          ltri: '\u25C3',
          ltrie: '\u22B4',
          ltrif: '\u25C2',
          lurdshar: '\u294A',
          luruhar: '\u2966',
          lvertneqq: '\u2268\uFE00',
          lvnE: '\u2268\uFE00',
          mDDot: '\u223A',
          macr: '\xAF',
          male: '\u2642',
          malt: '\u2720',
          maltese: '\u2720',
          map: '\u21A6',
          mapsto: '\u21A6',
          mapstodown: '\u21A7',
          mapstoleft: '\u21A4',
          mapstoup: '\u21A5',
          marker: '\u25AE',
          mcomma: '\u2A29',
          mcy: '\u043C',
          mdash: '\u2014',
          measuredangle: '\u2221',
          mfr: '\u{1D52A}',
          mho: '\u2127',
          micro: '\xB5',
          mid: '\u2223',
          midast: '*',
          midcir: '\u2AF0',
          middot: '\xB7',
          minus: '\u2212',
          minusb: '\u229F',
          minusd: '\u2238',
          minusdu: '\u2A2A',
          mlcp: '\u2ADB',
          mldr: '\u2026',
          mnplus: '\u2213',
          models: '\u22A7',
          mopf: '\u{1D55E}',
          mp: '\u2213',
          mscr: '\u{1D4C2}',
          mstpos: '\u223E',
          mu: '\u03BC',
          multimap: '\u22B8',
          mumap: '\u22B8',
          nGg: '\u22D9\u0338',
          nGt: '\u226B\u20D2',
          nGtv: '\u226B\u0338',
          nLeftarrow: '\u21CD',
          nLeftrightarrow: '\u21CE',
          nLl: '\u22D8\u0338',
          nLt: '\u226A\u20D2',
          nLtv: '\u226A\u0338',
          nRightarrow: '\u21CF',
          nVDash: '\u22AF',
          nVdash: '\u22AE',
          nabla: '\u2207',
          nacute: '\u0144',
          nang: '\u2220\u20D2',
          nap: '\u2249',
          napE: '\u2A70\u0338',
          napid: '\u224B\u0338',
          napos: '\u0149',
          napprox: '\u2249',
          natur: '\u266E',
          natural: '\u266E',
          naturals: '\u2115',
          nbsp: '\xA0',
          nbump: '\u224E\u0338',
          nbumpe: '\u224F\u0338',
          ncap: '\u2A43',
          ncaron: '\u0148',
          ncedil: '\u0146',
          ncong: '\u2247',
          ncongdot: '\u2A6D\u0338',
          ncup: '\u2A42',
          ncy: '\u043D',
          ndash: '\u2013',
          ne: '\u2260',
          neArr: '\u21D7',
          nearhk: '\u2924',
          nearr: '\u2197',
          nearrow: '\u2197',
          nedot: '\u2250\u0338',
          nequiv: '\u2262',
          nesear: '\u2928',
          nesim: '\u2242\u0338',
          nexist: '\u2204',
          nexists: '\u2204',
          nfr: '\u{1D52B}',
          ngE: '\u2267\u0338',
          nge: '\u2271',
          ngeq: '\u2271',
          ngeqq: '\u2267\u0338',
          ngeqslant: '\u2A7E\u0338',
          nges: '\u2A7E\u0338',
          ngsim: '\u2275',
          ngt: '\u226F',
          ngtr: '\u226F',
          nhArr: '\u21CE',
          nharr: '\u21AE',
          nhpar: '\u2AF2',
          ni: '\u220B',
          nis: '\u22FC',
          nisd: '\u22FA',
          niv: '\u220B',
          njcy: '\u045A',
          nlArr: '\u21CD',
          nlE: '\u2266\u0338',
          nlarr: '\u219A',
          nldr: '\u2025',
          nle: '\u2270',
          nleftarrow: '\u219A',
          nleftrightarrow: '\u21AE',
          nleq: '\u2270',
          nleqq: '\u2266\u0338',
          nleqslant: '\u2A7D\u0338',
          nles: '\u2A7D\u0338',
          nless: '\u226E',
          nlsim: '\u2274',
          nlt: '\u226E',
          nltri: '\u22EA',
          nltrie: '\u22EC',
          nmid: '\u2224',
          nopf: '\u{1D55F}',
          not: '\xAC',
          notin: '\u2209',
          notinE: '\u22F9\u0338',
          notindot: '\u22F5\u0338',
          notinva: '\u2209',
          notinvb: '\u22F7',
          notinvc: '\u22F6',
          notni: '\u220C',
          notniva: '\u220C',
          notnivb: '\u22FE',
          notnivc: '\u22FD',
          npar: '\u2226',
          nparallel: '\u2226',
          nparsl: '\u2AFD\u20E5',
          npart: '\u2202\u0338',
          npolint: '\u2A14',
          npr: '\u2280',
          nprcue: '\u22E0',
          npre: '\u2AAF\u0338',
          nprec: '\u2280',
          npreceq: '\u2AAF\u0338',
          nrArr: '\u21CF',
          nrarr: '\u219B',
          nrarrc: '\u2933\u0338',
          nrarrw: '\u219D\u0338',
          nrightarrow: '\u219B',
          nrtri: '\u22EB',
          nrtrie: '\u22ED',
          nsc: '\u2281',
          nsccue: '\u22E1',
          nsce: '\u2AB0\u0338',
          nscr: '\u{1D4C3}',
          nshortmid: '\u2224',
          nshortparallel: '\u2226',
          nsim: '\u2241',
          nsime: '\u2244',
          nsimeq: '\u2244',
          nsmid: '\u2224',
          nspar: '\u2226',
          nsqsube: '\u22E2',
          nsqsupe: '\u22E3',
          nsub: '\u2284',
          nsubE: '\u2AC5\u0338',
          nsube: '\u2288',
          nsubset: '\u2282\u20D2',
          nsubseteq: '\u2288',
          nsubseteqq: '\u2AC5\u0338',
          nsucc: '\u2281',
          nsucceq: '\u2AB0\u0338',
          nsup: '\u2285',
          nsupE: '\u2AC6\u0338',
          nsupe: '\u2289',
          nsupset: '\u2283\u20D2',
          nsupseteq: '\u2289',
          nsupseteqq: '\u2AC6\u0338',
          ntgl: '\u2279',
          ntilde: '\xF1',
          ntlg: '\u2278',
          ntriangleleft: '\u22EA',
          ntrianglelefteq: '\u22EC',
          ntriangleright: '\u22EB',
          ntrianglerighteq: '\u22ED',
          nu: '\u03BD',
          num: '#',
          numero: '\u2116',
          numsp: '\u2007',
          nvDash: '\u22AD',
          nvHarr: '\u2904',
          nvap: '\u224D\u20D2',
          nvdash: '\u22AC',
          nvge: '\u2265\u20D2',
          nvgt: '>\u20D2',
          nvinfin: '\u29DE',
          nvlArr: '\u2902',
          nvle: '\u2264\u20D2',
          nvlt: '<\u20D2',
          nvltrie: '\u22B4\u20D2',
          nvrArr: '\u2903',
          nvrtrie: '\u22B5\u20D2',
          nvsim: '\u223C\u20D2',
          nwArr: '\u21D6',
          nwarhk: '\u2923',
          nwarr: '\u2196',
          nwarrow: '\u2196',
          nwnear: '\u2927',
          oS: '\u24C8',
          oacute: '\xF3',
          oast: '\u229B',
          ocir: '\u229A',
          ocirc: '\xF4',
          ocy: '\u043E',
          odash: '\u229D',
          odblac: '\u0151',
          odiv: '\u2A38',
          odot: '\u2299',
          odsold: '\u29BC',
          oelig: '\u0153',
          ofcir: '\u29BF',
          ofr: '\u{1D52C}',
          ogon: '\u02DB',
          ograve: '\xF2',
          ogt: '\u29C1',
          ohbar: '\u29B5',
          ohm: '\u03A9',
          oint: '\u222E',
          olarr: '\u21BA',
          olcir: '\u29BE',
          olcross: '\u29BB',
          oline: '\u203E',
          olt: '\u29C0',
          omacr: '\u014D',
          omega: '\u03C9',
          omicron: '\u03BF',
          omid: '\u29B6',
          ominus: '\u2296',
          oopf: '\u{1D560}',
          opar: '\u29B7',
          operp: '\u29B9',
          oplus: '\u2295',
          or: '\u2228',
          orarr: '\u21BB',
          ord: '\u2A5D',
          order: '\u2134',
          orderof: '\u2134',
          ordf: '\xAA',
          ordm: '\xBA',
          origof: '\u22B6',
          oror: '\u2A56',
          orslope: '\u2A57',
          orv: '\u2A5B',
          oscr: '\u2134',
          oslash: '\xF8',
          osol: '\u2298',
          otilde: '\xF5',
          otimes: '\u2297',
          otimesas: '\u2A36',
          ouml: '\xF6',
          ovbar: '\u233D',
          par: '\u2225',
          para: '\xB6',
          parallel: '\u2225',
          parsim: '\u2AF3',
          parsl: '\u2AFD',
          part: '\u2202',
          pcy: '\u043F',
          percnt: '%',
          period: '.',
          permil: '\u2030',
          perp: '\u22A5',
          pertenk: '\u2031',
          pfr: '\u{1D52D}',
          phi: '\u03C6',
          phiv: '\u03D5',
          phmmat: '\u2133',
          phone: '\u260E',
          pi: '\u03C0',
          pitchfork: '\u22D4',
          piv: '\u03D6',
          planck: '\u210F',
          planckh: '\u210E',
          plankv: '\u210F',
          plus: '+',
          plusacir: '\u2A23',
          plusb: '\u229E',
          pluscir: '\u2A22',
          plusdo: '\u2214',
          plusdu: '\u2A25',
          pluse: '\u2A72',
          plusmn: '\xB1',
          plussim: '\u2A26',
          plustwo: '\u2A27',
          pm: '\xB1',
          pointint: '\u2A15',
          popf: '\u{1D561}',
          pound: '\xA3',
          pr: '\u227A',
          prE: '\u2AB3',
          prap: '\u2AB7',
          prcue: '\u227C',
          pre: '\u2AAF',
          prec: '\u227A',
          precapprox: '\u2AB7',
          preccurlyeq: '\u227C',
          preceq: '\u2AAF',
          precnapprox: '\u2AB9',
          precneqq: '\u2AB5',
          precnsim: '\u22E8',
          precsim: '\u227E',
          prime: '\u2032',
          primes: '\u2119',
          prnE: '\u2AB5',
          prnap: '\u2AB9',
          prnsim: '\u22E8',
          prod: '\u220F',
          profalar: '\u232E',
          profline: '\u2312',
          profsurf: '\u2313',
          prop: '\u221D',
          propto: '\u221D',
          prsim: '\u227E',
          prurel: '\u22B0',
          pscr: '\u{1D4C5}',
          psi: '\u03C8',
          puncsp: '\u2008',
          qfr: '\u{1D52E}',
          qint: '\u2A0C',
          qopf: '\u{1D562}',
          qprime: '\u2057',
          qscr: '\u{1D4C6}',
          quaternions: '\u210D',
          quatint: '\u2A16',
          quest: '?',
          questeq: '\u225F',
          quot: '"',
          rAarr: '\u21DB',
          rArr: '\u21D2',
          rAtail: '\u291C',
          rBarr: '\u290F',
          rHar: '\u2964',
          race: '\u223D\u0331',
          racute: '\u0155',
          radic: '\u221A',
          raemptyv: '\u29B3',
          rang: '\u27E9',
          rangd: '\u2992',
          range: '\u29A5',
          rangle: '\u27E9',
          raquo: '\xBB',
          rarr: '\u2192',
          rarrap: '\u2975',
          rarrb: '\u21E5',
          rarrbfs: '\u2920',
          rarrc: '\u2933',
          rarrfs: '\u291E',
          rarrhk: '\u21AA',
          rarrlp: '\u21AC',
          rarrpl: '\u2945',
          rarrsim: '\u2974',
          rarrtl: '\u21A3',
          rarrw: '\u219D',
          ratail: '\u291A',
          ratio: '\u2236',
          rationals: '\u211A',
          rbarr: '\u290D',
          rbbrk: '\u2773',
          rbrace: '}',
          rbrack: ']',
          rbrke: '\u298C',
          rbrksld: '\u298E',
          rbrkslu: '\u2990',
          rcaron: '\u0159',
          rcedil: '\u0157',
          rceil: '\u2309',
          rcub: '}',
          rcy: '\u0440',
          rdca: '\u2937',
          rdldhar: '\u2969',
          rdquo: '\u201D',
          rdquor: '\u201D',
          rdsh: '\u21B3',
          real: '\u211C',
          realine: '\u211B',
          realpart: '\u211C',
          reals: '\u211D',
          rect: '\u25AD',
          reg: '\xAE',
          rfisht: '\u297D',
          rfloor: '\u230B',
          rfr: '\u{1D52F}',
          rhard: '\u21C1',
          rharu: '\u21C0',
          rharul: '\u296C',
          rho: '\u03C1',
          rhov: '\u03F1',
          rightarrow: '\u2192',
          rightarrowtail: '\u21A3',
          rightharpoondown: '\u21C1',
          rightharpoonup: '\u21C0',
          rightleftarrows: '\u21C4',
          rightleftharpoons: '\u21CC',
          rightrightarrows: '\u21C9',
          rightsquigarrow: '\u219D',
          rightthreetimes: '\u22CC',
          ring: '\u02DA',
          risingdotseq: '\u2253',
          rlarr: '\u21C4',
          rlhar: '\u21CC',
          rlm: '\u200F',
          rmoust: '\u23B1',
          rmoustache: '\u23B1',
          rnmid: '\u2AEE',
          roang: '\u27ED',
          roarr: '\u21FE',
          robrk: '\u27E7',
          ropar: '\u2986',
          ropf: '\u{1D563}',
          roplus: '\u2A2E',
          rotimes: '\u2A35',
          rpar: ')',
          rpargt: '\u2994',
          rppolint: '\u2A12',
          rrarr: '\u21C9',
          rsaquo: '\u203A',
          rscr: '\u{1D4C7}',
          rsh: '\u21B1',
          rsqb: ']',
          rsquo: '\u2019',
          rsquor: '\u2019',
          rthree: '\u22CC',
          rtimes: '\u22CA',
          rtri: '\u25B9',
          rtrie: '\u22B5',
          rtrif: '\u25B8',
          rtriltri: '\u29CE',
          ruluhar: '\u2968',
          rx: '\u211E',
          sacute: '\u015B',
          sbquo: '\u201A',
          sc: '\u227B',
          scE: '\u2AB4',
          scap: '\u2AB8',
          scaron: '\u0161',
          sccue: '\u227D',
          sce: '\u2AB0',
          scedil: '\u015F',
          scirc: '\u015D',
          scnE: '\u2AB6',
          scnap: '\u2ABA',
          scnsim: '\u22E9',
          scpolint: '\u2A13',
          scsim: '\u227F',
          scy: '\u0441',
          sdot: '\u22C5',
          sdotb: '\u22A1',
          sdote: '\u2A66',
          seArr: '\u21D8',
          searhk: '\u2925',
          searr: '\u2198',
          searrow: '\u2198',
          sect: '\xA7',
          semi: ';',
          seswar: '\u2929',
          setminus: '\u2216',
          setmn: '\u2216',
          sext: '\u2736',
          sfr: '\u{1D530}',
          sfrown: '\u2322',
          sharp: '\u266F',
          shchcy: '\u0449',
          shcy: '\u0448',
          shortmid: '\u2223',
          shortparallel: '\u2225',
          shy: '\xAD',
          sigma: '\u03C3',
          sigmaf: '\u03C2',
          sigmav: '\u03C2',
          sim: '\u223C',
          simdot: '\u2A6A',
          sime: '\u2243',
          simeq: '\u2243',
          simg: '\u2A9E',
          simgE: '\u2AA0',
          siml: '\u2A9D',
          simlE: '\u2A9F',
          simne: '\u2246',
          simplus: '\u2A24',
          simrarr: '\u2972',
          slarr: '\u2190',
          smallsetminus: '\u2216',
          smashp: '\u2A33',
          smeparsl: '\u29E4',
          smid: '\u2223',
          smile: '\u2323',
          smt: '\u2AAA',
          smte: '\u2AAC',
          smtes: '\u2AAC\uFE00',
          softcy: '\u044C',
          sol: '/',
          solb: '\u29C4',
          solbar: '\u233F',
          sopf: '\u{1D564}',
          spades: '\u2660',
          spadesuit: '\u2660',
          spar: '\u2225',
          sqcap: '\u2293',
          sqcaps: '\u2293\uFE00',
          sqcup: '\u2294',
          sqcups: '\u2294\uFE00',
          sqsub: '\u228F',
          sqsube: '\u2291',
          sqsubset: '\u228F',
          sqsubseteq: '\u2291',
          sqsup: '\u2290',
          sqsupe: '\u2292',
          sqsupset: '\u2290',
          sqsupseteq: '\u2292',
          squ: '\u25A1',
          square: '\u25A1',
          squarf: '\u25AA',
          squf: '\u25AA',
          srarr: '\u2192',
          sscr: '\u{1D4C8}',
          ssetmn: '\u2216',
          ssmile: '\u2323',
          sstarf: '\u22C6',
          star: '\u2606',
          starf: '\u2605',
          straightepsilon: '\u03F5',
          straightphi: '\u03D5',
          strns: '\xAF',
          sub: '\u2282',
          subE: '\u2AC5',
          subdot: '\u2ABD',
          sube: '\u2286',
          subedot: '\u2AC3',
          submult: '\u2AC1',
          subnE: '\u2ACB',
          subne: '\u228A',
          subplus: '\u2ABF',
          subrarr: '\u2979',
          subset: '\u2282',
          subseteq: '\u2286',
          subseteqq: '\u2AC5',
          subsetneq: '\u228A',
          subsetneqq: '\u2ACB',
          subsim: '\u2AC7',
          subsub: '\u2AD5',
          subsup: '\u2AD3',
          succ: '\u227B',
          succapprox: '\u2AB8',
          succcurlyeq: '\u227D',
          succeq: '\u2AB0',
          succnapprox: '\u2ABA',
          succneqq: '\u2AB6',
          succnsim: '\u22E9',
          succsim: '\u227F',
          sum: '\u2211',
          sung: '\u266A',
          sup1: '\xB9',
          sup2: '\xB2',
          sup3: '\xB3',
          sup: '\u2283',
          supE: '\u2AC6',
          supdot: '\u2ABE',
          supdsub: '\u2AD8',
          supe: '\u2287',
          supedot: '\u2AC4',
          suphsol: '\u27C9',
          suphsub: '\u2AD7',
          suplarr: '\u297B',
          supmult: '\u2AC2',
          supnE: '\u2ACC',
          supne: '\u228B',
          supplus: '\u2AC0',
          supset: '\u2283',
          supseteq: '\u2287',
          supseteqq: '\u2AC6',
          supsetneq: '\u228B',
          supsetneqq: '\u2ACC',
          supsim: '\u2AC8',
          supsub: '\u2AD4',
          supsup: '\u2AD6',
          swArr: '\u21D9',
          swarhk: '\u2926',
          swarr: '\u2199',
          swarrow: '\u2199',
          swnwar: '\u292A',
          szlig: '\xDF',
          target: '\u2316',
          tau: '\u03C4',
          tbrk: '\u23B4',
          tcaron: '\u0165',
          tcedil: '\u0163',
          tcy: '\u0442',
          tdot: '\u20DB',
          telrec: '\u2315',
          tfr: '\u{1D531}',
          there4: '\u2234',
          therefore: '\u2234',
          theta: '\u03B8',
          thetasym: '\u03D1',
          thetav: '\u03D1',
          thickapprox: '\u2248',
          thicksim: '\u223C',
          thinsp: '\u2009',
          thkap: '\u2248',
          thksim: '\u223C',
          thorn: '\xFE',
          tilde: '\u02DC',
          times: '\xD7',
          timesb: '\u22A0',
          timesbar: '\u2A31',
          timesd: '\u2A30',
          tint: '\u222D',
          toea: '\u2928',
          top: '\u22A4',
          topbot: '\u2336',
          topcir: '\u2AF1',
          topf: '\u{1D565}',
          topfork: '\u2ADA',
          tosa: '\u2929',
          tprime: '\u2034',
          trade: '\u2122',
          triangle: '\u25B5',
          triangledown: '\u25BF',
          triangleleft: '\u25C3',
          trianglelefteq: '\u22B4',
          triangleq: '\u225C',
          triangleright: '\u25B9',
          trianglerighteq: '\u22B5',
          tridot: '\u25EC',
          trie: '\u225C',
          triminus: '\u2A3A',
          triplus: '\u2A39',
          trisb: '\u29CD',
          tritime: '\u2A3B',
          trpezium: '\u23E2',
          tscr: '\u{1D4C9}',
          tscy: '\u0446',
          tshcy: '\u045B',
          tstrok: '\u0167',
          twixt: '\u226C',
          twoheadleftarrow: '\u219E',
          twoheadrightarrow: '\u21A0',
          uArr: '\u21D1',
          uHar: '\u2963',
          uacute: '\xFA',
          uarr: '\u2191',
          ubrcy: '\u045E',
          ubreve: '\u016D',
          ucirc: '\xFB',
          ucy: '\u0443',
          udarr: '\u21C5',
          udblac: '\u0171',
          udhar: '\u296E',
          ufisht: '\u297E',
          ufr: '\u{1D532}',
          ugrave: '\xF9',
          uharl: '\u21BF',
          uharr: '\u21BE',
          uhblk: '\u2580',
          ulcorn: '\u231C',
          ulcorner: '\u231C',
          ulcrop: '\u230F',
          ultri: '\u25F8',
          umacr: '\u016B',
          uml: '\xA8',
          uogon: '\u0173',
          uopf: '\u{1D566}',
          uparrow: '\u2191',
          updownarrow: '\u2195',
          upharpoonleft: '\u21BF',
          upharpoonright: '\u21BE',
          uplus: '\u228E',
          upsi: '\u03C5',
          upsih: '\u03D2',
          upsilon: '\u03C5',
          upuparrows: '\u21C8',
          urcorn: '\u231D',
          urcorner: '\u231D',
          urcrop: '\u230E',
          uring: '\u016F',
          urtri: '\u25F9',
          uscr: '\u{1D4CA}',
          utdot: '\u22F0',
          utilde: '\u0169',
          utri: '\u25B5',
          utrif: '\u25B4',
          uuarr: '\u21C8',
          uuml: '\xFC',
          uwangle: '\u29A7',
          vArr: '\u21D5',
          vBar: '\u2AE8',
          vBarv: '\u2AE9',
          vDash: '\u22A8',
          vangrt: '\u299C',
          varepsilon: '\u03F5',
          varkappa: '\u03F0',
          varnothing: '\u2205',
          varphi: '\u03D5',
          varpi: '\u03D6',
          varpropto: '\u221D',
          varr: '\u2195',
          varrho: '\u03F1',
          varsigma: '\u03C2',
          varsubsetneq: '\u228A\uFE00',
          varsubsetneqq: '\u2ACB\uFE00',
          varsupsetneq: '\u228B\uFE00',
          varsupsetneqq: '\u2ACC\uFE00',
          vartheta: '\u03D1',
          vartriangleleft: '\u22B2',
          vartriangleright: '\u22B3',
          vcy: '\u0432',
          vdash: '\u22A2',
          vee: '\u2228',
          veebar: '\u22BB',
          veeeq: '\u225A',
          vellip: '\u22EE',
          verbar: '|',
          vert: '|',
          vfr: '\u{1D533}',
          vltri: '\u22B2',
          vnsub: '\u2282\u20D2',
          vnsup: '\u2283\u20D2',
          vopf: '\u{1D567}',
          vprop: '\u221D',
          vrtri: '\u22B3',
          vscr: '\u{1D4CB}',
          vsubnE: '\u2ACB\uFE00',
          vsubne: '\u228A\uFE00',
          vsupnE: '\u2ACC\uFE00',
          vsupne: '\u228B\uFE00',
          vzigzag: '\u299A',
          wcirc: '\u0175',
          wedbar: '\u2A5F',
          wedge: '\u2227',
          wedgeq: '\u2259',
          weierp: '\u2118',
          wfr: '\u{1D534}',
          wopf: '\u{1D568}',
          wp: '\u2118',
          wr: '\u2240',
          wreath: '\u2240',
          wscr: '\u{1D4CC}',
          xcap: '\u22C2',
          xcirc: '\u25EF',
          xcup: '\u22C3',
          xdtri: '\u25BD',
          xfr: '\u{1D535}',
          xhArr: '\u27FA',
          xharr: '\u27F7',
          xi: '\u03BE',
          xlArr: '\u27F8',
          xlarr: '\u27F5',
          xmap: '\u27FC',
          xnis: '\u22FB',
          xodot: '\u2A00',
          xopf: '\u{1D569}',
          xoplus: '\u2A01',
          xotime: '\u2A02',
          xrArr: '\u27F9',
          xrarr: '\u27F6',
          xscr: '\u{1D4CD}',
          xsqcup: '\u2A06',
          xuplus: '\u2A04',
          xutri: '\u25B3',
          xvee: '\u22C1',
          xwedge: '\u22C0',
          yacute: '\xFD',
          yacy: '\u044F',
          ycirc: '\u0177',
          ycy: '\u044B',
          yen: '\xA5',
          yfr: '\u{1D536}',
          yicy: '\u0457',
          yopf: '\u{1D56A}',
          yscr: '\u{1D4CE}',
          yucy: '\u044E',
          yuml: '\xFF',
          zacute: '\u017A',
          zcaron: '\u017E',
          zcy: '\u0437',
          zdot: '\u017C',
          zeetrf: '\u2128',
          zeta: '\u03B6',
          zfr: '\u{1D537}',
          zhcy: '\u0436',
          zigrarr: '\u21DD',
          zopf: '\u{1D56B}',
          zscr: '\u{1D4CF}',
          zwj: '\u200D',
          zwnj: '\u200C',
        },
        K = {
          0: 65533,
          128: 8364,
          130: 8218,
          131: 402,
          132: 8222,
          133: 8230,
          134: 8224,
          135: 8225,
          136: 710,
          137: 8240,
          138: 352,
          139: 8249,
          140: 338,
          142: 381,
          145: 8216,
          146: 8217,
          147: 8220,
          148: 8221,
          149: 8226,
          150: 8211,
          151: 8212,
          152: 732,
          153: 8482,
          154: 353,
          155: 8250,
          156: 339,
          158: 382,
          159: 376,
        }
      function W(e10) {
        if (
          ((e10.startIndex = e10.tokenIndex = e10.index),
          (e10.startColumn = e10.tokenColumn = e10.column),
          (e10.startLine = e10.tokenLine = e10.line),
          e10.index >= e10.end)
        )
          return void e10.setToken(1048576)
        if (60 === e10.currentChar) {
          ;(f(e10), e10.setToken(8456256))
          return
        }
        if (123 === e10.currentChar) {
          ;(f(e10), e10.setToken(2162700))
          return
        }
        let t2 = 0
        for (; e10.index < e10.end; ) {
          let r3 = p[e10.source.charCodeAt(e10.index)]
          if (
            (1024 & r3 ? ((t2 |= 5), u(e10)) : 2048 & r3 ? (c(e10, t2), (t2 = (-5 & t2) | 1)) : f(e10),
            16384 & p[e10.currentChar])
          )
            break
        }
        e10.tokenIndex === e10.index && e10.report(0)
        let r2 = e10.source.slice(e10.tokenIndex, e10.index)
        ;(e10.options.raw && (e10.tokenRaw = r2),
          (e10.tokenValue = r2.replace(/&(?:[a-zA-Z]+|#[xX][\da-fA-F]+|#\d+);/g, (e11) => {
            if ('#' === e11.charAt(1)) {
              var t3
              let r3 = e11.charAt(2)
              return ((t3 = 'X' === r3 || 'x' === r3 ? parseInt(e11.slice(3), 16) : parseInt(e11.slice(2), 10)) >=
                55296 &&
                t3 <= 57343) ||
                t3 > 1114111
                ? '\uFFFD'
                : String.fromCodePoint(F(K, t3) ?? t3)
            }
            return F(Z, e11.slice(1, -1)) ?? e11
          })),
          e10.setToken(137))
      }
      function Q(e10) {
        if ((143360 & e10.getToken()) == 143360) {
          let { index: t2 } = e10,
            r2 = e10.currentChar
          for (; 32770 & p[r2]; ) r2 = f(e10)
          ;((e10.tokenValue += e10.source.slice(t2, e10.index)), e10.setToken(208897, true))
        }
        return e10.getToken()
      }
      class ee {
        parser
        type
        parent
        scopeError
        variableBindings = /* @__PURE__ */ new Map()
        constructor(e10, t2 = 2, r2) {
          ;((this.parser = e10), (this.type = t2), (this.parent = r2))
        }
        createChildScope(e10) {
          return new ee(this.parser, e10, this)
        }
        addVarOrBlock(e10, t2, r2, n2) {
          ;(4 & r2 ? this.addVarName(e10, t2, r2) : this.addBlockName(e10, t2, r2, n2),
            64 & n2 && this.parser.declareUnboundVariable(t2))
        }
        addVarName(e10, t2, r2) {
          let { parser: n2 } = this,
            o2 = this
          for (; o2 && (128 & o2.type) == 0; ) {
            let { variableBindings: a2 } = o2,
              i2 = a2.get(t2)
            ;(i2 &&
              248 & i2 &&
              ((n2.options.webcompat && (1 & e10) == 0 && ((128 & r2 && 68 & i2) || (128 & i2 && 68 & r2))) ||
                n2.report(145, t2)),
              o2 === this && i2 && 1 & i2 && 1 & r2 && o2.recordScopeError(145, t2),
              i2 && (256 & i2 || (512 & i2 && !n2.options.webcompat)) && n2.report(145, t2),
              o2.variableBindings.set(t2, r2),
              (o2 = o2.parent))
          }
        }
        hasVariable(e10) {
          return this.variableBindings.has(e10)
        }
        addBlockName(e10, t2, r2, n2) {
          let { parser: o2 } = this,
            a2 = this.variableBindings.get(t2)
          ;(a2 &&
            (2 & a2) == 0 &&
            (1 & r2
              ? this.recordScopeError(145, t2)
              : (o2.options.webcompat && (1 & e10) == 0 && 2 & n2 && 64 === a2 && 64 === r2) || o2.report(145, t2)),
            64 & this.type &&
              this.parent?.hasVariable(t2) &&
              (2 & this.parent.variableBindings.get(t2)) == 0 &&
              o2.report(145, t2),
            512 & this.type && a2 && (2 & a2) == 0 && 1 & r2 && this.recordScopeError(145, t2),
            32 & this.type && 768 & this.parent.variableBindings.get(t2) && o2.report(159, t2),
            this.variableBindings.set(t2, r2))
        }
        recordScopeError(e10, ...t2) {
          this.scopeError = { type: e10, params: t2, start: this.parser.tokenStart, end: this.parser.currentLocation }
        }
        reportScopeError() {
          let { scopeError: e10 } = this
          if (e10) throw new C(e10.start, e10.end, e10.type, ...e10.params)
        }
      }
      function et(e10, t2, r2) {
        let n2 = e10.createScope().createChildScope(512)
        return (n2.addBlockName(t2, r2, 1, 0), n2)
      }
      class er {
        parser
        parent
        refs = /* @__PURE__ */ Object.create(null)
        privateIdentifiers = /* @__PURE__ */ new Map()
        constructor(e10, t2) {
          ;((this.parser = e10), (this.parent = t2))
        }
        addPrivateIdentifier(e10, t2) {
          let { privateIdentifiers: r2 } = this,
            n2 = 800 & t2
          768 & n2 || (n2 |= 768)
          let o2 = r2.get(e10)
          ;(this.hasPrivateIdentifier(e10) && ((32 & o2) != (32 & n2) || o2 & n2 & 768) && this.parser.report(146, e10),
            r2.set(e10, this.hasPrivateIdentifier(e10) ? o2 | n2 : n2))
        }
        addPrivateIdentifierRef(e10) {
          ;((this.refs[e10] ??= []), this.refs[e10].push(this.parser.tokenStart))
        }
        isPrivateIdentifierDefined(e10) {
          return this.hasPrivateIdentifier(e10) || !!this.parent?.isPrivateIdentifierDefined(e10)
        }
        validatePrivateIdentifierRefs() {
          for (let e10 in this.refs)
            if (!this.isPrivateIdentifierDefined(e10)) {
              let { index: t2, line: r2, column: n2 } = this.refs[e10][0]
              throw new C(
                { index: t2, line: r2, column: n2 },
                { index: t2 + e10.length, line: r2, column: n2 + e10.length },
                4,
                e10
              )
            }
        }
        hasPrivateIdentifier(e10) {
          return this.privateIdentifiers.has(e10)
        }
      }
      class en {
        source
        options
        lastOnToken = null
        token = 1048576
        flags = 0
        index = 0
        line = 1
        column = 0
        startIndex = 0
        end = 0
        tokenIndex = 0
        startColumn = 0
        tokenColumn = 0
        tokenLine = 1
        startLine = 1
        tokenValue = ''
        tokenRaw = ''
        tokenRegExp = void 0
        currentChar = 0
        exportedNames = /* @__PURE__ */ new Set()
        exportedBindings = /* @__PURE__ */ new Set()
        assignable = 1
        destructible = 0
        leadingDecorators = { decorators: [] }
        constructor(e10, t2 = {}) {
          ;((this.source = e10), (this.options = t2), (this.end = e10.length), (this.currentChar = e10.charCodeAt(0)))
        }
        getToken() {
          return this.token
        }
        setToken(e10, t2 = false) {
          this.token = e10
          let { onToken: r2 } = this.options
          if (r2)
            if (1048576 !== e10) {
              let n2 = {
                start: { line: this.tokenLine, column: this.tokenColumn },
                end: { line: this.line, column: this.column },
              }
              ;(!t2 && this.lastOnToken && r2(...this.lastOnToken),
                (this.lastOnToken = [
                  (function (e11) {
                    switch (e11) {
                      case 134283266:
                        return 'NumericLiteral'
                      case 134283267:
                        return 'StringLiteral'
                      case 86021:
                      case 86022:
                        return 'BooleanLiteral'
                      case 86023:
                        return 'NullLiteral'
                      case 65540:
                        return 'RegularExpression'
                      case 67174408:
                      case 67174409:
                      case 131:
                        return 'TemplateLiteral'
                      default:
                        if ((143360 & e11) == 143360) return 'Identifier'
                        if ((4096 & e11) == 4096) return 'Keyword'
                        return 'Punctuator'
                    }
                  })(e10),
                  this.tokenIndex,
                  this.index,
                  n2,
                ]))
            } else this.lastOnToken && (r2(...this.lastOnToken), (this.lastOnToken = null))
          return e10
        }
        get tokenStart() {
          return { index: this.tokenIndex, line: this.tokenLine, column: this.tokenColumn }
        }
        get currentLocation() {
          return { index: this.index, line: this.line, column: this.column }
        }
        finishNode(e10, t2, r2) {
          if (this.options.ranges) {
            e10.start = t2.index
            let n2 = r2 ? r2.index : this.startIndex
            ;((e10.end = n2), (e10.range = [t2.index, n2]))
          }
          return (
            this.options.loc &&
              ((e10.loc = {
                start: { line: t2.line, column: t2.column },
                end: r2 ? { line: r2.line, column: r2.column } : { line: this.startLine, column: this.startColumn },
              }),
              this.options.source && (e10.loc.source = this.options.source)),
            e10
          )
        }
        addBindingToExports(e10) {
          this.exportedBindings.add(e10)
        }
        declareUnboundVariable(e10) {
          let { exportedNames: t2 } = this
          ;(t2.has(e10) && this.report(147, e10), t2.add(e10))
        }
        report(e10, ...t2) {
          throw new C(this.tokenStart, this.currentLocation, e10, ...t2)
        }
        createScopeIfLexical(e10, t2) {
          if (this.options.lexical) return this.createScope(e10, t2)
        }
        createScope(e10, t2) {
          return new ee(this, e10, t2)
        }
        createPrivateScopeIfLexical(e10) {
          if (this.options.lexical) return new er(this, e10)
        }
      }
      function eo(e10, t2 = {}, r2 = 0) {
        var n2, o2
        let a2,
          i2 =
            ((a2 = { ...t2 }).onComment &&
              (a2.onComment = Array.isArray(a2.onComment)
                ? ((n2 = a2.onComment),
                  function (e11, t3, r3, o3, i3) {
                    let s3 = { type: e11, value: t3 }
                    ;(a2.ranges && ((s3.start = r3), (s3.end = o3), (s3.range = [r3, o3])),
                      a2.loc && (s3.loc = i3),
                      n2.push(s3))
                  })
                : a2.onComment),
            a2.onToken &&
              (a2.onToken = Array.isArray(a2.onToken)
                ? ((o2 = a2.onToken),
                  function (e11, t3, r3, n3) {
                    let i3 = { token: e11 }
                    ;(a2.ranges && ((i3.start = t3), (i3.end = r3), (i3.range = [t3, r3])),
                      a2.loc && (i3.loc = n3),
                      o2.push(i3))
                  })
                : a2.onToken),
            a2)
        ;(i2.module && (r2 |= 3), i2.globalReturn && (r2 |= 4096), i2.impliedStrict && (r2 |= 1))
        let s2 = new en(e10, i2)
        !(function (e11) {
          let { source: t3 } = e11
          35 === e11.currentChar &&
            33 === t3.charCodeAt(e11.index + 1) &&
            (f(e11), f(e11), T(e11, t3, 0, 4, e11.tokenStart))
        })(s2)
        let l2 = s2.createScopeIfLexical(),
          c2 = [],
          u2 = 'script'
        if (2 & r2) {
          if (
            ((u2 = 'module'),
            (c2 = (function (e11, t3, r3) {
              $(e11, 32 | t3)
              let n3 = []
              for (; 134283267 === e11.getToken(); ) {
                let { tokenStart: r4 } = e11,
                  o3 = e11.getToken()
                n3.push(eu(e11, t3, ez(e11, t3), o3, r4))
              }
              for (; 1048576 !== e11.getToken(); )
                n3.push(
                  (function (e12, t4, r4) {
                    let n4
                    switch (
                      (132 === e12.getToken() &&
                        Object.assign(e12.leadingDecorators, {
                          start: e12.tokenStart,
                          decorators: e7(e12, t4, void 0),
                        }),
                      e12.getToken())
                    ) {
                      case 20564:
                        n4 = (function (e13, t5, r5) {
                          let n5 = e13.leadingDecorators.decorators.length
                            ? e13.leadingDecorators.start
                            : e13.tokenStart
                          $(e13, 32 | t5)
                          let o3 = [],
                            a3 = null,
                            i3 = null,
                            s3 = []
                          if (V(e13, 32 | t5, 20561)) {
                            switch (e13.getToken()) {
                              case 86104:
                                a3 = eX(e13, t5, r5, void 0, 4, 1, 1, 0, e13.tokenStart)
                                break
                              case 132:
                              case 86094:
                                a3 = e5(e13, t5, r5, void 0, 1)
                                break
                              case 209005: {
                                let { tokenStart: n6 } = e13
                                a3 = eH(e13, t5)
                                let { flags: o4 } = e13
                                ;(1 & o4) == 0 &&
                                  (86104 === e13.getToken()
                                    ? (a3 = eX(e13, t5, r5, void 0, 4, 1, 1, 1, n6))
                                    : 67174411 === e13.getToken()
                                      ? ((a3 = e6(e13, t5, void 0, a3, 1, 1, 0, o4, n6)),
                                        (a3 = eD(e13, t5, void 0, a3, 0, 0, n6)),
                                        (a3 = eq(e13, t5, void 0, 0, 0, n6, a3)))
                                      : 143360 & e13.getToken() &&
                                        (r5 && (r5 = et(e13, t5, e13.tokenValue)),
                                        (a3 = eH(e13, t5)),
                                        (a3 = e3(e13, t5, r5, void 0, [a3], 1, n6))))
                                break
                              }
                              default:
                                ;((a3 = eS(e13, t5, void 0, 1, 0, e13.tokenStart)), A(e13, 32 | t5))
                            }
                            return (
                              r5 && e13.declareUnboundVariable('default'),
                              e13.finishNode({ type: 'ExportDefaultDeclaration', declaration: a3 }, n5)
                            )
                          }
                          switch (e13.getToken()) {
                            case 8391476: {
                              $(e13, t5)
                              let o4 = null
                              ;(V(e13, t5, 77932) &&
                                (r5 && e13.declareUnboundVariable(e13.tokenValue), (o4 = eO(e13, t5))),
                                R(e13, t5, 209011),
                                134283267 !== e13.getToken() && e13.report(105, 'Export'))
                              let a4 = {
                                type: 'ExportAllDeclaration',
                                source: (i3 = ez(e13, t5)),
                                exported: o4,
                                attributes: eB(e13, t5),
                              }
                              return (A(e13, 32 | t5), e13.finishNode(a4, n5))
                            }
                            case 2162700: {
                              $(e13, t5)
                              let n6 = [],
                                a4 = [],
                                f3 = 0
                              for (; 143360 & e13.getToken() || 134283267 === e13.getToken(); ) {
                                let i4,
                                  { tokenStart: s4, tokenValue: l3 } = e13,
                                  c3 = eO(e13, t5)
                                ;('Literal' === c3.type && (f3 = 1),
                                  77932 === e13.getToken()
                                    ? ($(e13, t5),
                                      (143360 & e13.getToken()) == 0 && 134283267 !== e13.getToken() && e13.report(106),
                                      r5 && (n6.push(e13.tokenValue), a4.push(l3)),
                                      (i4 = eO(e13, t5)))
                                    : (r5 && (n6.push(e13.tokenValue), a4.push(e13.tokenValue)), (i4 = c3)),
                                  o3.push(e13.finishNode({ type: 'ExportSpecifier', local: c3, exported: i4 }, s4)),
                                  1074790415 !== e13.getToken() && R(e13, t5, 18))
                              }
                              ;(R(e13, t5, 1074790415),
                                V(e13, t5, 209011)
                                  ? (134283267 !== e13.getToken() && e13.report(105, 'Export'),
                                    (i3 = ez(e13, t5)),
                                    (s3 = eB(e13, t5)),
                                    r5 && n6.forEach((t6) => e13.declareUnboundVariable(t6)))
                                  : (f3 && e13.report(172),
                                    r5 &&
                                      (n6.forEach((t6) => e13.declareUnboundVariable(t6)),
                                      a4.forEach((t6) => e13.addBindingToExports(t6)))),
                                A(e13, 32 | t5))
                              break
                            }
                            case 132:
                            case 86094:
                              a3 = e5(e13, t5, r5, void 0, 2)
                              break
                            case 86104:
                              a3 = eX(e13, t5, r5, void 0, 4, 1, 2, 0, e13.tokenStart)
                              break
                            case 241737:
                              a3 = eg(e13, t5, r5, void 0, 8, 64)
                              break
                            case 86090:
                              a3 = eg(e13, t5, r5, void 0, 16, 64)
                              break
                            case 86088:
                              a3 = ex(e13, t5, r5, void 0, 64)
                              break
                            case 209005: {
                              let { tokenStart: n6 } = e13
                              if (($(e13, t5), (1 & e13.flags) == 0 && 86104 === e13.getToken())) {
                                a3 = eX(e13, t5, r5, void 0, 4, 1, 2, 1, n6)
                                break
                              }
                            }
                            default:
                              e13.report(30, N[255 & e13.getToken()])
                          }
                          let f2 = {
                            type: 'ExportNamedDeclaration',
                            declaration: a3,
                            specifiers: o3,
                            source: i3,
                            attributes: s3,
                          }
                          return e13.finishNode(f2, n5)
                        })(e12, t4, r4)
                        break
                      case 86106:
                        n4 = (function (e13, t5, r5) {
                          let n5 = e13.tokenStart
                          $(e13, t5)
                          let o3 = null,
                            { tokenStart: a3 } = e13,
                            i3 = []
                          if (134283267 === e13.getToken()) o3 = ez(e13, t5)
                          else {
                            var s3, f2
                            if (143360 & e13.getToken()) {
                              let n6 = eb(e13, t5, r5)
                              if (
                                ((i3 = [e13.finishNode({ type: 'ImportDefaultSpecifier', local: n6 }, a3)]),
                                V(e13, t5, 18))
                              )
                                switch (e13.getToken()) {
                                  case 8391476:
                                    i3.push(em(e13, t5, r5))
                                    break
                                  case 2162700:
                                    eT(e13, t5, r5, i3)
                                    break
                                  default:
                                    e13.report(107)
                                }
                            } else
                              switch (e13.getToken()) {
                                case 8391476:
                                  i3 = [em(e13, t5, r5)]
                                  break
                                case 2162700:
                                  eT(e13, t5, r5, i3)
                                  break
                                case 67174411:
                                  return ew(e13, t5, void 0, n5)
                                case 67108877:
                                  return ey(e13, t5, n5)
                                default:
                                  e13.report(30, N[255 & e13.getToken()])
                              }
                            ;(R((s3 = e13), (f2 = t5), 209011),
                              134283267 !== s3.getToken() && s3.report(105, 'Import'),
                              (o3 = ez(s3, f2)))
                          }
                          let l3 = { type: 'ImportDeclaration', specifiers: i3, source: o3, attributes: eB(e13, t5) }
                          return (A(e13, 32 | t5), e13.finishNode(l3, n5))
                        })(e12, t4, r4)
                        break
                      default:
                        n4 = ea(e12, t4, r4, void 0, 4, {})
                    }
                    return (e12.leadingDecorators?.decorators.length && e12.report(170), n4)
                  })(e11, t3, r3)
                )
              return n3
            })(s2, 8 | r2, l2)),
            l2)
          )
            for (let e11 of s2.exportedBindings) l2.hasVariable(e11) || s2.report(148, e11)
        } else
          c2 = (function (e11, t3, r3) {
            $(e11, 32 | t3 | 262144)
            let n3 = []
            for (; 134283267 === e11.getToken(); ) {
              let { index: r4, tokenValue: o3, tokenStart: a3, tokenIndex: i3 } = e11,
                s3 = e11.getToken(),
                f2 = ez(e11, t3)
              if (I(e11, r4, i3, o3)) {
                if (((t3 |= 1), 64 & e11.flags)) throw new C(e11.tokenStart, e11.currentLocation, 9)
                if (4096 & e11.flags) throw new C(e11.tokenStart, e11.currentLocation, 15)
              }
              n3.push(eu(e11, t3, f2, s3, a3))
            }
            for (; 1048576 !== e11.getToken(); ) n3.push(ea(e11, t3, r3, void 0, 4, {}))
            return n3
          })(s2, 8 | r2, l2)
        return s2.finishNode(
          { type: 'Program', sourceType: u2, body: c2 },
          { index: 0, line: 1, column: 0 },
          s2.currentLocation
        )
      }
      function ea(e10, t2, r2, n2, o2, a2) {
        let i2 = e10.tokenStart
        switch (e10.getToken()) {
          case 86104:
            return eX(e10, t2, r2, n2, o2, 1, 0, 0, i2)
          case 132:
          case 86094:
            return e5(e10, t2, r2, n2, 0)
          case 86090:
            return eg(e10, t2, r2, n2, 16, 0)
          case 241737:
            return (function (e11, t3, r3, n3, o3) {
              let { tokenValue: a3, tokenStart: i3 } = e11,
                s2 = e11.getToken(),
                f2 = eH(e11, t3)
              if (2240512 & e11.getToken()) {
                let o4 = ek(e11, t3, r3, n3, 8, 0)
                return (
                  A(e11, 32 | t3),
                  e11.finishNode({ type: 'VariableDeclaration', kind: 'let', declarations: o4 }, i3)
                )
              }
              if (((e11.assignable = 1), 1 & t3 && e11.report(85), 21 === e11.getToken()))
                return el(e11, t3, r3, n3, o3, {}, a3, f2, s2, 0, i3)
              if (10 === e11.getToken()) {
                let r4
                ;(e11.options.lexical && (r4 = et(e11, t3, a3)),
                  (e11.flags = (128 | e11.flags) ^ 128),
                  (f2 = e3(e11, t3, r4, n3, [f2], 0, i3)))
              } else ((f2 = eD(e11, t3, n3, f2, 0, 0, i3)), (f2 = eq(e11, t3, n3, 0, 0, i3, f2)))
              return (18 === e11.getToken() && (f2 = ev(e11, t3, n3, 0, i3, f2)), ef(e11, t3, f2, i3))
            })(e10, t2, r2, n2, o2)
          case 20564:
            e10.report(103, 'export')
          case 86106:
            switch (($(e10, t2), e10.getToken())) {
              case 67174411:
                return ew(e10, t2, n2, i2)
              case 67108877:
                return ey(e10, t2, i2)
              default:
                e10.report(103, 'import')
            }
          case 209005:
            return ec(e10, t2, r2, n2, o2, a2, 1)
          default:
            return ei(e10, t2, r2, n2, o2, a2, 1)
        }
      }
      function ei(e10, t2, r2, n2, o2, a2, i2) {
        var s2,
          f2,
          l2,
          c2,
          u2,
          d2,
          p2,
          g2,
          x2,
          k2,
          h2,
          b2,
          m2,
          T2,
          y2,
          w2,
          S2,
          v2,
          C2,
          q2,
          E2,
          N2,
          L2,
          I2,
          D2,
          U2,
          B2,
          O2,
          j2,
          M2
        switch (e10.getToken()) {
          case 86088:
            return ex(e10, t2, r2, n2, 0)
          case 20572:
            let J2, F2
            return (
              (s2 = e10),
              (f2 = t2),
              (l2 = n2),
              (4096 & f2) == 0 && s2.report(92),
              (J2 = s2.tokenStart),
              $(s2, 32 | f2),
              (F2 = 1 & s2.flags || 1048576 & s2.getToken() ? null : eC(s2, f2, l2, 0, 1, s2.tokenStart)),
              A(s2, 32 | f2),
              s2.finishNode({ type: 'ReturnStatement', argument: F2 }, J2)
            )
          case 20569:
            let H2, z2, X2, _2
            return (
              (c2 = e10),
              (u2 = t2),
              (d2 = r2),
              (p2 = n2),
              (g2 = a2),
              (H2 = c2.tokenStart),
              $(c2, u2),
              R(c2, 32 | u2, 67174411),
              (c2.assignable = 1),
              (z2 = eC(c2, u2, p2, 0, 1, c2.tokenStart)),
              R(c2, 32 | u2, 16),
              (X2 = ed(c2, u2, d2, p2, g2)),
              (_2 = null),
              20563 === c2.getToken() && ($(c2, 32 | u2), (_2 = ed(c2, u2, d2, p2, g2))),
              c2.finishNode({ type: 'IfStatement', test: z2, consequent: X2, alternate: _2 }, H2)
            )
          case 20567:
            return (function (e11, t3, r3, n3, o3) {
              let a3,
                i3 = e11.tokenStart
              $(e11, t3)
              let s3 = ((2048 & t3) > 0 || ((2 & t3) > 0 && (8 & t3) > 0)) && V(e11, t3, 209006)
              ;(R(e11, 32 | t3, 67174411), (r3 = r3?.createChildScope(1)))
              let f3 = null,
                l3 = null,
                c3 = 0,
                u3 = null,
                d3 = 86088 === e11.getToken() || 241737 === e11.getToken() || 86090 === e11.getToken(),
                { tokenStart: p3 } = e11,
                g3 = e11.getToken()
              if (d3)
                241737 === g3
                  ? ((u3 = eH(e11, t3)),
                    2240512 & e11.getToken()
                      ? (8673330 === e11.getToken()
                          ? 1 & t3 && e11.report(67)
                          : (u3 = e11.finishNode(
                              {
                                type: 'VariableDeclaration',
                                kind: 'let',
                                declarations: ek(e11, 131072 | t3, r3, n3, 8, 32),
                              },
                              p3
                            )),
                        (e11.assignable = 1))
                      : 1 & t3
                        ? e11.report(67)
                        : ((d3 = false),
                          (e11.assignable = 1),
                          (u3 = eD(e11, t3, n3, u3, 0, 0, p3)),
                          471156 === e11.getToken() && e11.report(115)))
                  : ($(e11, t3),
                    (u3 = e11.finishNode(
                      86088 === g3
                        ? {
                            type: 'VariableDeclaration',
                            kind: 'var',
                            declarations: ek(e11, 131072 | t3, r3, n3, 4, 32),
                          }
                        : {
                            type: 'VariableDeclaration',
                            kind: 'const',
                            declarations: ek(e11, 131072 | t3, r3, n3, 16, 32),
                          },
                      p3
                    )),
                    (e11.assignable = 1))
              else if (1074790417 === g3) s3 && e11.report(82)
              else if ((2097152 & g3) == 2097152) {
                let r4 = e11.tokenStart
                ;((u3 =
                  2162700 === g3 ? eW(e11, t3, void 0, n3, 1, 0, 0, 2, 32) : e$(e11, t3, void 0, n3, 1, 0, 0, 2, 32)),
                  64 & (c3 = e11.destructible) && e11.report(63),
                  (e11.assignable = 16 & c3 ? 2 : 1),
                  (u3 = eD(e11, 131072 | t3, n3, u3, 0, 0, r4)))
              } else u3 = eI(e11, 131072 | t3, n3, 1, 0, 1)
              if ((262144 & e11.getToken()) == 262144) {
                if (471156 === e11.getToken()) {
                  ;(2 & e11.assignable && e11.report(80, s3 ? 'await' : 'of'),
                    P(e11, u3),
                    $(e11, 32 | t3),
                    (a3 = eS(e11, t3, n3, 1, 0, e11.tokenStart)),
                    R(e11, 32 | t3, 16))
                  let f5 = ep(e11, t3, r3, n3, o3)
                  return e11.finishNode({ type: 'ForOfStatement', left: u3, right: a3, body: f5, await: s3 }, i3)
                }
                ;(2 & e11.assignable && e11.report(80, 'in'),
                  P(e11, u3),
                  $(e11, 32 | t3),
                  s3 && e11.report(82),
                  (a3 = eC(e11, t3, n3, 0, 1, e11.tokenStart)),
                  R(e11, 32 | t3, 16))
                let f4 = ep(e11, t3, r3, n3, o3)
                return e11.finishNode({ type: 'ForInStatement', body: f4, left: u3, right: a3 }, i3)
              }
              ;(s3 && e11.report(82),
                d3 ||
                  (8 & c3 && 1077936155 !== e11.getToken() && e11.report(80, 'loop'),
                  (u3 = eq(e11, 131072 | t3, n3, 0, 0, p3, u3))),
                18 === e11.getToken() && (u3 = ev(e11, t3, n3, 0, p3, u3)),
                R(e11, 32 | t3, 1074790417),
                1074790417 !== e11.getToken() && (f3 = eC(e11, t3, n3, 0, 1, e11.tokenStart)),
                R(e11, 32 | t3, 1074790417),
                16 !== e11.getToken() && (l3 = eC(e11, t3, n3, 0, 1, e11.tokenStart)),
                R(e11, 32 | t3, 16))
              let x3 = ep(e11, t3, r3, n3, o3)
              return e11.finishNode({ type: 'ForStatement', init: u3, test: f3, update: l3, body: x3 }, i3)
            })(e10, t2, r2, n2, a2)
          case 20562:
            let Y2, Z2, K2
            return (
              (x2 = e10),
              (k2 = t2),
              (h2 = r2),
              (b2 = n2),
              (m2 = a2),
              (Y2 = x2.tokenStart),
              $(x2, 32 | k2),
              (Z2 = ep(x2, k2, h2, b2, m2)),
              R(x2, k2, 20578),
              R(x2, 32 | k2, 67174411),
              (K2 = eC(x2, k2, b2, 0, 1, x2.tokenStart)),
              R(x2, 32 | k2, 16),
              V(x2, 32 | k2, 1074790417),
              x2.finishNode({ type: 'DoWhileStatement', body: Z2, test: K2 }, Y2)
            )
          case 20578:
            let W2, Q2, ee2
            return (
              (T2 = e10),
              (y2 = t2),
              (w2 = r2),
              (S2 = n2),
              (v2 = a2),
              (W2 = T2.tokenStart),
              $(T2, y2),
              R(T2, 32 | y2, 67174411),
              (Q2 = eC(T2, y2, S2, 0, 1, T2.tokenStart)),
              R(T2, 32 | y2, 16),
              (ee2 = ep(T2, y2, w2, S2, v2)),
              T2.finishNode({ type: 'WhileStatement', test: Q2, body: ee2 }, W2)
            )
          case 86110:
            return (function (e11, t3, r3, n3, o3) {
              let a3 = e11.tokenStart
              ;($(e11, t3), R(e11, 32 | t3, 67174411))
              let i3 = eC(e11, t3, n3, 0, 1, e11.tokenStart)
              ;(R(e11, t3, 16), R(e11, t3, 2162700))
              let s3 = [],
                f3 = 0
              for (r3 = r3?.createChildScope(8); 1074790415 !== e11.getToken(); ) {
                let { tokenStart: a4 } = e11,
                  i4 = null,
                  l3 = []
                for (
                  V(e11, 32 | t3, 20556)
                    ? (i4 = eC(e11, t3, n3, 0, 1, e11.tokenStart))
                    : (R(e11, 32 | t3, 20561), f3 && e11.report(89), (f3 = 1)),
                    R(e11, 32 | t3, 21);
                  20556 !== e11.getToken() && 1074790415 !== e11.getToken() && 20561 !== e11.getToken();
                )
                  l3.push(ea(e11, 4 | t3, r3, n3, 2, { $: o3 }))
                s3.push(e11.finishNode({ type: 'SwitchCase', test: i4, consequent: l3 }, a4))
              }
              return (
                R(e11, 32 | t3, 1074790415),
                e11.finishNode({ type: 'SwitchStatement', discriminant: i3, cases: s3 }, a3)
              )
            })(e10, t2, r2, n2, a2)
          case 1074790417:
            let et2
            return (
              (C2 = e10),
              (q2 = t2),
              (et2 = C2.tokenStart),
              $(C2, 32 | q2),
              C2.finishNode({ type: 'EmptyStatement' }, et2)
            )
          case 2162700:
            return es(e10, t2, r2?.createChildScope(), n2, a2, e10.tokenStart)
          case 86112:
            let er2, en2
            return (
              (E2 = e10),
              (N2 = t2),
              (L2 = n2),
              (er2 = E2.tokenStart),
              $(E2, 32 | N2),
              1 & E2.flags && E2.report(90),
              (en2 = eC(E2, N2, L2, 0, 1, E2.tokenStart)),
              A(E2, 32 | N2),
              E2.finishNode({ type: 'ThrowStatement', argument: en2 }, er2)
            )
          case 20555:
            return (function (e11, t3, r3) {
              let n3 = e11.tokenStart
              $(e11, 32 | t3)
              let o3 = null
              if ((1 & e11.flags) == 0 && 143360 & e11.getToken()) {
                let { tokenValue: n4 } = e11
                ;((o3 = eH(e11, 32 | t3)), G(e11, r3, n4, 0) || e11.report(138, n4))
              } else (132 & t3) == 0 && e11.report(69)
              return (A(e11, 32 | t3), e11.finishNode({ type: 'BreakStatement', label: o3 }, n3))
            })(e10, t2, a2)
          case 20559:
            return (function (e11, t3, r3) {
              ;(128 & t3) == 0 && e11.report(68)
              let n3 = e11.tokenStart
              $(e11, t3)
              let o3 = null
              if ((1 & e11.flags) == 0 && 143360 & e11.getToken()) {
                let { tokenValue: n4 } = e11
                ;((o3 = eH(e11, 32 | t3)), G(e11, r3, n4, 1) || e11.report(138, n4))
              }
              return (A(e11, 32 | t3), e11.finishNode({ type: 'ContinueStatement', label: o3 }, n3))
            })(e10, t2, a2)
          case 20577:
            return (function (e11, t3, r3, n3, o3) {
              var a3, i3, s3, f3, l3, c3
              let u3,
                d3,
                p3 = e11.tokenStart
              $(e11, 32 | t3)
              let g3 = es(e11, t3, r3?.createChildScope(16), n3, { $: o3 }),
                { tokenStart: x3 } = e11,
                k3 = V(e11, 32 | t3, 20557)
                  ? ((a3 = e11),
                    (i3 = t3),
                    (s3 = r3),
                    (f3 = n3),
                    (l3 = o3),
                    (c3 = x3),
                    (u3 = null),
                    V(a3, i3, 67174411) &&
                      ((u3 = tr(
                        a3,
                        i3,
                        (s3 = s3?.createChildScope(4)),
                        f3,
                        (2097152 & a3.getToken()) == 2097152 ? 256 : 512,
                        0
                      )),
                      18 === a3.getToken() ? a3.report(86) : 1077936155 === a3.getToken() && a3.report(87),
                      R(a3, 32 | i3, 16)),
                    (d3 = es(a3, i3, s3?.createChildScope(32), f3, { $: l3 })),
                    a3.finishNode({ type: 'CatchClause', param: u3, body: d3 }, c3))
                  : null,
                h3 = null
              return (
                20566 === e11.getToken() &&
                  ($(e11, 32 | t3), (h3 = es(e11, t3, r3?.createChildScope(4), n3, { $: o3 }))),
                k3 || h3 || e11.report(88),
                e11.finishNode({ type: 'TryStatement', block: g3, handler: k3, finalizer: h3 }, p3)
              )
            })(e10, t2, r2, n2, a2)
          case 20579:
            let eo2, eu2, eg2
            return (
              (I2 = e10),
              (D2 = t2),
              (U2 = r2),
              (B2 = n2),
              (O2 = a2),
              (eo2 = I2.tokenStart),
              $(I2, D2),
              1 & D2 && I2.report(91),
              R(I2, 32 | D2, 67174411),
              (eu2 = eC(I2, D2, B2, 0, 1, I2.tokenStart)),
              R(I2, 32 | D2, 16),
              (eg2 = ei(I2, D2, U2, B2, 2, O2, 0)),
              I2.finishNode({ type: 'WithStatement', object: eu2, body: eg2 }, eo2)
            )
          case 20560:
            let eh2
            return (
              (j2 = e10),
              (M2 = t2),
              (eh2 = j2.tokenStart),
              $(j2, 32 | M2),
              A(j2, 32 | M2),
              j2.finishNode({ type: 'DebuggerStatement' }, eh2)
            )
          case 209005:
            return ec(e10, t2, r2, n2, o2, a2, 0)
          case 20557:
            e10.report(162)
          case 20566:
            e10.report(163)
          case 86104:
            e10.report(1 & t2 ? 76 : e10.options.webcompat ? 77 : 78)
          case 86094:
            e10.report(79)
          default:
            return (function (e11, t3, r3, n3, o3, a3, i3) {
              let s3,
                { tokenValue: f3, tokenStart: l3 } = e11,
                c3 = e11.getToken()
              return (241737 === c3
                ? ((s3 = eH(e11, t3)), 1 & t3 && e11.report(85), 69271571 === e11.getToken() && e11.report(84))
                : (s3 = eR(e11, t3, n3, 2, 0, 1, 0, 1, e11.tokenStart)),
              143360 & c3 && 21 === e11.getToken())
                ? el(e11, t3, r3, n3, o3, a3, f3, s3, c3, i3, l3)
                : ((s3 = eD(e11, t3, n3, s3, 0, 0, l3)),
                  (s3 = eq(e11, t3, n3, 0, 0, l3, s3)),
                  18 === e11.getToken() && (s3 = ev(e11, t3, n3, 0, l3, s3)),
                  ef(e11, t3, s3, l3))
            })(e10, t2, r2, n2, o2, a2, i2)
        }
      }
      function es(e10, t2, r2, n2, o2, a2 = e10.tokenStart, i2 = 'BlockStatement') {
        let s2 = []
        for (R(e10, 32 | t2, 2162700); 1074790415 !== e10.getToken(); ) s2.push(ea(e10, t2, r2, n2, 2, { $: o2 }))
        return (R(e10, 32 | t2, 1074790415), e10.finishNode({ type: i2, body: s2 }, a2))
      }
      function ef(e10, t2, r2, n2) {
        return (A(e10, 32 | t2), e10.finishNode({ type: 'ExpressionStatement', expression: r2 }, n2))
      }
      function el(e10, t2, r2, n2, o2, a2, i2, s2, f2, l2, c2) {
        U(e10, t2, 0, f2, 1)
        let u2 = a2
        for (; u2; ) (u2['$' + i2] && e10.report(136, i2), (u2 = u2.$))
        ;((a2['$' + i2] = 1), $(e10, 32 | t2))
        let d2 =
          l2 && (1 & t2) == 0 && e10.options.webcompat && 86104 === e10.getToken()
            ? eX(e10, t2, r2?.createChildScope(), n2, o2, 0, 0, 0, e10.tokenStart)
            : ei(e10, t2, r2, n2, o2, a2, l2)
        return e10.finishNode({ type: 'LabeledStatement', label: s2, body: d2 }, c2)
      }
      function ec(e10, t2, r2, n2, o2, a2, i2) {
        let { tokenValue: s2, tokenStart: f2 } = e10,
          l2 = e10.getToken(),
          c2 = eH(e10, t2)
        if (21 === e10.getToken()) return el(e10, t2, r2, n2, o2, a2, s2, c2, l2, 1, f2)
        let u2 = 1 & e10.flags
        if (!u2) {
          if (86104 === e10.getToken()) return (i2 || e10.report(123), eX(e10, t2, r2, n2, o2, 1, 0, 1, f2))
          if (M(t2, e10.getToken()))
            return (
              (c2 = e8(e10, t2, n2, 1, f2)),
              18 === e10.getToken() && (c2 = ev(e10, t2, n2, 0, f2, c2)),
              ef(e10, t2, c2, f2)
            )
        }
        return (
          67174411 === e10.getToken()
            ? (c2 = e6(e10, t2, n2, c2, 1, 1, 0, u2, f2))
            : (10 === e10.getToken() &&
                (J(e10, t2, l2),
                (36864 & l2) == 36864 && (e10.flags |= 256),
                (c2 = e1(e10, 2048 | t2, n2, e10.tokenValue, c2, 0, 1, 0, f2))),
              (e10.assignable = 1)),
          (c2 = eD(e10, t2, n2, c2, 0, 0, f2)),
          (c2 = eq(e10, t2, n2, 0, 0, f2, c2)),
          (e10.assignable = 1),
          18 === e10.getToken() && (c2 = ev(e10, t2, n2, 0, f2, c2)),
          ef(e10, t2, c2, f2)
        )
      }
      function eu(e10, t2, r2, n2, o2) {
        let a2 = e10.startIndex
        1074790417 !== n2 &&
          ((e10.assignable = 2),
          (r2 = eD(e10, t2, void 0, r2, 0, 0, o2)),
          1074790417 !== e10.getToken() &&
            ((r2 = eq(e10, t2, void 0, 0, 0, o2, r2)), 18 === e10.getToken() && (r2 = ev(e10, t2, void 0, 0, o2, r2))),
          A(e10, 32 | t2))
        let i2 = { type: 'ExpressionStatement', expression: r2 }
        return (
          'Literal' === r2.type &&
            'string' == typeof r2.value &&
            (i2.directive = e10.source.slice(o2.index + 1, a2 - 1)),
          e10.finishNode(i2, o2)
        )
      }
      function ed(e10, t2, r2, n2, o2) {
        let { tokenStart: a2 } = e10
        return 1 & t2 || !e10.options.webcompat || 86104 !== e10.getToken()
          ? ei(e10, t2, r2, n2, 0, { $: o2 }, 0)
          : eX(e10, t2, r2?.createChildScope(), n2, 0, 0, 0, 0, a2)
      }
      function ep(e10, t2, r2, n2, o2) {
        return ei(e10, ((131072 | t2) ^ 131072) | 128, r2, n2, 0, { loop: 1, $: o2 }, 0)
      }
      function eg(e10, t2, r2, n2, o2, a2) {
        let i2 = e10.tokenStart
        $(e10, t2)
        let s2 = ek(e10, t2, r2, n2, o2, a2)
        return (
          A(e10, 32 | t2),
          e10.finishNode({ type: 'VariableDeclaration', kind: 8 & o2 ? 'let' : 'const', declarations: s2 }, i2)
        )
      }
      function ex(e10, t2, r2, n2, o2) {
        let a2 = e10.tokenStart
        $(e10, t2)
        let i2 = ek(e10, t2, r2, n2, 4, o2)
        return (A(e10, 32 | t2), e10.finishNode({ type: 'VariableDeclaration', kind: 'var', declarations: i2 }, a2))
      }
      function ek(e10, t2, r2, n2, o2, a2) {
        let i2 = 1,
          s2 = [eh(e10, t2, r2, n2, o2, a2)]
        for (; V(e10, t2, 18); ) (i2++, s2.push(eh(e10, t2, r2, n2, o2, a2)))
        return (i2 > 1 && 32 & a2 && 262144 & e10.getToken() && e10.report(61, N[255 & e10.getToken()]), s2)
      }
      function eh(e10, t2, r2, n2, o2, a2) {
        let { tokenStart: i2 } = e10,
          s2 = e10.getToken(),
          f2 = null,
          l2 = tr(e10, t2, r2, n2, o2, a2)
        if (1077936155 === e10.getToken()) {
          if (
            ($(e10, 32 | t2),
            (f2 = eS(e10, t2, n2, 1, 0, e10.tokenStart)),
            (32 & a2 || (2097152 & s2) == 0) &&
              (471156 === e10.getToken() || (8673330 === e10.getToken() && (2097152 & s2 || (4 & o2) == 0 || 1 & t2))))
          )
            throw new C(i2, e10.currentLocation, 60, 471156 === e10.getToken() ? 'of' : 'in')
        } else
          (16 & o2 || (2097152 & s2) > 0) &&
            (262144 & e10.getToken()) != 262144 &&
            e10.report(59, 16 & o2 ? 'const' : 'destructuring')
        return e10.finishNode({ type: 'VariableDeclarator', id: l2, init: f2 }, i2)
      }
      function eb(e10, t2, r2) {
        return (
          M(t2, e10.getToken()) || e10.report(118),
          (537079808 & e10.getToken()) == 537079808 && e10.report(119),
          r2?.addBlockName(t2, e10.tokenValue, 8, 0),
          eH(e10, t2)
        )
      }
      function em(e10, t2, r2) {
        let { tokenStart: n2 } = e10
        if (($(e10, t2), R(e10, t2, 77932), (134217728 & e10.getToken()) == 134217728))
          throw new C(n2, e10.currentLocation, 30, N[255 & e10.getToken()])
        return e10.finishNode({ type: 'ImportNamespaceSpecifier', local: eb(e10, t2, r2) }, n2)
      }
      function eT(e10, t2, r2, n2) {
        for ($(e10, t2); 143360 & e10.getToken() || 134283267 === e10.getToken(); ) {
          let o2,
            { tokenValue: a2, tokenStart: i2 } = e10,
            s2 = e10.getToken(),
            f2 = eO(e10, t2)
          ;(V(e10, t2, 77932)
            ? ((134217728 & e10.getToken()) == 134217728 || 18 === e10.getToken()
                ? e10.report(106)
                : U(e10, t2, 16, e10.getToken(), 0),
              (a2 = e10.tokenValue),
              (o2 = eH(e10, t2)))
            : 'Identifier' === f2.type
              ? (U(e10, t2, 16, s2, 0), (o2 = f2))
              : e10.report(25, N[108]),
            r2?.addBlockName(t2, a2, 8, 0),
            n2.push(e10.finishNode({ type: 'ImportSpecifier', local: o2, imported: f2 }, i2)),
            1074790415 !== e10.getToken() && R(e10, t2, 18))
        }
        return (R(e10, t2, 1074790415), n2)
      }
      function ey(e10, t2, r2) {
        let n2 = eP(e10, t2, e10.finishNode({ type: 'Identifier', name: 'import' }, r2), r2)
        return (
          (n2 = eD(e10, t2, void 0, n2, 0, 0, r2)),
          (n2 = eq(e10, t2, void 0, 0, 0, r2, n2)),
          18 === e10.getToken() && (n2 = ev(e10, t2, void 0, 0, r2, n2)),
          ef(e10, t2, n2, r2)
        )
      }
      function ew(e10, t2, r2, n2) {
        let o2 = eU(e10, t2, r2, 0, n2)
        return (
          (o2 = eD(e10, t2, r2, o2, 0, 0, n2)),
          18 === e10.getToken() && (o2 = ev(e10, t2, r2, 0, n2, o2)),
          ef(e10, t2, o2, n2)
        )
      }
      function eS(e10, t2, r2, n2, o2, a2) {
        let i2 = eR(e10, t2, r2, 2, 0, n2, o2, 1, a2)
        return ((i2 = eD(e10, t2, r2, i2, o2, 0, a2)), eq(e10, t2, r2, o2, 0, a2, i2))
      }
      function ev(e10, t2, r2, n2, o2, a2) {
        let i2 = [a2]
        for (; V(e10, 32 | t2, 18); ) i2.push(eS(e10, t2, r2, 1, n2, e10.tokenStart))
        return e10.finishNode({ type: 'SequenceExpression', expressions: i2 }, o2)
      }
      function eC(e10, t2, r2, n2, o2, a2) {
        let i2 = eS(e10, t2, r2, o2, n2, a2)
        return 18 === e10.getToken() ? ev(e10, t2, r2, n2, a2, i2) : i2
      }
      function eq(e10, t2, r2, n2, o2, a2, i2) {
        let s2 = e10.getToken()
        if ((4194304 & s2) == 4194304) {
          ;(2 & e10.assignable && e10.report(26),
            ((o2 || 1077936155 !== s2 || 'ArrayExpression' !== i2.type) && 'ObjectExpression' !== i2.type) ||
              P(e10, i2),
            $(e10, 32 | t2))
          let f2 = eS(e10, t2, r2, 1, n2, e10.tokenStart)
          return (
            (e10.assignable = 2),
            e10.finishNode(
              o2
                ? { type: 'AssignmentPattern', left: i2, right: f2 }
                : { type: 'AssignmentExpression', left: i2, operator: N[255 & s2], right: f2 },
              a2
            )
          )
        }
        return (
          (8388608 & s2) == 8388608 && (i2 = eL(e10, t2, r2, n2, a2, 4, s2, i2)),
          V(e10, 32 | t2, 22) && (i2 = eN(e10, t2, r2, i2, a2)),
          i2
        )
      }
      function eE(e10, t2, r2, n2, o2, a2, i2) {
        let s2 = e10.getToken()
        $(e10, 32 | t2)
        let f2 = eS(e10, t2, r2, 1, n2, e10.tokenStart)
        return (
          (i2 = e10.finishNode(
            o2
              ? { type: 'AssignmentPattern', left: i2, right: f2 }
              : { type: 'AssignmentExpression', left: i2, operator: N[255 & s2], right: f2 },
            a2
          )),
          (e10.assignable = 2),
          i2
        )
      }
      function eN(e10, t2, r2, n2, o2) {
        let a2 = eS(e10, (131072 | t2) ^ 131072, r2, 1, 0, e10.tokenStart)
        ;(R(e10, 32 | t2, 21), (e10.assignable = 1))
        let i2 = eS(e10, t2, r2, 1, 0, e10.tokenStart)
        return (
          (e10.assignable = 2),
          e10.finishNode({ type: 'ConditionalExpression', test: n2, consequent: a2, alternate: i2 }, o2)
        )
      }
      function eL(e10, t2, r2, n2, o2, a2, i2, s2) {
        let f2,
          l2,
          c2 = 8673330 & -((131072 & t2) > 0)
        for (
          e10.assignable = 2;
          8388608 & e10.getToken() &&
          ((l2 = 3840 & (f2 = e10.getToken())),
          ((524288 & f2 && 268435456 & i2) || (524288 & i2 && 268435456 & f2)) && e10.report(165),
          !(l2 + ((8391735 === f2) << 8) - ((c2 === f2) << 12) <= a2));
        )
          ($(e10, 32 | t2),
            (s2 = e10.finishNode(
              {
                type: 524288 & f2 || 268435456 & f2 ? 'LogicalExpression' : 'BinaryExpression',
                left: s2,
                right: eL(e10, t2, r2, n2, e10.tokenStart, l2, f2, eI(e10, t2, r2, 0, n2, 1)),
                operator: N[255 & f2],
              },
              o2
            )))
        return (1077936155 === e10.getToken() && e10.report(26), s2)
      }
      function eA(e10, t2, r2, n2, o2, a2, i2) {
        let { tokenStart: s2 } = e10
        R(e10, 32 | t2, 2162700)
        let f2 = []
        if (1074790415 !== e10.getToken()) {
          for (; 134283267 === e10.getToken(); ) {
            let { index: r3, tokenStart: n3, tokenIndex: o3, tokenValue: a3 } = e10,
              s3 = e10.getToken(),
              l2 = ez(e10, t2)
            if (I(e10, r3, o3, a3)) {
              if (((t2 |= 1), 128 & e10.flags)) throw new C(n3, e10.currentLocation, 66)
              if (64 & e10.flags) throw new C(n3, e10.currentLocation, 9)
              if (4096 & e10.flags) throw new C(n3, e10.currentLocation, 15)
              i2?.reportScopeError()
            }
            f2.push(eu(e10, t2, l2, s3, n3))
          }
          1 & t2 &&
            (a2 && ((537079808 & a2) == 537079808 && e10.report(119), (36864 & a2) == 36864 && e10.report(40)),
            512 & e10.flags && e10.report(119),
            256 & e10.flags && e10.report(118))
        }
        for (
          e10.flags = (512 | e10.flags | 4416) ^ 4928, e10.destructible = (256 | e10.destructible) ^ 256;
          1074790415 !== e10.getToken();
        )
          f2.push(ea(e10, t2, r2, n2, 4, {}))
        return (
          R(e10, 24 & o2 ? 32 | t2 : t2, 1074790415),
          (e10.flags &= -4289),
          1077936155 === e10.getToken() && e10.report(26),
          e10.finishNode({ type: 'BlockStatement', body: f2 }, s2)
        )
      }
      function eI(e10, t2, r2, n2, o2, a2) {
        let i2 = e10.tokenStart,
          s2 = eR(e10, t2, r2, 2, 0, n2, o2, a2, i2)
        return eD(e10, t2, r2, s2, o2, 0, i2)
      }
      function eD(e10, t2, r2, n2, o2, a2, i2) {
        if ((33619968 & e10.getToken()) == 33619968 && (1 & e10.flags) == 0) {
          var s2, f2
          let r3
          ;((s2 = t2),
            (f2 = n2),
            2 & e10.assignable && e10.report(55),
            (r3 = e10.getToken()),
            $(e10, s2),
            (e10.assignable = 2),
            (n2 = e10.finishNode({ type: 'UpdateExpression', argument: f2, operator: N[255 & r3], prefix: false }, i2)))
        } else if ((67108864 & e10.getToken()) == 67108864) {
          switch (((t2 = (131072 | t2) ^ 131072), e10.getToken())) {
            case 67108877: {
              ;($(e10, (262144 | t2 | 8) ^ 8),
                16 & t2 && 130 === e10.getToken() && 'super' === e10.tokenValue && e10.report(173),
                (e10.assignable = 1))
              let o3 = eV(e10, 64 | t2, r2)
              n2 = e10.finishNode(
                { type: 'MemberExpression', object: n2, computed: false, property: o3, optional: false },
                i2
              )
              break
            }
            case 69271571: {
              let a3 = false
              ;((2048 & e10.flags) == 2048 && ((a3 = true), (e10.flags = (2048 | e10.flags) ^ 2048)), $(e10, 32 | t2))
              let { tokenStart: s3 } = e10,
                f3 = eC(e10, t2, r2, o2, 1, s3)
              ;(R(e10, t2, 20),
                (e10.assignable = 1),
                (n2 = e10.finishNode(
                  { type: 'MemberExpression', object: n2, computed: true, property: f3, optional: false },
                  i2
                )),
                a3 && (e10.flags |= 2048))
              break
            }
            case 67174411: {
              if ((1024 & e10.flags) == 1024) return ((e10.flags = (1024 | e10.flags) ^ 1024), n2)
              let a3 = false
              ;(2048 & e10.flags) == 2048 && ((a3 = true), (e10.flags = (2048 | e10.flags) ^ 2048))
              let s3 = eF(e10, t2, r2, o2)
              ;((e10.assignable = 2),
                (n2 = e10.finishNode({ type: 'CallExpression', callee: n2, arguments: s3, optional: false }, i2)),
                a3 && (e10.flags |= 2048))
              break
            }
            case 67108990:
              ;($(e10, (262144 | t2 | 8) ^ 8),
                (e10.flags |= 2048),
                (e10.assignable = 2),
                (n2 = (function (e11, t3, r3, n3, o3) {
                  let a3,
                    i3 = false
                  if (
                    ((69271571 === e11.getToken() || 67174411 === e11.getToken()) &&
                      (2048 & e11.flags) == 2048 &&
                      ((i3 = true), (e11.flags = (2048 | e11.flags) ^ 2048)),
                    69271571 === e11.getToken())
                  ) {
                    $(e11, 32 | t3)
                    let { tokenStart: i4 } = e11,
                      s3 = eC(e11, t3, r3, 0, 1, i4)
                    ;(R(e11, t3, 20),
                      (e11.assignable = 2),
                      (a3 = e11.finishNode(
                        { type: 'MemberExpression', object: n3, computed: true, optional: true, property: s3 },
                        o3
                      )))
                  } else if (67174411 === e11.getToken()) {
                    let i4 = eF(e11, t3, r3, 0)
                    ;((e11.assignable = 2),
                      (a3 = e11.finishNode({ type: 'CallExpression', callee: n3, arguments: i4, optional: true }, o3)))
                  } else {
                    let i4 = eV(e11, t3, r3)
                    ;((e11.assignable = 2),
                      (a3 = e11.finishNode(
                        { type: 'MemberExpression', object: n3, computed: false, optional: true, property: i4 },
                        o3
                      )))
                  }
                  return (i3 && (e11.flags |= 2048), a3)
                })(e10, t2, r2, n2, i2)))
              break
            default:
              ;((2048 & e10.flags) == 2048 && e10.report(166),
                (e10.assignable = 2),
                (n2 = e10.finishNode(
                  {
                    type: 'TaggedTemplateExpression',
                    tag: n2,
                    quasi: 67174408 === e10.getToken() ? eM(e10, 64 | t2, r2) : ej(e10, t2),
                  },
                  i2
                )))
          }
          n2 = eD(e10, t2, r2, n2, 0, 1, i2)
        }
        return (
          0 === a2 &&
            (2048 & e10.flags) == 2048 &&
            ((e10.flags = (2048 | e10.flags) ^ 2048),
            (n2 = e10.finishNode({ type: 'ChainExpression', expression: n2 }, i2))),
          n2
        )
      }
      function eV(e10, t2, r2) {
        return (
          (143360 & e10.getToken()) == 0 &&
            -2147483528 !== e10.getToken() &&
            -2147483527 !== e10.getToken() &&
            130 !== e10.getToken() &&
            e10.report(160),
          130 === e10.getToken() ? te(e10, t2, r2, 0) : eH(e10, t2)
        )
      }
      function eR(e10, t2, r2, n2, o2, a2, i2, s2, l2) {
        var c2, u2, d2, g2, x2, k2, h2, b2, m2, T2, y2, w2, S2, v2, q2
        if ((143360 & e10.getToken()) == 143360) {
          switch (e10.getToken()) {
            case 209006:
              ;(i2 && (e10.destructible |= 128), 524288 & t2 && e10.report(177))
              let f2 = e0(e10, t2, r2)
              if ('ArrowFunctionExpression' === f2.type || (65536 & e10.getToken()) == 0) {
                if (2048 & t2)
                  throw new C(l2, { index: e10.startIndex, line: e10.startLine, column: e10.startColumn }, 176)
                if (2 & t2 || (8192 & t2 && 2048 & t2))
                  throw new C(l2, { index: e10.startIndex, line: e10.startLine, column: e10.startColumn }, 110)
                return f2
              }
              if (8192 & t2)
                throw new C(l2, { index: e10.startIndex, line: e10.startLine, column: e10.startColumn }, 31)
              if (2048 & t2 || (2 & t2 && 8 & t2)) {
                if (o2) throw new C(l2, { index: e10.startIndex, line: e10.startLine, column: e10.startColumn }, 0)
                let n3 = eI(e10, t2, r2, 0, 0, 1)
                return (
                  8391735 === e10.getToken() && e10.report(33),
                  (e10.assignable = 2),
                  e10.finishNode({ type: 'AwaitExpression', argument: n3 }, l2)
                )
              }
              if (2 & t2) throw new C(l2, { index: e10.startIndex, line: e10.startLine, column: e10.startColumn }, 98)
              return f2
            case 241771:
              if ((i2 && (e10.destructible |= 256), 1024 & t2)) {
                ;($(e10, 32 | t2),
                  8192 & t2 && e10.report(32),
                  a2 || e10.report(26),
                  22 === e10.getToken() && e10.report(124))
                let n3 = null,
                  o3 = false
                return (
                  (1 & e10.flags) == 0
                    ? ((o3 = V(e10, 32 | t2, 8391476)),
                      (77824 & e10.getToken() || o3) && (n3 = eS(e10, t2, r2, 1, 0, e10.tokenStart)))
                    : 8391476 === e10.getToken() && e10.report(30, N[255 & e10.getToken()]),
                  (e10.assignable = 2),
                  e10.finishNode({ type: 'YieldExpression', argument: n3, delegate: o3 }, l2)
                )
              }
              return (1 & t2 && e10.report(97, 'yield'), e0(e10, t2, r2))
            case 209005:
              return (function (e11, t3, r3, n3, o3, a3, i3, s3) {
                let f3 = e11.getToken(),
                  l3 = eH(e11, t3),
                  { flags: c4 } = e11
                if ((1 & c4) == 0) {
                  if (86104 === e11.getToken()) return e_(e11, t3, r3, 1, n3, s3)
                  if (M(t3, e11.getToken()))
                    return (
                      o3 || e11.report(0),
                      (36864 & e11.getToken()) == 36864 && (e11.flags |= 256),
                      e8(e11, t3, r3, a3, s3)
                    )
                }
                return i3 || 67174411 !== e11.getToken()
                  ? 10 === e11.getToken()
                    ? (J(e11, t3, f3),
                      i3 && e11.report(51),
                      (36864 & f3) == 36864 && (e11.flags |= 256),
                      e1(e11, t3, r3, e11.tokenValue, l3, i3, a3, 0, s3))
                    : ((e11.assignable = 1), l3)
                  : e6(e11, t3, r3, l3, a3, 1, 0, c4, s3)
              })(e10, t2, r2, i2, s2, a2, o2, l2)
          }
          let { tokenValue: c3 } = e10,
            u3 = e10.getToken(),
            d3 = eH(e10, 64 | t2)
          return 10 === e10.getToken()
            ? (s2 || e10.report(0),
              J(e10, t2, u3),
              (36864 & u3) == 36864 && (e10.flags |= 256),
              e1(e10, t2, r2, c3, d3, o2, a2, 0, l2))
            : (!(16 & t2) || 32768 & t2 || 8192 & t2 || 'arguments' !== e10.tokenValue || e10.report(130),
              (255 & u3) == 73 && (1 & t2 && e10.report(113), 24 & n2 && e10.report(100)),
              (e10.assignable = 1 & t2 && (537079808 & u3) == 537079808 ? 2 : 1),
              d3)
        }
        if ((134217728 & e10.getToken()) == 134217728) return ez(e10, t2)
        switch (e10.getToken()) {
          case 33619993:
          case 33619994:
            let E2, L2
            return (
              o2 && e10.report(56),
              s2 || e10.report(0),
              (E2 = e10.getToken()),
              $(e10, 32 | t2),
              (L2 = eI(e10, t2, r2, 0, 0, 1)),
              2 & e10.assignable && e10.report(55),
              (e10.assignable = 2),
              e10.finishNode({ type: 'UpdateExpression', argument: L2, operator: N[255 & E2], prefix: true }, l2)
            )
          case 16863276:
          case 16842798:
          case 16842799:
          case 25233968:
          case 25233969:
          case 16863275:
          case 16863277:
            return (function (e11, t3, r3, n3, o3) {
              n3 || e11.report(0)
              let { tokenStart: a3 } = e11,
                i3 = e11.getToken()
              $(e11, 32 | t3)
              let s3 = eI(e11, t3, r3, 0, o3, 1)
              if ((8391735 === e11.getToken() && e11.report(33), 1 & t3 && 16863276 === i3))
                if ('Identifier' === s3.type) e11.report(121)
                else s3.property && 'PrivateIdentifier' === s3.property.type && e11.report(127)
              return (
                (e11.assignable = 2),
                e11.finishNode({ type: 'UnaryExpression', operator: N[255 & i3], argument: s3, prefix: true }, a3)
              )
            })(e10, t2, r2, s2, i2)
          case 86104:
            return e_(e10, t2, r2, 0, i2, l2)
          case 2162700:
            let A2
            return (
              (A2 = eW((c2 = e10), t2, void 0, r2, +!a2, i2, 0, 2, 0)),
              64 & c2.destructible && c2.report(63),
              8 & c2.destructible && c2.report(62),
              A2
            )
          case 69271571:
            let I2
            return (
              (I2 = e$((u2 = e10), t2, void 0, r2, +!a2, i2, 0, 2, 0)),
              64 & u2.destructible && u2.report(63),
              8 & u2.destructible && u2.report(62),
              I2
            )
          case 67174411:
            return (function (e11, t3, r3, n3, o3, a3, i3) {
              let s3
              e11.flags = (128 | e11.flags) ^ 128
              let f2 = e11.tokenStart
              $(e11, 32 | t3 | 262144)
              let l3 = e11.createScopeIfLexical()?.createChildScope(512)
              if (V(e11, (t3 = (131072 | t3) ^ 131072), 16)) return e2(e11, t3, l3, r3, [], n3, 0, i3)
              let c3 = 0
              e11.destructible &= -385
              let u3 = [],
                d3 = 0,
                p2 = 0,
                g3 = 0,
                x3 = e11.tokenStart
              for (e11.assignable = 1; 16 !== e11.getToken(); ) {
                let { tokenStart: n4 } = e11,
                  o4 = e11.getToken()
                if (143360 & o4)
                  (l3?.addBlockName(t3, e11.tokenValue, 1, 0),
                    (537079808 & o4) == 537079808 ? (p2 = 1) : (36864 & o4) == 36864 && (g3 = 1),
                    (s3 = eR(e11, t3, r3, 1, 0, 1, 1, 1, n4)),
                    16 === e11.getToken() || 18 === e11.getToken()
                      ? 2 & e11.assignable && ((c3 |= 16), (p2 = 1))
                      : (1077936155 === e11.getToken() ? (p2 = 1) : (c3 |= 16),
                        (s3 = eD(e11, t3, r3, s3, 1, 0, n4)),
                        16 !== e11.getToken() && 18 !== e11.getToken() && (s3 = eq(e11, t3, r3, 1, 0, n4, s3))))
                else if ((2097152 & o4) == 2097152)
                  ((s3 =
                    2162700 === o4
                      ? eW(e11, 262144 | t3, l3, r3, 0, 1, 0, 1, 0)
                      : e$(e11, 262144 | t3, l3, r3, 0, 1, 0, 1, 0)),
                    (c3 |= e11.destructible),
                    (p2 = 1),
                    (e11.assignable = 2),
                    16 !== e11.getToken() &&
                      18 !== e11.getToken() &&
                      (8 & c3 && e11.report(122),
                      (s3 = eD(e11, t3, r3, s3, 0, 0, n4)),
                      (c3 |= 16),
                      16 !== e11.getToken() && 18 !== e11.getToken() && (s3 = eq(e11, t3, r3, 0, 0, n4, s3))))
                else if (14 === o4) {
                  ;((s3 = eZ(e11, t3, l3, r3, 16, 1, 0, 0, 1, 0)),
                    16 & e11.destructible && e11.report(74),
                    (p2 = 1),
                    d3 && (16 === e11.getToken() || 18 === e11.getToken()) && u3.push(s3),
                    (c3 |= 8))
                  break
                } else {
                  if (
                    ((c3 |= 16),
                    (s3 = eS(e11, t3, r3, 1, 1, n4)),
                    d3 && (16 === e11.getToken() || 18 === e11.getToken()) && u3.push(s3),
                    18 !== e11.getToken() || d3 || ((d3 = 1), (u3 = [s3])),
                    d3)
                  ) {
                    for (; V(e11, 32 | t3, 18); ) u3.push(eS(e11, t3, r3, 1, 1, e11.tokenStart))
                    ;((e11.assignable = 2), (s3 = e11.finishNode({ type: 'SequenceExpression', expressions: u3 }, x3)))
                  }
                  return (
                    R(e11, t3, 16),
                    (e11.destructible = c3),
                    e11.options.preserveParens
                      ? e11.finishNode({ type: 'ParenthesizedExpression', expression: s3 }, f2)
                      : s3
                  )
                }
                if ((d3 && (16 === e11.getToken() || 18 === e11.getToken()) && u3.push(s3), !V(e11, 32 | t3, 18))) break
                if ((d3 || ((d3 = 1), (u3 = [s3])), 16 === e11.getToken())) {
                  c3 |= 8
                  break
                }
              }
              return (d3 &&
                ((e11.assignable = 2), (s3 = e11.finishNode({ type: 'SequenceExpression', expressions: u3 }, x3))),
              R(e11, t3, 16),
              16 & c3 && 8 & c3 && e11.report(151),
              (c3 |= 256 & e11.destructible ? 256 : 128 & e11.destructible ? 128 : 0),
              10 === e11.getToken())
                ? (48 & c3 && e11.report(49),
                  2050 & t3 && 128 & c3 && e11.report(31),
                  1025 & t3 && 256 & c3 && e11.report(32),
                  p2 && (e11.flags |= 128),
                  g3 && (e11.flags |= 256),
                  e2(e11, t3, l3, r3, d3 ? u3 : [s3], n3, 0, i3))
                : (64 & c3 && e11.report(63),
                  8 & c3 && e11.report(144),
                  (e11.destructible = ((256 | e11.destructible) ^ 256) | c3),
                  e11.options.preserveParens
                    ? e11.finishNode({ type: 'ParenthesizedExpression', expression: s3 }, f2)
                    : s3)
            })(e10, 64 | t2, r2, a2, 1, 0, l2)
          case 86021:
          case 86022:
          case 86023:
            let D2, P2, U2
            return (
              (d2 = e10),
              (g2 = t2),
              (D2 = d2.tokenStart),
              (P2 = N[255 & d2.getToken()]),
              (U2 = 86023 === d2.getToken() ? null : 'true' === P2),
              $(d2, g2),
              (d2.assignable = 2),
              d2.finishNode(
                d2.options.raw ? { type: 'Literal', value: U2, raw: P2 } : { type: 'Literal', value: U2 },
                D2
              )
            )
          case 86111:
            return (function (e11, t3) {
              let { tokenStart: r3 } = e11
              return ($(e11, t3), (e11.assignable = 2), e11.finishNode({ type: 'ThisExpression' }, r3))
            })(e10, t2)
          case 65540:
            return (function (e11, t3) {
              let { tokenRaw: r3, tokenRegExp: n3, tokenValue: o3, tokenStart: a3 } = e11
              ;($(e11, t3), (e11.assignable = 2))
              let i3 = { type: 'Literal', value: o3, regex: n3 }
              return (e11.options.raw && (i3.raw = r3), e11.finishNode(i3, a3))
            })(e10, t2)
          case 132:
          case 86094:
            let B2, G2, F2, H2, z2
            return (
              (x2 = e10),
              (k2 = t2),
              (h2 = r2),
              (b2 = i2),
              (m2 = l2),
              (B2 = null),
              (G2 = null),
              (F2 = e7(x2, k2, h2)),
              $(x2, (k2 = (1 | k2 | 16384) ^ 16384)),
              4096 & x2.getToken() &&
                20565 !== x2.getToken() &&
                (O(x2, k2, x2.getToken()) && x2.report(118),
                (537079808 & x2.getToken()) == 537079808 && x2.report(119),
                (B2 = eH(x2, k2))),
              (H2 = k2),
              V(x2, 32 | k2, 20565) ? ((G2 = eI(x2, k2, h2, 0, b2, 0)), (H2 |= 512)) : (H2 = (512 | H2) ^ 512),
              (z2 = e9(x2, H2, k2, void 0, h2, 2, 0, b2)),
              (x2.assignable = 2),
              x2.finishNode(
                {
                  type: 'ClassExpression',
                  id: B2,
                  superClass: G2,
                  body: z2,
                  ...(x2.options.next ? { decorators: F2 } : null),
                },
                m2
              )
            )
          case 86109:
            return (function (e11, t3) {
              let { tokenStart: r3 } = e11
              switch (($(e11, t3), e11.getToken())) {
                case 67108990:
                  e11.report(167)
                case 67174411:
                  ;((512 & t3) == 0 && e11.report(28), (e11.assignable = 2))
                  break
                case 69271571:
                case 67108877:
                  ;((256 & t3) == 0 && e11.report(29), (e11.assignable = 1))
                  break
                default:
                  e11.report(30, 'super')
              }
              return e11.finishNode({ type: 'Super' }, r3)
            })(e10, t2)
          case 67174409:
            return ej(e10, t2)
          case 67174408:
            return eM(e10, t2, r2)
          case 86107:
            return (function (e11, t3, r3, n3) {
              let { tokenStart: o3 } = e11,
                a3 = eH(e11, 32 | t3),
                { tokenStart: i3 } = e11
              if (V(e11, t3, 67108877)) {
                if (65536 & t3 && 209029 === e11.getToken()) {
                  var s3, f2, l3, c3
                  let r4
                  return (
                    (e11.assignable = 2),
                    (s3 = e11),
                    (f2 = t3),
                    (l3 = a3),
                    (c3 = o3),
                    (r4 = eH(s3, f2)),
                    s3.finishNode({ type: 'MetaProperty', meta: l3, property: r4 }, c3)
                  )
                }
                e11.report(94)
              }
              ;((e11.assignable = 2),
                (16842752 & e11.getToken()) == 16842752 && e11.report(65, N[255 & e11.getToken()]))
              let u3 = eR(e11, t3, r3, 2, 1, 0, n3, 1, i3)
              ;((t3 = (131072 | t3) ^ 131072), 67108990 === e11.getToken() && e11.report(168))
              let d3 = (function e12(t4, r4, n4, o4, a4, i4) {
                let s4 = t4.getToken()
                if (67108864 & s4) {
                  if (67108877 === s4) {
                    ;($(t4, 262144 | r4), (t4.assignable = 1))
                    let a5 = eV(t4, r4, n4)
                    return e12(
                      t4,
                      r4,
                      n4,
                      t4.finishNode(
                        { type: 'MemberExpression', object: o4, computed: false, property: a5, optional: false },
                        i4
                      ),
                      0,
                      i4
                    )
                  } else if (69271571 === s4) {
                    $(t4, 32 | r4)
                    let { tokenStart: s5 } = t4,
                      f3 = eC(t4, r4, n4, a4, 1, s5)
                    return (
                      R(t4, r4, 20),
                      (t4.assignable = 1),
                      e12(
                        t4,
                        r4,
                        n4,
                        t4.finishNode(
                          { type: 'MemberExpression', object: o4, computed: true, property: f3, optional: false },
                          i4
                        ),
                        0,
                        i4
                      )
                    )
                  } else if (67174408 === s4 || 67174409 === s4)
                    return (
                      (t4.assignable = 2),
                      e12(
                        t4,
                        r4,
                        n4,
                        t4.finishNode(
                          {
                            type: 'TaggedTemplateExpression',
                            tag: o4,
                            quasi: 67174408 === t4.getToken() ? eM(t4, 64 | r4, n4) : ej(t4, 64 | r4),
                          },
                          i4
                        ),
                        0,
                        i4
                      )
                    )
                }
                return o4
              })(e11, t3, r3, u3, n3, i3)
              return (
                (e11.assignable = 2),
                e11.finishNode(
                  {
                    type: 'NewExpression',
                    callee: d3,
                    arguments: 67174411 === e11.getToken() ? eF(e11, t3, r3, n3) : [],
                  },
                  o3
                )
              )
            })(e10, t2, r2, i2)
          case 134283388:
            return eG(e10, t2)
          case 130:
            return te(e10, t2, r2, 0)
          case 86106:
            let X2
            return (
              (T2 = e10),
              (y2 = t2),
              (w2 = r2),
              (S2 = o2),
              (v2 = i2),
              (q2 = l2),
              (X2 = eH(T2, y2)),
              67108877 === T2.getToken()
                ? eP(T2, y2, X2, q2)
                : (S2 && T2.report(142),
                  (X2 = eU(T2, y2, w2, v2, q2)),
                  (T2.assignable = 2),
                  eD(T2, y2, w2, X2, v2, 0, q2))
            )
          case 8456256:
            if (e10.options.jsx)
              return (function e11(t3, r3, n3, o3, a3) {
                var i3, s3, l3, c3, u3, d3, g3
                let x3, k3, h3
                if ((o3 || R(t3, r3, 8456256), 8390721 === t3.getToken())) {
                  let f2 = ((i3 = t3), (s3 = a3), W(i3), i3.finishNode({ type: 'JSXOpeningFragment' }, s3)),
                    [l4, c4] = (function (t4, r4, n4, o4) {
                      let a4 = []
                      for (;;) {
                        let i4 = (function (t5, r5, n5, o5) {
                          if (137 === t5.getToken()) return to(t5, r5)
                          if (2162700 === t5.getToken()) return ts(t5, r5, n5, 1, 0)
                          if (8456256 === t5.getToken()) {
                            let { tokenStart: a5 } = t5
                            if (($(t5, r5), 8457014 === t5.getToken()))
                              return (
                                R(t5, r5, 8457014),
                                8390721 !== t5.getToken() && t5.report(25, N[65]),
                                o5 ? W(t5) : $(t5, r5),
                                t5.finishNode({ type: 'JSXClosingFragment' }, a5)
                              )
                            return e11(t5, r5, n5, 1, a5)
                          }
                          t5.report(0)
                        })(t4, r4, n4, o4)
                        if ('JSXClosingFragment' === i4.type) return [a4, i4]
                        a4.push(i4)
                      }
                    })(t3, r3, n3, o3)
                  return t3.finishNode(
                    { type: 'JSXFragment', openingFragment: f2, children: l4, closingFragment: c4 },
                    a3
                  )
                }
                8457014 === t3.getToken() && t3.report(30, N[255 & t3.getToken()])
                let b3 = null,
                  m3 = [],
                  T3 =
                    ((l3 = t3),
                    (c3 = r3),
                    (u3 = n3),
                    (d3 = o3),
                    (g3 = a3),
                    (143360 & l3.getToken()) != 143360 && (4096 & l3.getToken()) != 4096 && l3.report(0),
                    (x3 = ta(l3, c3)),
                    (k3 = (function (t4, r4, n4) {
                      let o4 = []
                      for (; 8457014 !== t4.getToken() && 8390721 !== t4.getToken() && 1048576 !== t4.getToken(); )
                        o4.push(
                          (function (t5, r5, n5) {
                            let { tokenStart: o5 } = t5
                            if (2162700 === t5.getToken()) {
                              let e12, o6
                              return (
                                (e12 = t5.tokenStart),
                                $(t5, r5),
                                R(t5, r5, 14),
                                (o6 = eS(t5, r5, n5, 1, 0, t5.tokenStart)),
                                R(t5, r5, 1074790415),
                                t5.finishNode({ type: 'JSXSpreadAttribute', argument: o6 }, e12)
                              )
                            }
                            Q(t5)
                            let a4 = null,
                              i4 = tf(t5, r5)
                            if ((21 === t5.getToken() && (i4 = ti(t5, r5, i4, o5)), 1077936155 === t5.getToken()))
                              switch (
                                ((t5.startIndex = t5.tokenIndex = t5.index),
                                (t5.startColumn = t5.tokenColumn = t5.column),
                                (t5.startLine = t5.tokenLine = t5.line),
                                t5.setToken(
                                  8192 & p[t5.currentChar]
                                    ? (function (e12) {
                                        let t6 = e12.currentChar,
                                          r6 = f(e12),
                                          n6 = e12.index
                                        for (; r6 !== t6; ) (e12.index >= e12.end && e12.report(16), (r6 = f(e12)))
                                        return (
                                          r6 !== t6 && e12.report(16),
                                          (e12.tokenValue = e12.source.slice(n6, e12.index)),
                                          f(e12),
                                          e12.options.raw &&
                                            (e12.tokenRaw = e12.source.slice(e12.tokenIndex, e12.index)),
                                          134283267
                                        )
                                      })(t5)
                                    : Y(t5, r5, 0)
                                ),
                                t5.getToken())
                              ) {
                                case 134283267:
                                  a4 = ez(t5, r5)
                                  break
                                case 8456256:
                                  a4 = e11(t5, r5, n5, 0, t5.tokenStart)
                                  break
                                case 2162700:
                                  a4 = ts(t5, r5, n5, 0, 1)
                                  break
                                default:
                                  t5.report(154)
                              }
                            return t5.finishNode({ type: 'JSXAttribute', value: a4, name: i4 }, o5)
                          })(t4, r4, n4)
                        )
                      return o4
                    })(l3, c3, u3)),
                    (h3 = 8457014 === l3.getToken()) && R(l3, c3, 8457014),
                    8390721 !== l3.getToken() && l3.report(25, N[65]),
                    d3 || !h3 ? W(l3) : $(l3, c3),
                    l3.finishNode({ type: 'JSXOpeningElement', name: x3, attributes: k3, selfClosing: h3 }, g3))
                if (!T3.selfClosing) {
                  ;[m3, b3] = (function (t4, r4, n4, o4) {
                    let a5 = []
                    for (;;) {
                      let i4 = (function (t5, r5, n5, o5) {
                        if (137 === t5.getToken()) return to(t5, r5)
                        if (2162700 === t5.getToken()) return ts(t5, r5, n5, 1, 0)
                        if (8456256 === t5.getToken()) {
                          let { tokenStart: a6 } = t5
                          if (($(t5, r5), 8457014 === t5.getToken())) {
                            let e12
                            return (
                              R(t5, r5, 8457014),
                              (e12 = ta(t5, r5)),
                              8390721 !== t5.getToken() && t5.report(25, N[65]),
                              o5 ? W(t5) : $(t5, r5),
                              t5.finishNode({ type: 'JSXClosingElement', name: e12 }, a6)
                            )
                          }
                          return e11(t5, r5, n5, 1, a6)
                        }
                        t5.report(0)
                      })(t4, r4, n4, o4)
                      if ('JSXClosingElement' === i4.type) return [a5, i4]
                      a5.push(i4)
                    }
                  })(t3, r3, n3, o3)
                  let a4 = j(b3.name)
                  j(T3.name) !== a4 && t3.report(155, a4)
                }
                return t3.finishNode({ type: 'JSXElement', children: m3, openingElement: T3, closingElement: b3 }, a3)
              })(e10, t2, r2, 0, e10.tokenStart)
          default:
            if (M(t2, e10.getToken())) return e0(e10, t2, r2)
            e10.report(30, N[255 & e10.getToken()])
        }
      }
      function eP(e10, t2, r2, n2) {
        ;((2 & t2) == 0 && e10.report(169), $(e10, t2))
        let o2 = e10.getToken()
        return (
          209030 !== o2 && 'meta' !== e10.tokenValue ? e10.report(174) : -2147483648 & o2 && e10.report(175),
          (e10.assignable = 2),
          e10.finishNode({ type: 'MetaProperty', meta: r2, property: eH(e10, t2) }, n2)
        )
      }
      function eU(e10, t2, r2, n2, o2) {
        ;(R(e10, 32 | t2, 67174411), 14 === e10.getToken() && e10.report(143))
        let a2 = eS(e10, t2, r2, 1, n2, e10.tokenStart),
          i2 = null
        18 === e10.getToken() &&
          (R(e10, t2, 18),
          16 !== e10.getToken() && (i2 = eS(e10, (131072 | t2) ^ 131072, r2, 1, n2, e10.tokenStart)),
          V(e10, t2, 18))
        let s2 = { type: 'ImportExpression', source: a2, options: i2 }
        return (R(e10, t2, 16), e10.finishNode(s2, o2))
      }
      function eB(e10, t2) {
        if (!V(e10, t2, 20579)) return []
        R(e10, t2, 2162700)
        let r2 = [],
          n2 = /* @__PURE__ */ new Set()
        for (; 1074790415 !== e10.getToken(); ) {
          var o2, a2
          let i2 = e10.tokenStart,
            s2 =
              ((o2 = e10),
              (a2 = t2),
              134283267 === o2.getToken()
                ? ez(o2, a2)
                : 143360 & o2.getToken()
                  ? eH(o2, a2)
                  : void o2.report(30, N[255 & o2.getToken()]))
          R(e10, t2, 21)
          let f2 = (function (e11, t3) {
              if (134283267 === e11.getToken()) return ez(e11, t3)
              e11.report(30, N[255 & e11.getToken()])
            })(e10, t2),
            l2 = 'Literal' === s2.type ? s2.value : s2.name
          ;(n2.has(l2) && e10.report(145, `${l2}`),
            n2.add(l2),
            r2.push(e10.finishNode({ type: 'ImportAttribute', key: s2, value: f2 }, i2)),
            1074790415 !== e10.getToken() && R(e10, t2, 18))
        }
        return (R(e10, t2, 1074790415), r2)
      }
      function eO(e10, t2) {
        return 134283267 === e10.getToken()
          ? (!(function (e11, t3) {
              let r2 = t3.length
              for (let n2 = 0; n2 < r2; n2++) {
                let o2 = t3.charCodeAt(n2)
                ;(64512 & o2) == 55296 &&
                  (o2 > 56319 || ++n2 >= r2 || (64512 & t3.charCodeAt(n2)) != 56320) &&
                  e11.report(171, JSON.stringify(t3.charAt(n2--)))
              }
            })(e10, e10.tokenValue),
            ez(e10, t2))
          : 143360 & e10.getToken()
            ? eH(e10, t2)
            : void e10.report(30, N[255 & e10.getToken()])
      }
      function eG(e10, t2) {
        let { tokenRaw: r2, tokenValue: n2, tokenStart: o2 } = e10
        ;($(e10, t2), (e10.assignable = 2))
        let a2 = { type: 'Literal', value: n2, bigint: String(n2) }
        return (e10.options.raw && (a2.raw = r2), e10.finishNode(a2, o2))
      }
      function ej(e10, t2) {
        e10.assignable = 2
        let { tokenValue: r2, tokenRaw: n2, tokenStart: o2 } = e10
        R(e10, t2, 67174409)
        let a2 = [eJ(e10, r2, n2, o2, true)]
        return e10.finishNode({ type: 'TemplateLiteral', expressions: [], quasis: a2 }, o2)
      }
      function eM(e10, t2, r2) {
        var n2
        let { tokenValue: o2, tokenRaw: a2, tokenStart: i2 } = e10
        R(e10, (-65 & (t2 = (131072 | t2) ^ 131072)) | 32, 67174408)
        let s2 = [eJ(e10, o2, a2, i2, false)],
          f2 = [eC(e10, -65 & t2, r2, 0, 1, e10.tokenStart)]
        for (
          1074790415 !== e10.getToken() && e10.report(83);
          67174409 !==
          e10.setToken(((n2 = t2), e10.index >= e10.end && e10.report(0), e10.index--, e10.column--, S(e10, n2)), true);
        ) {
          let { tokenValue: n3, tokenRaw: o3, tokenStart: a3 } = e10
          ;(R(e10, (-65 & t2) | 32, 67174408),
            s2.push(eJ(e10, n3, o3, a3, false)),
            f2.push(eC(e10, t2, r2, 0, 1, e10.tokenStart)),
            1074790415 !== e10.getToken() && e10.report(83))
        }
        {
          let { tokenValue: r3, tokenRaw: n3, tokenStart: o3 } = e10
          ;(R(e10, t2, 67174409), s2.push(eJ(e10, r3, n3, o3, true)))
        }
        return e10.finishNode({ type: 'TemplateLiteral', expressions: f2, quasis: s2 }, i2)
      }
      function eJ(e10, t2, r2, n2, o2) {
        let a2 = e10.finishNode({ type: 'TemplateElement', value: { cooked: t2, raw: r2 }, tail: o2 }, n2),
          i2 = o2 ? 1 : 2
        return (
          e10.options.ranges && ((a2.start += 1), (a2.range[0] += 1), (a2.end -= i2), (a2.range[1] -= i2)),
          e10.options.loc && ((a2.loc.start.column += 1), (a2.loc.end.column -= i2)),
          a2
        )
      }
      function eF(e10, t2, r2, n2) {
        var o2, a2, i2
        let s2, f2
        $(e10, 32 | t2)
        let l2 = []
        if (16 === e10.getToken()) return ($(e10, 64 | t2), l2)
        for (
          ;
          16 !== e10.getToken() &&
          (14 === e10.getToken()
            ? l2.push(
                ((o2 = e10),
                (a2 = t2),
                (i2 = r2),
                (s2 = o2.tokenStart),
                R(o2, 32 | (a2 = (131072 | a2) ^ 131072), 14),
                (f2 = eS(o2, a2, i2, 1, 0, o2.tokenStart)),
                (o2.assignable = 1),
                o2.finishNode({ type: 'SpreadElement', argument: f2 }, s2))
              )
            : l2.push(eS(e10, t2, r2, 1, n2, e10.tokenStart)),
          18 === e10.getToken()) &&
          ($(e10, 32 | t2), 16 !== e10.getToken());
        );
        return (R(e10, 64 | t2, 16), l2)
      }
      function eH(e10, t2) {
        let { tokenValue: r2, tokenStart: n2 } = e10,
          o2 = 'await' === r2 && (-2147483648 & e10.getToken()) == 0
        return ($(e10, t2 | (32 * !!o2)), e10.finishNode({ type: 'Identifier', name: r2 }, n2))
      }
      function ez(e10, t2) {
        let { tokenValue: r2, tokenRaw: n2, tokenStart: o2 } = e10
        return 134283388 === e10.getToken()
          ? eG(e10, t2)
          : ($(e10, t2),
            (e10.assignable = 2),
            e10.finishNode(
              e10.options.raw ? { type: 'Literal', value: r2, raw: n2 } : { type: 'Literal', value: r2 },
              o2
            ))
      }
      function eX(e10, t2, r2, n2, o2, a2, i2, s2, f2) {
        let l2
        $(e10, 32 | t2)
        let c2 = a2 ? D(e10, t2, 8391476) : 0,
          u2 = null,
          d2 = r2 ? e10.createScope() : void 0
        if (67174411 === e10.getToken()) (1 & i2) == 0 && e10.report(39, 'Function')
        else {
          let n3 = 4 & o2 && ((8 & t2) == 0 || (2 & t2) == 0) ? 4 : 64 | (1024 * !!s2) | (1024 * !!c2)
          ;(B(e10, t2, e10.getToken()),
            r2 &&
              (4 & n3 ? r2.addVarName(t2, e10.tokenValue, n3) : r2.addBlockName(t2, e10.tokenValue, n3, o2),
              (d2 = d2?.createChildScope(128)),
              i2 && 2 & i2 && e10.declareUnboundVariable(e10.tokenValue)),
            (l2 = e10.getToken()),
            143360 & e10.getToken() ? (u2 = eH(e10, t2)) : e10.report(30, N[255 & e10.getToken()]))
        }
        let p2 = e4(
            e10,
            (8192 | (t2 = ((28416 | t2) ^ 28416) | 65536 | (2048 * !!s2) | (1024 * !!c2) | (262144 * !c2))) & -524289,
            (d2 = d2?.createChildScope(256)),
            n2,
            0,
            1
          ),
          g2 = eA(e10, ((524428 | t2) ^ 524428) | 36864, d2?.createChildScope(64), n2, 8, l2, d2)
        return e10.finishNode(
          { type: 'FunctionDeclaration', id: u2, params: p2, body: g2, async: 1 === s2, generator: 1 === c2 },
          f2
        )
      }
      function e_(e10, t2, r2, n2, o2, a2) {
        let i2
        $(e10, 32 | t2)
        let s2 = D(e10, t2, 8391476),
          f2 = (2048 * !!n2) | (1024 * !!s2),
          l2 = null,
          c2 = e10.createScopeIfLexical()
        143360 & e10.getToken() &&
          (B(e10, ((552704 | t2) ^ 552704) | f2, e10.getToken()),
          (c2 = c2?.createChildScope(128)),
          (i2 = e10.getToken()),
          (l2 = eH(e10, t2)))
        let u2 = e4(
            e10,
            (8192 | (t2 = ((552704 | t2) ^ 552704) | 65536 | f2 | (262144 * !s2))) & -524289,
            (c2 = c2?.createChildScope(256)),
            r2,
            o2,
            1
          ),
          d2 = eA(e10, (-131229 & t2) | 36864, c2?.createChildScope(64), r2, 0, i2, c2)
        return (
          (e10.assignable = 2),
          e10.finishNode(
            { type: 'FunctionExpression', id: l2, params: u2, body: d2, async: 1 === n2, generator: 1 === s2 },
            a2
          )
        )
      }
      function e$(e10, t2, r2, n2, o2, a2, i2, s2, f2) {
        let { tokenStart: l2 } = e10
        $(e10, 32 | t2)
        let c2 = [],
          u2 = 0
        for (t2 = (131072 | t2) ^ 131072; 20 !== e10.getToken(); )
          if (V(e10, 32 | t2, 18)) c2.push(null)
          else {
            let o3,
              { tokenStart: l3, tokenValue: d3 } = e10,
              p2 = e10.getToken()
            if (143360 & p2)
              if (((o3 = eR(e10, t2, n2, s2, 0, 1, a2, 1, l3)), 1077936155 === e10.getToken())) {
                ;(2 & e10.assignable && e10.report(26), $(e10, 32 | t2), r2?.addVarOrBlock(t2, d3, s2, f2))
                let c3 = eS(e10, t2, n2, 1, a2, e10.tokenStart)
                ;((o3 = e10.finishNode(
                  i2
                    ? { type: 'AssignmentPattern', left: o3, right: c3 }
                    : { type: 'AssignmentExpression', operator: '=', left: o3, right: c3 },
                  l3
                )),
                  (u2 |= 256 & e10.destructible ? 256 : 128 & e10.destructible ? 128 : 0))
              } else
                18 === e10.getToken() || 20 === e10.getToken()
                  ? (2 & e10.assignable ? (u2 |= 16) : r2?.addVarOrBlock(t2, d3, s2, f2),
                    (u2 |= 256 & e10.destructible ? 256 : 128 & e10.destructible ? 128 : 0))
                  : ((u2 |= 1 & s2 ? 32 : 16 * ((2 & s2) == 0)),
                    (o3 = eD(e10, t2, n2, o3, a2, 0, l3)),
                    18 !== e10.getToken() && 20 !== e10.getToken()
                      ? (1077936155 !== e10.getToken() && (u2 |= 16), (o3 = eq(e10, t2, n2, a2, i2, l3, o3)))
                      : 1077936155 !== e10.getToken() && (u2 |= 2 & e10.assignable ? 16 : 32))
            else
              2097152 & p2
                ? ((o3 =
                    2162700 === e10.getToken()
                      ? eW(e10, t2, r2, n2, 0, a2, i2, s2, f2)
                      : e$(e10, t2, r2, n2, 0, a2, i2, s2, f2)),
                  (u2 |= e10.destructible),
                  (e10.assignable = 16 & e10.destructible ? 2 : 1),
                  18 === e10.getToken() || 20 === e10.getToken()
                    ? 2 & e10.assignable && (u2 |= 16)
                    : 8 & e10.destructible
                      ? e10.report(71)
                      : ((o3 = eD(e10, t2, n2, o3, a2, 0, l3)),
                        (u2 = 2 & e10.assignable ? 16 : 0),
                        18 !== e10.getToken() && 20 !== e10.getToken()
                          ? (o3 = eq(e10, t2, n2, a2, i2, l3, o3))
                          : 1077936155 !== e10.getToken() && (u2 |= 2 & e10.assignable ? 16 : 32)))
                : 14 === p2
                  ? ((o3 = eZ(e10, t2, r2, n2, 20, s2, f2, 0, a2, i2)),
                    (u2 |= e10.destructible),
                    18 !== e10.getToken() && 20 !== e10.getToken() && e10.report(30, N[255 & e10.getToken()]))
                  : ((o3 = eI(e10, t2, n2, 1, 0, 1)),
                    18 !== e10.getToken() && 20 !== e10.getToken()
                      ? ((o3 = eq(e10, t2, n2, a2, i2, l3, o3)), (3 & s2) == 0 && 67174411 === p2 && (u2 |= 16))
                      : 2 & e10.assignable
                        ? (u2 |= 16)
                        : 67174411 === p2 && (u2 |= 1 & e10.assignable && 3 & s2 ? 32 : 16))
            if ((c2.push(o3), V(e10, 32 | t2, 18))) {
              if (20 === e10.getToken()) break
            } else break
          }
        R(e10, t2, 20)
        let d2 = e10.finishNode({ type: i2 ? 'ArrayPattern' : 'ArrayExpression', elements: c2 }, l2)
        return !o2 && 4194304 & e10.getToken() ? eY(e10, t2, n2, u2, a2, i2, l2, d2) : ((e10.destructible = u2), d2)
      }
      function eY(e10, t2, r2, n2, o2, a2, i2, s2) {
        ;(1077936155 !== e10.getToken() && e10.report(26), $(e10, 32 | t2), 16 & n2 && e10.report(26), a2 || P(e10, s2))
        let { tokenStart: f2 } = e10,
          l2 = eS(e10, t2, r2, 1, o2, f2)
        return (
          (e10.destructible =
            ((64 | n2 | 8) ^ 72) | (128 & e10.destructible ? 128 : 0) | (256 & e10.destructible ? 256 : 0)),
          e10.finishNode(
            a2
              ? { type: 'AssignmentPattern', left: s2, right: l2 }
              : { type: 'AssignmentExpression', left: s2, operator: '=', right: l2 },
            i2
          )
        )
      }
      function eZ(e10, t2, r2, n2, o2, a2, i2, s2, f2, l2) {
        let { tokenStart: c2 } = e10
        $(e10, 32 | t2)
        let u2 = null,
          d2 = 0,
          { tokenValue: p2, tokenStart: g2 } = e10,
          x2 = e10.getToken()
        if (143360 & x2)
          ((e10.assignable = 1),
            (u2 = eR(e10, t2, n2, a2, 0, 1, f2, 1, g2)),
            (x2 = e10.getToken()),
            (u2 = eD(e10, t2, n2, u2, f2, 0, g2)),
            18 !== e10.getToken() &&
              e10.getToken() !== o2 &&
              (2 & e10.assignable && 1077936155 === e10.getToken() && e10.report(71),
              (d2 |= 16),
              (u2 = eq(e10, t2, n2, f2, l2, g2, u2))),
            2 & e10.assignable ? (d2 |= 16) : x2 === o2 || 18 === x2 ? r2?.addVarOrBlock(t2, p2, a2, i2) : (d2 |= 32),
            (d2 |= 128 & e10.destructible ? 128 : 0))
        else if (x2 === o2) e10.report(41)
        else if (2097152 & x2)
          ((u2 =
            2162700 === e10.getToken()
              ? eW(e10, t2, r2, n2, 1, f2, l2, a2, i2)
              : e$(e10, t2, r2, n2, 1, f2, l2, a2, i2)),
            1077936155 !== (x2 = e10.getToken()) && x2 !== o2 && 18 !== x2
              ? (8 & e10.destructible && e10.report(71),
                (u2 = eD(e10, t2, n2, u2, f2, 0, g2)),
                (d2 |= 2 & e10.assignable ? 16 : 0),
                (4194304 & e10.getToken()) == 4194304
                  ? (1077936155 !== e10.getToken() && (d2 |= 16), (u2 = eq(e10, t2, n2, f2, l2, g2, u2)))
                  : ((8388608 & e10.getToken()) == 8388608 && (u2 = eL(e10, t2, n2, 1, g2, 4, x2, u2)),
                    V(e10, 32 | t2, 22) && (u2 = eN(e10, t2, n2, u2, g2)),
                    (d2 |= 2 & e10.assignable ? 16 : 32)))
              : (d2 |= 1074790415 === o2 && 1077936155 !== x2 ? 16 : e10.destructible))
        else {
          ;((d2 |= 32), (u2 = eI(e10, t2, n2, 1, f2, 1)))
          let { tokenStart: r3 } = e10,
            a3 = e10.getToken()
          return (
            1077936155 === a3
              ? (2 & e10.assignable && e10.report(26), (u2 = eq(e10, t2, n2, f2, l2, r3, u2)), (d2 |= 16))
              : (18 === a3 ? (d2 |= 16) : a3 !== o2 && (u2 = eq(e10, t2, n2, f2, l2, r3, u2)),
                (d2 |= 1 & e10.assignable ? 32 : 16)),
            (e10.destructible = d2),
            e10.getToken() !== o2 && 18 !== e10.getToken() && e10.report(161),
            e10.finishNode({ type: l2 ? 'RestElement' : 'SpreadElement', argument: u2 }, c2)
          )
        }
        if (e10.getToken() !== o2)
          if ((1 & a2 && (d2 |= s2 ? 16 : 32), V(e10, 32 | t2, 1077936155))) {
            ;(16 & d2 && e10.report(26), P(e10, u2))
            let r3 = eS(e10, t2, n2, 1, f2, e10.tokenStart)
            ;((u2 = e10.finishNode(
              l2
                ? { type: 'AssignmentPattern', left: u2, right: r3 }
                : { type: 'AssignmentExpression', left: u2, operator: '=', right: r3 },
              g2
            )),
              (d2 = 16))
          } else d2 |= 16
        return (
          (e10.destructible = d2),
          e10.finishNode({ type: l2 ? 'RestElement' : 'SpreadElement', argument: u2 }, c2)
        )
      }
      function eK(e10, t2, r2, n2, o2, a2) {
        let i2 = 11264 | (16896 * ((64 & n2) == 0))
        t2 = ((t2 | i2) ^ i2) | (8 & n2 ? 1024 : 0) | (16 & n2 ? 2048 : 0) | (64 & n2 ? 16384 : 0) | 98560
        let s2 = e10.createScopeIfLexical(256),
          f2 = (function (e11, t3, r3, n3, o3, a3, i3) {
            R(e11, t3, 67174411)
            let s3 = []
            if (((e11.flags = (128 | e11.flags) ^ 128), 16 === e11.getToken()))
              return (512 & o3 && e11.report(37, 'Setter', 'one', ''), $(e11, t3), s3)
            ;(256 & o3 && e11.report(37, 'Getter', 'no', 's'),
              512 & o3 && 14 === e11.getToken() && e11.report(38),
              (t3 = (131072 | t3) ^ 131072))
            let f3 = 0,
              l3 = 0
            for (; 18 !== e11.getToken(); ) {
              let a4 = null,
                { tokenStart: c2 } = e11
              if (
                (143360 & e11.getToken()
                  ? ((1 & t3) == 0 &&
                      ((36864 & e11.getToken()) == 36864 && (e11.flags |= 256),
                      (537079808 & e11.getToken()) == 537079808 && (e11.flags |= 512)),
                    (a4 = tn(e11, t3, r3, 1 | o3, 0)))
                  : (2162700 === e11.getToken()
                      ? (a4 = eW(e11, t3, r3, n3, 1, i3, 1, 1, 0))
                      : 69271571 === e11.getToken()
                        ? (a4 = e$(e11, t3, r3, n3, 1, i3, 1, 1, 0))
                        : 14 === e11.getToken() && (a4 = eZ(e11, t3, r3, n3, 16, 1, 0, 0, i3, 1)),
                    (l3 = 1),
                    48 & e11.destructible && e11.report(50)),
                1077936155 === e11.getToken())
              ) {
                ;($(e11, 32 | t3), (l3 = 1))
                let r4 = eS(e11, t3, n3, 1, 0, e11.tokenStart)
                a4 = e11.finishNode({ type: 'AssignmentPattern', left: a4, right: r4 }, c2)
              }
              if ((f3++, s3.push(a4), !V(e11, t3, 18) || 16 === e11.getToken())) break
            }
            return (
              512 & o3 && 1 !== f3 && e11.report(37, 'Setter', 'one', ''),
              r3?.reportScopeError(),
              l3 && (e11.flags |= 128),
              R(e11, t3, 16),
              s3
            )
          })(e10, (8192 | t2) & -524289, s2, r2, n2, 1, o2),
          l2 = eA(e10, (-655373 & t2) | 36864, (s2 = s2?.createChildScope(64)), r2, 0, void 0, s2?.parent)
        return e10.finishNode(
          { type: 'FunctionExpression', params: f2, body: l2, async: (16 & n2) > 0, generator: (8 & n2) > 0, id: null },
          a2
        )
      }
      function eW(e10, t2, r2, n2, o2, a2, i2, s2, f2) {
        let { tokenStart: l2 } = e10
        $(e10, t2)
        let c2 = [],
          u2 = 0,
          d2 = 0
        for (t2 = (131072 | t2) ^ 131072; 1074790415 !== e10.getToken(); ) {
          let { tokenValue: o3, tokenStart: l3 } = e10,
            p3 = e10.getToken()
          if (14 === p3) c2.push(eZ(e10, t2, r2, n2, 1074790415, s2, f2, 0, a2, i2))
          else {
            let g2,
              x2 = 0,
              k2 = null
            if (143360 & e10.getToken() || -2147483528 === e10.getToken() || -2147483527 === e10.getToken())
              if (
                (-2147483527 === e10.getToken() && (u2 |= 16),
                (k2 = eH(e10, t2)),
                18 === e10.getToken() || 1074790415 === e10.getToken() || 1077936155 === e10.getToken())
              )
                if (
                  ((x2 |= 4),
                  1 & t2 && (537079808 & p3) == 537079808 ? (u2 |= 16) : U(e10, t2, s2, p3, 0),
                  r2?.addVarOrBlock(t2, o3, s2, f2),
                  V(e10, 32 | t2, 1077936155))
                ) {
                  u2 |= 8
                  let r3 = eS(e10, t2, n2, 1, a2, e10.tokenStart)
                  ;((u2 |= 256 & e10.destructible ? 256 : 128 & e10.destructible ? 128 : 0),
                    (g2 = e10.finishNode(
                      {
                        type: 'AssignmentPattern',
                        left: e10.options.uniqueKeyInPattern ? Object.assign({}, k2) : k2,
                        right: r3,
                      },
                      l3
                    )))
                } else
                  ((u2 |= (128 * (209006 === p3)) | (16 * (-2147483528 === p3))),
                    (g2 = e10.options.uniqueKeyInPattern ? Object.assign({}, k2) : k2))
              else if (V(e10, 32 | t2, 21)) {
                let { tokenStart: l4 } = e10
                if (('__proto__' === o3 && d2++, 143360 & e10.getToken())) {
                  let o4 = e10.getToken(),
                    c3 = e10.tokenValue
                  g2 = eR(e10, t2, n2, s2, 0, 1, a2, 1, l4)
                  let d3 = e10.getToken()
                  ;((g2 = eD(e10, t2, n2, g2, a2, 0, l4)),
                    18 === e10.getToken() || 1074790415 === e10.getToken()
                      ? 1077936155 === d3 || 1074790415 === d3 || 18 === d3
                        ? ((u2 |= 128 & e10.destructible ? 128 : 0),
                          2 & e10.assignable
                            ? (u2 |= 16)
                            : (143360 & o4) == 143360 && r2?.addVarOrBlock(t2, c3, s2, f2))
                        : (u2 |= 1 & e10.assignable ? 32 : 16)
                      : (4194304 & e10.getToken()) == 4194304
                        ? (2 & e10.assignable
                            ? (u2 |= 16)
                            : 1077936155 !== d3
                              ? (u2 |= 32)
                              : r2?.addVarOrBlock(t2, c3, s2, f2),
                          (g2 = eq(e10, t2, n2, a2, i2, l4, g2)))
                        : ((u2 |= 16),
                          (8388608 & e10.getToken()) == 8388608 && (g2 = eL(e10, t2, n2, 1, l4, 4, d3, g2)),
                          V(e10, 32 | t2, 22) && (g2 = eN(e10, t2, n2, g2, l4))))
                } else
                  (2097152 & e10.getToken()) == 2097152
                    ? ((g2 =
                        69271571 === e10.getToken()
                          ? e$(e10, t2, r2, n2, 0, a2, i2, s2, f2)
                          : eW(e10, t2, r2, n2, 0, a2, i2, s2, f2)),
                      (u2 = e10.destructible),
                      (e10.assignable = 16 & u2 ? 2 : 1),
                      18 === e10.getToken() || 1074790415 === e10.getToken()
                        ? 2 & e10.assignable && (u2 |= 16)
                        : 8 & e10.destructible
                          ? e10.report(71)
                          : ((g2 = eD(e10, t2, n2, g2, a2, 0, l4)),
                            (u2 = 2 & e10.assignable ? 16 : 0),
                            (4194304 & e10.getToken()) == 4194304
                              ? (g2 = eE(e10, t2, n2, a2, i2, l4, g2))
                              : ((8388608 & e10.getToken()) == 8388608 && (g2 = eL(e10, t2, n2, 1, l4, 4, p3, g2)),
                                V(e10, 32 | t2, 22) && (g2 = eN(e10, t2, n2, g2, l4)),
                                (u2 |= 2 & e10.assignable ? 16 : 32))))
                    : ((g2 = eI(e10, t2, n2, 1, a2, 1)),
                      (u2 |= 1 & e10.assignable ? 32 : 16),
                      18 === e10.getToken() || 1074790415 === e10.getToken()
                        ? 2 & e10.assignable && (u2 |= 16)
                        : ((g2 = eD(e10, t2, n2, g2, a2, 0, l4)),
                          (u2 = 2 & e10.assignable ? 16 : 0),
                          18 !== e10.getToken() &&
                            1074790415 !== p3 &&
                            (1077936155 !== e10.getToken() && (u2 |= 16), (g2 = eq(e10, t2, n2, a2, i2, l4, g2)))))
              } else
                69271571 === e10.getToken()
                  ? ((u2 |= 16),
                    209005 === p3 && (x2 |= 16),
                    (x2 |= (209008 === p3 ? 256 : 209009 === p3 ? 512 : 1) | 2),
                    (k2 = eQ(e10, t2, n2, a2)),
                    (u2 |= e10.assignable),
                    (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                  : 143360 & e10.getToken()
                    ? ((u2 |= 16),
                      -2147483528 === p3 && e10.report(95),
                      209005 === p3
                        ? (1 & e10.flags && e10.report(132), (x2 |= 17))
                        : 209008 === p3
                          ? (x2 |= 256)
                          : 209009 === p3
                            ? (x2 |= 512)
                            : e10.report(0),
                      (k2 = eH(e10, t2)),
                      (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                    : 67174411 === e10.getToken()
                      ? ((u2 |= 16), (x2 |= 1), (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                      : 8391476 === e10.getToken()
                        ? ((u2 |= 16),
                          209008 === p3
                            ? e10.report(42)
                            : 209009 === p3
                              ? e10.report(43)
                              : 209005 !== p3 && e10.report(30, N[52]),
                          $(e10, t2),
                          (x2 |= 9 | (16 * (209005 === p3))),
                          143360 & e10.getToken()
                            ? (k2 = eH(e10, t2))
                            : (134217728 & e10.getToken()) == 134217728
                              ? (k2 = ez(e10, t2))
                              : 69271571 === e10.getToken()
                                ? ((x2 |= 2), (k2 = eQ(e10, t2, n2, a2)), (u2 |= e10.assignable))
                                : e10.report(30, N[255 & e10.getToken()]),
                          (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                        : (134217728 & e10.getToken()) == 134217728
                          ? (209005 === p3 && (x2 |= 16),
                            (x2 |= 209008 === p3 ? 256 : 209009 === p3 ? 512 : 1),
                            (u2 |= 16),
                            (k2 = ez(e10, t2)),
                            (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                          : e10.report(133)
            else if ((134217728 & e10.getToken()) == 134217728)
              if (((k2 = ez(e10, t2)), 21 === e10.getToken())) {
                R(e10, 32 | t2, 21)
                let { tokenStart: l4 } = e10
                if (('__proto__' === o3 && d2++, 143360 & e10.getToken())) {
                  g2 = eR(e10, t2, n2, s2, 0, 1, a2, 1, l4)
                  let { tokenValue: o4 } = e10,
                    c3 = e10.getToken()
                  ;((g2 = eD(e10, t2, n2, g2, a2, 0, l4)),
                    18 === e10.getToken() || 1074790415 === e10.getToken()
                      ? 1077936155 === c3 || 1074790415 === c3 || 18 === c3
                        ? 2 & e10.assignable
                          ? (u2 |= 16)
                          : r2?.addVarOrBlock(t2, o4, s2, f2)
                        : (u2 |= 1 & e10.assignable ? 32 : 16)
                      : (1077936155 === e10.getToken() ? 2 & e10.assignable && (u2 |= 16) : (u2 |= 16),
                        (g2 = eq(e10, t2, n2, a2, i2, l4, g2))))
                } else
                  (2097152 & e10.getToken()) == 2097152
                    ? ((g2 =
                        69271571 === e10.getToken()
                          ? e$(e10, t2, r2, n2, 0, a2, i2, s2, f2)
                          : eW(e10, t2, r2, n2, 0, a2, i2, s2, f2)),
                      (u2 = e10.destructible),
                      (e10.assignable = 16 & u2 ? 2 : 1),
                      18 === e10.getToken() || 1074790415 === e10.getToken()
                        ? 2 & e10.assignable && (u2 |= 16)
                        : (8 & e10.destructible) != 8 &&
                          ((g2 = eD(e10, t2, n2, g2, a2, 0, l4)),
                          (u2 = 2 & e10.assignable ? 16 : 0),
                          (4194304 & e10.getToken()) == 4194304
                            ? (g2 = eE(e10, t2, n2, a2, i2, l4, g2))
                            : ((8388608 & e10.getToken()) == 8388608 && (g2 = eL(e10, t2, n2, 1, l4, 4, p3, g2)),
                              V(e10, 32 | t2, 22) && (g2 = eN(e10, t2, n2, g2, l4)),
                              (u2 |= 2 & e10.assignable ? 16 : 32))))
                    : ((g2 = eI(e10, t2, n2, 1, 0, 1)),
                      (u2 |= 1 & e10.assignable ? 32 : 16),
                      18 === e10.getToken() || 1074790415 === e10.getToken()
                        ? 2 & e10.assignable && (u2 |= 16)
                        : ((g2 = eD(e10, t2, n2, g2, a2, 0, l4)),
                          (u2 = 1 & e10.assignable ? 0 : 16),
                          18 !== e10.getToken() &&
                            1074790415 !== e10.getToken() &&
                            (1077936155 !== e10.getToken() && (u2 |= 16), (g2 = eq(e10, t2, n2, a2, i2, l4, g2)))))
              } else
                67174411 === e10.getToken()
                  ? ((x2 |= 1), (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)), (u2 = 16 | e10.assignable))
                  : e10.report(134)
            else if (69271571 === e10.getToken())
              if (
                ((k2 = eQ(e10, t2, n2, a2)), (u2 |= 256 & e10.destructible ? 256 : 0), (x2 |= 2), 21 === e10.getToken())
              ) {
                $(e10, 32 | t2)
                let { tokenStart: o4, tokenValue: l4 } = e10,
                  c3 = e10.getToken()
                if (143360 & e10.getToken()) {
                  g2 = eR(e10, t2, n2, s2, 0, 1, a2, 1, o4)
                  let d3 = e10.getToken()
                  ;((g2 = eD(e10, t2, n2, g2, a2, 0, o4)),
                    (4194304 & e10.getToken()) == 4194304
                      ? ((u2 |= 2 & e10.assignable ? 16 : 32 * (1077936155 !== d3)),
                        (g2 = eE(e10, t2, n2, a2, i2, o4, g2)))
                      : 18 === e10.getToken() || 1074790415 === e10.getToken()
                        ? 1077936155 === d3 || 1074790415 === d3 || 18 === d3
                          ? 2 & e10.assignable
                            ? (u2 |= 16)
                            : (143360 & c3) == 143360 && r2?.addVarOrBlock(t2, l4, s2, f2)
                          : (u2 |= 1 & e10.assignable ? 32 : 16)
                        : ((u2 |= 16), (g2 = eq(e10, t2, n2, a2, i2, o4, g2))))
                } else
                  (2097152 & e10.getToken()) == 2097152
                    ? ((g2 =
                        69271571 === e10.getToken()
                          ? e$(e10, t2, r2, n2, 0, a2, i2, s2, f2)
                          : eW(e10, t2, r2, n2, 0, a2, i2, s2, f2)),
                      (u2 = e10.destructible),
                      (e10.assignable = 16 & u2 ? 2 : 1),
                      18 === e10.getToken() || 1074790415 === e10.getToken()
                        ? 2 & e10.assignable && (u2 |= 16)
                        : 8 & u2
                          ? e10.report(62)
                          : ((g2 = eD(e10, t2, n2, g2, a2, 0, o4)),
                            (u2 = 2 & e10.assignable ? 16 | u2 : 0),
                            (4194304 & e10.getToken()) == 4194304
                              ? (1077936155 !== e10.getToken() && (u2 |= 16), (g2 = eE(e10, t2, n2, a2, i2, o4, g2)))
                              : ((8388608 & e10.getToken()) == 8388608 && (g2 = eL(e10, t2, n2, 1, o4, 4, p3, g2)),
                                V(e10, 32 | t2, 22) && (g2 = eN(e10, t2, n2, g2, o4)),
                                (u2 |= 2 & e10.assignable ? 16 : 32))))
                    : ((g2 = eI(e10, t2, n2, 1, 0, 1)),
                      (u2 |= 1 & e10.assignable ? 32 : 16),
                      18 === e10.getToken() || 1074790415 === e10.getToken()
                        ? 2 & e10.assignable && (u2 |= 16)
                        : ((g2 = eD(e10, t2, n2, g2, a2, 0, o4)),
                          (u2 = 1 & e10.assignable ? 0 : 16),
                          18 !== e10.getToken() &&
                            1074790415 !== e10.getToken() &&
                            (1077936155 !== e10.getToken() && (u2 |= 16), (g2 = eq(e10, t2, n2, a2, i2, o4, g2)))))
              } else
                67174411 === e10.getToken()
                  ? ((x2 |= 1), (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)), (u2 = 16))
                  : e10.report(44)
            else if (8391476 === p3)
              if ((R(e10, 32 | t2, 8391476), (x2 |= 8), 143360 & e10.getToken())) {
                let r3 = e10.getToken()
                if (((k2 = eH(e10, t2)), (x2 |= 1), 67174411 === e10.getToken()))
                  ((u2 |= 16), (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                else
                  throw new C(
                    e10.tokenStart,
                    e10.currentLocation,
                    209005 === r3 ? 46 : 209008 === r3 || 209009 === e10.getToken() ? 45 : 47,
                    N[255 & r3]
                  )
              } else
                (134217728 & e10.getToken()) == 134217728
                  ? ((u2 |= 16), (k2 = ez(e10, t2)), (x2 |= 1), (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                  : 69271571 === e10.getToken()
                    ? ((u2 |= 16),
                      (x2 |= 3),
                      (k2 = eQ(e10, t2, n2, a2)),
                      (g2 = eK(e10, t2, n2, x2, a2, e10.tokenStart)))
                    : e10.report(126)
            else e10.report(30, N[255 & p3])
            ;((u2 |= 128 & e10.destructible ? 128 : 0),
              (e10.destructible = u2),
              c2.push(
                e10.finishNode(
                  {
                    type: 'Property',
                    key: k2,
                    value: g2,
                    kind: 768 & x2 ? (512 & x2 ? 'set' : 'get') : 'init',
                    computed: (2 & x2) > 0,
                    method: (1 & x2) > 0,
                    shorthand: (4 & x2) > 0,
                  },
                  l3
                )
              ))
          }
          if (((u2 |= e10.destructible), 18 !== e10.getToken())) break
          $(e10, t2)
        }
        ;(R(e10, t2, 1074790415), d2 > 1 && (u2 |= 64))
        let p2 = e10.finishNode({ type: i2 ? 'ObjectPattern' : 'ObjectExpression', properties: c2 }, l2)
        return !o2 && 4194304 & e10.getToken() ? eY(e10, t2, n2, u2, a2, i2, l2, p2) : ((e10.destructible = u2), p2)
      }
      function eQ(e10, t2, r2, n2) {
        $(e10, 32 | t2)
        let o2 = eS(e10, (131072 | t2) ^ 131072, r2, 1, n2, e10.tokenStart)
        return (R(e10, t2, 20), o2)
      }
      function e0(e10, t2, r2) {
        let { tokenStart: n2 } = e10,
          { tokenValue: o2 } = e10,
          a2 = 0,
          i2 = 0
        ;(537079808 & e10.getToken()) == 537079808 ? (a2 = 1) : (36864 & e10.getToken()) == 36864 && (i2 = 1)
        let s2 = eH(e10, t2)
        if (((e10.assignable = 1), 10 === e10.getToken())) {
          let f2 = e10.options.lexical ? et(e10, t2, o2) : void 0
          return (a2 && (e10.flags |= 128), i2 && (e10.flags |= 256), e3(e10, t2, f2, r2, [s2], 0, n2))
        }
        return s2
      }
      function e1(e10, t2, r2, n2, o2, a2, i2, s2, f2) {
        ;(i2 || e10.report(57), a2 && e10.report(51), (e10.flags &= -129))
        let l2 = e10.options.lexical ? et(e10, t2, n2) : void 0
        return e3(e10, t2, l2, r2, [o2], s2, f2)
      }
      function e2(e10, t2, r2, n2, o2, a2, i2, s2) {
        a2 || e10.report(57)
        for (let t3 = 0; t3 < o2.length; ++t3) P(e10, o2[t3])
        return e3(e10, t2, r2, n2, o2, i2, s2)
      }
      function e3(e10, t2, r2, n2, o2, a2, i2) {
        let s2
        ;(1 & e10.flags && e10.report(48), R(e10, 32 | t2, 10), (t2 = ((535552 | t2) ^ 535552) | (2048 * !!a2)))
        let f2 = 2162700 !== e10.getToken()
        if ((r2?.reportScopeError(), f2))
          ((e10.flags = (512 | e10.flags | 4416) ^ 4928), (s2 = eS(e10, t2, n2, 1, 0, e10.tokenStart)))
        else {
          switch (
            ((s2 = eA(e10, ((131084 | t2) ^ 131084) | 4096, (r2 = r2?.createChildScope(64)), n2, 16, void 0, void 0)),
            e10.getToken())
          ) {
            case 69271571:
              ;(1 & e10.flags) == 0 && e10.report(116)
              break
            case 67108877:
            case 67174409:
            case 22:
              e10.report(117)
            case 67174411:
              ;((1 & e10.flags) == 0 && e10.report(116), (e10.flags |= 1024))
          }
          ;((8388608 & e10.getToken()) == 8388608 && (1 & e10.flags) == 0 && e10.report(30, N[255 & e10.getToken()]),
            (33619968 & e10.getToken()) == 33619968 && e10.report(125))
        }
        return (
          (e10.assignable = 2),
          e10.finishNode(
            {
              type: 'ArrowFunctionExpression',
              params: o2,
              body: s2,
              async: 1 === a2,
              expression: f2,
              generator: false,
            },
            i2
          )
        )
      }
      function e4(e10, t2, r2, n2, o2, a2) {
        ;(R(e10, t2, 67174411), (e10.flags = (128 | e10.flags) ^ 128))
        let i2 = []
        if (V(e10, t2, 16)) return i2
        t2 = (131072 | t2) ^ 131072
        let s2 = 0
        for (; 18 !== e10.getToken(); ) {
          let f2,
            { tokenStart: l2 } = e10,
            c2 = e10.getToken()
          if (
            (143360 & c2
              ? ((1 & t2) == 0 &&
                  ((36864 & c2) == 36864 && (e10.flags |= 256), (537079808 & c2) == 537079808 && (e10.flags |= 512)),
                (f2 = tn(e10, t2, r2, 1 | a2, 0)))
              : (2162700 === c2
                  ? (f2 = eW(e10, t2, r2, n2, 1, o2, 1, a2, 0))
                  : 69271571 === c2
                    ? (f2 = e$(e10, t2, r2, n2, 1, o2, 1, a2, 0))
                    : 14 === c2
                      ? (f2 = eZ(e10, t2, r2, n2, 16, a2, 0, 0, o2, 1))
                      : e10.report(30, N[255 & c2]),
                (s2 = 1),
                48 & e10.destructible && e10.report(50)),
            1077936155 === e10.getToken())
          ) {
            ;($(e10, 32 | t2), (s2 = 1))
            let r3 = eS(e10, t2, n2, 1, o2, e10.tokenStart)
            f2 = e10.finishNode({ type: 'AssignmentPattern', left: f2, right: r3 }, l2)
          }
          if ((i2.push(f2), !V(e10, t2, 18) || 16 === e10.getToken())) break
        }
        return (s2 && (e10.flags |= 128), (s2 || 1 & t2) && r2?.reportScopeError(), R(e10, t2, 16), i2)
      }
      function e8(e10, t2, r2, n2, o2) {
        return (
          209006 === e10.getToken() && e10.report(31),
          1025 & t2 && 241771 === e10.getToken() && e10.report(32),
          J(e10, t2, e10.getToken()),
          (36864 & e10.getToken()) == 36864 && (e10.flags |= 256),
          e1(e10, (-524289 & t2) | 2048, r2, e10.tokenValue, eH(e10, t2), 0, n2, 1, o2)
        )
      }
      function e6(e10, t2, r2, n2, o2, a2, i2, s2, f2) {
        $(e10, 32 | t2)
        let l2 = e10.createScopeIfLexical()?.createChildScope(512)
        if (V(e10, (t2 = (131072 | t2) ^ 131072), 16))
          return 10 === e10.getToken()
            ? (1 & s2 && e10.report(48), e2(e10, t2, l2, r2, [], o2, 1, f2))
            : e10.finishNode({ type: 'CallExpression', callee: n2, arguments: [], optional: false }, f2)
        let c2 = 0,
          u2 = null,
          d2 = 0
        e10.destructible = (256 | e10.destructible | 128) ^ 384
        let p2 = []
        for (; 16 !== e10.getToken(); ) {
          let { tokenStart: o3 } = e10,
            s3 = e10.getToken()
          if (143360 & s3)
            (l2?.addBlockName(t2, e10.tokenValue, a2, 0),
              (537079808 & s3) == 537079808 ? (e10.flags |= 512) : (36864 & s3) == 36864 && (e10.flags |= 256),
              (u2 = eR(e10, t2, r2, a2, 0, 1, 1, 1, o3)),
              16 === e10.getToken() || 18 === e10.getToken()
                ? 2 & e10.assignable && ((c2 |= 16), (d2 = 1))
                : (1077936155 === e10.getToken() ? (d2 = 1) : (c2 |= 16),
                  (u2 = eD(e10, t2, r2, u2, 1, 0, o3)),
                  16 !== e10.getToken() && 18 !== e10.getToken() && (u2 = eq(e10, t2, r2, 1, 0, o3, u2))))
          else if (2097152 & s3)
            ((u2 = 2162700 === s3 ? eW(e10, t2, l2, r2, 0, 1, 0, a2, i2) : e$(e10, t2, l2, r2, 0, 1, 0, a2, i2)),
              (c2 |= e10.destructible),
              (d2 = 1),
              16 !== e10.getToken() &&
                18 !== e10.getToken() &&
                (8 & c2 && e10.report(122),
                (u2 = eD(e10, t2, r2, u2, 0, 0, o3)),
                (c2 |= 16),
                (8388608 & e10.getToken()) == 8388608 && (u2 = eL(e10, t2, r2, 1, f2, 4, s3, u2)),
                V(e10, 32 | t2, 22) && (u2 = eN(e10, t2, r2, u2, f2))))
          else if (14 === s3)
            ((u2 = eZ(e10, t2, l2, r2, 16, a2, i2, 1, 1, 0)),
              (c2 |= (16 * (16 !== e10.getToken())) | e10.destructible),
              (d2 = 1))
          else {
            for (u2 = eS(e10, t2, r2, 1, 0, o3), c2 = e10.assignable, p2.push(u2); V(e10, 32 | t2, 18); )
              p2.push(eS(e10, t2, r2, 1, 0, o3))
            return (
              (c2 |= e10.assignable),
              R(e10, t2, 16),
              (e10.destructible = 16 | c2),
              (e10.assignable = 2),
              e10.finishNode({ type: 'CallExpression', callee: n2, arguments: p2, optional: false }, f2)
            )
          }
          if ((p2.push(u2), !V(e10, 32 | t2, 18))) break
        }
        return (R(e10, t2, 16),
        (c2 |= 256 & e10.destructible ? 256 : 128 & e10.destructible ? 128 : 0),
        10 === e10.getToken())
          ? (48 & c2 && e10.report(27),
            (1 & e10.flags || 1 & s2) && e10.report(48),
            128 & c2 && e10.report(31),
            1025 & t2 && 256 & c2 && e10.report(32),
            d2 && (e10.flags |= 128),
            e2(e10, 2048 | t2, l2, r2, p2, o2, 1, f2))
          : (64 & c2 && e10.report(63),
            8 & c2 && e10.report(62),
            (e10.assignable = 2),
            e10.finishNode({ type: 'CallExpression', callee: n2, arguments: p2, optional: false }, f2))
      }
      function e5(e10, t2, r2, n2, o2) {
        let a2, i2
        ;(e10.leadingDecorators.decorators.length
          ? (132 === e10.getToken() && e10.report(30, '@'),
            (a2 = e10.leadingDecorators.start),
            (i2 = [...e10.leadingDecorators.decorators]),
            (e10.leadingDecorators.decorators.length = 0))
          : ((a2 = e10.tokenStart), (i2 = e7(e10, t2, n2))),
          $(e10, (t2 = (16384 | t2 | 1) ^ 16384)))
        let s2 = null,
          f2 = null,
          { tokenValue: l2 } = e10
        4096 & e10.getToken() && 20565 !== e10.getToken()
          ? (O(e10, t2, e10.getToken()) && e10.report(118),
            (537079808 & e10.getToken()) == 537079808 && e10.report(119),
            r2 && (r2.addBlockName(t2, l2, 32, 0), o2 && 2 & o2 && e10.declareUnboundVariable(l2)),
            (s2 = eH(e10, t2)))
          : (1 & o2) == 0 && e10.report(39, 'Class')
        let c2 = t2
        V(e10, 32 | t2, 20565) ? ((f2 = eI(e10, t2, n2, 0, 0, 0)), (c2 |= 512)) : (c2 = (512 | c2) ^ 512)
        let u2 = e9(e10, c2, t2, r2, n2, 2, 8, 0)
        return e10.finishNode(
          {
            type: 'ClassDeclaration',
            id: s2,
            superClass: f2,
            body: u2,
            ...(e10.options.next ? { decorators: i2 } : null),
          },
          a2
        )
      }
      function e7(e10, t2, r2) {
        let n2 = []
        if (e10.options.next)
          for (; 132 === e10.getToken(); )
            n2.push(
              (function (e11, t3, r3) {
                let n3 = e11.tokenStart
                $(e11, 32 | t3)
                let o2 = eR(e11, t3, r3, 2, 0, 1, 0, 1, n3)
                return (
                  (o2 = eD(e11, t3, r3, o2, 0, 0, e11.tokenStart)),
                  e11.finishNode({ type: 'Decorator', expression: o2 }, n3)
                )
              })(e10, t2, r2)
            )
        return n2
      }
      function e9(e10, t2, r2, n2, o2, a2, i2, s2) {
        let { tokenStart: f2 } = e10,
          l2 = e10.createPrivateScopeIfLexical(o2)
        ;(R(e10, 32 | t2, 2162700), (t2 = (655360 | t2) ^ 655360))
        let c2 = 32 & e10.flags
        e10.flags = (32 | e10.flags) ^ 32
        let u2 = []
        for (; 1074790415 !== e10.getToken(); ) {
          let o3 = e10.tokenStart,
            i3 = e7(e10, t2, l2)
          if (
            (i3.length > 0 && 'constructor' === e10.tokenValue && e10.report(109),
            1074790415 === e10.getToken() && e10.report(108),
            V(e10, t2, 1074790417))
          ) {
            i3.length > 0 && e10.report(120)
            continue
          }
          u2.push(
            (function e11(t3, r3, n3, o4, a3, i4, s3, f3, l3, c3) {
              let u3 = 32 * !!f3,
                d2 = null,
                p2 = t3.getToken()
              if (176128 & p2 || -2147483528 === p2)
                switch (((d2 = eH(t3, r3)), p2)) {
                  case 36970:
                    if (
                      !f3 &&
                      67174411 !== t3.getToken() &&
                      (1048576 & t3.getToken()) != 1048576 &&
                      1077936155 !== t3.getToken()
                    )
                      return e11(t3, r3, n3, o4, a3, i4, s3, 1, l3, c3)
                    break
                  case 209005:
                    if (67174411 !== t3.getToken() && (1 & t3.flags) == 0) {
                      if ((1073741824 & t3.getToken()) == 1073741824) return tt(t3, r3, o4, d2, u3, s3, c3)
                      u3 |= 16 | (8 * !!D(t3, r3, 8391476))
                    }
                    break
                  case 209008:
                    if (67174411 !== t3.getToken()) {
                      if ((1073741824 & t3.getToken()) == 1073741824) return tt(t3, r3, o4, d2, u3, s3, c3)
                      u3 |= 256
                    }
                    break
                  case 209009:
                    if (67174411 !== t3.getToken()) {
                      if ((1073741824 & t3.getToken()) == 1073741824) return tt(t3, r3, o4, d2, u3, s3, c3)
                      u3 |= 512
                    }
                    break
                  case 12402:
                    if (67174411 !== t3.getToken() && (1 & t3.flags) == 0) {
                      if ((1073741824 & t3.getToken()) == 1073741824) return tt(t3, r3, o4, d2, u3, s3, c3)
                      t3.options.next && (u3 |= 1024)
                    }
                }
              else if (69271571 === p2) ((u3 |= 2), (d2 = eQ(t3, a3, o4, l3)))
              else if ((134217728 & p2) == 134217728) d2 = ez(t3, r3)
              else if (8391476 === p2) ((u3 |= 8), $(t3, r3))
              else if (130 === t3.getToken()) ((u3 |= 8192), (d2 = te(t3, 16 | r3, o4, 768)))
              else if ((1073741824 & t3.getToken()) == 1073741824) u3 |= 128
              else if (f3 && 2162700 === p2) {
                var g2, x2
                return (
                  (g2 = 16 | r3),
                  (x2 = n3),
                  es(t3, (g2 = ((5764 | g2) ^ 5764) | 592128), (x2 = x2?.createChildScope()), o4, {}, c3, 'StaticBlock')
                )
              } else
                -2147483527 === p2
                  ? ((d2 = eH(t3, r3)), 67174411 !== t3.getToken() && t3.report(30, N[255 & t3.getToken()]))
                  : t3.report(30, N[255 & t3.getToken()])
              if (
                (1816 & u3 &&
                  (143360 & t3.getToken() || -2147483528 === t3.getToken() || -2147483527 === t3.getToken()
                    ? (d2 = eH(t3, r3))
                    : (134217728 & t3.getToken()) == 134217728
                      ? (d2 = ez(t3, r3))
                      : 69271571 === t3.getToken()
                        ? ((u3 |= 2), (d2 = eQ(t3, r3, o4, 0)))
                        : 130 === t3.getToken()
                          ? ((u3 |= 8192), (d2 = te(t3, r3, o4, u3)))
                          : t3.report(135)),
                (2 & u3) == 0 &&
                  ('constructor' === t3.tokenValue
                    ? ((1073741824 & t3.getToken()) == 1073741824
                        ? t3.report(129)
                        : (32 & u3) == 0 &&
                          67174411 === t3.getToken() &&
                          (920 & u3
                            ? t3.report(53, 'accessor')
                            : (512 & r3) == 0 && (32 & t3.flags ? t3.report(54) : (t3.flags |= 32))),
                      (u3 |= 64))
                    : (8192 & u3) == 0 && 32 & u3 && 'prototype' === t3.tokenValue && t3.report(52)),
                1024 & u3 || (67174411 !== t3.getToken() && (768 & u3) == 0))
              )
                return tt(t3, r3, o4, d2, u3, s3, c3)
              let k2 = eK(t3, 16 | r3, o4, u3, l3, t3.tokenStart)
              return t3.finishNode(
                {
                  type: 'MethodDefinition',
                  kind: (32 & u3) == 0 && 64 & u3 ? 'constructor' : 256 & u3 ? 'get' : 512 & u3 ? 'set' : 'method',
                  static: (32 & u3) > 0,
                  computed: (2 & u3) > 0,
                  key: d2,
                  value: k2,
                  ...(t3.options.next ? { decorators: s3 } : null),
                },
                c3
              )
            })(e10, t2, n2, l2, r2, a2, i3, 0, s2, i3.length > 0 ? o3 : e10.tokenStart)
          )
        }
        return (
          R(e10, 8 & i2 ? 32 | t2 : t2, 1074790415),
          l2?.validatePrivateIdentifierRefs(),
          (e10.flags = (-33 & e10.flags) | c2),
          e10.finishNode({ type: 'ClassBody', body: u2 }, f2)
        )
      }
      function te(e10, t2, r2, n2) {
        let { tokenStart: o2 } = e10
        $(e10, t2)
        let { tokenValue: a2 } = e10
        return (
          'constructor' === a2 && e10.report(128),
          e10.options.lexical &&
            (r2 || e10.report(4, a2), n2 ? r2.addPrivateIdentifier(a2, n2) : r2.addPrivateIdentifierRef(a2)),
          $(e10, t2),
          e10.finishNode({ type: 'PrivateIdentifier', name: a2 }, o2)
        )
      }
      function tt(e10, t2, r2, n2, o2, a2, i2) {
        let s2 = null
        if ((8 & o2 && e10.report(0), 1077936155 === e10.getToken())) {
          $(e10, 32 | t2)
          let { tokenStart: n3 } = e10
          537079927 === e10.getToken() && e10.report(119)
          let a3 = 11264 | (16896 * ((64 & o2) == 0))
          ;((s2 = eR(
            e10,
            16 | (t2 = ((t2 | a3) ^ a3) | (8 & o2 ? 1024 : 0) | (16 & o2 ? 2048 : 0) | (64 & o2 ? 16384 : 0) | 65792),
            r2,
            2,
            0,
            1,
            0,
            1,
            n3
          )),
            ((1073741824 & e10.getToken()) != 1073741824 || (4194304 & e10.getToken()) == 4194304) &&
              ((s2 = eD(e10, 16 | t2, r2, s2, 0, 0, n3)), (s2 = eq(e10, 16 | t2, r2, 0, 0, n3, s2))))
        }
        return (
          A(e10, t2),
          e10.finishNode(
            {
              type: 1024 & o2 ? 'AccessorProperty' : 'PropertyDefinition',
              key: n2,
              value: s2,
              static: (32 & o2) > 0,
              computed: (2 & o2) > 0,
              ...(e10.options.next ? { decorators: a2 } : null),
            },
            i2
          )
        )
      }
      function tr(e10, t2, r2, n2, o2, a2) {
        if (143360 & e10.getToken() || ((1 & t2) == 0 && -2147483527 === e10.getToken())) return tn(e10, t2, r2, o2, a2)
        ;(2097152 & e10.getToken()) != 2097152 && e10.report(30, N[255 & e10.getToken()])
        let i2 =
          69271571 === e10.getToken() ? e$(e10, t2, r2, n2, 1, 0, 1, o2, a2) : eW(e10, t2, r2, n2, 1, 0, 1, o2, a2)
        return (16 & e10.destructible && e10.report(50), 32 & e10.destructible && e10.report(50), i2)
      }
      function tn(e10, t2, r2, n2, o2) {
        let a2 = e10.getToken()
        ;(1 & t2 &&
          ((537079808 & a2) == 537079808
            ? e10.report(119)
            : ((36864 & a2) == 36864 || -2147483527 === a2) && e10.report(118)),
          (20480 & a2) == 20480 && e10.report(102),
          241771 === a2 && (1024 & t2 && e10.report(32), 2 & t2 && e10.report(111)),
          (255 & a2) == 73 && 24 & n2 && e10.report(100),
          209006 === a2 && (2048 & t2 && e10.report(176), 2 & t2 && e10.report(110)))
        let { tokenValue: i2, tokenStart: s2 } = e10
        return ($(e10, t2), r2?.addVarOrBlock(t2, i2, n2, o2), e10.finishNode({ type: 'Identifier', name: i2 }, s2))
      }
      function to(e10, t2) {
        let r2 = e10.tokenStart
        $(e10, t2)
        let n2 = { type: 'JSXText', value: e10.tokenValue }
        return (e10.options.raw && (n2.raw = e10.tokenRaw), e10.finishNode(n2, r2))
      }
      function ta(e10, t2) {
        let { tokenStart: r2 } = e10
        Q(e10)
        let n2 = tf(e10, t2)
        if (21 === e10.getToken()) return ti(e10, t2, n2, r2)
        for (; V(e10, t2, 67108877); )
          (Q(e10),
            (n2 = (function (e11, t3, r3, n3) {
              let o2 = tf(e11, t3)
              return e11.finishNode({ type: 'JSXMemberExpression', object: r3, property: o2 }, n3)
            })(e10, t2, n2, r2)))
        return n2
      }
      function ti(e10, t2, r2, n2) {
        R(e10, t2, 21)
        let o2 = tf(e10, t2)
        return e10.finishNode({ type: 'JSXNamespacedName', namespace: r2, name: o2 }, n2)
      }
      function ts(e10, t2, r2, n2, o2) {
        var a2, i2, s2, f2, l2, c2
        let { tokenStart: u2 } = e10
        $(e10, 32 | t2)
        let { tokenStart: d2 } = e10
        if (14 === e10.getToken()) {
          let n3
          return (
            (a2 = e10),
            (i2 = t2),
            (s2 = r2),
            (f2 = u2),
            R(a2, i2, 14),
            (n3 = eS(a2, i2, s2, 1, 0, a2.tokenStart)),
            R(a2, i2, 1074790415),
            a2.finishNode({ type: 'JSXSpreadChild', expression: n3 }, f2)
          )
        }
        let p2 = null
        return (
          1074790415 === e10.getToken()
            ? (o2 && e10.report(157),
              (l2 = e10),
              (c2 = { index: e10.startIndex, line: e10.startLine, column: e10.startColumn }),
              (p2 = l2.finishNode({ type: 'JSXEmptyExpression' }, c2, l2.tokenStart)))
            : (p2 = eS(e10, t2, r2, 1, 0, d2)),
          1074790415 !== e10.getToken() && e10.report(25, N[15]),
          n2 ? W(e10) : $(e10, t2),
          e10.finishNode({ type: 'JSXExpressionContainer', expression: p2 }, u2)
        )
      }
      function tf(e10, t2) {
        let r2 = e10.tokenStart
        143360 & e10.getToken() || e10.report(30, N[255 & e10.getToken()])
        let { tokenValue: n2 } = e10
        return ($(e10, t2), e10.finishNode({ type: 'JSXIdentifier', name: n2 }, r2))
      }
      let tl = '6.1.4'
      function tc(e10, t2) {
        return eo(e10, t2)
      }
      function tu(e10, t2) {
        return eo(e10, t2, 3)
      }
      function td(e10, t2) {
        return eo(e10, t2)
      }
      module2.exports = a
    })()
  },
})

// node_modules/dd-trace/vendor/dist/astring/index.js
var require_astring = __commonJS({
  'node_modules/dd-trace/vendor/dist/astring/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      let e, t, i, r, n, s
      var l = {}
      ;((l.d = (e2, t2) => {
        for (var i2 in t2)
          l.o(t2, i2) && !l.o(e2, i2) && Object.defineProperty(e2, i2, { enumerable: true, get: t2[i2] })
      }),
        (l.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2)),
        (l.r = (e2) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e2, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(e2, '__esModule', { value: true }))
        }))
      var o = {}
      ;(l.r(o),
        l.d(o, {
          EXPRESSIONS_PRECEDENCE: () => u,
          GENERATOR: () => f,
          NEEDS_PARENTHESES: () => w,
          baseGenerator: () => b,
          generate: () => E,
        }))
      let { stringify: a } = JSON
      if (!String.prototype.repeat)
        throw Error('String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation')
      if (!String.prototype.endsWith)
        throw Error('String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation')
      let p = {
          '||': 2,
          '??': 3,
          '&&': 4,
          '|': 5,
          '^': 6,
          '&': 7,
          '==': 8,
          '!=': 8,
          '===': 8,
          '!==': 8,
          '<': 9,
          '>': 9,
          '<=': 9,
          '>=': 9,
          in: 9,
          instanceof: 9,
          '<<': 10,
          '>>': 10,
          '>>>': 10,
          '+': 11,
          '-': 11,
          '*': 12,
          '%': 12,
          '/': 12,
          '**': 13,
        },
        w = 17,
        u = {
          ArrayExpression: 20,
          TaggedTemplateExpression: 20,
          ThisExpression: 20,
          Identifier: 20,
          PrivateIdentifier: 20,
          Literal: 18,
          TemplateLiteral: 20,
          Super: 20,
          SequenceExpression: 20,
          MemberExpression: 19,
          ChainExpression: 19,
          CallExpression: 19,
          NewExpression: 19,
          ArrowFunctionExpression: 17,
          ClassExpression: 17,
          FunctionExpression: 17,
          ObjectExpression: 17,
          UpdateExpression: 16,
          UnaryExpression: 15,
          AwaitExpression: 15,
          BinaryExpression: 14,
          LogicalExpression: 13,
          ConditionalExpression: 4,
          AssignmentExpression: 3,
          YieldExpression: 2,
          RestElement: 1,
        }
      function h(e2, t2) {
        let { generator: i2 } = e2
        if ((e2.write('('), null != t2 && t2.length > 0)) {
          i2[t2[0].type](t2[0], e2)
          let { length: r2 } = t2
          for (let n2 = 1; n2 < r2; n2++) {
            let r3 = t2[n2]
            ;(e2.write(', '), i2[r3.type](r3, e2))
          }
        }
        e2.write(')')
      }
      function c(e2, t2, i2, r2) {
        let n2 = e2.expressionsPrecedence[t2.type]
        if (n2 === w) return true
        let s2 = e2.expressionsPrecedence[i2.type]
        return n2 !== s2
          ? (!r2 && 15 === n2 && 14 === s2 && '**' === i2.operator) || n2 < s2
          : (13 === n2 || 14 === n2) &&
              ('**' === t2.operator && '**' === i2.operator
                ? !r2
                : (13 === n2 && 13 === s2 && ('??' === t2.operator || '??' === i2.operator)) ||
                  (r2 ? p[t2.operator] <= p[i2.operator] : p[t2.operator] < p[i2.operator]))
      }
      function m(e2, t2, i2, r2) {
        let { generator: n2 } = e2
        c(e2, t2, i2, r2) ? (e2.write('('), n2[t2.type](t2, e2), e2.write(')')) : n2[t2.type](t2, e2)
      }
      function y(e2, t2, i2, r2) {
        let { length: n2 } = t2
        for (let s2 = 0; s2 < n2; s2++) {
          let n3 = t2[s2]
          ;(e2.write(i2),
            'L' === n3.type[0]
              ? e2.write('// ' + n3.value.trim() + '\n', n3)
              : (e2.write('/*'),
                (function (e3, t3, i3, r3) {
                  let n4 = t3.split('\n'),
                    s3 = n4.length - 1
                  if ((e3.write(n4[0].trim()), s3 > 0)) {
                    e3.write(r3)
                    for (let t4 = 1; t4 < s3; t4++) e3.write(i3 + n4[t4].trim() + r3)
                    e3.write(i3 + n4[s3].trim())
                  }
                })(e2, n3.value, i2, r2),
                e2.write('*/' + r2)))
        }
      }
      function d(e2, t2) {
        let { generator: i2 } = e2,
          { declarations: r2 } = t2
        e2.write(t2.kind + ' ')
        let { length: n2 } = r2
        if (n2 > 0) {
          i2.VariableDeclarator(r2[0], e2)
          for (let t3 = 1; t3 < n2; t3++) (e2.write(', '), i2.VariableDeclarator(r2[t3], e2))
        }
      }
      let f = {
          Program(e2, t2) {
            let i2 = t2.indent.repeat(t2.indentLevel),
              { lineEnd: r2, writeComments: n2 } = t2
            n2 && null != e2.comments && y(t2, e2.comments, i2, r2)
            let s2 = e2.body,
              { length: l2 } = s2
            for (let e3 = 0; e3 < l2; e3++) {
              let l3 = s2[e3]
              ;(n2 && null != l3.comments && y(t2, l3.comments, i2, r2),
                t2.write(i2),
                this[l3.type](l3, t2),
                t2.write(r2))
            }
            n2 && null != e2.trailingComments && y(t2, e2.trailingComments, i2, r2)
          },
          BlockStatement: (s = function (e2, t2) {
            let i2 = t2.indent.repeat(t2.indentLevel++),
              { lineEnd: r2, writeComments: n2 } = t2,
              s2 = i2 + t2.indent
            t2.write('{')
            let l2 = e2.body
            if (null != l2 && l2.length > 0) {
              ;(t2.write(r2), n2 && null != e2.comments && y(t2, e2.comments, s2, r2))
              let { length: o2 } = l2
              for (let e3 = 0; e3 < o2; e3++) {
                let i3 = l2[e3]
                ;(n2 && null != i3.comments && y(t2, i3.comments, s2, r2),
                  t2.write(s2),
                  this[i3.type](i3, t2),
                  t2.write(r2))
              }
              t2.write(i2)
            } else n2 && null != e2.comments && (t2.write(r2), y(t2, e2.comments, s2, r2), t2.write(i2))
            ;(n2 && null != e2.trailingComments && y(t2, e2.trailingComments, s2, r2), t2.write('}'), t2.indentLevel--)
          }),
          ClassBody: s,
          StaticBlock(e2, t2) {
            ;(t2.write('static '), this.BlockStatement(e2, t2))
          },
          EmptyStatement(e2, t2) {
            t2.write(';')
          },
          ExpressionStatement(e2, t2) {
            let i2 = t2.expressionsPrecedence[e2.expression.type]
            ;(i2 === w || (3 === i2 && 'O' === e2.expression.left.type[0])
              ? (t2.write('('), this[e2.expression.type](e2.expression, t2), t2.write(')'))
              : this[e2.expression.type](e2.expression, t2),
              t2.write(';'))
          },
          IfStatement(e2, t2) {
            ;(t2.write('if ('),
              this[e2.test.type](e2.test, t2),
              t2.write(') '),
              this[e2.consequent.type](e2.consequent, t2),
              null != e2.alternate && (t2.write(' else '), this[e2.alternate.type](e2.alternate, t2)))
          },
          LabeledStatement(e2, t2) {
            ;(this[e2.label.type](e2.label, t2), t2.write(': '), this[e2.body.type](e2.body, t2))
          },
          BreakStatement(e2, t2) {
            ;(t2.write('break'), null != e2.label && (t2.write(' '), this[e2.label.type](e2.label, t2)), t2.write(';'))
          },
          ContinueStatement(e2, t2) {
            ;(t2.write('continue'),
              null != e2.label && (t2.write(' '), this[e2.label.type](e2.label, t2)),
              t2.write(';'))
          },
          WithStatement(e2, t2) {
            ;(t2.write('with ('), this[e2.object.type](e2.object, t2), t2.write(') '), this[e2.body.type](e2.body, t2))
          },
          SwitchStatement(e2, t2) {
            let i2 = t2.indent.repeat(t2.indentLevel++),
              { lineEnd: r2, writeComments: n2 } = t2
            t2.indentLevel++
            let s2 = i2 + t2.indent,
              l2 = s2 + t2.indent
            ;(t2.write('switch ('), this[e2.discriminant.type](e2.discriminant, t2), t2.write(') {' + r2))
            let { cases: o2 } = e2,
              { length: a2 } = o2
            for (let e3 = 0; e3 < a2; e3++) {
              let i3 = o2[e3]
              ;(n2 && null != i3.comments && y(t2, i3.comments, s2, r2),
                i3.test
                  ? (t2.write(s2 + 'case '), this[i3.test.type](i3.test, t2), t2.write(':' + r2))
                  : t2.write(s2 + 'default:' + r2))
              let { consequent: a3 } = i3,
                { length: p2 } = a3
              for (let e4 = 0; e4 < p2; e4++) {
                let i4 = a3[e4]
                ;(n2 && null != i4.comments && y(t2, i4.comments, l2, r2),
                  t2.write(l2),
                  this[i4.type](i4, t2),
                  t2.write(r2))
              }
            }
            ;((t2.indentLevel -= 2), t2.write(i2 + '}'))
          },
          ReturnStatement(e2, t2) {
            ;(t2.write('return'),
              e2.argument && (t2.write(' '), this[e2.argument.type](e2.argument, t2)),
              t2.write(';'))
          },
          ThrowStatement(e2, t2) {
            ;(t2.write('throw '), this[e2.argument.type](e2.argument, t2), t2.write(';'))
          },
          TryStatement(e2, t2) {
            if ((t2.write('try '), this[e2.block.type](e2.block, t2), e2.handler)) {
              let { handler: i2 } = e2
              ;(null == i2.param
                ? t2.write(' catch ')
                : (t2.write(' catch ('), this[i2.param.type](i2.param, t2), t2.write(') ')),
                this[i2.body.type](i2.body, t2))
            }
            e2.finalizer && (t2.write(' finally '), this[e2.finalizer.type](e2.finalizer, t2))
          },
          WhileStatement(e2, t2) {
            ;(t2.write('while ('), this[e2.test.type](e2.test, t2), t2.write(') '), this[e2.body.type](e2.body, t2))
          },
          DoWhileStatement(e2, t2) {
            ;(t2.write('do '),
              this[e2.body.type](e2.body, t2),
              t2.write(' while ('),
              this[e2.test.type](e2.test, t2),
              t2.write(');'))
          },
          ForStatement(e2, t2) {
            if ((t2.write('for ('), null != e2.init)) {
              let { init: i2 } = e2
              'V' === i2.type[0] ? d(t2, i2) : this[i2.type](i2, t2)
            }
            ;(t2.write('; '),
              e2.test && this[e2.test.type](e2.test, t2),
              t2.write('; '),
              e2.update && this[e2.update.type](e2.update, t2),
              t2.write(') '),
              this[e2.body.type](e2.body, t2))
          },
          ForInStatement: (e = function (e2, t2) {
            t2.write(`for ${e2.await ? 'await ' : ''}(`)
            let { left: i2 } = e2
            ;('V' === i2.type[0] ? d(t2, i2) : this[i2.type](i2, t2),
              t2.write('I' === e2.type[3] ? ' in ' : ' of '),
              this[e2.right.type](e2.right, t2),
              t2.write(') '),
              this[e2.body.type](e2.body, t2))
          }),
          ForOfStatement: e,
          DebuggerStatement(e2, t2) {
            t2.write('debugger;', e2)
          },
          FunctionDeclaration: (t = function (e2, t2) {
            ;(t2.write(
              (e2.async ? 'async ' : '') + (e2.generator ? 'function* ' : 'function ') + (e2.id ? e2.id.name : ''),
              e2
            ),
              h(t2, e2.params),
              t2.write(' '),
              this[e2.body.type](e2.body, t2))
          }),
          FunctionExpression: t,
          VariableDeclaration(e2, t2) {
            ;(d(t2, e2), t2.write(';'))
          },
          VariableDeclarator(e2, t2) {
            ;(this[e2.id.type](e2.id, t2), null != e2.init && (t2.write(' = '), this[e2.init.type](e2.init, t2)))
          },
          ClassDeclaration(e2, t2) {
            if ((t2.write('class ' + (e2.id ? `${e2.id.name} ` : ''), e2), e2.superClass)) {
              t2.write('extends ')
              let { superClass: i2 } = e2,
                { type: r2 } = i2,
                n2 = t2.expressionsPrecedence[r2]
              ;(('C' !== r2[0] || 'l' !== r2[1] || 'E' !== r2[5]) &&
              (n2 === w || n2 < t2.expressionsPrecedence.ClassExpression)
                ? (t2.write('('), this[e2.superClass.type](i2, t2), t2.write(')'))
                : this[i2.type](i2, t2),
                t2.write(' '))
            }
            this.ClassBody(e2.body, t2)
          },
          ImportDeclaration(e2, t2) {
            t2.write('import ')
            let { specifiers: i2, attributes: r2 } = e2,
              { length: n2 } = i2,
              s2 = 0
            if (n2 > 0) {
              for (; s2 < n2; ) {
                s2 > 0 && t2.write(', ')
                let e3 = i2[s2],
                  r3 = e3.type[6]
                if ('D' === r3) (t2.write(e3.local.name, e3), s2++)
                else if ('N' === r3) (t2.write('* as ' + e3.local.name, e3), s2++)
                else break
              }
              if (s2 < n2) {
                for (t2.write('{'); ; ) {
                  let e3 = i2[s2],
                    { name: r3 } = e3.imported
                  if ((t2.write(r3, e3), r3 !== e3.local.name && t2.write(' as ' + e3.local.name), ++s2 < n2))
                    t2.write(', ')
                  else break
                }
                t2.write('}')
              }
              t2.write(' from ')
            }
            if ((this.Literal(e2.source, t2), r2 && r2.length > 0)) {
              t2.write(' with { ')
              for (let e3 = 0; e3 < r2.length; e3++)
                (this.ImportAttribute(r2[e3], t2), e3 < r2.length - 1 && t2.write(', '))
              t2.write(' }')
            }
            t2.write(';')
          },
          ImportAttribute(e2, t2) {
            ;(this.Identifier(e2.key, t2), t2.write(': '), this.Literal(e2.value, t2))
          },
          ImportExpression(e2, t2) {
            ;(t2.write('import('), this[e2.source.type](e2.source, t2), t2.write(')'))
          },
          ExportDefaultDeclaration(e2, t2) {
            ;(t2.write('export default '),
              this[e2.declaration.type](e2.declaration, t2),
              null != t2.expressionsPrecedence[e2.declaration.type] && 'F' !== e2.declaration.type[0] && t2.write(';'))
          },
          ExportNamedDeclaration(e2, t2) {
            if ((t2.write('export '), e2.declaration)) this[e2.declaration.type](e2.declaration, t2)
            else {
              t2.write('{')
              let { specifiers: i2 } = e2,
                { length: r2 } = i2
              if (r2 > 0)
                for (let e3 = 0; ; ) {
                  let n2 = i2[e3],
                    { name: s2 } = n2.local
                  if ((t2.write(s2, n2), s2 !== n2.exported.name && t2.write(' as ' + n2.exported.name), ++e3 < r2))
                    t2.write(', ')
                  else break
                }
              if (
                (t2.write('}'),
                e2.source && (t2.write(' from '), this.Literal(e2.source, t2)),
                e2.attributes && e2.attributes.length > 0)
              ) {
                t2.write(' with { ')
                for (let i3 = 0; i3 < e2.attributes.length; i3++)
                  (this.ImportAttribute(e2.attributes[i3], t2), i3 < e2.attributes.length - 1 && t2.write(', '))
                t2.write(' }')
              }
              t2.write(';')
            }
          },
          ExportAllDeclaration(e2, t2) {
            if (
              (null != e2.exported
                ? t2.write('export * as ' + e2.exported.name + ' from ')
                : t2.write('export * from '),
              this.Literal(e2.source, t2),
              e2.attributes && e2.attributes.length > 0)
            ) {
              t2.write(' with { ')
              for (let i2 = 0; i2 < e2.attributes.length; i2++)
                (this.ImportAttribute(e2.attributes[i2], t2), i2 < e2.attributes.length - 1 && t2.write(', '))
              t2.write(' }')
            }
            t2.write(';')
          },
          MethodDefinition(e2, t2) {
            e2.static && t2.write('static ')
            let i2 = e2.kind[0]
            ;(('g' === i2 || 's' === i2) && t2.write(e2.kind + ' '),
              e2.value.async && t2.write('async '),
              e2.value.generator && t2.write('*'),
              e2.computed
                ? (t2.write('['), this[e2.key.type](e2.key, t2), t2.write(']'))
                : this[e2.key.type](e2.key, t2),
              h(t2, e2.value.params),
              t2.write(' '),
              this[e2.value.body.type](e2.value.body, t2))
          },
          ClassExpression(e2, t2) {
            this.ClassDeclaration(e2, t2)
          },
          ArrowFunctionExpression(e2, t2) {
            t2.write(e2.async ? 'async ' : '', e2)
            let { params: i2 } = e2
            ;(null != i2 && (1 === i2.length && 'I' === i2[0].type[0] ? t2.write(i2[0].name, i2[0]) : h(t2, e2.params)),
              t2.write(' => '),
              'O' === e2.body.type[0]
                ? (t2.write('('), this.ObjectExpression(e2.body, t2), t2.write(')'))
                : this[e2.body.type](e2.body, t2))
          },
          ThisExpression(e2, t2) {
            t2.write('this', e2)
          },
          Super(e2, t2) {
            t2.write('super', e2)
          },
          RestElement: (i = function (e2, t2) {
            ;(t2.write('...'), this[e2.argument.type](e2.argument, t2))
          }),
          SpreadElement: i,
          YieldExpression(e2, t2) {
            ;(t2.write(e2.delegate ? 'yield*' : 'yield'),
              e2.argument && (t2.write(' '), this[e2.argument.type](e2.argument, t2)))
          },
          AwaitExpression(e2, t2) {
            ;(t2.write('await ', e2), m(t2, e2.argument, e2))
          },
          TemplateLiteral(e2, t2) {
            let { quasis: i2, expressions: r2 } = e2
            t2.write('`')
            let { length: n2 } = r2
            for (let e3 = 0; e3 < n2; e3++) {
              let n3 = r2[e3],
                s3 = i2[e3]
              ;(t2.write(s3.value.raw, s3), t2.write('${'), this[n3.type](n3, t2), t2.write('}'))
            }
            let s2 = i2[i2.length - 1]
            ;(t2.write(s2.value.raw, s2), t2.write('`'))
          },
          TemplateElement(e2, t2) {
            t2.write(e2.value.raw, e2)
          },
          TaggedTemplateExpression(e2, t2) {
            ;(m(t2, e2.tag, e2), this[e2.quasi.type](e2.quasi, t2))
          },
          ArrayExpression: (n = function (e2, t2) {
            if ((t2.write('['), e2.elements.length > 0)) {
              let { elements: i2 } = e2,
                { length: r2 } = i2
              for (let e3 = 0; ; ) {
                let n2 = i2[e3]
                if ((null != n2 && this[n2.type](n2, t2), ++e3 < r2)) t2.write(', ')
                else {
                  null == n2 && t2.write(', ')
                  break
                }
              }
            }
            t2.write(']')
          }),
          ArrayPattern: n,
          ObjectExpression(e2, t2) {
            let i2 = t2.indent.repeat(t2.indentLevel++),
              { lineEnd: r2, writeComments: n2 } = t2,
              s2 = i2 + t2.indent
            if ((t2.write('{'), e2.properties.length > 0)) {
              ;(t2.write(r2), n2 && null != e2.comments && y(t2, e2.comments, s2, r2))
              let l2 = ',' + r2,
                { properties: o2 } = e2,
                { length: a2 } = o2
              for (let e3 = 0; ; ) {
                let i3 = o2[e3]
                if (
                  (n2 && null != i3.comments && y(t2, i3.comments, s2, r2),
                  t2.write(s2),
                  this[i3.type](i3, t2),
                  ++e3 < a2)
                )
                  t2.write(l2)
                else break
              }
              ;(t2.write(r2),
                n2 && null != e2.trailingComments && y(t2, e2.trailingComments, s2, r2),
                t2.write(i2 + '}'))
            } else
              n2
                ? null != e2.comments
                  ? (t2.write(r2),
                    y(t2, e2.comments, s2, r2),
                    null != e2.trailingComments && y(t2, e2.trailingComments, s2, r2),
                    t2.write(i2 + '}'))
                  : null != e2.trailingComments
                    ? (t2.write(r2), y(t2, e2.trailingComments, s2, r2), t2.write(i2 + '}'))
                    : t2.write('}')
                : t2.write('}')
            t2.indentLevel--
          },
          Property(e2, t2) {
            e2.method || 'i' !== e2.kind[0]
              ? this.MethodDefinition(e2, t2)
              : (e2.shorthand ||
                  (e2.computed
                    ? (t2.write('['), this[e2.key.type](e2.key, t2), t2.write(']'))
                    : this[e2.key.type](e2.key, t2),
                  t2.write(': ')),
                this[e2.value.type](e2.value, t2))
          },
          PropertyDefinition(e2, t2) {
            if (
              (e2.static && t2.write('static '),
              e2.computed && t2.write('['),
              this[e2.key.type](e2.key, t2),
              e2.computed && t2.write(']'),
              null == e2.value)
            ) {
              'F' !== e2.key.type[0] && t2.write(';')
              return
            }
            ;(t2.write(' = '), this[e2.value.type](e2.value, t2), t2.write(';'))
          },
          ObjectPattern(e2, t2) {
            if ((t2.write('{'), e2.properties.length > 0)) {
              let { properties: i2 } = e2,
                { length: r2 } = i2
              for (let e3 = 0; ; )
                if ((this[i2[e3].type](i2[e3], t2), ++e3 < r2)) t2.write(', ')
                else break
            }
            t2.write('}')
          },
          SequenceExpression(e2, t2) {
            h(t2, e2.expressions)
          },
          UnaryExpression(e2, t2) {
            if (e2.prefix) {
              let {
                operator: i2,
                argument: r2,
                argument: { type: n2 },
              } = e2
              t2.write(i2)
              let s2 = c(t2, r2, e2)
              ;(!s2 &&
                (i2.length > 1 ||
                  ('U' === n2[0] &&
                    ('n' === n2[1] || 'p' === n2[1]) &&
                    r2.prefix &&
                    r2.operator[0] === i2 &&
                    ('+' === i2 || '-' === i2))) &&
                t2.write(' '),
                s2 ? (t2.write(i2.length > 1 ? ' (' : '('), this[n2](r2, t2), t2.write(')')) : this[n2](r2, t2))
            } else (this[e2.argument.type](e2.argument, t2), t2.write(e2.operator))
          },
          UpdateExpression(e2, t2) {
            e2.prefix
              ? (t2.write(e2.operator), this[e2.argument.type](e2.argument, t2))
              : (this[e2.argument.type](e2.argument, t2), t2.write(e2.operator))
          },
          AssignmentExpression(e2, t2) {
            ;(this[e2.left.type](e2.left, t2), t2.write(' ' + e2.operator + ' '), this[e2.right.type](e2.right, t2))
          },
          AssignmentPattern(e2, t2) {
            ;(this[e2.left.type](e2.left, t2), t2.write(' = '), this[e2.right.type](e2.right, t2))
          },
          BinaryExpression: (r = function (e2, t2) {
            let i2 = 'in' === e2.operator
            ;(i2 && t2.write('('),
              m(t2, e2.left, e2, false),
              t2.write(' ' + e2.operator + ' '),
              m(t2, e2.right, e2, true),
              i2 && t2.write(')'))
          }),
          LogicalExpression: r,
          ConditionalExpression(e2, t2) {
            let { test: i2 } = e2,
              r2 = t2.expressionsPrecedence[i2.type]
            ;(r2 === w || r2 <= t2.expressionsPrecedence.ConditionalExpression
              ? (t2.write('('), this[i2.type](i2, t2), t2.write(')'))
              : this[i2.type](i2, t2),
              t2.write(' ? '),
              this[e2.consequent.type](e2.consequent, t2),
              t2.write(' : '),
              this[e2.alternate.type](e2.alternate, t2))
          },
          NewExpression(e2, t2) {
            t2.write('new ')
            let i2 = t2.expressionsPrecedence[e2.callee.type]
            ;(i2 === w ||
            i2 < t2.expressionsPrecedence.CallExpression ||
            (function (e3) {
              let t3 = e3
              for (; null != t3; ) {
                let { type: e4 } = t3
                if ('C' === e4[0] && 'a' === e4[1]) return true
                if ('M' !== e4[0] || 'e' !== e4[1] || 'm' !== e4[2]) return false
                t3 = t3.object
              }
            })(e2.callee)
              ? (t2.write('('), this[e2.callee.type](e2.callee, t2), t2.write(')'))
              : this[e2.callee.type](e2.callee, t2),
              h(t2, e2.arguments))
          },
          CallExpression(e2, t2) {
            let i2 = t2.expressionsPrecedence[e2.callee.type]
            ;(i2 === w || i2 < t2.expressionsPrecedence.CallExpression
              ? (t2.write('('), this[e2.callee.type](e2.callee, t2), t2.write(')'))
              : this[e2.callee.type](e2.callee, t2),
              e2.optional && t2.write('?.'),
              h(t2, e2.arguments))
          },
          ChainExpression(e2, t2) {
            this[e2.expression.type](e2.expression, t2)
          },
          MemberExpression(e2, t2) {
            let i2 = t2.expressionsPrecedence[e2.object.type]
            ;(i2 === w || i2 < t2.expressionsPrecedence.MemberExpression
              ? (t2.write('('), this[e2.object.type](e2.object, t2), t2.write(')'))
              : this[e2.object.type](e2.object, t2),
              e2.computed
                ? (e2.optional && t2.write('?.'), t2.write('['), this[e2.property.type](e2.property, t2), t2.write(']'))
                : (e2.optional ? t2.write('?.') : t2.write('.'), this[e2.property.type](e2.property, t2)))
          },
          MetaProperty(e2, t2) {
            t2.write(e2.meta.name + '.' + e2.property.name, e2)
          },
          Identifier(e2, t2) {
            t2.write(e2.name, e2)
          },
          PrivateIdentifier(e2, t2) {
            t2.write(`#${e2.name}`, e2)
          },
          Literal(e2, t2) {
            null != e2.raw
              ? t2.write(e2.raw, e2)
              : null != e2.regex
                ? this.RegExpLiteral(e2, t2)
                : null != e2.bigint
                  ? t2.write(e2.bigint + 'n', e2)
                  : t2.write(a(e2.value), e2)
          },
          RegExpLiteral(e2, t2) {
            let { regex: i2 } = e2
            t2.write(`/${i2.pattern}/${i2.flags}`, e2)
          },
        },
        g = {},
        b = f
      class x {
        constructor(e2) {
          const t2 = null == e2 ? g : e2
          ;((this.output = ''),
            null != t2.output ? ((this.output = t2.output), (this.write = this.writeToStream)) : (this.output = ''),
            (this.generator = null != t2.generator ? t2.generator : f),
            (this.expressionsPrecedence = null != t2.expressionsPrecedence ? t2.expressionsPrecedence : u),
            (this.indent = null != t2.indent ? t2.indent : '  '),
            (this.lineEnd = null != t2.lineEnd ? t2.lineEnd : '\n'),
            (this.indentLevel = null != t2.startingIndentLevel ? t2.startingIndentLevel : 0),
            (this.writeComments = !!t2.comments && t2.comments),
            null != t2.sourceMap &&
              ((this.write = null == t2.output ? this.writeAndMap : this.writeToStreamAndMap),
              (this.sourceMap = t2.sourceMap),
              (this.line = 1),
              (this.column = 0),
              (this.lineEndSize = this.lineEnd.split('\n').length - 1),
              (this.mapping = {
                original: null,
                generated: this,
                name: void 0,
                source: t2.sourceMap.file || t2.sourceMap._file,
              })))
        }
        write(e2) {
          this.output += e2
        }
        writeToStream(e2) {
          this.output.write(e2)
        }
        writeAndMap(e2, t2) {
          ;((this.output += e2), this.map(e2, t2))
        }
        writeToStreamAndMap(e2, t2) {
          ;(this.output.write(e2), this.map(e2, t2))
        }
        map(e2, t2) {
          if (null != t2) {
            let { type: i3 } = t2
            if ('L' === i3[0] && 'n' === i3[2]) {
              ;((this.column = 0), this.line++)
              return
            }
            if (null != t2.loc) {
              let { mapping: e3 } = this
              ;((e3.original = t2.loc.start), (e3.name = t2.name), this.sourceMap.addMapping(e3))
            }
            if (('T' === i3[0] && 'E' === i3[8]) || ('L' === i3[0] && 'i' === i3[1] && 'string' == typeof t2.value)) {
              let { length: t3 } = e2,
                { column: i4, line: r3 } = this
              for (let n2 = 0; n2 < t3; n2++) '\n' === e2[n2] ? ((i4 = 0), r3++) : i4++
              ;((this.column = i4), (this.line = r3))
              return
            }
          }
          let { length: i2 } = e2,
            { lineEnd: r2 } = this
          i2 > 0 &&
            (this.lineEndSize > 0 && (1 === r2.length ? e2[i2 - 1] === r2 : e2.endsWith(r2))
              ? ((this.line += this.lineEndSize), (this.column = 0))
              : (this.column += i2))
        }
        toString() {
          return this.output
        }
      }
      function E(e2, t2) {
        let i2 = new x(t2)
        return (i2.generator[e2.type](e2, i2), i2.output)
      }
      module2.exports = o
    })()
  },
})

// node_modules/dd-trace/vendor/dist/esquery/index.js
var require_esquery = __commonJS({
  'node_modules/dd-trace/vendor/dist/esquery/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e = {}
      ;((e.d = (t2, r2) => {
        for (var n2 in r2)
          e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] })
      }),
        (e.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2)),
        (e.r = (e2) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e2, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(e2, '__esModule', { value: true }))
        }))
      var t = {}
      function r(e2) {
        return (r =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (e3) {
                return typeof e3
              }
            : function (e3) {
                return e3 && 'function' == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype
                  ? 'symbol'
                  : typeof e3
              })(e2)
      }
      function n(e2, t2) {
        return (
          (function (e3) {
            if (Array.isArray(e3)) return e3
          })(e2) ||
          (function (e3, t3) {
            var r2 = null == e3 ? null : ('undefined' != typeof Symbol && e3[Symbol.iterator]) || e3['@@iterator']
            if (null != r2) {
              var n2,
                o2,
                a2,
                i2,
                s2 = [],
                l2 = true,
                u2 = false
              try {
                if (((a2 = (r2 = r2.call(e3)).next), 0 === t3)) {
                  if (Object(r2) !== r2) return
                  l2 = false
                } else for (; !(l2 = (n2 = a2.call(r2)).done) && (s2.push(n2.value), s2.length !== t3); l2 = true);
              } catch (e4) {
                ;((u2 = true), (o2 = e4))
              } finally {
                try {
                  if (!l2 && null != r2.return && ((i2 = r2.return()), Object(i2) !== i2)) return
                } finally {
                  if (u2) throw o2
                }
              }
              return s2
            }
          })(e2, t2) ||
          o(e2, t2) ||
          (function () {
            throw TypeError(
              'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
            )
          })()
        )
      }
      function o(e2, t2) {
        if (e2) {
          if ('string' == typeof e2) return a(e2, t2)
          var r2 = Object.prototype.toString.call(e2).slice(8, -1)
          return (
            'Object' === r2 && e2.constructor && (r2 = e2.constructor.name),
            'Map' === r2 || 'Set' === r2
              ? Array.from(e2)
              : 'Arguments' === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2)
                ? a(e2, t2)
                : void 0
          )
        }
      }
      function a(e2, t2) {
        ;(null == t2 || t2 > e2.length) && (t2 = e2.length)
        for (var r2 = 0, n2 = Array(t2); r2 < t2; r2++) n2[r2] = e2[r2]
        return n2
      }
      function i(e2, t2) {
        return (e2((t2 = { exports: {} }), t2.exports), t2.exports)
      }
      ;(e.r(t),
        e.d(t, { default: () => E }),
        'undefined' != typeof globalThis ||
          ('undefined' != typeof window
            ? window
            : 'undefined' != typeof global
              ? global
              : 'undefined' != typeof self && self))
      var s = i(function (e2, t2) {
          !(function e3(t3) {
            var r2, n2, o2, a2, i2, s2
            function l2(e4) {
              var t4,
                r3,
                n3 = {}
              for (t4 in e4)
                e4.hasOwnProperty(t4) && ((r3 = e4[t4]), (n3[t4] = 'object' == typeof r3 && null !== r3 ? l2(r3) : r3))
              return n3
            }
            function u2(e4, t4) {
              ;((this.parent = e4), (this.key = t4))
            }
            function c2(e4, t4, r3, n3) {
              ;((this.node = e4), (this.path = t4), (this.wrap = r3), (this.ref = n3))
            }
            function f2() {}
            function p2(e4) {
              return null != e4 && 'object' == typeof e4 && 'string' == typeof e4.type
            }
            function h2(e4, t4) {
              return (e4 === r2.ObjectExpression || e4 === r2.ObjectPattern) && 'properties' === t4
            }
            function y2(e4, t4) {
              for (var r3 = e4.length - 1; r3 >= 0; --r3) if (e4[r3].node === t4) return true
              return false
            }
            function d2(e4, t4) {
              return new f2().traverse(e4, t4)
            }
            return (
              (r2 = {
                AssignmentExpression: 'AssignmentExpression',
                AssignmentPattern: 'AssignmentPattern',
                ArrayExpression: 'ArrayExpression',
                ArrayPattern: 'ArrayPattern',
                ArrowFunctionExpression: 'ArrowFunctionExpression',
                AwaitExpression: 'AwaitExpression',
                BlockStatement: 'BlockStatement',
                BinaryExpression: 'BinaryExpression',
                BreakStatement: 'BreakStatement',
                CallExpression: 'CallExpression',
                CatchClause: 'CatchClause',
                ChainExpression: 'ChainExpression',
                ClassBody: 'ClassBody',
                ClassDeclaration: 'ClassDeclaration',
                ClassExpression: 'ClassExpression',
                ComprehensionBlock: 'ComprehensionBlock',
                ComprehensionExpression: 'ComprehensionExpression',
                ConditionalExpression: 'ConditionalExpression',
                ContinueStatement: 'ContinueStatement',
                DebuggerStatement: 'DebuggerStatement',
                DirectiveStatement: 'DirectiveStatement',
                DoWhileStatement: 'DoWhileStatement',
                EmptyStatement: 'EmptyStatement',
                ExportAllDeclaration: 'ExportAllDeclaration',
                ExportDefaultDeclaration: 'ExportDefaultDeclaration',
                ExportNamedDeclaration: 'ExportNamedDeclaration',
                ExportSpecifier: 'ExportSpecifier',
                ExpressionStatement: 'ExpressionStatement',
                ForStatement: 'ForStatement',
                ForInStatement: 'ForInStatement',
                ForOfStatement: 'ForOfStatement',
                FunctionDeclaration: 'FunctionDeclaration',
                FunctionExpression: 'FunctionExpression',
                GeneratorExpression: 'GeneratorExpression',
                Identifier: 'Identifier',
                IfStatement: 'IfStatement',
                ImportExpression: 'ImportExpression',
                ImportDeclaration: 'ImportDeclaration',
                ImportDefaultSpecifier: 'ImportDefaultSpecifier',
                ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
                ImportSpecifier: 'ImportSpecifier',
                Literal: 'Literal',
                LabeledStatement: 'LabeledStatement',
                LogicalExpression: 'LogicalExpression',
                MemberExpression: 'MemberExpression',
                MetaProperty: 'MetaProperty',
                MethodDefinition: 'MethodDefinition',
                ModuleSpecifier: 'ModuleSpecifier',
                NewExpression: 'NewExpression',
                ObjectExpression: 'ObjectExpression',
                ObjectPattern: 'ObjectPattern',
                PrivateIdentifier: 'PrivateIdentifier',
                Program: 'Program',
                Property: 'Property',
                PropertyDefinition: 'PropertyDefinition',
                RestElement: 'RestElement',
                ReturnStatement: 'ReturnStatement',
                SequenceExpression: 'SequenceExpression',
                SpreadElement: 'SpreadElement',
                Super: 'Super',
                SwitchStatement: 'SwitchStatement',
                SwitchCase: 'SwitchCase',
                TaggedTemplateExpression: 'TaggedTemplateExpression',
                TemplateElement: 'TemplateElement',
                TemplateLiteral: 'TemplateLiteral',
                ThisExpression: 'ThisExpression',
                ThrowStatement: 'ThrowStatement',
                TryStatement: 'TryStatement',
                UnaryExpression: 'UnaryExpression',
                UpdateExpression: 'UpdateExpression',
                VariableDeclaration: 'VariableDeclaration',
                VariableDeclarator: 'VariableDeclarator',
                WhileStatement: 'WhileStatement',
                WithStatement: 'WithStatement',
                YieldExpression: 'YieldExpression',
              }),
              (o2 = {
                AssignmentExpression: ['left', 'right'],
                AssignmentPattern: ['left', 'right'],
                ArrayExpression: ['elements'],
                ArrayPattern: ['elements'],
                ArrowFunctionExpression: ['params', 'body'],
                AwaitExpression: ['argument'],
                BlockStatement: ['body'],
                BinaryExpression: ['left', 'right'],
                BreakStatement: ['label'],
                CallExpression: ['callee', 'arguments'],
                CatchClause: ['param', 'body'],
                ChainExpression: ['expression'],
                ClassBody: ['body'],
                ClassDeclaration: ['id', 'superClass', 'body'],
                ClassExpression: ['id', 'superClass', 'body'],
                ComprehensionBlock: ['left', 'right'],
                ComprehensionExpression: ['blocks', 'filter', 'body'],
                ConditionalExpression: ['test', 'consequent', 'alternate'],
                ContinueStatement: ['label'],
                DebuggerStatement: [],
                DirectiveStatement: [],
                DoWhileStatement: ['body', 'test'],
                EmptyStatement: [],
                ExportAllDeclaration: ['source'],
                ExportDefaultDeclaration: ['declaration'],
                ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
                ExportSpecifier: ['exported', 'local'],
                ExpressionStatement: ['expression'],
                ForStatement: ['init', 'test', 'update', 'body'],
                ForInStatement: ['left', 'right', 'body'],
                ForOfStatement: ['left', 'right', 'body'],
                FunctionDeclaration: ['id', 'params', 'body'],
                FunctionExpression: ['id', 'params', 'body'],
                GeneratorExpression: ['blocks', 'filter', 'body'],
                Identifier: [],
                IfStatement: ['test', 'consequent', 'alternate'],
                ImportExpression: ['source'],
                ImportDeclaration: ['specifiers', 'source'],
                ImportDefaultSpecifier: ['local'],
                ImportNamespaceSpecifier: ['local'],
                ImportSpecifier: ['imported', 'local'],
                Literal: [],
                LabeledStatement: ['label', 'body'],
                LogicalExpression: ['left', 'right'],
                MemberExpression: ['object', 'property'],
                MetaProperty: ['meta', 'property'],
                MethodDefinition: ['key', 'value'],
                ModuleSpecifier: [],
                NewExpression: ['callee', 'arguments'],
                ObjectExpression: ['properties'],
                ObjectPattern: ['properties'],
                PrivateIdentifier: [],
                Program: ['body'],
                Property: ['key', 'value'],
                PropertyDefinition: ['key', 'value'],
                RestElement: ['argument'],
                ReturnStatement: ['argument'],
                SequenceExpression: ['expressions'],
                SpreadElement: ['argument'],
                Super: [],
                SwitchStatement: ['discriminant', 'cases'],
                SwitchCase: ['test', 'consequent'],
                TaggedTemplateExpression: ['tag', 'quasi'],
                TemplateElement: [],
                TemplateLiteral: ['quasis', 'expressions'],
                ThisExpression: [],
                ThrowStatement: ['argument'],
                TryStatement: ['block', 'handler', 'finalizer'],
                UnaryExpression: ['argument'],
                UpdateExpression: ['argument'],
                VariableDeclaration: ['declarations'],
                VariableDeclarator: ['id', 'init'],
                WhileStatement: ['test', 'body'],
                WithStatement: ['object', 'body'],
                YieldExpression: ['argument'],
              }),
              (n2 = { Break: (a2 = {}), Skip: (i2 = {}), Remove: (s2 = {}) }),
              (u2.prototype.replace = function (e4) {
                this.parent[this.key] = e4
              }),
              (u2.prototype.remove = function () {
                return Array.isArray(this.parent)
                  ? (this.parent.splice(this.key, 1), true)
                  : (this.replace(null), false)
              }),
              (f2.prototype.path = function () {
                var e4, t4, r3, n3, o3
                function a3(e5, t5) {
                  if (Array.isArray(t5)) for (r3 = 0, n3 = t5.length; r3 < n3; ++r3) e5.push(t5[r3])
                  else e5.push(t5)
                }
                if (!this.__current.path) return null
                for (o3 = [], e4 = 2, t4 = this.__leavelist.length; e4 < t4; ++e4) a3(o3, this.__leavelist[e4].path)
                return (a3(o3, this.__current.path), o3)
              }),
              (f2.prototype.type = function () {
                return this.current().type || this.__current.wrap
              }),
              (f2.prototype.parents = function () {
                var e4, t4, r3
                for (r3 = [], e4 = 1, t4 = this.__leavelist.length; e4 < t4; ++e4) r3.push(this.__leavelist[e4].node)
                return r3
              }),
              (f2.prototype.current = function () {
                return this.__current.node
              }),
              (f2.prototype.__execute = function (e4, t4) {
                var r3, n3
                return (
                  (n3 = void 0),
                  (r3 = this.__current),
                  (this.__current = t4),
                  (this.__state = null),
                  e4 && (n3 = e4.call(this, t4.node, this.__leavelist[this.__leavelist.length - 1].node)),
                  (this.__current = r3),
                  n3
                )
              }),
              (f2.prototype.notify = function (e4) {
                this.__state = e4
              }),
              (f2.prototype.skip = function () {
                this.notify(i2)
              }),
              (f2.prototype.break = function () {
                this.notify(a2)
              }),
              (f2.prototype.remove = function () {
                this.notify(s2)
              }),
              (f2.prototype.__initialize = function (e4, t4) {
                ;((this.visitor = t4),
                  (this.root = e4),
                  (this.__worklist = []),
                  (this.__leavelist = []),
                  (this.__current = null),
                  (this.__state = null),
                  (this.__fallback = null),
                  'iteration' === t4.fallback
                    ? (this.__fallback = Object.keys)
                    : 'function' == typeof t4.fallback && (this.__fallback = t4.fallback),
                  (this.__keys = o2),
                  t4.keys && (this.__keys = Object.assign(Object.create(this.__keys), t4.keys)))
              }),
              (f2.prototype.traverse = function (e4, t4) {
                var r3, n3, o3, s3, l3, u3, f3, d3, m2, x2, v2, g2
                for (
                  this.__initialize(e4, t4),
                    g2 = {},
                    r3 = this.__worklist,
                    n3 = this.__leavelist,
                    r3.push(new c2(e4, null, null, null)),
                    n3.push(new c2(null, null, null, null));
                  r3.length;
                )
                  if ((o3 = r3.pop()) !== g2) {
                    if (o3.node) {
                      if (((u3 = this.__execute(t4.enter, o3)), this.__state === a2 || u3 === a2)) return
                      if ((r3.push(g2), n3.push(o3), this.__state === i2 || u3 === i2)) continue
                      if (((l3 = (s3 = o3.node).type || o3.wrap), !(x2 = this.__keys[l3]))) {
                        if (!this.__fallback) throw Error('Unknown node type ' + l3 + '.')
                        x2 = this.__fallback(s3)
                      }
                      for (d3 = x2.length; (d3 -= 1) >= 0; )
                        if ((v2 = s3[(f3 = x2[d3])])) {
                          if (Array.isArray(v2)) {
                            for (m2 = v2.length; (m2 -= 1) >= 0; )
                              if (v2[m2] && !y2(n3, v2[m2])) {
                                if (h2(l3, x2[d3])) o3 = new c2(v2[m2], [f3, m2], 'Property', null)
                                else {
                                  if (!p2(v2[m2])) continue
                                  o3 = new c2(v2[m2], [f3, m2], null, null)
                                }
                                r3.push(o3)
                              }
                          } else if (p2(v2)) {
                            if (y2(n3, v2)) continue
                            r3.push(new c2(v2, f3, null, null))
                          }
                        }
                    }
                  } else if (((o3 = n3.pop()), (u3 = this.__execute(t4.leave, o3)), this.__state === a2 || u3 === a2))
                    return
              }),
              (f2.prototype.replace = function (e4, t4) {
                var r3, n3, o3, l3, f3, y3, d3, m2, x2, v2, g2, A2, b2
                function E2(e5) {
                  var t5, n4, o4, a3
                  if (e5.ref.remove()) {
                    for (n4 = e5.ref.key, a3 = e5.ref.parent, t5 = r3.length; t5--; )
                      if ((o4 = r3[t5]).ref && o4.ref.parent === a3) {
                        if (o4.ref.key < n4) break
                        --o4.ref.key
                      }
                  }
                }
                for (
                  this.__initialize(e4, t4),
                    g2 = {},
                    r3 = this.__worklist,
                    n3 = this.__leavelist,
                    y3 = new c2(e4, null, null, new u2((A2 = { root: e4 }), 'root')),
                    r3.push(y3),
                    n3.push(y3);
                  r3.length;
                )
                  if ((y3 = r3.pop()) !== g2) {
                    if (
                      (void 0 !== (f3 = this.__execute(t4.enter, y3)) &&
                        f3 !== a2 &&
                        f3 !== i2 &&
                        f3 !== s2 &&
                        (y3.ref.replace(f3), (y3.node = f3)),
                      (this.__state !== s2 && f3 !== s2) || (E2(y3), (y3.node = null)),
                      this.__state === a2 || f3 === a2)
                    )
                      return A2.root
                    if ((o3 = y3.node) && (r3.push(g2), n3.push(y3), this.__state !== i2 && f3 !== i2)) {
                      if (((l3 = o3.type || y3.wrap), !(x2 = this.__keys[l3]))) {
                        if (!this.__fallback) throw Error('Unknown node type ' + l3 + '.')
                        x2 = this.__fallback(o3)
                      }
                      for (d3 = x2.length; (d3 -= 1) >= 0; )
                        if ((v2 = o3[(b2 = x2[d3])]))
                          if (Array.isArray(v2)) {
                            for (m2 = v2.length; (m2 -= 1) >= 0; )
                              if (v2[m2]) {
                                if (h2(l3, x2[d3])) y3 = new c2(v2[m2], [b2, m2], 'Property', new u2(v2, m2))
                                else {
                                  if (!p2(v2[m2])) continue
                                  y3 = new c2(v2[m2], [b2, m2], null, new u2(v2, m2))
                                }
                                r3.push(y3)
                              }
                          } else p2(v2) && r3.push(new c2(v2, b2, null, new u2(o3, b2)))
                    }
                  } else if (
                    ((y3 = n3.pop()),
                    void 0 !== (f3 = this.__execute(t4.leave, y3)) &&
                      f3 !== a2 &&
                      f3 !== i2 &&
                      f3 !== s2 &&
                      y3.ref.replace(f3),
                    (this.__state !== s2 && f3 !== s2) || E2(y3),
                    this.__state === a2 || f3 === a2)
                  )
                    break
                return A2.root
              }),
              (t3.Syntax = r2),
              (t3.traverse = d2),
              (t3.replace = function (e4, t4) {
                return new f2().replace(e4, t4)
              }),
              (t3.attachComments = function (e4, t4, r3) {
                var o3,
                  a3,
                  i3,
                  s3,
                  u3 = []
                if (!e4.range) throw Error('attachComments needs range information')
                if (!r3.length) {
                  if (t4.length) {
                    for (i3 = 0, a3 = t4.length; i3 < a3; i3 += 1)
                      (((o3 = l2(t4[i3])).extendedRange = [0, e4.range[0]]), u3.push(o3))
                    e4.leadingComments = u3
                  }
                  return e4
                }
                for (i3 = 0, a3 = t4.length; i3 < a3; i3 += 1)
                  u3.push(
                    (function (e5, t5) {
                      var r4
                      return (
                        (r4 = (function (e6, t6) {
                          var r5, n3, o4, a4
                          for (n3 = e6.length, o4 = 0; n3; )
                            t6(e6[(a4 = o4 + (r5 = n3 >>> 1))]) ? (n3 = r5) : ((o4 = a4 + 1), (n3 -= r5 + 1))
                          return o4
                        })(t5, function (t6) {
                          return t6.range[0] > e5.range[0]
                        })),
                        (e5.extendedRange = [e5.range[0], e5.range[1]]),
                        r4 !== t5.length && (e5.extendedRange[1] = t5[r4].range[0]),
                        (r4 -= 1) >= 0 && (e5.extendedRange[0] = t5[r4].range[1]),
                        e5
                      )
                    })(l2(t4[i3]), r3)
                  )
                return (
                  (s3 = 0),
                  d2(e4, {
                    enter: function (e5) {
                      for (var t5; s3 < u3.length && !((t5 = u3[s3]).extendedRange[1] > e5.range[0]); )
                        t5.extendedRange[1] === e5.range[0]
                          ? (e5.leadingComments || (e5.leadingComments = []),
                            e5.leadingComments.push(t5),
                            u3.splice(s3, 1))
                          : (s3 += 1)
                      return s3 === u3.length ? n2.Break : u3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0
                    },
                  }),
                  (s3 = 0),
                  d2(e4, {
                    leave: function (e5) {
                      for (var t5; s3 < u3.length && ((t5 = u3[s3]), !(e5.range[1] < t5.extendedRange[0])); )
                        e5.range[1] === t5.extendedRange[0]
                          ? (e5.trailingComments || (e5.trailingComments = []),
                            e5.trailingComments.push(t5),
                            u3.splice(s3, 1))
                          : (s3 += 1)
                      return s3 === u3.length ? n2.Break : u3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0
                    },
                  }),
                  e4
                )
              }),
              (t3.VisitorKeys = o2),
              (t3.VisitorOption = n2),
              (t3.Controller = f2),
              (t3.cloneEnvironment = function () {
                return e3({})
              }),
              t3
            )
          })(t2)
        }),
        l = i(function (e2) {
          e2.exports &&
            (e2.exports = (function () {
              function e3(t2, r2, n2, o2) {
                ;((this.message = t2),
                  (this.expected = r2),
                  (this.found = n2),
                  (this.location = o2),
                  (this.name = 'SyntaxError'),
                  'function' == typeof Error.captureStackTrace && Error.captureStackTrace(this, e3))
              }
              return (
                (function (e4, t2) {
                  function r2() {
                    this.constructor = e4
                  }
                  ;((r2.prototype = t2.prototype), (e4.prototype = new r2()))
                })(e3, Error),
                (e3.buildMessage = function (e4, t2) {
                  var r2 = {
                    literal: function (e5) {
                      return '"' + o2(e5.text) + '"'
                    },
                    class: function (e5) {
                      var t3,
                        r3 = ''
                      for (t3 = 0; t3 < e5.parts.length; t3++)
                        r3 +=
                          e5.parts[t3] instanceof Array
                            ? a2(e5.parts[t3][0]) + '-' + a2(e5.parts[t3][1])
                            : a2(e5.parts[t3])
                      return '[' + (e5.inverted ? '^' : '') + r3 + ']'
                    },
                    any: function (e5) {
                      return 'any character'
                    },
                    end: function (e5) {
                      return 'end of input'
                    },
                    other: function (e5) {
                      return e5.description
                    },
                  }
                  function n2(e5) {
                    return e5.charCodeAt(0).toString(16).toUpperCase()
                  }
                  function o2(e5) {
                    return e5
                      .replace(/\\/g, '\\\\')
                      .replace(/"/g, '\\"')
                      .replace(/\0/g, '\\0')
                      .replace(/\t/g, '\\t')
                      .replace(/\n/g, '\\n')
                      .replace(/\r/g, '\\r')
                      .replace(/[\x00-\x0F]/g, function (e6) {
                        return '\\x0' + n2(e6)
                      })
                      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (e6) {
                        return '\\x' + n2(e6)
                      })
                  }
                  function a2(e5) {
                    return e5
                      .replace(/\\/g, '\\\\')
                      .replace(/\]/g, '\\]')
                      .replace(/\^/g, '\\^')
                      .replace(/-/g, '\\-')
                      .replace(/\0/g, '\\0')
                      .replace(/\t/g, '\\t')
                      .replace(/\n/g, '\\n')
                      .replace(/\r/g, '\\r')
                      .replace(/[\x00-\x0F]/g, function (e6) {
                        return '\\x0' + n2(e6)
                      })
                      .replace(/[\x10-\x1F\x7F-\x9F]/g, function (e6) {
                        return '\\x' + n2(e6)
                      })
                  }
                  return (
                    'Expected ' +
                    (function (e5) {
                      var t3,
                        n3,
                        o3,
                        a3 = Array(e5.length)
                      for (t3 = 0; t3 < e5.length; t3++) a3[t3] = r2[(o3 = e5[t3]).type](o3)
                      if ((a3.sort(), a3.length > 0)) {
                        for (t3 = 1, n3 = 1; t3 < a3.length; t3++) a3[t3 - 1] !== a3[t3] && ((a3[n3] = a3[t3]), n3++)
                        a3.length = n3
                      }
                      switch (a3.length) {
                        case 1:
                          return a3[0]
                        case 2:
                          return a3[0] + ' or ' + a3[1]
                        default:
                          return a3.slice(0, -1).join(', ') + ', or ' + a3[a3.length - 1]
                      }
                    })(e4) +
                    ' but ' +
                    (t2 ? '"' + o2(t2) + '"' : 'end of input') +
                    ' found.'
                  )
                }),
                {
                  SyntaxError: e3,
                  parse: function (t2, r2) {
                    r2 = void 0 !== r2 ? r2 : {}
                    var n2,
                      o2,
                      a2,
                      i2,
                      s2 = {},
                      l2 = { start: em },
                      u2 = em,
                      c2 = ef(' ', false),
                      f2 = /^[^ [\],():#!=><~+.]/,
                      p2 = ep([' ', '[', ']', ',', '(', ')', ':', '#', '!', '=', '>', '<', '~', '+', '.'], true, false),
                      h2 = ef('>', false),
                      y2 = ef('~', false),
                      d2 = ef('+', false),
                      m2 = ef(',', false),
                      x2 = function (e4, t3) {
                        return [e4].concat(
                          t3.map(function (e5) {
                            return e5[3]
                          })
                        )
                      },
                      v2 = ef('!', false),
                      g2 = ef('*', false),
                      A2 = ef('#', false),
                      b2 = ef('[', false),
                      E2 = ef(']', false),
                      S = /^[><!]/,
                      _ = ep(['>', '<', '!'], false, false),
                      C = ef('=', false),
                      P = function (e4) {
                        return (e4 || '') + '='
                      },
                      w = /^[><]/,
                      k = ep(['>', '<'], false, false),
                      D = ef('.', false),
                      j = function (e4, t3, r3) {
                        return { type: 'attribute', name: e4, operator: t3, value: r3 }
                      },
                      I = ef('"', false),
                      T = /^[^\\"]/,
                      F = ep(['\\', '"'], true, false),
                      O = ef('\\', false),
                      R = { type: 'any' },
                      M = function (e4, t3) {
                        return e4 + t3
                      },
                      L = function (e4) {
                        return {
                          type: 'literal',
                          value: e4.join('').replace(/\\(.)/g, function (e5, t3) {
                            switch (t3) {
                              case 'b':
                                return '\b'
                              case 'f':
                                return '\f'
                              case 'n':
                                return '\n'
                              case 'r':
                                return '\r'
                              case 't':
                                return '	'
                              case 'v':
                                return '\v'
                              default:
                                return t3
                            }
                          }),
                        }
                      },
                      B = ef("'", false),
                      U = /^[^\\']/,
                      K = ep(['\\', "'"], true, false),
                      N = /^[0-9]/,
                      W = ep([['0', '9']], false, false),
                      V = ef('type(', false),
                      q = /^[^ )]/,
                      G = ep([' ', ')'], true, false),
                      z = ef(')', false),
                      H = /^[imsu]/,
                      Y = ep(['i', 'm', 's', 'u'], false, false),
                      $ = ef('/', false),
                      J = /^[^\/]/,
                      Q = ep(['/'], true, false),
                      X = ef(':not(', false),
                      Z = ef(':matches(', false),
                      ee = ef(':has(', false),
                      et = ef(':first-child', false),
                      er = ef(':last-child', false),
                      en = ef(':nth-child(', false),
                      eo = ef(':nth-last-child(', false),
                      ea = ef(':', false),
                      ei = 0,
                      es = [{ line: 1, column: 1 }],
                      el = 0,
                      eu = [],
                      ec = {}
                    if ('startRule' in r2) {
                      if (!(r2.startRule in l2)) throw Error(`Can't start parsing from rule "` + r2.startRule + '".')
                      u2 = l2[r2.startRule]
                    }
                    function ef(e4, t3) {
                      return { type: 'literal', text: e4, ignoreCase: t3 }
                    }
                    function ep(e4, t3, r3) {
                      return { type: 'class', parts: e4, inverted: t3, ignoreCase: r3 }
                    }
                    function eh(e4) {
                      var r3,
                        n3 = es[e4]
                      if (n3) return n3
                      for (r3 = e4 - 1; !es[r3]; ) r3--
                      for (n3 = { line: (n3 = es[r3]).line, column: n3.column }; r3 < e4; )
                        (10 === t2.charCodeAt(r3) ? (n3.line++, (n3.column = 1)) : n3.column++, r3++)
                      return ((es[e4] = n3), n3)
                    }
                    function ey(e4, t3) {
                      var r3 = eh(e4),
                        n3 = eh(t3)
                      return {
                        start: { offset: e4, line: r3.line, column: r3.column },
                        end: { offset: t3, line: n3.line, column: n3.column },
                      }
                    }
                    function ed(e4) {
                      ei < el || (ei > el && ((el = ei), (eu = [])), eu.push(e4))
                    }
                    function em() {
                      var e4,
                        t3,
                        r3,
                        n3,
                        o3 = 32 * ei + 0,
                        a3 = ec[o3]
                      return a3
                        ? ((ei = a3.nextPos), a3.result)
                        : ((e4 = ei),
                          (t3 = ex()) !== s2 && (r3 = eA()) !== s2 && ex() !== s2
                            ? (e4 = t3 = 1 === (n3 = r3).length ? n3[0] : { type: 'matches', selectors: n3 })
                            : ((ei = e4), (e4 = s2)),
                          e4 === s2 && ((e4 = ei), (t3 = ex()) !== s2 && (t3 = void 0), (e4 = t3)),
                          (ec[o3] = { nextPos: ei, result: e4 }),
                          e4)
                    }
                    function ex() {
                      var e4,
                        r3,
                        n3 = 32 * ei + 1,
                        o3 = ec[n3]
                      if (o3) return ((ei = o3.nextPos), o3.result)
                      for (e4 = [], 32 === t2.charCodeAt(ei) ? ((r3 = ' '), ei++) : ((r3 = s2), ed(c2)); r3 !== s2; )
                        (e4.push(r3), 32 === t2.charCodeAt(ei) ? ((r3 = ' '), ei++) : ((r3 = s2), ed(c2)))
                      return ((ec[n3] = { nextPos: ei, result: e4 }), e4)
                    }
                    function ev() {
                      var e4,
                        r3,
                        n3,
                        o3 = 32 * ei + 2,
                        a3 = ec[o3]
                      if (a3) return ((ei = a3.nextPos), a3.result)
                      if (
                        ((r3 = []),
                        f2.test(t2.charAt(ei)) ? ((n3 = t2.charAt(ei)), ei++) : ((n3 = s2), ed(p2)),
                        n3 !== s2)
                      )
                        for (; n3 !== s2; )
                          (r3.push(n3), f2.test(t2.charAt(ei)) ? ((n3 = t2.charAt(ei)), ei++) : ((n3 = s2), ed(p2)))
                      else r3 = s2
                      return (r3 !== s2 && (r3 = r3.join('')), (e4 = r3), (ec[o3] = { nextPos: ei, result: e4 }), e4)
                    }
                    function eg() {
                      var e4,
                        r3,
                        n3,
                        o3 = 32 * ei + 3,
                        a3 = ec[o3]
                      return a3
                        ? ((ei = a3.nextPos), a3.result)
                        : ((e4 = ei),
                          (r3 = ex()) !== s2
                            ? (62 === t2.charCodeAt(ei) ? ((n3 = '>'), ei++) : ((n3 = s2), ed(h2)),
                              n3 !== s2 && ex() !== s2 ? (e4 = r3 = 'child') : ((ei = e4), (e4 = s2)))
                            : ((ei = e4), (e4 = s2)),
                          e4 === s2 &&
                            ((e4 = ei),
                            (r3 = ex()) !== s2
                              ? (126 === t2.charCodeAt(ei) ? ((n3 = '~'), ei++) : ((n3 = s2), ed(y2)),
                                n3 !== s2 && ex() !== s2 ? (e4 = r3 = 'sibling') : ((ei = e4), (e4 = s2)))
                              : ((ei = e4), (e4 = s2)),
                            e4 === s2 &&
                              ((e4 = ei),
                              (r3 = ex()) !== s2
                                ? (43 === t2.charCodeAt(ei) ? ((n3 = '+'), ei++) : ((n3 = s2), ed(d2)),
                                  n3 !== s2 && ex() !== s2 ? (e4 = r3 = 'adjacent') : ((ei = e4), (e4 = s2)))
                                : ((ei = e4), (e4 = s2)),
                              e4 === s2 &&
                                ((e4 = ei),
                                32 === t2.charCodeAt(ei) ? ((r3 = ' '), ei++) : ((r3 = s2), ed(c2)),
                                r3 !== s2 && (n3 = ex()) !== s2 ? (e4 = r3 = 'descendant') : ((ei = e4), (e4 = s2))))),
                          (ec[o3] = { nextPos: ei, result: e4 }),
                          e4)
                    }
                    function eA() {
                      var e4,
                        r3,
                        n3,
                        o3,
                        a3,
                        i3,
                        l3,
                        u3,
                        c3 = 32 * ei + 5,
                        f3 = ec[c3]
                      if (f3) return ((ei = f3.nextPos), f3.result)
                      if (((e4 = ei), (r3 = eE()) !== s2)) {
                        for (
                          n3 = [],
                            o3 = ei,
                            (a3 = ex()) !== s2
                              ? (44 === t2.charCodeAt(ei) ? ((i3 = ','), ei++) : ((i3 = s2), ed(m2)),
                                i3 !== s2 && (l3 = ex()) !== s2 && (u3 = eE()) !== s2
                                  ? (o3 = a3 = [a3, i3, l3, u3])
                                  : ((ei = o3), (o3 = s2)))
                              : ((ei = o3), (o3 = s2));
                          o3 !== s2;
                        )
                          (n3.push(o3),
                            (o3 = ei),
                            (a3 = ex()) !== s2
                              ? (44 === t2.charCodeAt(ei) ? ((i3 = ','), ei++) : ((i3 = s2), ed(m2)),
                                i3 !== s2 && (l3 = ex()) !== s2 && (u3 = eE()) !== s2
                                  ? (o3 = a3 = [a3, i3, l3, u3])
                                  : ((ei = o3), (o3 = s2)))
                              : ((ei = o3), (o3 = s2)))
                        n3 !== s2 ? (e4 = r3 = x2(r3, n3)) : ((ei = e4), (e4 = s2))
                      } else ((ei = e4), (e4 = s2))
                      return ((ec[c3] = { nextPos: ei, result: e4 }), e4)
                    }
                    function eb() {
                      var e4,
                        t3,
                        r3,
                        n3,
                        o3,
                        a3 = 32 * ei + 6,
                        i3 = ec[a3]
                      return i3
                        ? ((ei = i3.nextPos), i3.result)
                        : ((e4 = ei),
                          (t3 = eg()) === s2 && (t3 = null),
                          t3 !== s2 && (r3 = eE()) !== s2
                            ? ((o3 = r3),
                              (e4 = t3 = (n3 = t3) ? { type: n3, left: { type: 'exactNode' }, right: o3 } : o3))
                            : ((ei = e4), (e4 = s2)),
                          (ec[a3] = { nextPos: ei, result: e4 }),
                          e4)
                    }
                    function eE() {
                      var e4,
                        t3,
                        r3,
                        n3,
                        o3,
                        a3,
                        i3,
                        l3 = 32 * ei + 7,
                        u3 = ec[l3]
                      if (u3) return ((ei = u3.nextPos), u3.result)
                      if (((e4 = ei), (t3 = eS()) !== s2)) {
                        for (
                          r3 = [],
                            n3 = ei,
                            (o3 = eg()) !== s2 && (a3 = eS()) !== s2 ? (n3 = o3 = [o3, a3]) : ((ei = n3), (n3 = s2));
                          n3 !== s2;
                        )
                          (r3.push(n3),
                            (n3 = ei),
                            (o3 = eg()) !== s2 && (a3 = eS()) !== s2 ? (n3 = o3 = [o3, a3]) : ((ei = n3), (n3 = s2)))
                        r3 !== s2
                          ? ((i3 = t3),
                            (e4 = t3 =
                              r3.reduce(function (e5, t4) {
                                return { type: t4[0], left: e5, right: t4[1] }
                              }, i3)))
                          : ((ei = e4), (e4 = s2))
                      } else ((ei = e4), (e4 = s2))
                      return ((ec[l3] = { nextPos: ei, result: e4 }), e4)
                    }
                    function eS() {
                      var e4,
                        r3,
                        n3,
                        o3,
                        a3,
                        i3,
                        l3,
                        u3 = 32 * ei + 8,
                        c3 = ec[u3]
                      if (c3) return ((ei = c3.nextPos), c3.result)
                      if (
                        ((e4 = ei),
                        33 === t2.charCodeAt(ei) ? ((r3 = '!'), ei++) : ((r3 = s2), ed(v2)),
                        r3 === s2 && (r3 = null),
                        r3 !== s2)
                      ) {
                        if (((n3 = []), (o3 = e_()) !== s2)) for (; o3 !== s2; ) (n3.push(o3), (o3 = e_()))
                        else n3 = s2
                        n3 !== s2
                          ? ((a3 = r3),
                            (l3 = 1 === (i3 = n3).length ? i3[0] : { type: 'compound', selectors: i3 }),
                            a3 && (l3.subject = true),
                            (e4 = r3 = l3))
                          : ((ei = e4), (e4 = s2))
                      } else ((ei = e4), (e4 = s2))
                      return ((ec[u3] = { nextPos: ei, result: e4 }), e4)
                    }
                    function e_() {
                      var e4,
                        r3,
                        n3,
                        o3,
                        a3,
                        i3,
                        l3,
                        u3,
                        c3,
                        f3,
                        p3,
                        h3,
                        y3,
                        d3,
                        es2,
                        el2,
                        eu2,
                        ef2,
                        ep2,
                        eh2,
                        ey2,
                        em2,
                        eg2,
                        eE2,
                        eS2,
                        e_2,
                        ek,
                        eD,
                        ej,
                        eI,
                        eT,
                        eF,
                        eO,
                        eR,
                        eM,
                        eL,
                        eB,
                        eU,
                        eK,
                        eN,
                        eW,
                        eV,
                        eq,
                        eG,
                        ez,
                        eH,
                        eY,
                        e$,
                        eJ,
                        eQ,
                        eX,
                        eZ,
                        e1,
                        e0,
                        e22,
                        e32,
                        e42,
                        e9,
                        e6,
                        e5,
                        e7,
                        e8,
                        te,
                        tt,
                        tr,
                        tn,
                        to,
                        ta = 32 * ei + 9,
                        ti = ec[ta]
                      return ti
                        ? ((ei = ti.nextPos), ti.result)
                        : ((to = (o3 = ec[(n3 = 32 * ei + 10)])
                            ? ((ei = o3.nextPos), o3.result)
                            : (42 === t2.charCodeAt(ei) ? ((r3 = '*'), ei++) : ((r3 = s2), ed(g2)),
                              r3 !== s2 && (r3 = { type: 'wildcard', value: r3 }),
                              (e4 = r3),
                              (ec[n3] = { nextPos: ei, result: e4 }),
                              e4)) === s2 &&
                            (to = (c3 = ec[(u3 = 32 * ei + 11)])
                              ? ((ei = c3.nextPos), c3.result)
                              : ((a3 = ei),
                                35 === t2.charCodeAt(ei) ? ((i3 = '#'), ei++) : ((i3 = s2), ed(A2)),
                                i3 === s2 && (i3 = null),
                                i3 !== s2 && (l3 = ev()) !== s2
                                  ? (a3 = i3 = { type: 'identifier', value: l3 })
                                  : ((ei = a3), (a3 = s2)),
                                (ec[u3] = { nextPos: ei, result: a3 }),
                                a3)) === s2 &&
                            (to = (es2 = ec[(d3 = 32 * ei + 12)])
                              ? ((ei = es2.nextPos), es2.result)
                              : ((f3 = ei),
                                91 === t2.charCodeAt(ei) ? ((p3 = '['), ei++) : ((p3 = s2), ed(b2)),
                                p3 !== s2 &&
                                ex() !== s2 &&
                                (h3 = (ey2 = ec[(eh2 = 32 * ei + 16)])
                                  ? ((ei = ey2.nextPos), ey2.result)
                                  : ((el2 = ei),
                                    (eu2 = eC()) !== s2 &&
                                    ex() !== s2 &&
                                    (ef2 = (e_2 = ec[(eS2 = 32 * ei + 14)])
                                      ? ((ei = e_2.nextPos), e_2.result)
                                      : ((em2 = ei),
                                        33 === t2.charCodeAt(ei) ? ((eg2 = '!'), ei++) : ((eg2 = s2), ed(v2)),
                                        eg2 === s2 && (eg2 = null),
                                        eg2 !== s2
                                          ? (61 === t2.charCodeAt(ei) ? ((eE2 = '='), ei++) : ((eE2 = s2), ed(C)),
                                            eE2 !== s2 ? (em2 = eg2 = P(eg2)) : ((ei = em2), (em2 = s2)))
                                          : ((ei = em2), (em2 = s2)),
                                        (ec[eS2] = { nextPos: ei, result: em2 }),
                                        em2)) !== s2 &&
                                    ex() !== s2
                                      ? ((ep2 = (function () {
                                          var e10,
                                            r4,
                                            n4,
                                            o4,
                                            a4,
                                            i4 = 32 * ei + 20,
                                            l4 = ec[i4]
                                          if (l4) return ((ei = l4.nextPos), l4.result)
                                          if (
                                            ((e10 = ei),
                                            'type(' === t2.substr(ei, 5)
                                              ? ((r4 = 'type('), (ei += 5))
                                              : ((r4 = s2), ed(V)),
                                            r4 !== s2)
                                          )
                                            if (ex() !== s2) {
                                              if (
                                                ((n4 = []),
                                                q.test(t2.charAt(ei))
                                                  ? ((o4 = t2.charAt(ei)), ei++)
                                                  : ((o4 = s2), ed(G)),
                                                o4 !== s2)
                                              )
                                                for (; o4 !== s2; )
                                                  (n4.push(o4),
                                                    q.test(t2.charAt(ei))
                                                      ? ((o4 = t2.charAt(ei)), ei++)
                                                      : ((o4 = s2), ed(G)))
                                              else n4 = s2
                                              n4 !== s2 && (o4 = ex()) !== s2
                                                ? (41 === t2.charCodeAt(ei) ? ((a4 = ')'), ei++) : ((a4 = s2), ed(z)),
                                                  a4 !== s2
                                                    ? (e10 = r4 = { type: 'type', value: n4.join('') })
                                                    : ((ei = e10), (e10 = s2)))
                                                : ((ei = e10), (e10 = s2))
                                            } else ((ei = e10), (e10 = s2))
                                          else ((ei = e10), (e10 = s2))
                                          return ((ec[i4] = { nextPos: ei, result: e10 }), e10)
                                        })()) === s2 &&
                                          (ep2 = (function () {
                                            var e10,
                                              r4,
                                              n4,
                                              o4,
                                              a4,
                                              i4,
                                              l4 = 32 * ei + 22,
                                              u4 = ec[l4]
                                            if (u4) return ((ei = u4.nextPos), u4.result)
                                            if (
                                              ((e10 = ei),
                                              47 === t2.charCodeAt(ei) ? ((r4 = '/'), ei++) : ((r4 = s2), ed($)),
                                              r4 !== s2)
                                            ) {
                                              if (
                                                ((n4 = []),
                                                J.test(t2.charAt(ei))
                                                  ? ((o4 = t2.charAt(ei)), ei++)
                                                  : ((o4 = s2), ed(Q)),
                                                o4 !== s2)
                                              )
                                                for (; o4 !== s2; )
                                                  (n4.push(o4),
                                                    J.test(t2.charAt(ei))
                                                      ? ((o4 = t2.charAt(ei)), ei++)
                                                      : ((o4 = s2), ed(Q)))
                                              else n4 = s2
                                              n4 !== s2
                                                ? (47 === t2.charCodeAt(ei) ? ((o4 = '/'), ei++) : ((o4 = s2), ed($)),
                                                  o4 !== s2
                                                    ? ((a4 = (function () {
                                                        var e11,
                                                          r5,
                                                          n5 = 32 * ei + 21,
                                                          o5 = ec[n5]
                                                        if (o5) return ((ei = o5.nextPos), o5.result)
                                                        if (
                                                          ((e11 = []),
                                                          H.test(t2.charAt(ei))
                                                            ? ((r5 = t2.charAt(ei)), ei++)
                                                            : ((r5 = s2), ed(Y)),
                                                          r5 !== s2)
                                                        )
                                                          for (; r5 !== s2; )
                                                            (e11.push(r5),
                                                              H.test(t2.charAt(ei))
                                                                ? ((r5 = t2.charAt(ei)), ei++)
                                                                : ((r5 = s2), ed(Y)))
                                                        else e11 = s2
                                                        return ((ec[n5] = { nextPos: ei, result: e11 }), e11)
                                                      })()) === s2 && (a4 = null),
                                                      a4 !== s2
                                                        ? ((i4 = a4),
                                                          (e10 = r4 =
                                                            {
                                                              type: 'regexp',
                                                              value: new RegExp(n4.join(''), i4 ? i4.join('') : ''),
                                                            }))
                                                        : ((ei = e10), (e10 = s2)))
                                                    : ((ei = e10), (e10 = s2)))
                                                : ((ei = e10), (e10 = s2))
                                            } else ((ei = e10), (e10 = s2))
                                            return ((ec[l4] = { nextPos: ei, result: e10 }), e10)
                                          })()),
                                        ep2 !== s2 ? (el2 = eu2 = j(eu2, ef2, ep2)) : ((ei = el2), (el2 = s2)))
                                      : ((ei = el2), (el2 = s2)),
                                    el2 === s2 &&
                                      ((el2 = ei),
                                      (eu2 = eC()) !== s2 &&
                                      ex() !== s2 &&
                                      (ef2 = (eT = ec[(eI = 32 * ei + 13)])
                                        ? ((ei = eT.nextPos), eT.result)
                                        : ((ek = ei),
                                          S.test(t2.charAt(ei)) ? ((eD = t2.charAt(ei)), ei++) : ((eD = s2), ed(_)),
                                          eD === s2 && (eD = null),
                                          eD !== s2
                                            ? (61 === t2.charCodeAt(ei) ? ((ej = '='), ei++) : ((ej = s2), ed(C)),
                                              ej !== s2 ? (ek = eD = P(eD)) : ((ei = ek), (ek = s2)))
                                            : ((ei = ek), (ek = s2)),
                                          ek === s2 &&
                                            (w.test(t2.charAt(ei)) ? ((ek = t2.charAt(ei)), ei++) : ((ek = s2), ed(k))),
                                          (ec[eI] = { nextPos: ei, result: ek }),
                                          ek)) !== s2 &&
                                      ex() !== s2
                                        ? ((ep2 = (function () {
                                            var e10,
                                              r4,
                                              n4,
                                              o4,
                                              a4,
                                              i4,
                                              l4 = 32 * ei + 17,
                                              u4 = ec[l4]
                                            if (u4) return ((ei = u4.nextPos), u4.result)
                                            if (
                                              ((e10 = ei),
                                              34 === t2.charCodeAt(ei) ? ((r4 = '"'), ei++) : ((r4 = s2), ed(I)),
                                              r4 !== s2)
                                            ) {
                                              for (
                                                n4 = [],
                                                  T.test(t2.charAt(ei))
                                                    ? ((o4 = t2.charAt(ei)), ei++)
                                                    : ((o4 = s2), ed(F)),
                                                  o4 === s2 &&
                                                    ((o4 = ei),
                                                    92 === t2.charCodeAt(ei) ? ((a4 = '\\'), ei++) : ((a4 = s2), ed(O)),
                                                    a4 !== s2
                                                      ? (t2.length > ei
                                                          ? ((i4 = t2.charAt(ei)), ei++)
                                                          : ((i4 = s2), ed(R)),
                                                        i4 !== s2 ? (o4 = a4 = M(a4, i4)) : ((ei = o4), (o4 = s2)))
                                                      : ((ei = o4), (o4 = s2)));
                                                o4 !== s2;
                                              )
                                                (n4.push(o4),
                                                  T.test(t2.charAt(ei))
                                                    ? ((o4 = t2.charAt(ei)), ei++)
                                                    : ((o4 = s2), ed(F)),
                                                  o4 === s2 &&
                                                    ((o4 = ei),
                                                    92 === t2.charCodeAt(ei) ? ((a4 = '\\'), ei++) : ((a4 = s2), ed(O)),
                                                    a4 !== s2
                                                      ? (t2.length > ei
                                                          ? ((i4 = t2.charAt(ei)), ei++)
                                                          : ((i4 = s2), ed(R)),
                                                        i4 !== s2 ? (o4 = a4 = M(a4, i4)) : ((ei = o4), (o4 = s2)))
                                                      : ((ei = o4), (o4 = s2))))
                                              n4 !== s2
                                                ? (34 === t2.charCodeAt(ei) ? ((o4 = '"'), ei++) : ((o4 = s2), ed(I)),
                                                  o4 !== s2 ? (e10 = r4 = L(n4)) : ((ei = e10), (e10 = s2)))
                                                : ((ei = e10), (e10 = s2))
                                            } else ((ei = e10), (e10 = s2))
                                            if (e10 === s2)
                                              if (
                                                ((e10 = ei),
                                                39 === t2.charCodeAt(ei) ? ((r4 = "'"), ei++) : ((r4 = s2), ed(B)),
                                                r4 !== s2)
                                              ) {
                                                for (
                                                  n4 = [],
                                                    U.test(t2.charAt(ei))
                                                      ? ((o4 = t2.charAt(ei)), ei++)
                                                      : ((o4 = s2), ed(K)),
                                                    o4 === s2 &&
                                                      ((o4 = ei),
                                                      92 === t2.charCodeAt(ei)
                                                        ? ((a4 = '\\'), ei++)
                                                        : ((a4 = s2), ed(O)),
                                                      a4 !== s2
                                                        ? (t2.length > ei
                                                            ? ((i4 = t2.charAt(ei)), ei++)
                                                            : ((i4 = s2), ed(R)),
                                                          i4 !== s2 ? (o4 = a4 = M(a4, i4)) : ((ei = o4), (o4 = s2)))
                                                        : ((ei = o4), (o4 = s2)));
                                                  o4 !== s2;
                                                )
                                                  (n4.push(o4),
                                                    U.test(t2.charAt(ei))
                                                      ? ((o4 = t2.charAt(ei)), ei++)
                                                      : ((o4 = s2), ed(K)),
                                                    o4 === s2 &&
                                                      ((o4 = ei),
                                                      92 === t2.charCodeAt(ei)
                                                        ? ((a4 = '\\'), ei++)
                                                        : ((a4 = s2), ed(O)),
                                                      a4 !== s2
                                                        ? (t2.length > ei
                                                            ? ((i4 = t2.charAt(ei)), ei++)
                                                            : ((i4 = s2), ed(R)),
                                                          i4 !== s2 ? (o4 = a4 = M(a4, i4)) : ((ei = o4), (o4 = s2)))
                                                        : ((ei = o4), (o4 = s2))))
                                                n4 !== s2
                                                  ? (39 === t2.charCodeAt(ei) ? ((o4 = "'"), ei++) : ((o4 = s2), ed(B)),
                                                    o4 !== s2 ? (e10 = r4 = L(n4)) : ((ei = e10), (e10 = s2)))
                                                  : ((ei = e10), (e10 = s2))
                                              } else ((ei = e10), (e10 = s2))
                                            return ((ec[l4] = { nextPos: ei, result: e10 }), e10)
                                          })()) === s2 &&
                                            (ep2 = (function () {
                                              var e10,
                                                r4,
                                                n4,
                                                o4,
                                                a4,
                                                i4,
                                                l4 = 32 * ei + 18,
                                                u4 = ec[l4]
                                              if (u4) return ((ei = u4.nextPos), u4.result)
                                              for (
                                                e10 = ei,
                                                  r4 = ei,
                                                  n4 = [],
                                                  N.test(t2.charAt(ei))
                                                    ? ((o4 = t2.charAt(ei)), ei++)
                                                    : ((o4 = s2), ed(W));
                                                o4 !== s2;
                                              )
                                                (n4.push(o4),
                                                  N.test(t2.charAt(ei))
                                                    ? ((o4 = t2.charAt(ei)), ei++)
                                                    : ((o4 = s2), ed(W)))
                                              if (
                                                (n4 !== s2
                                                  ? (46 === t2.charCodeAt(ei) ? ((o4 = '.'), ei++) : ((o4 = s2), ed(D)),
                                                    o4 !== s2 ? (r4 = n4 = [n4, o4]) : ((ei = r4), (r4 = s2)))
                                                  : ((ei = r4), (r4 = s2)),
                                                r4 === s2 && (r4 = null),
                                                r4 !== s2)
                                              ) {
                                                if (
                                                  ((n4 = []),
                                                  N.test(t2.charAt(ei))
                                                    ? ((o4 = t2.charAt(ei)), ei++)
                                                    : ((o4 = s2), ed(W)),
                                                  o4 !== s2)
                                                )
                                                  for (; o4 !== s2; )
                                                    (n4.push(o4),
                                                      N.test(t2.charAt(ei))
                                                        ? ((o4 = t2.charAt(ei)), ei++)
                                                        : ((o4 = s2), ed(W)))
                                                else n4 = s2
                                                n4 !== s2
                                                  ? ((i4 = n4),
                                                    (e10 = r4 =
                                                      {
                                                        type: 'literal',
                                                        value: parseFloat(
                                                          ((a4 = r4) ? [].concat.apply([], a4).join('') : '') +
                                                            i4.join('')
                                                        ),
                                                      }))
                                                  : ((ei = e10), (e10 = s2))
                                              } else ((ei = e10), (e10 = s2))
                                              return ((ec[l4] = { nextPos: ei, result: e10 }), e10)
                                            })()) === s2 &&
                                            (ep2 = (eM = ec[(eR = 32 * ei + 19)])
                                              ? ((ei = eM.nextPos), eM.result)
                                              : ((eO = ev()) !== s2 && (eO = { type: 'literal', value: eO }),
                                                (eF = eO),
                                                (ec[eR] = { nextPos: ei, result: eF }),
                                                eF)),
                                          ep2 !== s2 ? (el2 = eu2 = j(eu2, ef2, ep2)) : ((ei = el2), (el2 = s2)))
                                        : ((ei = el2), (el2 = s2)),
                                      el2 === s2 &&
                                        ((el2 = ei),
                                        (eu2 = eC()) !== s2 && (eu2 = { type: 'attribute', name: eu2 }),
                                        (el2 = eu2))),
                                    (ec[eh2] = { nextPos: ei, result: el2 }),
                                    el2)) !== s2 &&
                                ex() !== s2
                                  ? (93 === t2.charCodeAt(ei) ? ((y3 = ']'), ei++) : ((y3 = s2), ed(E2)),
                                    y3 !== s2 ? (f3 = p3 = h3) : ((ei = f3), (f3 = s2)))
                                  : ((ei = f3), (f3 = s2)),
                                (ec[d3] = { nextPos: ei, result: f3 }),
                                f3)) === s2 &&
                            (to = (function () {
                              var e10,
                                r4,
                                n4,
                                o4,
                                a4,
                                i4,
                                l4,
                                u4 = 32 * ei + 23,
                                c4 = ec[u4]
                              if (c4) return ((ei = c4.nextPos), c4.result)
                              if (
                                ((e10 = ei),
                                46 === t2.charCodeAt(ei) ? ((r4 = '.'), ei++) : ((r4 = s2), ed(D)),
                                r4 !== s2)
                              )
                                if ((n4 = ev()) !== s2) {
                                  for (
                                    o4 = [],
                                      a4 = ei,
                                      46 === t2.charCodeAt(ei) ? ((i4 = '.'), ei++) : ((i4 = s2), ed(D)),
                                      i4 !== s2 && (l4 = ev()) !== s2 ? (a4 = i4 = [i4, l4]) : ((ei = a4), (a4 = s2));
                                    a4 !== s2;
                                  )
                                    (o4.push(a4),
                                      (a4 = ei),
                                      46 === t2.charCodeAt(ei) ? ((i4 = '.'), ei++) : ((i4 = s2), ed(D)),
                                      i4 !== s2 && (l4 = ev()) !== s2 ? (a4 = i4 = [i4, l4]) : ((ei = a4), (a4 = s2)))
                                  o4 !== s2
                                    ? (e10 = r4 =
                                        {
                                          type: 'field',
                                          name: o4.reduce(function (e11, t3) {
                                            return e11 + t3[0] + t3[1]
                                          }, n4),
                                        })
                                    : ((ei = e10), (e10 = s2))
                                } else ((ei = e10), (e10 = s2))
                              else ((ei = e10), (e10 = s2))
                              return ((ec[u4] = { nextPos: ei, result: e10 }), e10)
                            })()) === s2 &&
                            (to = (eW = ec[(eN = 32 * ei + 24)])
                              ? ((ei = eW.nextPos), eW.result)
                              : ((eL = ei),
                                ':not(' === t2.substr(ei, 5) ? ((eB = ':not('), (ei += 5)) : ((eB = s2), ed(X)),
                                eB !== s2 && ex() !== s2 && (eU = eA()) !== s2 && ex() !== s2
                                  ? (41 === t2.charCodeAt(ei) ? ((eK = ')'), ei++) : ((eK = s2), ed(z)),
                                    eK !== s2 ? (eL = eB = { type: 'not', selectors: eU }) : ((ei = eL), (eL = s2)))
                                  : ((ei = eL), (eL = s2)),
                                (ec[eN] = { nextPos: ei, result: eL }),
                                eL)) === s2 &&
                            (to = (eY = ec[(eH = 32 * ei + 25)])
                              ? ((ei = eY.nextPos), eY.result)
                              : ((eV = ei),
                                ':matches(' === t2.substr(ei, 9) ? ((eq = ':matches('), (ei += 9)) : ((eq = s2), ed(Z)),
                                eq !== s2 && ex() !== s2 && (eG = eA()) !== s2 && ex() !== s2
                                  ? (41 === t2.charCodeAt(ei) ? ((ez = ')'), ei++) : ((ez = s2), ed(z)),
                                    ez !== s2 ? (eV = eq = { type: 'matches', selectors: eG }) : ((ei = eV), (eV = s2)))
                                  : ((ei = eV), (eV = s2)),
                                (ec[eH] = { nextPos: ei, result: eV }),
                                eV)) === s2 &&
                            (to = (e1 = ec[(eZ = 32 * ei + 26)])
                              ? ((ei = e1.nextPos), e1.result)
                              : ((e$ = ei),
                                ':has(' === t2.substr(ei, 5) ? ((eJ = ':has('), (ei += 5)) : ((eJ = s2), ed(ee)),
                                eJ !== s2 &&
                                ex() !== s2 &&
                                (eQ = (function () {
                                  var e10,
                                    r4,
                                    n4,
                                    o4,
                                    a4,
                                    i4,
                                    l4,
                                    u4,
                                    c4 = 32 * ei + 4,
                                    f4 = ec[c4]
                                  if (f4) return ((ei = f4.nextPos), f4.result)
                                  if (((e10 = ei), (r4 = eb()) !== s2)) {
                                    for (
                                      n4 = [],
                                        o4 = ei,
                                        (a4 = ex()) !== s2
                                          ? (44 === t2.charCodeAt(ei) ? ((i4 = ','), ei++) : ((i4 = s2), ed(m2)),
                                            i4 !== s2 && (l4 = ex()) !== s2 && (u4 = eb()) !== s2
                                              ? (o4 = a4 = [a4, i4, l4, u4])
                                              : ((ei = o4), (o4 = s2)))
                                          : ((ei = o4), (o4 = s2));
                                      o4 !== s2;
                                    )
                                      (n4.push(o4),
                                        (o4 = ei),
                                        (a4 = ex()) !== s2
                                          ? (44 === t2.charCodeAt(ei) ? ((i4 = ','), ei++) : ((i4 = s2), ed(m2)),
                                            i4 !== s2 && (l4 = ex()) !== s2 && (u4 = eb()) !== s2
                                              ? (o4 = a4 = [a4, i4, l4, u4])
                                              : ((ei = o4), (o4 = s2)))
                                          : ((ei = o4), (o4 = s2)))
                                    n4 !== s2 ? (e10 = r4 = x2(r4, n4)) : ((ei = e10), (e10 = s2))
                                  } else ((ei = e10), (e10 = s2))
                                  return ((ec[c4] = { nextPos: ei, result: e10 }), e10)
                                })()) !== s2 &&
                                ex() !== s2
                                  ? (41 === t2.charCodeAt(ei) ? ((eX = ')'), ei++) : ((eX = s2), ed(z)),
                                    eX !== s2 ? (e$ = eJ = { type: 'has', selectors: eQ }) : ((ei = e$), (e$ = s2)))
                                  : ((ei = e$), (e$ = s2)),
                                (ec[eZ] = { nextPos: ei, result: e$ }),
                                e$)) === s2 &&
                            (to = (e42 = ec[(e32 = 32 * ei + 27)])
                              ? ((ei = e42.nextPos), e42.result)
                              : (':first-child' === t2.substr(ei, 12)
                                  ? ((e22 = ':first-child'), (ei += 12))
                                  : ((e22 = s2), ed(et)),
                                e22 !== s2 && (e22 = eP(1)),
                                (e0 = e22),
                                (ec[e32] = { nextPos: ei, result: e0 }),
                                e0)) === s2 &&
                            (to = (e7 = ec[(e5 = 32 * ei + 28)])
                              ? ((ei = e7.nextPos), e7.result)
                              : (':last-child' === t2.substr(ei, 11)
                                  ? ((e6 = ':last-child'), (ei += 11))
                                  : ((e6 = s2), ed(er)),
                                e6 !== s2 && (e6 = ew(1)),
                                (e9 = e6),
                                (ec[e5] = { nextPos: ei, result: e9 }),
                                e9)) === s2 &&
                            (to = (function () {
                              var e10,
                                r4,
                                n4,
                                o4,
                                a4,
                                i4 = 32 * ei + 29,
                                l4 = ec[i4]
                              if (l4) return ((ei = l4.nextPos), l4.result)
                              if (
                                ((e10 = ei),
                                ':nth-child(' === t2.substr(ei, 11)
                                  ? ((r4 = ':nth-child('), (ei += 11))
                                  : ((r4 = s2), ed(en)),
                                r4 !== s2)
                              )
                                if (ex() !== s2) {
                                  if (
                                    ((n4 = []),
                                    N.test(t2.charAt(ei)) ? ((o4 = t2.charAt(ei)), ei++) : ((o4 = s2), ed(W)),
                                    o4 !== s2)
                                  )
                                    for (; o4 !== s2; )
                                      (n4.push(o4),
                                        N.test(t2.charAt(ei)) ? ((o4 = t2.charAt(ei)), ei++) : ((o4 = s2), ed(W)))
                                  else n4 = s2
                                  n4 !== s2 && (o4 = ex()) !== s2
                                    ? (41 === t2.charCodeAt(ei) ? ((a4 = ')'), ei++) : ((a4 = s2), ed(z)),
                                      a4 !== s2 ? (e10 = r4 = eP(parseInt(n4.join(''), 10))) : ((ei = e10), (e10 = s2)))
                                    : ((ei = e10), (e10 = s2))
                                } else ((ei = e10), (e10 = s2))
                              else ((ei = e10), (e10 = s2))
                              return ((ec[i4] = { nextPos: ei, result: e10 }), e10)
                            })()) === s2 &&
                            (to = (function () {
                              var e10,
                                r4,
                                n4,
                                o4,
                                a4,
                                i4 = 32 * ei + 30,
                                l4 = ec[i4]
                              if (l4) return ((ei = l4.nextPos), l4.result)
                              if (
                                ((e10 = ei),
                                ':nth-last-child(' === t2.substr(ei, 16)
                                  ? ((r4 = ':nth-last-child('), (ei += 16))
                                  : ((r4 = s2), ed(eo)),
                                r4 !== s2)
                              )
                                if (ex() !== s2) {
                                  if (
                                    ((n4 = []),
                                    N.test(t2.charAt(ei)) ? ((o4 = t2.charAt(ei)), ei++) : ((o4 = s2), ed(W)),
                                    o4 !== s2)
                                  )
                                    for (; o4 !== s2; )
                                      (n4.push(o4),
                                        N.test(t2.charAt(ei)) ? ((o4 = t2.charAt(ei)), ei++) : ((o4 = s2), ed(W)))
                                  else n4 = s2
                                  n4 !== s2 && (o4 = ex()) !== s2
                                    ? (41 === t2.charCodeAt(ei) ? ((a4 = ')'), ei++) : ((a4 = s2), ed(z)),
                                      a4 !== s2 ? (e10 = r4 = ew(parseInt(n4.join(''), 10))) : ((ei = e10), (e10 = s2)))
                                    : ((ei = e10), (e10 = s2))
                                } else ((ei = e10), (e10 = s2))
                              else ((ei = e10), (e10 = s2))
                              return ((ec[i4] = { nextPos: ei, result: e10 }), e10)
                            })()) === s2 &&
                            (to = (tn = ec[(tr = 32 * ei + 31)])
                              ? ((ei = tn.nextPos), tn.result)
                              : ((e8 = ei),
                                58 === t2.charCodeAt(ei) ? ((te = ':'), ei++) : ((te = s2), ed(ea)),
                                te !== s2 && (tt = ev()) !== s2
                                  ? (e8 = te = { type: 'class', name: tt })
                                  : ((ei = e8), (e8 = s2)),
                                (ec[tr] = { nextPos: ei, result: e8 }),
                                e8)),
                          (ec[ta] = { nextPos: ei, result: to }),
                          to)
                    }
                    function eC() {
                      var e4,
                        r3,
                        n3,
                        o3,
                        a3,
                        i3,
                        l3,
                        u3 = 32 * ei + 15,
                        c3 = ec[u3]
                      if (c3) return ((ei = c3.nextPos), c3.result)
                      if (((e4 = ei), (r3 = ev()) !== s2)) {
                        for (
                          n3 = [],
                            o3 = ei,
                            46 === t2.charCodeAt(ei) ? ((a3 = '.'), ei++) : ((a3 = s2), ed(D)),
                            a3 !== s2 && (i3 = ev()) !== s2 ? (o3 = a3 = [a3, i3]) : ((ei = o3), (o3 = s2));
                          o3 !== s2;
                        )
                          (n3.push(o3),
                            (o3 = ei),
                            46 === t2.charCodeAt(ei) ? ((a3 = '.'), ei++) : ((a3 = s2), ed(D)),
                            a3 !== s2 && (i3 = ev()) !== s2 ? (o3 = a3 = [a3, i3]) : ((ei = o3), (o3 = s2)))
                        n3 !== s2 ? ((l3 = r3), (e4 = r3 = [].concat.apply([l3], n3).join(''))) : ((ei = e4), (e4 = s2))
                      } else ((ei = e4), (e4 = s2))
                      return ((ec[u3] = { nextPos: ei, result: e4 }), e4)
                    }
                    function eP(e4) {
                      return { type: 'nth-child', index: { type: 'literal', value: e4 } }
                    }
                    function ew(e4) {
                      return { type: 'nth-last-child', index: { type: 'literal', value: e4 } }
                    }
                    if ((n2 = u2()) !== s2 && ei === t2.length) return n2
                    throw (
                      n2 !== s2 && ei < t2.length && ed({ type: 'end' }),
                      (o2 = eu),
                      (a2 = el < t2.length ? t2.charAt(el) : null),
                      (i2 = el < t2.length ? ey(el, el + 1) : ey(el, el)),
                      new e3(e3.buildMessage(o2, a2), o2, a2, i2)
                    )
                  },
                }
              )
            })())
        })
      function u(e2, t2) {
        for (var r2 = 0; r2 < t2.length && null != e2; ++r2) e2 = e2[t2[r2]]
        return e2
      }
      var c = 'function' == typeof WeakMap ? /* @__PURE__ */ new WeakMap() : null
      function f(e2) {
        if (null == e2)
          return function () {
            return true
          }
        if (null != c) {
          var t2 = c.get(e2)
          return (null != t2 || ((t2 = p(e2)), c.set(e2, t2)), t2)
        }
        return p(e2)
      }
      function p(e2) {
        switch (e2.type) {
          case 'wildcard':
            return function () {
              return true
            }
          case 'identifier':
            var t2 = e2.value.toLowerCase()
            return function (e3, r2, n3) {
              return t2 === e3[(n3 && n3.nodeTypeKey) || 'type'].toLowerCase()
            }
          case 'exactNode':
            return function (e3, t3) {
              return 0 === t3.length
            }
          case 'field':
            var n2 = e2.name.split('.')
            return function (e3, t3) {
              return (function e4(t4, r2, n3, o3) {
                for (var a3 = r2, i3 = o3; i3 < n3.length; ++i3) {
                  if (null == a3) return false
                  var s2 = a3[n3[i3]]
                  if (Array.isArray(s2)) {
                    for (var l3 = 0; l3 < s2.length; ++l3) if (e4(t4, s2[l3], n3, i3 + 1)) return true
                    return false
                  }
                  a3 = s2
                }
                return t4 === a3
              })(e3, t3[n2.length - 1], n2, 0)
            }
          case 'matches':
            var o2 = e2.selectors.map(f)
            return function (e3, t3, r2) {
              for (var n3 = 0; n3 < o2.length; ++n3) if (o2[n3](e3, t3, r2)) return true
              return false
            }
          case 'compound':
            var a2 = e2.selectors.map(f)
            return function (e3, t3, r2) {
              for (var n3 = 0; n3 < a2.length; ++n3) if (!a2[n3](e3, t3, r2)) return false
              return true
            }
          case 'not':
            var i2 = e2.selectors.map(f)
            return function (e3, t3, r2) {
              for (var n3 = 0; n3 < i2.length; ++n3) if (i2[n3](e3, t3, r2)) return false
              return true
            }
          case 'has':
            var l2 = e2.selectors.map(f)
            return function (e3, t3, r2) {
              var n3 = false,
                o3 = []
              return (
                s.traverse(e3, {
                  enter: function (e4, t4) {
                    null != t4 && o3.unshift(t4)
                    for (var a3 = 0; a3 < l2.length; ++a3)
                      if (l2[a3](e4, o3, r2)) return ((n3 = true), void this.break())
                  },
                  leave: function () {
                    o3.shift()
                  },
                  keys: r2 && r2.visitorKeys,
                  fallback: (r2 && r2.fallback) || 'iteration',
                }),
                n3
              )
            }
          case 'child':
            var c2 = f(e2.left),
              p2 = f(e2.right)
            return function (e3, t3, r2) {
              return !!(t3.length > 0 && p2(e3, t3, r2)) && c2(t3[0], t3.slice(1), r2)
            }
          case 'descendant':
            var h2 = f(e2.left),
              y2 = f(e2.right)
            return function (e3, t3, r2) {
              if (y2(e3, t3, r2)) {
                for (var n3 = 0, o3 = t3.length; n3 < o3; ++n3) if (h2(t3[n3], t3.slice(n3 + 1), r2)) return true
              }
              return false
            }
          case 'attribute':
            var v2 = e2.name.split('.')
            switch (e2.operator) {
              case void 0:
                return function (e3) {
                  return null != u(e3, v2)
                }
              case '=':
                switch (e2.value.type) {
                  case 'regexp':
                    return function (t3) {
                      var r2 = u(t3, v2)
                      return 'string' == typeof r2 && e2.value.value.test(r2)
                    }
                  case 'literal':
                    var g2 = ''.concat(e2.value.value)
                    return function (e3) {
                      return g2 === ''.concat(u(e3, v2))
                    }
                  case 'type':
                    return function (t3) {
                      return e2.value.value === r(u(t3, v2))
                    }
                }
                throw Error('Unknown selector value type: '.concat(e2.value.type))
              case '!=':
                switch (e2.value.type) {
                  case 'regexp':
                    return function (t3) {
                      return !e2.value.value.test(u(t3, v2))
                    }
                  case 'literal':
                    var A2 = ''.concat(e2.value.value)
                    return function (e3) {
                      return A2 !== ''.concat(u(e3, v2))
                    }
                  case 'type':
                    return function (t3) {
                      return e2.value.value !== r(u(t3, v2))
                    }
                }
                throw Error('Unknown selector value type: '.concat(e2.value.type))
              case '<=':
                return function (t3) {
                  return u(t3, v2) <= e2.value.value
                }
              case '<':
                return function (t3) {
                  return u(t3, v2) < e2.value.value
                }
              case '>':
                return function (t3) {
                  return u(t3, v2) > e2.value.value
                }
              case '>=':
                return function (t3) {
                  return u(t3, v2) >= e2.value.value
                }
            }
            throw Error('Unknown operator: '.concat(e2.operator))
          case 'sibling':
            var b2 = f(e2.left),
              E2 = f(e2.right)
            return function (t3, r2, n3) {
              return (
                (E2(t3, r2, n3) && d(t3, b2, r2, 'LEFT_SIDE', n3)) ||
                (e2.left.subject && b2(t3, r2, n3) && d(t3, E2, r2, 'RIGHT_SIDE', n3))
              )
            }
          case 'adjacent':
            var S = f(e2.left),
              _ = f(e2.right)
            return function (t3, r2, n3) {
              return (
                (_(t3, r2, n3) && m(t3, S, r2, 'LEFT_SIDE', n3)) ||
                (e2.right.subject && S(t3, r2, n3) && m(t3, _, r2, 'RIGHT_SIDE', n3))
              )
            }
          case 'nth-child':
            var C = e2.index.value,
              P = f(e2.right)
            return function (e3, t3, r2) {
              return P(e3, t3, r2) && x(e3, t3, C, r2)
            }
          case 'nth-last-child':
            var w = -e2.index.value,
              k = f(e2.right)
            return function (e3, t3, r2) {
              return k(e3, t3, r2) && x(e3, t3, w, r2)
            }
          case 'class':
            var D = e2.name.toLowerCase()
            return function (t3, r2, n3) {
              if (n3 && n3.matchClass) return n3.matchClass(e2.name, t3, r2)
              if (n3 && n3.nodeTypeKey) return false
              switch (D) {
                case 'statement':
                  if ('Statement' === t3.type.slice(-9)) return true
                case 'declaration':
                  return 'Declaration' === t3.type.slice(-11)
                case 'pattern':
                  if ('Pattern' === t3.type.slice(-7)) return true
                case 'expression':
                  return (
                    'Expression' === t3.type.slice(-10) ||
                    'Literal' === t3.type.slice(-7) ||
                    ('Identifier' === t3.type && (0 === r2.length || 'MetaProperty' !== r2[0].type)) ||
                    'MetaProperty' === t3.type
                  )
                case 'function':
                  return (
                    'FunctionDeclaration' === t3.type ||
                    'FunctionExpression' === t3.type ||
                    'ArrowFunctionExpression' === t3.type
                  )
              }
              throw Error('Unknown class name: '.concat(e2.name))
            }
        }
        throw Error('Unknown selector type: '.concat(e2.type))
      }
      function h(e2, t2) {
        var r2 = (t2 && t2.nodeTypeKey) || 'type',
          n2 = e2[r2]
        return t2 && t2.visitorKeys && t2.visitorKeys[n2]
          ? t2.visitorKeys[n2]
          : s.VisitorKeys[n2]
            ? s.VisitorKeys[n2]
            : t2 && 'function' == typeof t2.fallback
              ? t2.fallback(e2)
              : Object.keys(e2).filter(function (e3) {
                  return e3 !== r2
                })
      }
      function y(e2, t2) {
        var n2 = (t2 && t2.nodeTypeKey) || 'type'
        return null !== e2 && 'object' === r(e2) && 'string' == typeof e2[n2]
      }
      function d(e2, t2, r2, o2, a2) {
        var i2 = n(r2, 1)[0]
        if (!i2) return false
        for (var s2 = h(i2, a2), l2 = 0; l2 < s2.length; ++l2) {
          var u2 = i2[s2[l2]]
          if (Array.isArray(u2)) {
            var c2 = u2.indexOf(e2)
            if (c2 < 0) continue
            var f2 = void 0,
              p2 = void 0
            'LEFT_SIDE' === o2 ? ((f2 = 0), (p2 = c2)) : ((f2 = c2 + 1), (p2 = u2.length))
            for (var d2 = f2; d2 < p2; ++d2) if (y(u2[d2], a2) && t2(u2[d2], r2, a2)) return true
          }
        }
        return false
      }
      function m(e2, t2, r2, o2, a2) {
        var i2 = n(r2, 1)[0]
        if (!i2) return false
        for (var s2 = h(i2, a2), l2 = 0; l2 < s2.length; ++l2) {
          var u2 = i2[s2[l2]]
          if (Array.isArray(u2)) {
            var c2 = u2.indexOf(e2)
            if (c2 < 0) continue
            if (
              ('LEFT_SIDE' === o2 && c2 > 0 && y(u2[c2 - 1], a2) && t2(u2[c2 - 1], r2, a2)) ||
              ('RIGHT_SIDE' === o2 && c2 < u2.length - 1 && y(u2[c2 + 1], a2) && t2(u2[c2 + 1], r2, a2))
            )
              return true
          }
        }
        return false
      }
      function x(e2, t2, r2, o2) {
        if (0 === r2) return false
        var a2 = n(t2, 1)[0]
        if (!a2) return false
        for (var i2 = h(a2, o2), s2 = 0; s2 < i2.length; ++s2) {
          var l2 = a2[i2[s2]]
          if (Array.isArray(l2)) {
            var u2 = r2 < 0 ? l2.length + r2 : r2 - 1
            if (u2 >= 0 && u2 < l2.length && l2[u2] === e2) return true
          }
        }
        return false
      }
      function v(e2, t2, n2, i2) {
        if (t2) {
          var l2 = [],
            u2 = f(t2),
            c2 = (function e3(t3, n3) {
              if (null == t3 || 'object' != r(t3)) return []
              null == n3 && (n3 = t3)
              for (var i3 = t3.subject ? [n3] : [], s2 = Object.keys(t3), l3 = 0; l3 < s2.length; ++l3) {
                var u3,
                  c3 = s2[l3],
                  f2 = t3[c3]
                i3.push.apply(
                  i3,
                  (function (e4) {
                    if (Array.isArray(e4)) return a(e4)
                  })((u3 = e3(f2, 'left' === c3 ? f2 : n3))) ||
                    (function (e4) {
                      if (('undefined' != typeof Symbol && null != e4[Symbol.iterator]) || null != e4['@@iterator'])
                        return Array.from(e4)
                    })(u3) ||
                    o(u3) ||
                    (function () {
                      throw TypeError(
                        'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                      )
                    })()
                )
              }
              return i3
            })(t2).map(f)
          s.traverse(e2, {
            enter: function (e3, t3) {
              if ((null != t3 && l2.unshift(t3), u2(e3, l2, i2)))
                if (c2.length)
                  for (var r2 = 0, o2 = c2.length; r2 < o2; ++r2) {
                    c2[r2](e3, l2, i2) && n2(e3, t3, l2)
                    for (var a2 = 0, s2 = l2.length; a2 < s2; ++a2) {
                      var f2 = l2.slice(a2 + 1)
                      c2[r2](l2[a2], f2, i2) && n2(l2[a2], t3, f2)
                    }
                  }
                else n2(e3, t3, l2)
            },
            leave: function () {
              l2.shift()
            },
            keys: i2 && i2.visitorKeys,
            fallback: (i2 && i2.fallback) || 'iteration',
          })
        }
      }
      function g(e2, t2, r2) {
        var n2 = []
        return (
          v(
            e2,
            t2,
            function (e3) {
              n2.push(e3)
            },
            r2
          ),
          n2
        )
      }
      function A(e2) {
        return l.parse(e2)
      }
      function b(e2, t2, r2) {
        return g(e2, A(t2), r2)
      }
      ;((b.parse = A),
        (b.match = g),
        (b.traverse = v),
        (b.matches = function (e2, t2, r2, n2) {
          return !t2 || (!!e2 && (r2 || (r2 = []), f(t2)(e2, r2, n2)))
        }),
        (b.query = b))
      let E = b
      module2.exports = t
    })()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/compiler.js
var require_compiler = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/compiler.js'(exports2, module2) {
    'use strict'
    var meriyah
    var astring
    var esquery
    module2.exports = {
      parse: (...args) => {
        meriyah ??= require_meriyah()
        return meriyah.parse(...args)
      },
      generate: (...args) => {
        astring ??= require_astring()
        return astring.generate(...args)
      },
      traverse: (ast, query, visitor) => {
        esquery ??= require_esquery().default
        const selector = esquery.parse(query)
        return esquery.traverse(ast, selector, visitor)
      },
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/transforms.js
var require_transforms2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/transforms.js'(exports2, module2) {
    'use strict'
    var { parse } = require_compiler()
    var tracingChannelPredicate = (node) =>
      node.specifiers?.[0]?.local?.name === 'tr_ch_apm_tracingChannel' ||
      node.declarations?.[0]?.id?.properties?.[0]?.value?.name === 'tr_ch_apm_tracingChannel'
    var transforms = (module2.exports = {
      tracingChannelImport({ format }, node) {
        if (node.body.some(tracingChannelPredicate)) return
        const index = node.body.findIndex((child) => child.directive === 'use strict')
        const code =
          format === 'module'
            ? 'import { tracingChannel as tr_ch_apm_tracingChannel } from "diagnostics_channel"'
            : 'const {tracingChannel: tr_ch_apm_tracingChannel} = require("diagnostics_channel")'
        node.body.splice(index + 1, 0, parse(code, { module: format === 'module' }).body[0])
      },
      tracingChannelDeclaration(state, node) {
        const {
          channelName,
          module: { name },
        } = state
        const channelVariable = 'tr_ch_apm$' + channelName.replaceAll(':', '_')
        if (node.body.some((child) => child.declarations?.[0]?.id?.name === channelVariable)) return
        transforms.tracingChannelImport(state, node)
        const index = node.body.findIndex(tracingChannelPredicate)
        const code = `
      const ${channelVariable} = tr_ch_apm_tracingChannel("orchestrion:${name}:${channelName}")
    `
        node.body.splice(index + 1, 0, parse(code).body[0])
      },
      traceCallback: traceAny,
      tracePromise: traceAny,
      traceSync: traceAny,
    })
    function traceAny(state, node, _parent, ancestry) {
      const program = ancestry[ancestry.length - 1]
      if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {
        traceInstanceMethod(state, node, program)
      } else {
        traceFunction(state, node, program)
      }
    }
    function traceFunction(state, node, program) {
      const { operator } = state
      transforms.tracingChannelDeclaration(state, program)
      node.body = wrap(state, {
        type: 'ArrowFunctionExpression',
        params: node.params,
        body: node.body,
        async: operator === 'tracePromise',
        expression: false,
        generator: false,
      })
    }
    function traceInstanceMethod(state, node, program) {
      const { functionQuery, operator } = state
      const { methodName } = functionQuery
      const classBody = node.body
      if (classBody.body.some(({ key }) => key.name === methodName)) return
      let ctor = classBody.body.find(({ kind }) => kind === 'constructor')
      transforms.tracingChannelDeclaration(state, program)
      if (!ctor) {
        ctor = parse(
          node.superClass ? 'class A { constructor (...args) { super(...args) } }' : 'class A { constructor () {} }'
        ).body[0].body.body[0]
        classBody.body.unshift(ctor)
      }
      const ctorBody = parse(`
    const __apm$${methodName} = this["${methodName}"]
    this["${methodName}"] = function () {}
  `).body
      const fn = ctorBody[1].expression.right
      fn.async = operator === 'tracePromise'
      fn.body = wrap(state, { type: 'Identifier', name: `__apm$${methodName}` })
      ctor.value.body.body.push(...ctorBody)
    }
    function wrap(state, node) {
      const {
        channelName,
        operator,
        functionQuery: { index = -1 },
      } = state
      const async = operator === 'tracePromise' ? 'async' : ''
      const channelVariable = 'tr_ch_apm$' + channelName.replaceAll(':', '_')
      const tracedArgs =
        operator === 'traceCallback'
          ? `__apm$original_args.splice(${index}, 1, arguments[${index >= 0 ? index : `arguments.length + ${index}`}])`
          : '__apm$original_args'
      const traceParams = operator === 'traceCallback' ? `__apm$traced, ${index}` : '__apm$traced'
      const wrapper = parse(`
    function wrapper () {
      const __apm$original_args = arguments;
      const __apm$traced = ${async} function () {
        const __apm$wrapped = () => {};
        const __apm$traced_args = ${tracedArgs};
        return __apm$wrapped.apply(this, __apm$traced_args);
      };
      if (!${channelVariable}.hasSubscribers) return __apm$traced.apply(this, arguments);
      return ${channelVariable}.${operator}(${traceParams}, {
        arguments,
        self: this,
        moduleVersion: "1.0.0"
      }, this, ...arguments);
    }
  `).body[0].body
      wrapper.body[1].declarations[0].init.body.body[0].declarations[0].init = node
      return wrapper
    }
  },
})

// node_modules/dd-trace/vendor/dist/@datadog/source-map/index.js
var require_source_map = __commonJS({
  'node_modules/dd-trace/vendor/dist/@datadog/source-map/index.js'(exports2, module2) {
    ;(() => {
      var e = {
          './@datadog/source-map/lib/array-set.js': function (e2, n2, r2) {
            var t2 = r2('./@datadog/source-map/lib/util.js'),
              o = Object.prototype.hasOwnProperty,
              i = 'undefined' != typeof Map
            function s() {
              ;((this._array = []), (this._set = i ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null)))
            }
            ;((s.fromArray = function (e3, n3) {
              for (var r3 = new s(), t3 = 0, o2 = e3.length; t3 < o2; t3++) r3.add(e3[t3], n3)
              return r3
            }),
              (s.prototype.size = function () {
                return i ? this._set.size : Object.getOwnPropertyNames(this._set).length
              }),
              (s.prototype.add = function (e3, n3) {
                var r3 = i ? e3 : t2.toSetString(e3),
                  s2 = i ? this.has(e3) : o.call(this._set, r3),
                  a = this._array.length
                ;((!s2 || n3) && this._array.push(e3), s2 || (i ? this._set.set(e3, a) : (this._set[r3] = a)))
              }),
              (s.prototype.has = function (e3) {
                if (i) return this._set.has(e3)
                var n3 = t2.toSetString(e3)
                return o.call(this._set, n3)
              }),
              (s.prototype.indexOf = function (e3) {
                if (i) {
                  var n3 = this._set.get(e3)
                  if (n3 >= 0) return n3
                } else {
                  var r3 = t2.toSetString(e3)
                  if (o.call(this._set, r3)) return this._set[r3]
                }
                throw Error('"' + e3 + '" is not in the set.')
              }),
              (s.prototype.at = function (e3) {
                if (e3 >= 0 && e3 < this._array.length) return this._array[e3]
                throw Error('No element indexed by ' + e3)
              }),
              (s.prototype.toArray = function () {
                return this._array.slice()
              }),
              (n2.ArraySet = s))
          },
          './@datadog/source-map/lib/base64-vlq.js': function (e2, n2, r2) {
            var t2 = r2('./@datadog/source-map/lib/base64.js')
            ;((n2.encode = function (e3) {
              var n3,
                r3 = '',
                o = e3 < 0 ? (-e3 << 1) + 1 : (e3 << 1) + 0
              do ((n3 = 31 & o), (o >>>= 5) > 0 && (n3 |= 32), (r3 += t2.encode(n3)))
              while (o > 0)
              return r3
            }),
              (n2.decode = function (e3, n3, r3) {
                var o,
                  i,
                  s,
                  a,
                  u = e3.length,
                  l = 0,
                  c = 0
                do {
                  if (n3 >= u) throw Error('Expected more digits in base 64 VLQ value.')
                  if (-1 === (a = t2.decode(e3.charCodeAt(n3++))))
                    throw Error('Invalid base64 digit: ' + e3.charAt(n3 - 1))
                  ;((s = !!(32 & a)), (a &= 31), (l += a << c), (c += 5))
                } while (s)
                ;((i = (o = l) >> 1), (r3.value = (1 & o) == 1 ? -i : i), (r3.rest = n3))
              }))
          },
          './@datadog/source-map/lib/base64.js': function (e2, n2) {
            var r2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('')
            ;((n2.encode = function (e3) {
              if (0 <= e3 && e3 < r2.length) return r2[e3]
              throw TypeError('Must be between 0 and 63: ' + e3)
            }),
              (n2.decode = function (e3) {
                return 65 <= e3 && e3 <= 90
                  ? e3 - 65
                  : 97 <= e3 && e3 <= 122
                    ? e3 - 97 + 26
                    : 48 <= e3 && e3 <= 57
                      ? e3 - 48 + 52
                      : 43 == e3
                        ? 62
                        : 47 == e3
                          ? 63
                          : -1
              }))
          },
          './@datadog/source-map/lib/binary-search.js': function (e2, n2) {
            ;((n2.GREATEST_LOWER_BOUND = 1),
              (n2.LEAST_UPPER_BOUND = 2),
              (n2.search = function (e3, r2, t2, o) {
                if (0 === r2.length) return -1
                var i = (function e4(r3, t3, o2, i2, s, a) {
                  var u = Math.floor((t3 - r3) / 2) + r3,
                    l = s(o2, i2[u], true)
                  return 0 === l
                    ? u
                    : l > 0
                      ? t3 - u > 1
                        ? e4(u, t3, o2, i2, s, a)
                        : a == n2.LEAST_UPPER_BOUND
                          ? t3 < i2.length
                            ? t3
                            : -1
                          : u
                      : u - r3 > 1
                        ? e4(r3, u, o2, i2, s, a)
                        : a == n2.LEAST_UPPER_BOUND
                          ? u
                          : r3 < 0
                            ? -1
                            : r3
                })(-1, r2.length, e3, r2, t2, o || n2.GREATEST_LOWER_BOUND)
                if (i < 0) return -1
                for (; i - 1 >= 0 && 0 === t2(r2[i], r2[i - 1], true); ) --i
                return i
              }))
          },
          './@datadog/source-map/lib/mapping-list.js': function (e2, n2, r2) {
            var t2 = r2('./@datadog/source-map/lib/util.js')
            function o() {
              ;((this._array = []), (this._sorted = true), (this._last = { generatedLine: -1, generatedColumn: 0 }))
            }
            ;((o.prototype.unsortedForEach = function (e3, n3) {
              this._array.forEach(e3, n3)
            }),
              (o.prototype.add = function (e3) {
                var n3, r3, o2, i, s
                ;(((n3 = this._last),
                (r3 = n3.generatedLine),
                (o2 = e3.generatedLine),
                (i = n3.generatedColumn),
                (s = e3.generatedColumn),
                o2 > r3 || (o2 == r3 && s >= i) || 0 >= t2.compareByGeneratedPositionsInflated(n3, e3))
                  ? (this._last = e3)
                  : (this._sorted = false),
                  this._array.push(e3))
              }),
              (o.prototype.toArray = function () {
                return (
                  this._sorted || (this._array.sort(t2.compareByGeneratedPositionsInflated), (this._sorted = true)),
                  this._array
                )
              }),
              (n2.MappingList = o))
          },
          './@datadog/source-map/lib/quick-sort.js': function (e2, n2) {
            function r2(e3, n3, r3) {
              var t2 = e3[n3]
              ;((e3[n3] = e3[r3]), (e3[r3] = t2))
            }
            n2.quickSort = function (e3, n3) {
              !(function e4(n4, t2, o, i) {
                if (o < i) {
                  var s = Math.round(o + Math.random() * (i - o)),
                    a = o - 1
                  r2(n4, s, i)
                  for (var u = n4[i], l = o; l < i; l++) 0 >= t2(n4[l], u) && r2(n4, (a += 1), l)
                  r2(n4, a + 1, l)
                  var c = a + 1
                  ;(e4(n4, t2, o, c - 1), e4(n4, t2, c + 1, i))
                }
              })(e3, n3, 0, e3.length - 1)
            }
          },
          './@datadog/source-map/lib/source-map-consumer.js': function (e2, n2, r2) {
            var t2 = r2('./@datadog/source-map/lib/util.js'),
              o = r2('./@datadog/source-map/lib/binary-search.js'),
              i = r2('./@datadog/source-map/lib/array-set.js').ArraySet,
              s = r2('./@datadog/source-map/lib/base64-vlq.js'),
              a = r2('./@datadog/source-map/lib/quick-sort.js').quickSort
            function u(e3, n3) {
              var r3 = e3
              return (
                'string' == typeof e3 && (r3 = t2.parseSourceMapInput(e3)),
                null != r3.sections ? new g(r3, n3) : new l(r3, n3)
              )
            }
            function l(e3, n3) {
              var r3 = e3
              'string' == typeof e3 && (r3 = t2.parseSourceMapInput(e3))
              var o2 = t2.getArg(r3, 'version'),
                s2 = t2.getArg(r3, 'sources'),
                a2 = t2.getArg(r3, 'names', []),
                u2 = t2.getArg(r3, 'sourceRoot', null),
                l2 = t2.getArg(r3, 'sourcesContent', null),
                c2 = t2.getArg(r3, 'mappings'),
                g2 = t2.getArg(r3, 'file', null)
              if (o2 != this._version) throw Error('Unsupported version: ' + o2)
              ;(u2 && (u2 = t2.normalize(u2)),
                (s2 = s2
                  .map(String)
                  .map(t2.normalize)
                  .map(function (e4) {
                    return u2 && t2.isAbsolute(u2) && t2.isAbsolute(e4) ? t2.relative(u2, e4) : e4
                  })),
                (this._names = i.fromArray(a2.map(String), true)),
                (this._sources = i.fromArray(s2, true)),
                (this._absoluteSources = this._sources.toArray().map(function (e4) {
                  return t2.computeSourceURL(u2, e4, n3)
                })),
                (this.sourceRoot = u2),
                (this.sourcesContent = l2),
                (this._mappings = c2),
                (this._sourceMapURL = n3),
                (this.file = g2))
            }
            function c() {
              ;((this.generatedLine = 0),
                (this.generatedColumn = 0),
                (this.source = null),
                (this.originalLine = null),
                (this.originalColumn = null),
                (this.name = null))
            }
            function g(e3, n3) {
              var r3 = e3
              'string' == typeof e3 && (r3 = t2.parseSourceMapInput(e3))
              var o2 = t2.getArg(r3, 'version'),
                s2 = t2.getArg(r3, 'sections')
              if (o2 != this._version) throw Error('Unsupported version: ' + o2)
              ;((this._sources = new i()), (this._names = new i()))
              var a2 = { line: -1, column: 0 }
              this._sections = s2.map(function (e4) {
                if (e4.url) throw Error('Support for url field in sections not implemented.')
                var r4 = t2.getArg(e4, 'offset'),
                  o3 = t2.getArg(r4, 'line'),
                  i2 = t2.getArg(r4, 'column')
                if (o3 < a2.line || (o3 === a2.line && i2 < a2.column))
                  throw Error('Section offsets must be ordered and non-overlapping.')
                return (
                  (a2 = r4),
                  {
                    generatedOffset: { generatedLine: o3 + 1, generatedColumn: i2 + 1 },
                    consumer: new u(t2.getArg(e4, 'map'), n3),
                  }
                )
              })
            }
            ;((u.fromSourceMap = function (e3, n3) {
              return l.fromSourceMap(e3, n3)
            }),
              (u.prototype._version = 3),
              (u.prototype.__generatedMappings = null),
              Object.defineProperty(u.prototype, '_generatedMappings', {
                configurable: true,
                enumerable: true,
                get: function () {
                  return (
                    this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot),
                    this.__generatedMappings
                  )
                },
              }),
              (u.prototype.__originalMappings = null),
              Object.defineProperty(u.prototype, '_originalMappings', {
                configurable: true,
                enumerable: true,
                get: function () {
                  return (
                    this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot),
                    this.__originalMappings
                  )
                },
              }),
              (u.prototype._charIsMappingSeparator = function (e3, n3) {
                var r3 = e3.charAt(n3)
                return ';' === r3 || ',' === r3
              }),
              (u.prototype._parseMappings = function (e3, n3) {
                throw Error('Subclasses must implement _parseMappings')
              }),
              (u.GENERATED_ORDER = 1),
              (u.ORIGINAL_ORDER = 2),
              (u.GREATEST_LOWER_BOUND = 1),
              (u.LEAST_UPPER_BOUND = 2),
              (u.prototype.eachMapping = function (e3, n3, r3) {
                switch (r3 || u.GENERATED_ORDER) {
                  case u.GENERATED_ORDER:
                    o2 = this._generatedMappings
                    break
                  case u.ORIGINAL_ORDER:
                    o2 = this._originalMappings
                    break
                  default:
                    throw Error('Unknown order of iteration.')
                }
                var o2,
                  i2 = this.sourceRoot
                o2.map(function (e4) {
                  var n4 = null === e4.source ? null : this._sources.at(e4.source)
                  return {
                    source: (n4 = t2.computeSourceURL(i2, n4, this._sourceMapURL)),
                    generatedLine: e4.generatedLine,
                    generatedColumn: e4.generatedColumn,
                    originalLine: e4.originalLine,
                    originalColumn: e4.originalColumn,
                    name: null === e4.name ? null : this._names.at(e4.name),
                  }
                }, this).forEach(e3, n3 || null)
              }),
              (u.prototype.allGeneratedPositionsFor = function (e3) {
                var n3 = t2.getArg(e3, 'line'),
                  r3 = { source: t2.getArg(e3, 'source'), originalLine: n3, originalColumn: t2.getArg(e3, 'column', 0) }
                if (((r3.source = this._findSourceIndex(r3.source)), r3.source < 0)) return []
                var i2 = [],
                  s2 = this._findMapping(
                    r3,
                    this._originalMappings,
                    'originalLine',
                    'originalColumn',
                    t2.compareByOriginalPositions,
                    o.LEAST_UPPER_BOUND
                  )
                if (s2 >= 0) {
                  var a2 = this._originalMappings[s2]
                  if (void 0 === e3.column)
                    for (var u2 = a2.originalLine; a2 && a2.originalLine === u2; )
                      (i2.push({
                        line: t2.getArg(a2, 'generatedLine', null),
                        column: t2.getArg(a2, 'generatedColumn', null),
                        lastColumn: t2.getArg(a2, 'lastGeneratedColumn', null),
                      }),
                        (a2 = this._originalMappings[++s2]))
                  else
                    for (var l2 = a2.originalColumn; a2 && a2.originalLine === n3 && a2.originalColumn == l2; )
                      (i2.push({
                        line: t2.getArg(a2, 'generatedLine', null),
                        column: t2.getArg(a2, 'generatedColumn', null),
                        lastColumn: t2.getArg(a2, 'lastGeneratedColumn', null),
                      }),
                        (a2 = this._originalMappings[++s2]))
                }
                return i2
              }),
              (n2.SourceMapConsumer = u),
              (l.prototype = Object.create(u.prototype)),
              (l.prototype.consumer = u),
              (l.prototype._findSourceIndex = function (e3) {
                var n3,
                  r3 = e3
                if ((null != this.sourceRoot && (r3 = t2.relative(this.sourceRoot, r3)), this._sources.has(r3)))
                  return this._sources.indexOf(r3)
                for (n3 = 0; n3 < this._absoluteSources.length; ++n3) if (this._absoluteSources[n3] == e3) return n3
                return -1
              }),
              (l.fromSourceMap = function (e3, n3) {
                var r3 = Object.create(l.prototype),
                  o2 = (r3._names = i.fromArray(e3._names.toArray(), true)),
                  s2 = (r3._sources = i.fromArray(e3._sources.toArray(), true))
                ;((r3.sourceRoot = e3._sourceRoot),
                  (r3.sourcesContent = e3._generateSourcesContent(r3._sources.toArray(), r3.sourceRoot)),
                  (r3.file = e3._file),
                  (r3._sourceMapURL = n3),
                  (r3._absoluteSources = r3._sources.toArray().map(function (e4) {
                    return t2.computeSourceURL(r3.sourceRoot, e4, n3)
                  })))
                for (
                  var u2 = e3._mappings.toArray().slice(),
                    g2 = (r3.__generatedMappings = []),
                    p = (r3.__originalMappings = []),
                    h = 0,
                    d = u2.length;
                  h < d;
                  h++
                ) {
                  var f = u2[h],
                    m = new c()
                  ;((m.generatedLine = f.generatedLine),
                    (m.generatedColumn = f.generatedColumn),
                    f.source &&
                      ((m.source = s2.indexOf(f.source)),
                      (m.originalLine = f.originalLine),
                      (m.originalColumn = f.originalColumn),
                      f.name && (m.name = o2.indexOf(f.name)),
                      p.push(m)),
                    g2.push(m))
                }
                return (a(r3.__originalMappings, t2.compareByOriginalPositions), r3)
              }),
              (l.prototype._version = 3),
              Object.defineProperty(l.prototype, 'sources', {
                get: function () {
                  return this._absoluteSources.slice()
                },
              }),
              (l.prototype._parseMappings = function (e3, n3) {
                for (
                  var r3,
                    o2,
                    i2,
                    u2,
                    l2,
                    g2 = 1,
                    p = 0,
                    h = 0,
                    d = 0,
                    f = 0,
                    m = 0,
                    _ = e3.length,
                    v = 0,
                    y = {},
                    C = {},
                    S = [],
                    A = [];
                  v < _;
                )
                  if (';' === e3.charAt(v)) (g2++, v++, (p = 0))
                  else if (',' === e3.charAt(v)) v++
                  else {
                    for (
                      (r3 = new c()).generatedLine = g2, u2 = v;
                      u2 < _ && !this._charIsMappingSeparator(e3, u2);
                      u2++
                    );
                    if ((i2 = y[(o2 = e3.slice(v, u2))])) v += o2.length
                    else {
                      for (i2 = []; v < u2; ) (s.decode(e3, v, C), (l2 = C.value), (v = C.rest), i2.push(l2))
                      if (2 === i2.length) throw Error('Found a source, but no line and column')
                      if (3 === i2.length) throw Error('Found a source and line, but no column')
                      y[o2] = i2
                    }
                    ;((r3.generatedColumn = p + i2[0]),
                      (p = r3.generatedColumn),
                      i2.length > 1 &&
                        ((r3.source = f + i2[1]),
                        (f += i2[1]),
                        (r3.originalLine = h + i2[2]),
                        (h = r3.originalLine),
                        (r3.originalLine += 1),
                        (r3.originalColumn = d + i2[3]),
                        (d = r3.originalColumn),
                        i2.length > 4 && ((r3.name = m + i2[4]), (m += i2[4]))),
                      A.push(r3),
                      'number' == typeof r3.originalLine && S.push(r3))
                  }
                ;(a(A, t2.compareByGeneratedPositionsDeflated),
                  (this.__generatedMappings = A),
                  a(S, t2.compareByOriginalPositions),
                  (this.__originalMappings = S))
              }),
              (l.prototype._findMapping = function (e3, n3, r3, t3, i2, s2) {
                if (e3[r3] <= 0) throw TypeError('Line must be greater than or equal to 1, got ' + e3[r3])
                if (e3[t3] < 0) throw TypeError('Column must be greater than or equal to 0, got ' + e3[t3])
                return o.search(e3, n3, i2, s2)
              }),
              (l.prototype.computeColumnSpans = function () {
                for (var e3 = 0; e3 < this._generatedMappings.length; ++e3) {
                  var n3 = this._generatedMappings[e3]
                  if (e3 + 1 < this._generatedMappings.length) {
                    var r3 = this._generatedMappings[e3 + 1]
                    if (n3.generatedLine === r3.generatedLine) {
                      n3.lastGeneratedColumn = r3.generatedColumn - 1
                      continue
                    }
                  }
                  n3.lastGeneratedColumn = 1 / 0
                }
              }),
              (l.prototype.originalPositionFor = function (e3) {
                var n3 = { generatedLine: t2.getArg(e3, 'line'), generatedColumn: t2.getArg(e3, 'column') },
                  r3 = this._findMapping(
                    n3,
                    this._generatedMappings,
                    'generatedLine',
                    'generatedColumn',
                    t2.compareByGeneratedPositionsDeflated,
                    t2.getArg(e3, 'bias', u.GREATEST_LOWER_BOUND)
                  )
                if (r3 >= 0) {
                  var o2 = this._generatedMappings[r3]
                  if (o2.generatedLine === n3.generatedLine) {
                    var i2 = t2.getArg(o2, 'source', null)
                    null !== i2 &&
                      ((i2 = this._sources.at(i2)), (i2 = t2.computeSourceURL(this.sourceRoot, i2, this._sourceMapURL)))
                    var s2 = t2.getArg(o2, 'name', null)
                    return (
                      null !== s2 && (s2 = this._names.at(s2)),
                      {
                        source: i2,
                        line: t2.getArg(o2, 'originalLine', null),
                        column: t2.getArg(o2, 'originalColumn', null),
                        name: s2,
                      }
                    )
                  }
                }
                return { source: null, line: null, column: null, name: null }
              }),
              (l.prototype.hasContentsOfAllSources = function () {
                return (
                  !!this.sourcesContent &&
                  this.sourcesContent.length >= this._sources.size() &&
                  !this.sourcesContent.some(function (e3) {
                    return null == e3
                  })
                )
              }),
              (l.prototype.sourceContentFor = function (e3, n3) {
                if (!this.sourcesContent) return null
                var r3,
                  o2 = this._findSourceIndex(e3)
                if (o2 >= 0) return this.sourcesContent[o2]
                var i2 = e3
                if (
                  (null != this.sourceRoot && (i2 = t2.relative(this.sourceRoot, i2)),
                  null != this.sourceRoot && (r3 = t2.urlParse(this.sourceRoot)))
                ) {
                  var s2 = i2.replace(/^file:\/\//, '')
                  if ('file' == r3.scheme && this._sources.has(s2))
                    return this.sourcesContent[this._sources.indexOf(s2)]
                  if ((!r3.path || '/' == r3.path) && this._sources.has('/' + i2))
                    return this.sourcesContent[this._sources.indexOf('/' + i2)]
                }
                if (n3) return null
                throw Error('"' + i2 + '" is not in the SourceMap.')
              }),
              (l.prototype.generatedPositionFor = function (e3) {
                var n3 = t2.getArg(e3, 'source')
                if ((n3 = this._findSourceIndex(n3)) < 0) return { line: null, column: null, lastColumn: null }
                var r3 = { source: n3, originalLine: t2.getArg(e3, 'line'), originalColumn: t2.getArg(e3, 'column') },
                  o2 = this._findMapping(
                    r3,
                    this._originalMappings,
                    'originalLine',
                    'originalColumn',
                    t2.compareByOriginalPositions,
                    t2.getArg(e3, 'bias', u.GREATEST_LOWER_BOUND)
                  )
                if (o2 >= 0) {
                  var i2 = this._originalMappings[o2]
                  if (i2.source === r3.source)
                    return {
                      line: t2.getArg(i2, 'generatedLine', null),
                      column: t2.getArg(i2, 'generatedColumn', null),
                      lastColumn: t2.getArg(i2, 'lastGeneratedColumn', null),
                    }
                }
                return { line: null, column: null, lastColumn: null }
              }),
              (g.prototype = Object.create(u.prototype)),
              (g.prototype.constructor = u),
              (g.prototype._version = 3),
              Object.defineProperty(g.prototype, 'sources', {
                get: function () {
                  for (var e3 = [], n3 = 0; n3 < this._sections.length; n3++)
                    for (var r3 = 0; r3 < this._sections[n3].consumer.sources.length; r3++)
                      e3.push(this._sections[n3].consumer.sources[r3])
                  return e3
                },
              }),
              (g.prototype.originalPositionFor = function (e3) {
                var n3 = { generatedLine: t2.getArg(e3, 'line'), generatedColumn: t2.getArg(e3, 'column') },
                  r3 = o.search(n3, this._sections, function (e4, n4) {
                    var r4 = e4.generatedLine - n4.generatedOffset.generatedLine
                    return r4 || e4.generatedColumn - n4.generatedOffset.generatedColumn
                  }),
                  i2 = this._sections[r3]
                return i2
                  ? i2.consumer.originalPositionFor({
                      line: n3.generatedLine - (i2.generatedOffset.generatedLine - 1),
                      column:
                        n3.generatedColumn -
                        (i2.generatedOffset.generatedLine === n3.generatedLine
                          ? i2.generatedOffset.generatedColumn - 1
                          : 0),
                      bias: e3.bias,
                    })
                  : { source: null, line: null, column: null, name: null }
              }),
              (g.prototype.hasContentsOfAllSources = function () {
                return this._sections.every(function (e3) {
                  return e3.consumer.hasContentsOfAllSources()
                })
              }),
              (g.prototype.sourceContentFor = function (e3, n3) {
                for (var r3 = 0; r3 < this._sections.length; r3++) {
                  var t3 = this._sections[r3].consumer.sourceContentFor(e3, true)
                  if (t3) return t3
                }
                if (n3) return null
                throw Error('"' + e3 + '" is not in the SourceMap.')
              }),
              (g.prototype.generatedPositionFor = function (e3) {
                for (var n3 = 0; n3 < this._sections.length; n3++) {
                  var r3 = this._sections[n3]
                  if (-1 !== r3.consumer._findSourceIndex(t2.getArg(e3, 'source'))) {
                    var o2 = r3.consumer.generatedPositionFor(e3)
                    if (o2)
                      return {
                        line: o2.line + (r3.generatedOffset.generatedLine - 1),
                        column:
                          o2.column +
                          (r3.generatedOffset.generatedLine === o2.line ? r3.generatedOffset.generatedColumn - 1 : 0),
                      }
                  }
                }
                return { line: null, column: null }
              }),
              (g.prototype._parseMappings = function (e3, n3) {
                ;((this.__generatedMappings = []), (this.__originalMappings = []))
                for (var r3 = 0; r3 < this._sections.length; r3++)
                  for (var o2 = this._sections[r3], i2 = o2.consumer._generatedMappings, s2 = 0; s2 < i2.length; s2++) {
                    var u2 = i2[s2],
                      l2 = o2.consumer._sources.at(u2.source)
                    ;((l2 = t2.computeSourceURL(o2.consumer.sourceRoot, l2, this._sourceMapURL)),
                      this._sources.add(l2),
                      (l2 = this._sources.indexOf(l2)))
                    var c2 = null
                    u2.name &&
                      ((c2 = o2.consumer._names.at(u2.name)), this._names.add(c2), (c2 = this._names.indexOf(c2)))
                    var g2 = {
                      source: l2,
                      generatedLine: u2.generatedLine + (o2.generatedOffset.generatedLine - 1),
                      generatedColumn:
                        u2.generatedColumn +
                        (o2.generatedOffset.generatedLine === u2.generatedLine
                          ? o2.generatedOffset.generatedColumn - 1
                          : 0),
                      originalLine: u2.originalLine,
                      originalColumn: u2.originalColumn,
                      name: c2,
                    }
                    ;(this.__generatedMappings.push(g2),
                      'number' == typeof g2.originalLine && this.__originalMappings.push(g2))
                  }
                ;(a(this.__generatedMappings, t2.compareByGeneratedPositionsDeflated),
                  a(this.__originalMappings, t2.compareByOriginalPositions))
              }))
          },
          './@datadog/source-map/lib/source-map-generator.js': function (e2, n2, r2) {
            var t2 = r2('./@datadog/source-map/lib/base64-vlq.js'),
              o = r2('./@datadog/source-map/lib/util.js'),
              i = r2('./@datadog/source-map/lib/array-set.js').ArraySet,
              s = r2('./@datadog/source-map/lib/mapping-list.js').MappingList
            function a(e3) {
              ;(e3 || (e3 = {}),
                (this._file = o.getArg(e3, 'file', null)),
                (this._sourceRoot = o.getArg(e3, 'sourceRoot', null)),
                (this._skipValidation = o.getArg(e3, 'skipValidation', false)),
                (this._sources = new i()),
                (this._names = new i()),
                (this._mappings = new s()),
                (this._sourcesContents = null))
            }
            ;((a.prototype._version = 3),
              (a.fromSourceMap = function (e3) {
                var n3 = e3.sourceRoot,
                  r3 = new a({ file: e3.file, sourceRoot: n3 })
                return (
                  e3.eachMapping(function (e4) {
                    var t3 = { generated: { line: e4.generatedLine, column: e4.generatedColumn } }
                    ;(null != e4.source &&
                      ((t3.source = e4.source),
                      null != n3 && (t3.source = o.relative(n3, t3.source)),
                      (t3.original = { line: e4.originalLine, column: e4.originalColumn }),
                      null != e4.name && (t3.name = e4.name)),
                      r3.addMapping(t3))
                  }),
                  e3.sources.forEach(function (t3) {
                    var i2 = t3
                    ;(null !== n3 && (i2 = o.relative(n3, t3)), r3._sources.has(i2) || r3._sources.add(i2))
                    var s2 = e3.sourceContentFor(t3)
                    null != s2 && r3.setSourceContent(t3, s2)
                  }),
                  r3
                )
              }),
              (a.prototype.addMapping = function (e3) {
                var n3 = o.getArg(e3, 'generated'),
                  r3 = o.getArg(e3, 'original', null),
                  t3 = o.getArg(e3, 'source', null),
                  i2 = o.getArg(e3, 'name', null)
                ;(this._skipValidation || this._validateMapping(n3, r3, t3, i2),
                  null != t3 && ((t3 = String(t3)), this._sources.has(t3) || this._sources.add(t3)),
                  null != i2 && ((i2 = String(i2)), this._names.has(i2) || this._names.add(i2)),
                  this._mappings.add({
                    generatedLine: n3.line,
                    generatedColumn: n3.column,
                    originalLine: null != r3 && r3.line,
                    originalColumn: null != r3 && r3.column,
                    source: t3,
                    name: i2,
                  }))
              }),
              (a.prototype.setSourceContent = function (e3, n3) {
                var r3 = e3
                ;(null != this._sourceRoot && (r3 = o.relative(this._sourceRoot, r3)),
                  null != n3
                    ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)),
                      (this._sourcesContents[o.toSetString(r3)] = n3))
                    : this._sourcesContents &&
                      (delete this._sourcesContents[o.toSetString(r3)],
                      0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null)))
              }),
              (a.prototype.applySourceMap = function (e3, n3, r3) {
                var t3 = n3
                if (null == n3) {
                  if (null == e3.file)
                    throw Error(
                      `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
                    )
                  t3 = e3.file
                }
                var s2 = this._sourceRoot
                null != s2 && (t3 = o.relative(s2, t3))
                var a2 = new i(),
                  u = new i()
                ;(this._mappings.unsortedForEach(function (n4) {
                  if (n4.source === t3 && null != n4.originalLine) {
                    var i2 = e3.originalPositionFor({ line: n4.originalLine, column: n4.originalColumn })
                    null != i2.source &&
                      ((n4.source = i2.source),
                      null != r3 && (n4.source = o.join(r3, n4.source)),
                      null != s2 && (n4.source = o.relative(s2, n4.source)),
                      (n4.originalLine = i2.line),
                      (n4.originalColumn = i2.column),
                      null != i2.name && (n4.name = i2.name))
                  }
                  var l = n4.source
                  null == l || a2.has(l) || a2.add(l)
                  var c = n4.name
                  null == c || u.has(c) || u.add(c)
                }, this),
                  (this._sources = a2),
                  (this._names = u),
                  e3.sources.forEach(function (n4) {
                    var t4 = e3.sourceContentFor(n4)
                    null != t4 &&
                      (null != r3 && (n4 = o.join(r3, n4)),
                      null != s2 && (n4 = o.relative(s2, n4)),
                      this.setSourceContent(n4, t4))
                  }, this))
              }),
              (a.prototype._validateMapping = function (e3, n3, r3, t3) {
                if (n3 && 'number' != typeof n3.line && 'number' != typeof n3.column)
                  throw Error(
                    'original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.'
                  )
                if (
                  !e3 ||
                  !('line' in e3) ||
                  !('column' in e3) ||
                  !(e3.line > 0) ||
                  !(e3.column >= 0) ||
                  n3 ||
                  r3 ||
                  t3
                ) {
                  if (
                    !e3 ||
                    !('line' in e3) ||
                    !('column' in e3) ||
                    !n3 ||
                    !('line' in n3) ||
                    !('column' in n3) ||
                    !(e3.line > 0) ||
                    !(e3.column >= 0) ||
                    !(n3.line > 0) ||
                    !(n3.column >= 0) ||
                    !r3
                  )
                    throw Error(
                      'Invalid mapping: ' + JSON.stringify({ generated: e3, source: r3, original: n3, name: t3 })
                    )
                }
              }),
              (a.prototype._serializeMappings = function () {
                for (
                  var e3,
                    n3,
                    r3,
                    i2,
                    s2 = 0,
                    a2 = 1,
                    u = 0,
                    l = 0,
                    c = 0,
                    g = 0,
                    p = '',
                    h = this._mappings.toArray(),
                    d = 0,
                    f = h.length;
                  d < f;
                  d++
                ) {
                  if (((n3 = h[d]), (e3 = ''), n3.generatedLine !== a2))
                    for (s2 = 0; n3.generatedLine !== a2; ) ((e3 += ';'), a2++)
                  else if (d > 0) {
                    if (!o.compareByGeneratedPositionsInflated(n3, h[d - 1])) continue
                    e3 += ','
                  }
                  ;((e3 += t2.encode(n3.generatedColumn - s2)),
                    (s2 = n3.generatedColumn),
                    null != n3.source &&
                      ((i2 = this._sources.indexOf(n3.source)),
                      (e3 += t2.encode(i2 - g)),
                      (g = i2),
                      (e3 += t2.encode(n3.originalLine - 1 - l)),
                      (l = n3.originalLine - 1),
                      (e3 += t2.encode(n3.originalColumn - u)),
                      (u = n3.originalColumn),
                      null != n3.name && ((r3 = this._names.indexOf(n3.name)), (e3 += t2.encode(r3 - c)), (c = r3))),
                    (p += e3))
                }
                return p
              }),
              (a.prototype._generateSourcesContent = function (e3, n3) {
                return e3.map(function (e4) {
                  if (!this._sourcesContents) return null
                  null != n3 && (e4 = o.relative(n3, e4))
                  var r3 = o.toSetString(e4)
                  return Object.prototype.hasOwnProperty.call(this._sourcesContents, r3)
                    ? this._sourcesContents[r3]
                    : null
                }, this)
              }),
              (a.prototype.toJSON = function () {
                var e3 = {
                  version: this._version,
                  sources: this._sources.toArray(),
                  names: this._names.toArray(),
                  mappings: this._serializeMappings(),
                }
                return (
                  null != this._file && (e3.file = this._file),
                  null != this._sourceRoot && (e3.sourceRoot = this._sourceRoot),
                  this._sourcesContents &&
                    (e3.sourcesContent = this._generateSourcesContent(e3.sources, e3.sourceRoot)),
                  e3
                )
              }),
              (a.prototype.toString = function () {
                return JSON.stringify(this.toJSON())
              }),
              (n2.SourceMapGenerator = a))
          },
          './@datadog/source-map/lib/source-node.js': function (e2, n2, r2) {
            var t2 = r2('./@datadog/source-map/lib/source-map-generator.js').SourceMapGenerator,
              o = r2('./@datadog/source-map/lib/util.js'),
              i = /(\r?\n)/,
              s = '$$$isSourceNode$$$'
            function a(e3, n3, r3, t3, o2) {
              ;((this.children = []),
                (this.sourceContents = {}),
                (this.line = null == e3 ? null : e3),
                (this.column = null == n3 ? null : n3),
                (this.source = null == r3 ? null : r3),
                (this.name = null == o2 ? null : o2),
                (this[s] = true),
                null != t3 && this.add(t3))
            }
            ;((a.fromStringWithSourceMap = function (e3, n3, r3) {
              var t3 = new a(),
                s2 = e3.split(i),
                u = 0,
                l = function () {
                  return e4() + (e4() || '')
                  function e4() {
                    return u < s2.length ? s2[u++] : void 0
                  }
                },
                c = 1,
                g = 0,
                p = null
              return (
                n3.eachMapping(function (e4) {
                  if (null !== p)
                    if (c < e4.generatedLine) (h(p, l()), c++, (g = 0))
                    else {
                      var n4 = s2[u] || '',
                        r4 = n4.substr(0, e4.generatedColumn - g)
                      ;((s2[u] = n4.substr(e4.generatedColumn - g)), (g = e4.generatedColumn), h(p, r4), (p = e4))
                      return
                    }
                  for (; c < e4.generatedLine; ) (t3.add(l()), c++)
                  if (g < e4.generatedColumn) {
                    var n4 = s2[u] || ''
                    ;(t3.add(n4.substr(0, e4.generatedColumn)),
                      (s2[u] = n4.substr(e4.generatedColumn)),
                      (g = e4.generatedColumn))
                  }
                  p = e4
                }, this),
                u < s2.length && (p && h(p, l()), t3.add(s2.splice(u).join(''))),
                n3.sources.forEach(function (e4) {
                  var i2 = n3.sourceContentFor(e4)
                  null != i2 && (null != r3 && (e4 = o.join(r3, e4)), t3.setSourceContent(e4, i2))
                }),
                t3
              )
              function h(e4, n4) {
                if (null === e4 || void 0 === e4.source) t3.add(n4)
                else {
                  var i2 = r3 ? o.join(r3, e4.source) : e4.source
                  t3.add(new a(e4.originalLine, e4.originalColumn, i2, n4, e4.name))
                }
              }
            }),
              (a.prototype.add = function (e3) {
                if (Array.isArray(e3))
                  e3.forEach(function (e4) {
                    this.add(e4)
                  }, this)
                else if (e3[s] || 'string' == typeof e3) e3 && this.children.push(e3)
                else throw TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + e3)
                return this
              }),
              (a.prototype.prepend = function (e3) {
                if (Array.isArray(e3)) for (var n3 = e3.length - 1; n3 >= 0; n3--) this.prepend(e3[n3])
                else if (e3[s] || 'string' == typeof e3) this.children.unshift(e3)
                else throw TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + e3)
                return this
              }),
              (a.prototype.walk = function (e3) {
                for (var n3, r3 = 0, t3 = this.children.length; r3 < t3; r3++)
                  (n3 = this.children[r3])[s]
                    ? n3.walk(e3)
                    : '' !== n3 &&
                      e3(n3, { source: this.source, line: this.line, column: this.column, name: this.name })
              }),
              (a.prototype.join = function (e3) {
                var n3,
                  r3,
                  t3 = this.children.length
                if (t3 > 0) {
                  for (r3 = 0, n3 = []; r3 < t3 - 1; r3++) (n3.push(this.children[r3]), n3.push(e3))
                  ;(n3.push(this.children[r3]), (this.children = n3))
                }
                return this
              }),
              (a.prototype.replaceRight = function (e3, n3) {
                var r3 = this.children[this.children.length - 1]
                return (
                  r3[s]
                    ? r3.replaceRight(e3, n3)
                    : 'string' == typeof r3
                      ? (this.children[this.children.length - 1] = r3.replace(e3, n3))
                      : this.children.push(''.replace(e3, n3)),
                  this
                )
              }),
              (a.prototype.setSourceContent = function (e3, n3) {
                this.sourceContents[o.toSetString(e3)] = n3
              }),
              (a.prototype.walkSourceContents = function (e3) {
                for (var n3 = 0, r3 = this.children.length; n3 < r3; n3++)
                  this.children[n3][s] && this.children[n3].walkSourceContents(e3)
                for (var t3 = Object.keys(this.sourceContents), n3 = 0, r3 = t3.length; n3 < r3; n3++)
                  e3(o.fromSetString(t3[n3]), this.sourceContents[t3[n3]])
              }),
              (a.prototype.toString = function () {
                var e3 = ''
                return (
                  this.walk(function (n3) {
                    e3 += n3
                  }),
                  e3
                )
              }),
              (a.prototype.toStringWithSourceMap = function (e3) {
                var n3 = { code: '', line: 1, column: 0 },
                  r3 = new t2(e3),
                  o2 = false,
                  i2 = null,
                  s2 = null,
                  a2 = null,
                  u = null
                return (
                  this.walk(function (e4, t3) {
                    ;((n3.code += e4),
                      null !== t3.source && null !== t3.line && null !== t3.column
                        ? ((i2 !== t3.source || s2 !== t3.line || a2 !== t3.column || u !== t3.name) &&
                            r3.addMapping({
                              source: t3.source,
                              original: { line: t3.line, column: t3.column },
                              generated: { line: n3.line, column: n3.column },
                              name: t3.name,
                            }),
                          (i2 = t3.source),
                          (s2 = t3.line),
                          (a2 = t3.column),
                          (u = t3.name),
                          (o2 = true))
                        : o2 &&
                          (r3.addMapping({ generated: { line: n3.line, column: n3.column } }),
                          (i2 = null),
                          (o2 = false)))
                    for (var l = 0, c = e4.length; l < c; l++)
                      10 === e4.charCodeAt(l)
                        ? (n3.line++,
                          (n3.column = 0),
                          l + 1 === c
                            ? ((i2 = null), (o2 = false))
                            : o2 &&
                              r3.addMapping({
                                source: t3.source,
                                original: { line: t3.line, column: t3.column },
                                generated: { line: n3.line, column: n3.column },
                                name: t3.name,
                              }))
                        : n3.column++
                  }),
                  this.walkSourceContents(function (e4, n4) {
                    r3.setSourceContent(e4, n4)
                  }),
                  { code: n3.code, map: r3 }
                )
              }),
              (n2.SourceNode = a))
          },
          './@datadog/source-map/lib/util.js': function (e2, n2) {
            n2.getArg = function (e3, n3, r3) {
              if (n3 in e3) return e3[n3]
              if (3 == arguments.length) return r3
              throw Error('"' + n3 + '" is a required argument.')
            }
            var r2 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
              t2 = /^data:.+\,.+$/
            function o(e3) {
              var n3 = e3.match(r2)
              return n3 ? { scheme: n3[1], auth: n3[2], host: n3[3], port: n3[4], path: n3[5] } : null
            }
            function i(e3) {
              var n3 = ''
              return (
                e3.scheme && (n3 += e3.scheme + ':'),
                (n3 += '//'),
                e3.auth && (n3 += e3.auth + '@'),
                e3.host && (n3 += e3.host),
                e3.port && (n3 += ':' + e3.port),
                e3.path && (n3 += e3.path),
                n3
              )
            }
            function s(e3) {
              var r3 = e3,
                t3 = o(e3)
              if (t3) {
                if (!t3.path) return e3
                r3 = t3.path
              }
              for (var s2, a2 = n2.isAbsolute(r3), u2 = r3.split(/\/+/), l2 = 0, c2 = u2.length - 1; c2 >= 0; c2--)
                '.' === (s2 = u2[c2])
                  ? u2.splice(c2, 1)
                  : '..' === s2
                    ? l2++
                    : l2 > 0 && ('' === s2 ? (u2.splice(c2 + 1, l2), (l2 = 0)) : (u2.splice(c2, 2), l2--))
              return ('' === (r3 = u2.join('/')) && (r3 = a2 ? '/' : '.'), t3) ? ((t3.path = r3), i(t3)) : r3
            }
            function a(e3, n3) {
              ;('' === e3 && (e3 = '.'), '' === n3 && (n3 = '.'))
              var r3 = o(n3),
                a2 = o(e3)
              if ((a2 && (e3 = a2.path || '/'), r3 && !r3.scheme)) return (a2 && (r3.scheme = a2.scheme), i(r3))
              if (r3 || n3.match(t2)) return n3
              if (a2 && !a2.host && !a2.path) return ((a2.host = n3), i(a2))
              var u2 = '/' === n3.charAt(0) ? n3 : s(e3.replace(/\/+$/, '') + '/' + n3)
              return a2 ? ((a2.path = u2), i(a2)) : u2
            }
            ;((n2.urlParse = o),
              (n2.urlGenerate = i),
              (n2.normalize = s),
              (n2.join = a),
              (n2.isAbsolute = function (e3) {
                return '/' === e3.charAt(0) || r2.test(e3)
              }),
              (n2.relative = function (e3, n3) {
                ;('' === e3 && (e3 = '.'), (e3 = e3.replace(/\/$/, '')))
                for (var r3 = 0; 0 !== n3.indexOf(e3 + '/'); ) {
                  var t3 = e3.lastIndexOf('/')
                  if (t3 < 0 || (e3 = e3.slice(0, t3)).match(/^([^\/]+:\/)?\/*$/)) return n3
                  ++r3
                }
                return Array(r3 + 1).join('../') + n3.substr(e3.length + 1)
              }))
            var u = !('__proto__' in /* @__PURE__ */ Object.create(null))
            function l(e3) {
              return e3
            }
            function c(e3) {
              if (!e3) return false
              var n3 = e3.length
              if (
                n3 < 9 ||
                95 !== e3.charCodeAt(n3 - 1) ||
                95 !== e3.charCodeAt(n3 - 2) ||
                111 !== e3.charCodeAt(n3 - 3) ||
                116 !== e3.charCodeAt(n3 - 4) ||
                111 !== e3.charCodeAt(n3 - 5) ||
                114 !== e3.charCodeAt(n3 - 6) ||
                112 !== e3.charCodeAt(n3 - 7) ||
                95 !== e3.charCodeAt(n3 - 8) ||
                95 !== e3.charCodeAt(n3 - 9)
              )
                return false
              for (var r3 = n3 - 10; r3 >= 0; r3--) if (36 !== e3.charCodeAt(r3)) return false
              return true
            }
            function g(e3, n3) {
              return e3 === n3 ? 0 : null === e3 ? 1 : null === n3 ? -1 : e3 > n3 ? 1 : -1
            }
            ;((n2.toSetString = u
              ? l
              : function (e3) {
                  return c(e3) ? '$' + e3 : e3
                }),
              (n2.fromSetString = u
                ? l
                : function (e3) {
                    return c(e3) ? e3.slice(1) : e3
                  }),
              (n2.compareByOriginalPositions = function (e3, n3, r3) {
                var t3 = g(e3.source, n3.source)
                return 0 !== t3 ||
                  0 != (t3 = e3.originalLine - n3.originalLine) ||
                  0 != (t3 = e3.originalColumn - n3.originalColumn) ||
                  r3 ||
                  0 != (t3 = e3.generatedColumn - n3.generatedColumn) ||
                  0 != (t3 = e3.generatedLine - n3.generatedLine)
                  ? t3
                  : g(e3.name, n3.name)
              }),
              (n2.compareByGeneratedPositionsDeflated = function (e3, n3, r3) {
                var t3 = e3.generatedLine - n3.generatedLine
                return 0 !== t3 ||
                  0 != (t3 = e3.generatedColumn - n3.generatedColumn) ||
                  r3 ||
                  0 !== (t3 = g(e3.source, n3.source)) ||
                  0 != (t3 = e3.originalLine - n3.originalLine) ||
                  0 != (t3 = e3.originalColumn - n3.originalColumn)
                  ? t3
                  : g(e3.name, n3.name)
              }),
              (n2.compareByGeneratedPositionsInflated = function (e3, n3) {
                var r3 = e3.generatedLine - n3.generatedLine
                return 0 !== r3 ||
                  0 != (r3 = e3.generatedColumn - n3.generatedColumn) ||
                  0 !== (r3 = g(e3.source, n3.source)) ||
                  0 != (r3 = e3.originalLine - n3.originalLine) ||
                  0 != (r3 = e3.originalColumn - n3.originalColumn)
                  ? r3
                  : g(e3.name, n3.name)
              }),
              (n2.parseSourceMapInput = function (e3) {
                return JSON.parse(e3.replace(/^\)]}'[^\n]*\n/, ''))
              }),
              (n2.computeSourceURL = function (e3, n3, r3) {
                if (
                  ((n3 = n3 || ''),
                  e3 && ('/' !== e3[e3.length - 1] && '/' !== n3[0] && (e3 += '/'), (n3 = e3 + n3)),
                  r3)
                ) {
                  var t3 = o(r3)
                  if (!t3) throw Error('sourceMapURL could not be parsed')
                  if (t3.path) {
                    var u2 = t3.path.lastIndexOf('/')
                    u2 >= 0 && (t3.path = t3.path.substring(0, u2 + 1))
                  }
                  n3 = a(i(t3), n3)
                }
                return s(n3)
              }))
          },
        },
        n = {}
      function r(t2) {
        var o = n[t2]
        if (void 0 !== o) return o.exports
        var i = (n[t2] = { exports: {} })
        return (e[t2](i, i.exports, r), i.exports)
      }
      var t = {}
      ;((t.SourceMapGenerator = r('./@datadog/source-map/lib/source-map-generator.js').SourceMapGenerator),
        (t.SourceMapConsumer = r('./@datadog/source-map/lib/source-map-consumer.js').SourceMapConsumer),
        (t.SourceNode = r('./@datadog/source-map/lib/source-node.js').SourceNode),
        (module2.exports = t))
    })()
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/index.js
var require_rewriter = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/index.js'(exports2, module2) {
    'use strict'
    var { readFileSync } = require('fs')
    var { join } = require('path')
    var semifies = require_semifies()
    var transforms = require_transforms2()
    var { generate, parse, traverse } = require_compiler()
    var log = require_log2()
    var instrumentations = require_instrumentations2()
    var { getEnvironmentVariable } = require_config_helper()
    var NODE_OPTIONS = getEnvironmentVariable('NODE_OPTIONS')
    var supported = {}
    var disabled = /* @__PURE__ */ new Set()
    var enableSourceMaps =
      NODE_OPTIONS?.includes('--enable-source-maps') ||
      process.execArgv?.some((arg) => arg.includes('--enable-source-maps'))
    var SourceMapGenerator
    function rewrite(content, filename, format) {
      if (!content) return content
      try {
        let ast
        filename = filename.replace('file://', '')
        for (const inst of instrumentations) {
          const {
            astQuery,
            functionQuery = {},
            module: { name, versionRange, filePath },
          } = inst
          const { kind } = functionQuery
          const operator = kind === 'Async' ? 'tracePromise' : kind === 'Callback' ? 'traceCallback' : 'traceSync'
          const transform = transforms[operator]
          if (disabled.has(name)) continue
          if (!filename.endsWith(`${name}/${filePath}`)) continue
          if (!transform) continue
          if (!satisfies(filename, filePath, versionRange)) continue
          ast ??= parse(content.toString(), { loc: true, ranges: true, module: format === 'module' })
          const query = astQuery || fromFunctionQuery(functionQuery)
          const state = { ...inst, format, functionQuery, operator }
          traverse(ast, query, (...args) => transform(state, ...args))
        }
        if (ast) {
          if (!enableSourceMaps) return generate(ast)
          SourceMapGenerator ??= require_source_map().SourceMapGenerator
          const sourceMap = new SourceMapGenerator({ file: filename })
          const code = generate(ast, { sourceMap })
          const map = Buffer.from(sourceMap.toString()).toString('base64')
          return (
            code +
            `
//# sourceMappingURL=data:application/json;base64,${map}`
          )
        }
      } catch (e) {
        log.error(e)
      }
      return content
    }
    function disable(instrumentation) {
      disabled.add(instrumentation)
    }
    function satisfies(filename, filePath, versions) {
      const [basename] = filename.split(filePath)
      if (supported[basename] === void 0) {
        try {
          const pkg = JSON.parse(readFileSync(join(basename, 'package.json'), 'utf8'))
          supported[basename] = semifies(pkg.version, versions)
        } catch {
          supported[basename] = false
        }
      }
      return supported[basename]
    }
    function fromFunctionQuery(functionQuery) {
      const { methodName, functionName, expressionName, className } = functionQuery
      const queries = []
      if (className) {
        queries.push(
          `[id.name="${className}"]`,
          `[id.name="${className}"] > ClassBody > [key.name="${methodName}"] > [async]`,
          `[id.name="${className}"] > ClassExpression > ClassBody > [key.name="${methodName}"] > [async]`
        )
      } else if (methodName) {
        queries.push(`ClassBody > [key.name="${methodName}"] > [async]`, `Property[key.name="${methodName}"] > [async]`)
      }
      if (functionName) {
        queries.push(`FunctionDeclaration[id.name="${functionName}"][async]`)
      } else if (expressionName) {
        queries.push(
          `FunctionExpression[id.name="${expressionName}"][async]`,
          `ArrowFunctionExpression[id.name="${expressionName}"][async]`
        )
      }
      return queries.join(', ')
    }
    module2.exports = { rewrite, disable }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/fetch.js
var require_fetch3 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/fetch.js'() {
    'use strict'
    var { isInServerlessEnvironment } = require_serverless()
    if (globalThis.fetch) {
      let wrapRealFetch = function () {
        const { channel, tracingChannel } = require_dc_polyfill()
        const { createWrapFetch } = require_fetch()
        const ch = tracingChannel('apm:fetch:request')
        const wrapFetch = createWrapFetch(globalThis.Request, ch, () => {
          channel('dd-trace:instrumentation:load').publish({ name: 'global:fetch' })
        })
        fetch2 = wrapFetch(globalFetch)
      }
      const globalFetch = globalThis.fetch
      let fetch2 = (input, init) => {
        wrapRealFetch()
        return fetch2(input, init)
      }
      if (!isInServerlessEnvironment()) {
        wrapRealFetch()
      }
      globalThis.fetch = function value(input, init) {
        return fetch2(input, init)
      }
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/process.js
var require_process = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/process.js'() {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { channel } = require_dc_polyfill()
    var startSetUncaughtExceptionCaptureCallback = channel('datadog:process:setUncaughtExceptionCaptureCallback:start')
    if (process.setUncaughtExceptionCaptureCallback) {
      let currentCallback
      shimmer.wrap(
        process,
        'setUncaughtExceptionCaptureCallback',
        function wrapSetUncaughtExceptionCaptureCallback(originalSetUncaughtExceptionCaptureCallback) {
          return function setUncaughtExceptionCaptureCallback(newCallback) {
            if (startSetUncaughtExceptionCaptureCallback.hasSubscribers) {
              const abortController = new AbortController()
              startSetUncaughtExceptionCaptureCallback.publish({ newCallback, currentCallback, abortController })
              if (abortController.signal.aborted) {
                return
              }
            }
            const result = originalSetUncaughtExceptionCaptureCallback.apply(this, arguments)
            currentCallback = newCallback
            return result
          }
        }
      )
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/register.js
var require_register2 = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/register.js'(exports2, module2) {
    'use strict'
    var { channel } = require_dc_polyfill()
    var path = require('path')
    var satisfies = require_semifies()
    var Hook = require_hook()
    var requirePackageJson = require_require_package_json()
    var log = require_log2()
    var checkRequireCache = require_check_require_cache()
    var telemetry = require_telemetry5()
    var { isInServerlessEnvironment } = require_serverless()
    var { getEnvironmentVariables } = require_config_helper()
    var rewriter = require_rewriter()
    var envs = getEnvironmentVariables()
    var { DD_TRACE_DISABLED_INSTRUMENTATIONS = '', DD_TRACE_DEBUG = '' } = envs
    var hooks = require_hooks()
    var instrumentations = require_instrumentations()
    var names = Object.keys(hooks)
    var pathSepExpr = new RegExp(`\\${path.sep}`, 'g')
    var disabledInstrumentations = new Set(DD_TRACE_DISABLED_INSTRUMENTATIONS?.split(','))
    var loadChannel = channel('dd-trace:instrumentation:load')
    if (!disabledInstrumentations.has('fetch')) {
      require_fetch3()
    }
    if (!disabledInstrumentations.has('process')) {
      require_process()
    }
    var HOOK_SYMBOL = /* @__PURE__ */ Symbol('hookExportsSet')
    if (DD_TRACE_DEBUG && DD_TRACE_DEBUG.toLowerCase() !== 'false') {
      checkRequireCache.checkForRequiredModules()
      setImmediate(checkRequireCache.checkForPotentialConflicts)
    }
    var seenCombo = /* @__PURE__ */ new Set()
    var allInstrumentations = {}
    for (const inst of disabledInstrumentations) {
      rewriter.disable(inst)
    }
    for (const packageName of names) {
      if (disabledInstrumentations.has(packageName)) continue
      const hookOptions = {}
      let hook = hooks[packageName]
      if (hook !== null && typeof hook === 'object') {
        if (hook.serverless === false && isInServerlessEnvironment()) continue
        hookOptions.internals = hook.esmFirst
        hook = hook.fn
      }
      const instrumentationFileName = parseHookInstrumentationFileName(packageName)
      Hook([packageName], hookOptions, (moduleExports, moduleName2, moduleBaseDir, moduleVersion, isIitm) => {
        moduleName2 = moduleName2.replace(pathSepExpr, '/')
        hook()
        if (!instrumentations[packageName]) {
          return moduleExports
        }
        const namesAndSuccesses = {}
        for (const { name, file, versions, hook: hook2, filePattern, patchDefault } of instrumentations[packageName]) {
          if (patchDefault === false && !moduleExports.default && isIitm) {
            return moduleExports
          } else if (patchDefault === true && moduleExports.default && isIitm) {
            moduleExports = moduleExports.default
          }
          let fullFilePattern = filePattern
          const fullFilename = filename(name, file)
          if (fullFilePattern) {
            fullFilePattern = filename(name, fullFilePattern)
          }
          hook2[HOOK_SYMBOL] ??= /* @__PURE__ */ new WeakSet()
          let matchesFile = moduleName2 === fullFilename
          if (fullFilePattern) {
            matchesFile = matchesFile || new RegExp(fullFilePattern).test(moduleName2)
          }
          if (matchesFile) {
            let version = moduleVersion
            try {
              version = version || getVersion(moduleBaseDir)
              allInstrumentations[instrumentationFileName] = allInstrumentations[instrumentationFileName] || false
            } catch (e) {
              log.error('Error getting version for "%s": %s', name, e.message, e)
              continue
            }
            if (namesAndSuccesses[`${name}@${version}`] === void 0 && !file) {
              namesAndSuccesses[`${name}@${version}`] = false
            }
            if (matchVersion(version, versions)) {
              allInstrumentations[instrumentationFileName] = true
              if (hook2[HOOK_SYMBOL].has(moduleExports)) {
                namesAndSuccesses[`${name}@${version}`] = true
                return moduleExports
              }
              try {
                loadChannel.publish({ name, version, file })
                moduleExports = hook2(moduleExports, version, name, isIitm) ?? moduleExports
                hook2[HOOK_SYMBOL].add(moduleExports)
              } catch (e) {
                log.info('Error during ddtrace instrumentation of application, aborting.', e)
                telemetry(
                  'error',
                  [`error_type:${e.constructor.name}`, `integration:${name}`, `integration_version:${version}`],
                  {
                    result: 'error',
                    result_class: 'internal_error',
                    result_reason: `Error during instrumentation of ${name}@${version}: ${e.message}`,
                  }
                )
              }
              namesAndSuccesses[`${name}@${version}`] = true
            }
          }
        }
        for (const nameVersion of Object.keys(namesAndSuccesses)) {
          const [name, version] = nameVersion.split('@')
          const success = namesAndSuccesses[nameVersion]
          if (!success && !seenCombo.has(nameVersion) && !allInstrumentations[instrumentationFileName]) {
            telemetry('abort.integration', [`integration:${name}`, `integration_version:${version}`], {
              result: 'abort',
              result_class: 'incompatible_library',
              result_reason: `Incompatible integration version: ${name}@${version}`,
            })
            log.info('Found incompatible integration version: %s', nameVersion)
            seenCombo.add(nameVersion)
          }
        }
        return moduleExports
      })
    }
    function matchVersion(version, ranges) {
      return !version || !ranges || ranges.some((range) => satisfies(version, range))
    }
    function getVersion(moduleBaseDir) {
      if (moduleBaseDir) {
        return requirePackageJson(moduleBaseDir, module2).version
      }
    }
    function filename(name, file) {
      return [name, file].filter(Boolean).join('/')
    }
    function parseHookInstrumentationFileName(packageName) {
      let hook = hooks[packageName]
      if (hook.fn) {
        hook = hook.fn
      }
      const hookString = hook.toString()
      const regex = /require\('([^']*)'\)/
      const match = hookString.match(regex)
      if (match && match[1]) {
        let moduleName2 = match[1]
        if (moduleName2.startsWith('../')) {
          moduleName2 = moduleName2.slice(3)
        }
        return moduleName2
      }
      return null
    }
    module2.exports = {
      filename,
      pathSepExpr,
      loadChannel,
      matchVersion,
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/bundler-register.js
var require_bundler_register = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/bundler-register.js'() {
    'use strict'
    var dc = require_dc_polyfill()
    var { filename, loadChannel, matchVersion } = require_register2()
    var hooks = require_hooks()
    var instrumentations = require_instrumentations()
    var log = require_log2()
    var CHANNEL = 'dd-trace:bundler:load'
    if (!dc.subscribe) {
      dc.subscribe = (channel, cb) => {
        dc.channel(channel).subscribe(cb)
      }
    }
    if (!dc.unsubscribe) {
      dc.unsubscribe = (channel, cb) => {
        if (dc.channel(channel).hasSubscribers) {
          dc.channel(channel).unsubscribe(cb)
        }
      }
    }
    function doHook(payload) {
      const hook = hooks[payload.package]
      if (!hook) {
        log.error('esbuild-wrapped %s missing in list of hooks', payload.package)
        return
      }
      const hookFn = hook.fn ?? hook
      if (typeof hookFn !== 'function') {
        log.error('esbuild-wrapped hook %s is not a function', payload.package)
        return
      }
      try {
        hookFn()
      } catch {
        log.error('esbuild-wrapped %s hook failed', payload.package)
      }
    }
    dc.subscribe(CHANNEL, (payload) => {
      doHook(payload)
      if (!instrumentations[payload.package]) {
        log.error('esbuild-wrapped %s missing in list of instrumentations', payload.package)
        return
      }
      for (const { name, file, versions, hook } of instrumentations[payload.package]) {
        if (payload.path !== filename(name, file)) continue
        if (!matchVersion(payload.version, versions)) continue
        try {
          loadChannel.publish({ name, version: payload.version, file })
          payload.module = hook(payload.module, payload.version)
        } catch (e) {
          log.error('Error executing bundler hook', e)
        }
      }
    })
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/loader.js
var require_loader = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/rewriter/loader.js'() {
    'use strict'
    var Module = require('module')
    var shimmer = require_datadog_shimmer()
    var { rewrite } = require_rewriter()
    shimmer.wrap(
      Module.prototype,
      '_compile',
      (compile) =>
        function (content, filename, format) {
          return compile.call(this, rewrite(content, filename, format), filename, format)
        }
    )
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/index.js
var require_datadog_instrumentations = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/index.js'() {
    'use strict'
    require_bundler_register()
    require_register2()
    require_loader()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/errors.js
var require_errors2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/errors.js'(exports2, module2) {
    'use strict'
    var ExtendedError = class extends Error {
      constructor(reason) {
        super(reason)
        Object.setPrototypeOf(this, new.target.prototype)
      }
    }
    var ImpendingTimeout = class extends ExtendedError {}
    ImpendingTimeout.prototype.name = 'Impending Timeout'
    module2.exports = {
      ImpendingTimeout,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/lambda/handler.js
var require_handler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/lambda/handler.js'(exports2) {
    'use strict'
    var log = require_log2()
    var { channel } = require_instrument()
    var { ERROR_MESSAGE, ERROR_TYPE } = require_constants2()
    var { ImpendingTimeout } = require_errors2()
    var { getEnvironmentVariable } = require_config_helper()
    var globalTracer = global._ddtrace
    var tracer2 = globalTracer._tracer
    var timeoutChannel = channel('apm:aws:lambda:timeout')
    timeoutChannel.subscribe((_) => {
      crashFlush()
    })
    var __lambdaTimeout
    function checkTimeout(context) {
      const remainingTimeInMillis = context.getRemainingTimeInMillis()
      let apmFlushDeadline = Number.parseInt(getEnvironmentVariable('DD_APM_FLUSH_DEADLINE_MILLISECONDS')) || 100
      apmFlushDeadline = apmFlushDeadline < 0 ? 100 : apmFlushDeadline
      __lambdaTimeout = setTimeout(() => {
        timeoutChannel.publish()
      }, remainingTimeInMillis - apmFlushDeadline)
    }
    function crashFlush() {
      const activeSpan = tracer2.scope().active()
      if (activeSpan === null) {
        log.debug('An impending timeout was reached, but no root span was found. No error will be tagged.')
      } else {
        const error = new ImpendingTimeout('Datadog detected an impending timeout')
        activeSpan.addTags({
          [ERROR_MESSAGE]: error.message,
          [ERROR_TYPE]: error.name,
        })
      }
      tracer2._processor.killAll()
      if (activeSpan !== null) {
        activeSpan.finish()
      }
    }
    function extractContext(args) {
      let context = args.length > 1 ? args[1] : void 0
      if (context === void 0 || context.getRemainingTimeInMillis === void 0) {
        context = args.length > 2 ? args[2] : void 0
        if (context === void 0 || context.getRemainingTimeInMillis === void 0) {
          throw new Error('Could not extract context')
        }
      }
      return context
    }
    exports2.datadog = function datadog(lambdaHandler) {
      return (...args) => {
        const context = extractContext(args)
        checkTimeout(context)
        const result = lambdaHandler.apply(this, args)
        if (result && typeof result.then === 'function') {
          return result.then((res) => {
            clearTimeout(__lambdaTimeout)
            return res
          })
        }
        clearTimeout(__lambdaTimeout)
        return result
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/patch.js
var require_patch = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/patch.js'() {
    'use strict'
    var path = require('path')
    var { _extractModuleNameAndHandlerPath, _extractModuleRootAndHandler, _getLambdaFilePaths } = require_ritm2()
    var { datadog } = require_handler()
    var { addHook } = require_instrument()
    var shimmer = require_datadog_shimmer()
    var { getEnvironmentVariable } = require_config_helper()
    var patchDatadogLambdaModule = (datadogLambdaModule) => {
      shimmer.wrap(datadogLambdaModule, 'datadog', patchDatadogLambdaHandler)
      return datadogLambdaModule
    }
    function patchDatadogLambdaHandler(datadogHandler) {
      return (userHandler) => {
        return datadogHandler(datadog(userHandler))
      }
    }
    var patchLambdaModule = (handlerPath) => (lambdaModule) => {
      shimmer.wrap(lambdaModule, handlerPath, patchLambdaHandler)
      return lambdaModule
    }
    function patchLambdaHandler(lambdaHandler) {
      return datadog(lambdaHandler)
    }
    var lambdaTaskRoot = getEnvironmentVariable('LAMBDA_TASK_ROOT')
    var originalLambdaHandler = getEnvironmentVariable('DD_LAMBDA_HANDLER')
    if (originalLambdaHandler === void 0) {
      addHook({ name: 'datadog-lambda-js' }, patchDatadogLambdaModule)
    } else {
      const [moduleRoot, moduleAndHandler] = _extractModuleRootAndHandler(originalLambdaHandler)
      const [_module, handlerPath] = _extractModuleNameAndHandlerPath(moduleAndHandler)
      const lambdaStylePath = path.resolve(lambdaTaskRoot, moduleRoot, _module)
      const lambdaFilePaths = _getLambdaFilePaths(lambdaStylePath)
      for (const lambdaFilePath of lambdaFilePaths) {
        addHook({ name: lambdaFilePath }, patchLambdaModule(handlerPath))
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/ritm.js
var require_ritm2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/ritm.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var Hook = require_hook()
    var instrumentations = require_instrumentations()
    var { filename, pathSepExpr } = require_register2()
    function _extractModuleRootAndHandler(fullHandler) {
      const handlerString = path.basename(fullHandler)
      const moduleRoot = fullHandler.slice(0, Math.max(0, fullHandler.indexOf(handlerString)))
      return [moduleRoot, handlerString]
    }
    function _extractModuleNameAndHandlerPath(handler) {
      const FUNCTION_EXPR = /^([^.]*)\.(.*)$/
      const match = handler.match(FUNCTION_EXPR)
      if (!match || match.length !== 3) {
        throw new Error(`Malformed handler name: ${handler}`)
      }
      return [match[1], match[2]]
    }
    function _getLambdaFilePaths(lambdaStylePath) {
      return [`${lambdaStylePath}.js`, `${lambdaStylePath}.mjs`, `${lambdaStylePath}.cjs`]
    }
    var registerLambdaHook = () => {
      const lambdaTaskRoot = getEnvironmentVariable('LAMBDA_TASK_ROOT')
      const originalLambdaHandler = getEnvironmentVariable('DD_LAMBDA_HANDLER')
      if (originalLambdaHandler !== void 0 && lambdaTaskRoot !== void 0) {
        const [moduleRoot, moduleAndHandler] = _extractModuleRootAndHandler(originalLambdaHandler)
        const [_module] = _extractModuleNameAndHandlerPath(moduleAndHandler)
        const lambdaStylePath = path.resolve(lambdaTaskRoot, moduleRoot, _module)
        const lambdaFilePaths = _getLambdaFilePaths(lambdaStylePath)
        Hook(lambdaFilePaths, (moduleExports, name) => {
          require_patch()
          for (const { hook } of instrumentations[name]) {
            try {
              moduleExports = hook(moduleExports)
            } catch (e) {
              log.error('Error executing lambda hook', e)
            }
          }
          return moduleExports
        })
      } else {
        const moduleToPatch = 'datadog-lambda-js'
        Hook([moduleToPatch], (moduleExports, moduleName2, _) => {
          moduleName2 = moduleName2.replace(pathSepExpr, '/')
          require_patch()
          for (const { name, file, hook } of instrumentations[moduleToPatch]) {
            const fullFilename = filename(name, file)
            if (moduleName2 === fullFilename) {
              try {
                moduleExports = hook(moduleExports)
              } catch (e) {
                log.error('Error executing lambda hook for datadog-lambda-js', e)
              }
            }
          }
          return moduleExports
        })
      }
    }
    module2.exports = {
      _extractModuleRootAndHandler,
      _extractModuleNameAndHandlerPath,
      _getLambdaFilePaths,
      registerLambdaHook,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/lambda/index.js
var require_lambda2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/lambda/index.js'() {
    'use strict'
    var { registerLambdaHook } = require_ritm2()
    var { getEnvironmentVariable } = require_config_helper()
    var _DD_TRACE_DISABLED_INSTRUMENTATIONS = getEnvironmentVariable('DD_TRACE_DISABLED_INSTRUMENTATIONS') || ''
    var _disabledInstrumentations = new Set(
      _DD_TRACE_DISABLED_INSTRUMENTATIONS ? _DD_TRACE_DISABLED_INSTRUMENTATIONS.split(',') : []
    )
    if (!_disabledInstrumentations.has('lambda')) {
      registerLambdaHook()
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js
var require_plugin_manager = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js'(exports2, module2) {
    'use strict'
    var { channel } = require_dc_polyfill()
    var { isFalse, isTrue, normalizePluginEnvName } = require_util()
    var plugins = require_plugins()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var TEST_OPTIMIZATION_PLUGINS = /* @__PURE__ */ new Set(['jest', 'vitest', 'cucumber', 'mocha', 'playwright'])
    var loadChannel = channel('dd-trace:instrumentation:load')
    require_datadog_instrumentations()
    if (getEnvironmentVariable('AWS_LAMBDA_FUNCTION_NAME') !== void 0) {
      require_lambda2()
    }
    var DD_TRACE_DISABLED_PLUGINS = getEnvironmentVariable('DD_TRACE_DISABLED_PLUGINS')
    var disabledPlugins = new Set(
      DD_TRACE_DISABLED_PLUGINS && DD_TRACE_DISABLED_PLUGINS.split(',').map((plugin) => plugin.trim())
    )
    var pluginClasses = {}
    loadChannel.subscribe(({ name }) => {
      maybeEnable(plugins[name])
    })
    function maybeEnable(Plugin) {
      if (!Plugin || typeof Plugin !== 'function') return
      if (!pluginClasses[Plugin.id]) {
        const enabled = getEnvEnabled(Plugin)
        if (isFalse(enabled) || disabledPlugins.has(Plugin.id)) {
          log.debug('Plugin "%s" was disabled via configuration option.', Plugin.id)
          pluginClasses[Plugin.id] = null
        } else {
          pluginClasses[Plugin.id] = Plugin
        }
      }
    }
    function getEnvEnabled(Plugin) {
      const envName = `DD_TRACE_${Plugin.id.toUpperCase()}_ENABLED`
      return getEnvironmentVariable(normalizePluginEnvName(envName))
    }
    module2.exports = class PluginManager {
      constructor(tracer2) {
        this._tracer = tracer2
        this._tracerConfig = null
        this._pluginsByName = {}
        this._configsByName = {}
        this._loadedSubscriber = ({ name }) => {
          const Plugin = plugins[name]
          if (!Plugin || typeof Plugin !== 'function') return
          this.loadPlugin(Plugin.id)
        }
        loadChannel.subscribe(this._loadedSubscriber)
      }
      loadPlugin(name) {
        const Plugin = pluginClasses[name]
        if (!Plugin) return
        if (!this._tracerConfig) return
        if (TEST_OPTIMIZATION_PLUGINS.has(name) && !this._tracerConfig.isCiVisibility) {
          log.debug('Plugin "%s" is not initialized because Test Optimization mode is not enabled.', name)
          return
        }
        if (!this._pluginsByName[name]) {
          this._pluginsByName[name] = new Plugin(this._tracer, this._tracerConfig)
        }
        const pluginConfig = this._configsByName[name] || {
          enabled: this._tracerConfig.plugins !== false && (!Plugin.experimental || isTrue(getEnvEnabled(Plugin))),
        }
        this._pluginsByName[name].configure({
          ...this._getSharedConfig(name),
          ...pluginConfig,
        })
      }
      // TODO: merge config instead of replacing
      configurePlugin(name, pluginConfig) {
        const enabled = this._isEnabled(pluginConfig)
        this._configsByName[name] = {
          ...pluginConfig,
          enabled,
        }
        this.loadPlugin(name)
      }
      // like instrumenter.enable()
      configure(config = {}) {
        this._tracerConfig = config
        this._tracer._nomenclature.configure(config)
        for (const name in pluginClasses) {
          this.loadPlugin(name)
        }
      }
      // This is basically just for testing. like intrumenter.disable()
      destroy() {
        for (const name in this._pluginsByName) {
          this._pluginsByName[name].configure({ enabled: false })
        }
        loadChannel.unsubscribe(this._loadedSubscriber)
      }
      _isEnabled(pluginConfig) {
        if (typeof pluginConfig === 'boolean') return pluginConfig
        if (!pluginConfig) return true
        return pluginConfig.enabled !== false
      }
      // TODO: figure out a better way to handle this
      _getSharedConfig(name) {
        const {
          logInjection,
          serviceMapping,
          queryStringObfuscation,
          site,
          url,
          headerTags,
          codeOriginForSpans,
          dbmPropagationMode,
          dsmEnabled,
          clientIpEnabled,
          clientIpHeader,
          memcachedCommandEnabled,
          ciVisibilityTestSessionName,
          ciVisAgentlessLogSubmissionEnabled,
          isTestDynamicInstrumentationEnabled,
          isServiceUserProvided,
          middlewareTracingEnabled,
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces,
          experimental,
          resourceRenamingEnabled,
        } = this._tracerConfig
        const sharedConfig = {
          codeOriginForSpans,
          dbmPropagationMode,
          dsmEnabled,
          memcachedCommandEnabled,
          site,
          url,
          headers: headerTags || [],
          clientIpHeader,
          ciVisibilityTestSessionName,
          ciVisAgentlessLogSubmissionEnabled,
          isTestDynamicInstrumentationEnabled,
          isServiceUserProvided,
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces,
          experimental,
          resourceRenamingEnabled,
        }
        if (logInjection !== void 0) {
          sharedConfig.logInjection = logInjection
        }
        if (queryStringObfuscation !== void 0) {
          sharedConfig.queryStringObfuscation = queryStringObfuscation
        }
        if (serviceMapping && serviceMapping[name]) {
          sharedConfig.service = serviceMapping[name]
        }
        if (clientIpEnabled !== void 0) {
          sharedConfig.clientIpEnabled = clientIpEnabled
        }
        if (middlewareTracingEnabled !== void 0) {
          sharedConfig.middleware = middlewareTracingEnabled
        }
        return sharedConfig
      }
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/flare/file.js
var require_file = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/flare/file.js'(exports2, module2) {
    'use strict'
    var { Writable } = require('stream')
    var INITIAL_SIZE = 64 * 1024
    var FlareFile = class extends Writable {
      constructor() {
        super()
        this.length = 0
        this._buffer = Buffer.alloc(INITIAL_SIZE)
      }
      get data() {
        return this._buffer.subarray(0, this.length)
      }
      _write(chunk, encoding, callback) {
        const length = Buffer.byteLength(chunk)
        this._reserve(length)
        this.length += Buffer.isBuffer(chunk)
          ? chunk.copy(this._buffer, this.length)
          : this._buffer.write(chunk, encoding)
        callback()
      }
      _reserve(length) {
        while (this.length + length > this._buffer.length) {
          const buffer = Buffer.alloc(this.length * 2)
          this._buffer.copy(buffer)
          this._buffer = buffer
        }
      }
    }
    module2.exports = FlareFile
  },
})

// node_modules/dd-trace/packages/dd-trace/src/flare/index.js
var require_flare = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/flare/index.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var startupLog = require_startup_log()
    var FlareFile = require_file()
    var { LogChannel } = require_channels()
    var request = require_request()
    var FormData = require_form_data()
    var MAX_LOG_SIZE = 12 * 1024 * 1024
    var TIMEOUT = 20 * 1e3 * 60
    var logChannel = null
    var tracerLogs = null
    var timer
    var tracerConfig = null
    var logger = {
      debug: (msg) => recordLog(msg),
      info: (msg) => recordLog(msg),
      warn: (msg) => recordLog(msg),
      error: (err) => recordLog(err.stack),
    }
    var flare = {
      enable(tracerConfig_) {
        tracerConfig = tracerConfig_
      },
      disable() {
        tracerConfig = null
        flare.cleanup()
      },
      prepare(logLevel) {
        if (!tracerConfig) return
        logChannel?.unsubscribe(logger)
        logChannel = new LogChannel(logLevel)
        logChannel.subscribe(logger)
        tracerLogs = tracerLogs || new FlareFile()
        timer = timer || setTimeout(flare.cleanup, TIMEOUT)
      },
      send(task) {
        if (!tracerConfig) return
        const tracerInfo = new FlareFile()
        tracerInfo.write(JSON.stringify(startupLog.tracerInfo(), null, 2))
        flare._sendFile(task, tracerInfo, 'tracer_info.txt')
        flare._sendFile(task, tracerLogs, 'tracer_logs.txt')
        flare.cleanup()
      },
      cleanup() {
        logChannel?.unsubscribe(logger)
        timer = clearTimeout(timer)
        logChannel = null
        tracerLogs = null
      },
      _sendFile(task, file, filename) {
        if (!file) return
        const form = new FormData()
        form.append('case_id', task.case_id)
        form.append('hostname', task.hostname)
        form.append('email', task.user_handle)
        form.append('source', 'tracer_nodejs')
        form.append('flare_file', file.data, { filename })
        request(
          form,
          {
            url: tracerConfig.url,
            hostname: tracerConfig.hostname,
            port: tracerConfig.port,
            method: 'POST',
            path: '/tracer_flare/v1',
            headers: form.getHeaders(),
          },
          (err) => {
            if (err) {
              log.error('Error sending flare payload', err)
            }
          }
        )
      },
    }
    function recordLog(msg) {
      if (tracerLogs.length > MAX_LOG_SIZE) return
      if (msg && typeof msg === 'object') {
        msg = JSON.stringify(msg)
      }
      tracerLogs.write(`${msg}
`)
    }
    module2.exports = flare
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/common.js
var require_common2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/common.js'(exports2, module2) {
    'use strict'
    var DD_TELEMETRY_REQUEST_METRICS = /* @__PURE__ */ Symbol('_dd.appsec.telemetry.request.metrics')
    var tags = {
      BLOCK_FAILURE: 'block_failure',
      EVENT_RULES_VERSION: 'event_rules_version',
      INPUT_TRUNCATED: 'input_truncated',
      RATE_LIMITED: 'rate_limited',
      REQUEST_BLOCKED: 'request_blocked',
      RULE_TRIGGERED: 'rule_triggered',
      WAF_ERROR: 'waf_error',
      WAF_TIMEOUT: 'waf_timeout',
      WAF_VERSION: 'waf_version',
    }
    function getVersionsTags(wafVersion, rulesVersion) {
      return {
        [tags.WAF_VERSION]: wafVersion,
        [tags.EVENT_RULES_VERSION]: rulesVersion || 'unknown',
      }
    }
    module2.exports = {
      tags,
      getVersionsTags,
      DD_TELEMETRY_REQUEST_METRICS,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/user.js
var require_user = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/user.js'(exports2, module2) {
    'use strict'
    var telemetryMetrics = require_metrics()
    var appsecMetrics = telemetryMetrics.manager.namespace('appsec')
    function incrementMissingUserLogin(framework, eventType) {
      appsecMetrics
        .count('instrum.user_auth.missing_user_login', {
          framework,
          event_type: eventType,
        })
        .inc()
    }
    function incrementMissingUserId(framework, eventType) {
      appsecMetrics
        .count('instrum.user_auth.missing_user_id', {
          framework,
          event_type: eventType,
        })
        .inc()
    }
    function incrementSdkEvent(eventType, sdkVersion = 'v1') {
      appsecMetrics
        .count('sdk.event', {
          event_type: eventType,
          sdk_version: sdkVersion,
        })
        .inc()
    }
    module2.exports = {
      incrementMissingUserLogin,
      incrementMissingUserId,
      incrementSdkEvent,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/rasp.js
var require_rasp = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/rasp.js'(exports2, module2) {
    'use strict'
    var telemetryMetrics = require_metrics()
    var { DD_TELEMETRY_REQUEST_METRICS, getVersionsTags } = require_common2()
    var appsecMetrics = telemetryMetrics.manager.namespace('appsec')
    var BLOCKING_STATUS = {
      FAILURE: 'failure',
      IRRELEVANT: 'irrelevant',
      SUCCESS: 'success',
    }
    function addRaspRequestMetrics(store, { duration, durationExt, wafTimeout, errorCode }) {
      store[DD_TELEMETRY_REQUEST_METRICS].raspDuration += duration || 0
      store[DD_TELEMETRY_REQUEST_METRICS].raspDurationExt += durationExt || 0
      store[DD_TELEMETRY_REQUEST_METRICS].raspEvalCount++
      if (wafTimeout) {
        store[DD_TELEMETRY_REQUEST_METRICS].raspTimeouts++
      }
      if (errorCode) {
        store[DD_TELEMETRY_REQUEST_METRICS].raspErrorCode = store[DD_TELEMETRY_REQUEST_METRICS].raspErrorCode
          ? Math.max(errorCode, store[DD_TELEMETRY_REQUEST_METRICS].raspErrorCode)
          : errorCode
      }
    }
    function trackRaspMetrics(store, metrics, raspRule) {
      const versionsTags = getVersionsTags(metrics.wafVersion, metrics.rulesVersion)
      const tags = { rule_type: raspRule.type, ...versionsTags }
      const telemetryMetrics2 = store[DD_TELEMETRY_REQUEST_METRICS]
      if (raspRule.variant) {
        tags.rule_variant = raspRule.variant
      }
      if (metrics.wafVersion) {
        telemetryMetrics2.wafVersion = metrics.wafVersion
      }
      if (metrics.rulesVersion) {
        telemetryMetrics2.rulesVersion = metrics.rulesVersion
      }
      appsecMetrics.count('rasp.rule.eval', tags).inc(1)
      if (metrics.errorCode) {
        const errorTags = { ...tags, waf_error: metrics.errorCode }
        appsecMetrics.count('rasp.error', errorTags).inc(1)
      }
      if (metrics.wafTimeout) {
        appsecMetrics.count('rasp.timeout', tags).inc(1)
      }
    }
    function trackRaspRuleMatch(store, raspRule, blockTriggered, blocked) {
      const telemetryMetrics2 = store[DD_TELEMETRY_REQUEST_METRICS]
      const tags = {
        waf_version: telemetryMetrics2.wafVersion,
        event_rules_version: telemetryMetrics2.rulesVersion,
        rule_type: raspRule.type,
        block: getRuleMatchBlockingStatus(blockTriggered, blocked),
      }
      if (raspRule.variant) {
        tags.rule_variant = raspRule.variant
      }
      appsecMetrics.count('rasp.rule.match', tags).inc(1)
    }
    function trackRaspRuleSkipped(raspRule, reason) {
      const tags = { reason, rule_type: raspRule.type }
      if (raspRule.variant) {
        tags.rule_variant = raspRule.variant
      }
      appsecMetrics.count('rasp.rule.skipped', tags).inc(1)
    }
    function getRuleMatchBlockingStatus(blockTriggered, blocked) {
      if (!blockTriggered) {
        return BLOCKING_STATUS.IRRELEVANT
      }
      return blocked ? BLOCKING_STATUS.SUCCESS : BLOCKING_STATUS.FAILURE
    }
    module2.exports = {
      addRaspRequestMetrics,
      trackRaspMetrics,
      trackRaspRuleMatch,
      trackRaspRuleSkipped,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/waf.js
var require_waf = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/waf.js'(exports2, module2) {
    'use strict'
    var telemetryMetrics = require_metrics()
    var { tags, getVersionsTags, DD_TELEMETRY_REQUEST_METRICS } = require_common2()
    var appsecMetrics = telemetryMetrics.manager.namespace('appsec')
    var DD_TELEMETRY_WAF_RESULT_TAGS = /* @__PURE__ */ Symbol('_dd.appsec.telemetry.waf.result.tags')
    var TRUNCATION_FLAGS = {
      STRING: 1,
      CONTAINER_SIZE: 2,
      CONTAINER_DEPTH: 4,
    }
    function addWafRequestMetrics(store, { duration, durationExt, wafTimeout, errorCode }) {
      store[DD_TELEMETRY_REQUEST_METRICS].duration += duration || 0
      store[DD_TELEMETRY_REQUEST_METRICS].durationExt += durationExt || 0
      if (wafTimeout) {
        store[DD_TELEMETRY_REQUEST_METRICS].wafTimeouts++
      }
      if (errorCode) {
        store[DD_TELEMETRY_REQUEST_METRICS].wafErrorCode = store[DD_TELEMETRY_REQUEST_METRICS].wafErrorCode
          ? Math.max(errorCode, store[DD_TELEMETRY_REQUEST_METRICS].wafErrorCode)
          : errorCode
      }
    }
    function trackWafMetrics(store, metrics) {
      const versionsTags = getVersionsTags(metrics.wafVersion, metrics.rulesVersion)
      const metricTags = getOrCreateMetricTags(store, versionsTags)
      if (metrics.blockFailed) {
        metricTags[tags.BLOCK_FAILURE] = true
      }
      if (metrics.blockTriggered) {
        metricTags[tags.REQUEST_BLOCKED] = true
      }
      if (metrics.rateLimited) {
        metricTags[tags.RATE_LIMITED] = true
      }
      if (metrics.ruleTriggered) {
        metricTags[tags.RULE_TRIGGERED] = true
      }
      if (metrics.errorCode) {
        metricTags[tags.WAF_ERROR] = true
        appsecMetrics.count('waf.error', { ...versionsTags, waf_error: metrics.errorCode }).inc()
      }
      if (metrics.wafTimeout) {
        metricTags[tags.WAF_TIMEOUT] = true
      }
      const truncationReason = getTruncationReason(metrics)
      if (truncationReason > 0) {
        metricTags[tags.INPUT_TRUNCATED] = true
        incrementTruncatedMetrics(metrics, truncationReason)
      }
      return metricTags
    }
    function getOrCreateMetricTags(store, versionsTags) {
      let metricTags = store[DD_TELEMETRY_WAF_RESULT_TAGS]
      if (!metricTags) {
        metricTags = {
          [tags.BLOCK_FAILURE]: false,
          [tags.INPUT_TRUNCATED]: false,
          [tags.RATE_LIMITED]: false,
          [tags.REQUEST_BLOCKED]: false,
          [tags.RULE_TRIGGERED]: false,
          [tags.WAF_ERROR]: false,
          [tags.WAF_TIMEOUT]: false,
          ...versionsTags,
        }
        store[DD_TELEMETRY_WAF_RESULT_TAGS] = metricTags
      }
      return metricTags
    }
    function incrementWafInit(wafVersion, rulesVersion, success) {
      const versionsTags = getVersionsTags(wafVersion, rulesVersion)
      appsecMetrics.count('waf.init', { ...versionsTags, success }).inc()
      if (!success) {
        appsecMetrics.count('waf.config_errors', { ...versionsTags, action: 'init' }).inc()
      }
    }
    function incrementWafUpdates(wafVersion, rulesVersion, success) {
      const versionsTags = getVersionsTags(wafVersion, rulesVersion)
      appsecMetrics.count('waf.updates', { ...versionsTags, success }).inc()
    }
    function incrementWafConfigErrors(wafVersion, rulesVersion) {
      const versionsTags = getVersionsTags(wafVersion, rulesVersion)
      appsecMetrics.count('waf.config_errors', { ...versionsTags, action: 'update' }).inc()
    }
    function incrementWafRequests(store) {
      const metricTags = store[DD_TELEMETRY_WAF_RESULT_TAGS]
      if (metricTags) {
        appsecMetrics.count('waf.requests', metricTags).inc()
      }
    }
    function incrementTruncatedMetrics(metrics, truncationReason) {
      const truncationTags = { truncation_reason: truncationReason }
      appsecMetrics.count('waf.input_truncated', truncationTags).inc(1)
    }
    function getTruncationReason({ maxTruncatedString, maxTruncatedContainerSize, maxTruncatedContainerDepth }) {
      let reason = 0
      if (maxTruncatedString) reason |= TRUNCATION_FLAGS.STRING
      if (maxTruncatedContainerSize) reason |= TRUNCATION_FLAGS.CONTAINER_SIZE
      if (maxTruncatedContainerDepth) reason |= TRUNCATION_FLAGS.CONTAINER_DEPTH
      return reason
    }
    module2.exports = {
      addWafRequestMetrics,
      trackWafMetrics,
      incrementWafInit,
      incrementWafUpdates,
      incrementWafConfigErrors,
      incrementWafRequests,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/index.js
var require_telemetry6 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/telemetry/index.js'(exports2, module2) {
    'use strict'
    var { DD_TELEMETRY_REQUEST_METRICS } = require_common2()
    var { incrementMissingUserId, incrementMissingUserLogin, incrementSdkEvent } = require_user()
    var { addRaspRequestMetrics, trackRaspMetrics, trackRaspRuleMatch, trackRaspRuleSkipped } = require_rasp()
    var {
      addWafRequestMetrics,
      trackWafMetrics,
      incrementWafInit,
      incrementWafUpdates,
      incrementWafConfigErrors,
      incrementWafRequests,
    } = require_waf()
    var metricsStoreMap = /* @__PURE__ */ new WeakMap()
    var enabled = false
    function enable(config) {
      enabled = config.telemetry?.enabled && config.telemetry?.metrics
    }
    function disable() {
      enabled = false
    }
    function newStore() {
      return {
        [DD_TELEMETRY_REQUEST_METRICS]: {
          duration: 0,
          durationExt: 0,
          raspDuration: 0,
          raspDurationExt: 0,
          raspEvalCount: 0,
          wafTimeouts: 0,
          raspTimeouts: 0,
          wafErrorCode: null,
          raspErrorCode: null,
          wafVersion: null,
          rulesVersion: null,
        },
      }
    }
    function getStore(req) {
      let store = metricsStoreMap.get(req)
      if (!store) {
        store = newStore()
        metricsStoreMap.set(req, store)
      }
      return store
    }
    function updateRaspRequestsMetricTags(metrics, req, raspRule) {
      if (!req) return
      const store = getStore(req)
      addRaspRequestMetrics(store, metrics)
      if (!enabled) return
      trackRaspMetrics(store, metrics, raspRule)
    }
    function updateRaspRuleMatchMetricTags(req, raspRule, blockTriggered, blocked) {
      if (!enabled || !req) return
      const store = getStore(req)
      trackRaspRuleMatch(store, raspRule, blockTriggered, blocked)
    }
    function updateRaspRuleSkippedMetricTags(raspRule, reason) {
      if (!enabled) return
      trackRaspRuleSkipped(raspRule, reason)
    }
    function updateWafRequestsMetricTags(metrics, req) {
      if (!req) return
      const store = getStore(req)
      addWafRequestMetrics(store, metrics)
      if (!enabled) return
      return trackWafMetrics(store, metrics)
    }
    function updateRateLimitedMetric(req) {
      if (!enabled) return
      const store = getStore(req)
      trackWafMetrics(store, { rateLimited: true })
    }
    function updateBlockFailureMetric(req) {
      if (!enabled) return
      const store = getStore(req)
      trackWafMetrics(store, { blockFailed: true })
    }
    function incrementWafInitMetric(wafVersion, rulesVersion, success) {
      if (!enabled) return
      incrementWafInit(wafVersion, rulesVersion, success)
    }
    function incrementWafUpdatesMetric(wafVersion, rulesVersion, success) {
      if (!enabled) return
      incrementWafUpdates(wafVersion, rulesVersion, success)
    }
    function incrementWafConfigErrorsMetric(wafVersion, rulesVersion) {
      if (!enabled) return
      incrementWafConfigErrors(wafVersion, rulesVersion)
    }
    function incrementWafRequestsMetric(req) {
      if (!req || !enabled) return
      const store = getStore(req)
      incrementWafRequests(store)
      metricsStoreMap.delete(req)
    }
    function incrementMissingUserLoginMetric(framework, eventType) {
      if (!enabled) return
      incrementMissingUserLogin(framework, eventType)
    }
    function incrementMissingUserIdMetric(framework, eventType) {
      if (!enabled) return
      incrementMissingUserId(framework, eventType)
    }
    function incrementSdkEventMetric(eventType, sdkVersion) {
      if (!enabled) return
      incrementSdkEvent(eventType, sdkVersion)
    }
    function getRequestMetrics(req) {
      if (req) {
        const store = getStore(req)
        return store?.[DD_TELEMETRY_REQUEST_METRICS]
      }
    }
    module2.exports = {
      enable,
      disable,
      updateWafRequestsMetricTags,
      updateRateLimitedMetric,
      updateBlockFailureMetric,
      updateRaspRequestsMetricTags,
      updateRaspRuleMatchMetricTags,
      updateRaspRuleSkippedMetricTags,
      incrementWafInitMetric,
      incrementWafUpdatesMetric,
      incrementWafConfigErrorsMetric,
      incrementWafRequestsMetric,
      incrementMissingUserLoginMetric,
      incrementMissingUserIdMetric,
      incrementSdkEventMetric,
      getRequestMetrics,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/standalone/product.js
var require_product = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/standalone/product.js'(exports2, module2) {
    'use strict'
    var { SAMPLING_MECHANISM_APPSEC } = require_constants2()
    var RateLimiter = require_rate_limiter()
    function getProductRateLimiter(config) {
      if (config?.appsec?.enabled || config?.iast?.enabled) {
        return new RateLimiter(1, 'minute')
      }
      return new RateLimiter(0)
    }
    var PRODUCTS = {
      APM: { id: 1 << 0 },
      ASM: { id: 1 << 1, mechanism: SAMPLING_MECHANISM_APPSEC },
      DSM: { id: 1 << 2 },
      DJM: { id: 1 << 3 },
      DBM: { id: 1 << 4 },
    }
    module2.exports = {
      ...PRODUCTS,
      getProductRateLimiter,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/waf/diagnostics.js
var require_diagnostics = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/waf/diagnostics.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      DIAGNOSTIC_KEYS: [
        'rules',
        'custom_rules',
        'exclusions',
        'actions',
        'processors',
        'scanners',
        'rules_override',
        'rules_data',
        'exclusion_data',
      ],
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js
var require_reporter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var zlib = require('zlib')
    var { storage } = require_datadog_core()
    var web = require_web3()
    var { ipHeaderList } = require_ip_extractor()
    var {
      incrementWafInitMetric,
      incrementWafUpdatesMetric,
      incrementWafConfigErrorsMetric,
      incrementWafRequestsMetric,
      updateWafRequestsMetricTags,
      updateRaspRequestsMetricTags,
      updateRaspRuleSkippedMetricTags,
      getRequestMetrics,
    } = require_telemetry6()
    var { keepTrace } = require_priority_sampler()
    var { ASM } = require_product()
    var { DIAGNOSTIC_KEYS } = require_diagnostics()
    var REQUEST_HEADER_TAG_PREFIX = 'http.request.headers.'
    var RESPONSE_HEADER_TAG_PREFIX = 'http.response.headers.'
    var COLLECTED_REQUEST_BODY_MAX_STRING_LENGTH = 4096
    var COLLECTED_REQUEST_BODY_MAX_DEPTH = 20
    var COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE = 256
    var telemetryLogCh = dc.channel('datadog:telemetry:log')
    var config = {
      headersExtendedCollectionEnabled: false,
      maxHeadersCollected: 0,
      headersRedaction: false,
      raspBodyCollection: false,
    }
    var metricsQueue = /* @__PURE__ */ new Map()
    var extendedDataCollectionRequest = /* @__PURE__ */ new WeakMap()
    var contentHeaderList = ['content-length', 'content-encoding', 'content-language']
    var responseHeaderList = [...contentHeaderList, 'content-type']
    var identificationHeaders = [
      'x-amzn-trace-id',
      'cloudfront-viewer-ja3-fingerprint',
      'cf-ray',
      'x-cloud-trace-context',
      'x-appgw-trace-id',
      'x-sigsci-requestid',
      'x-sigsci-tags',
      'akamai-user-risk',
    ]
    var eventHeadersList = [
      ...ipHeaderList,
      'x-forwarded',
      'forwarded',
      'via',
      ...contentHeaderList,
      'host',
      'accept-encoding',
      'accept-language',
    ]
    var requestHeadersList = ['content-type', 'user-agent', 'accept', ...identificationHeaders]
    var redactedHeadersList = [
      'authorization',
      'proxy-authorization',
      'www-authenticate',
      'proxy-authenticate',
      'authentication-info',
      'proxy-authentication-info',
      'cookie',
      'set-cookie',
    ]
    var REQUEST_HEADERS_MAP = mapHeaderAndTags(requestHeadersList, REQUEST_HEADER_TAG_PREFIX)
    var EVENT_HEADERS_MAP = mapHeaderAndTags(eventHeadersList, REQUEST_HEADER_TAG_PREFIX)
    var RESPONSE_HEADERS_MAP = mapHeaderAndTags(responseHeaderList, RESPONSE_HEADER_TAG_PREFIX)
    var NON_EXTENDED_REQUEST_HEADERS = /* @__PURE__ */ new Set([...requestHeadersList, ...eventHeadersList])
    var NON_EXTENDED_RESPONSE_HEADERS = new Set(responseHeaderList)
    var REDACTED_HEADERS = new Set(redactedHeadersList)
    function init(_config) {
      config.headersExtendedCollectionEnabled = _config.extendedHeadersCollection.enabled
      config.maxHeadersCollected = _config.extendedHeadersCollection.maxHeaders
      config.headersRedaction = _config.extendedHeadersCollection.redaction
      config.raspBodyCollection = _config.rasp.bodyCollection
    }
    function formatHeaderName(name) {
      return name
        .trim()
        .slice(0, 200)
        .replaceAll(/[^a-zA-Z0-9_\-:/]/g, '_')
        .toLowerCase()
    }
    function getHeaderTag(tagPrefix, headerName) {
      return `${tagPrefix}${formatHeaderName(headerName)}`
    }
    function mapHeaderAndTags(headerList, tagPrefix) {
      return new Map(headerList.map((headerName) => [headerName, getHeaderTag(tagPrefix, headerName)]))
    }
    function filterHeaders(headers, map) {
      const result = {}
      if (!headers) return result
      for (const [headerName, tagName] of map) {
        const headerValue = headers[headerName]
        if (headerValue) {
          result[tagName] = String(headerValue)
        }
      }
      return result
    }
    function filterExtendedHeaders(headers, excludedHeaderNames, tagPrefix, limit = 0) {
      const result = {}
      if (!headers) return result
      let counter = 0
      for (const [headerName, headerValue] of Object.entries(headers)) {
        if (counter >= limit) break
        if (!excludedHeaderNames.has(headerName)) {
          result[getHeaderTag(tagPrefix, headerName)] = REDACTED_HEADERS.has(headerName)
            ? '<redacted>'
            : String(headerValue)
          counter++
        }
      }
      return result
    }
    function getCollectedHeaders(
      req,
      res,
      shouldCollectEventHeaders2,
      storedResponseHeaders = {},
      extendedDataCollection
    ) {
      const mandatoryCollectedHeaders = filterHeaders(req.headers, REQUEST_HEADERS_MAP)
      if (!shouldCollectEventHeaders2) return mandatoryCollectedHeaders
      const responseHeaders =
        Object.keys(storedResponseHeaders).length === 0
          ? res.getHeaders()
          : { ...storedResponseHeaders, ...res.getHeaders() }
      const requestEventCollectedHeaders = filterHeaders(req.headers, EVENT_HEADERS_MAP)
      const responseEventCollectedHeaders = filterHeaders(responseHeaders, RESPONSE_HEADERS_MAP)
      if ((!config.headersExtendedCollectionEnabled || config.headersRedaction) && !extendedDataCollection) {
        return Object.assign(mandatoryCollectedHeaders, requestEventCollectedHeaders, responseEventCollectedHeaders)
      }
      const maxHeadersCollected = extendedDataCollection?.max_collected_headers ?? config.maxHeadersCollected
      const collectedHeadersCount =
        Object.keys(mandatoryCollectedHeaders).length + Object.keys(requestEventCollectedHeaders).length
      const requestExtendedHeadersAvailableCount = maxHeadersCollected - collectedHeadersCount
      const requestEventExtendedCollectedHeaders = filterExtendedHeaders(
        req.headers,
        NON_EXTENDED_REQUEST_HEADERS,
        REQUEST_HEADER_TAG_PREFIX,
        requestExtendedHeadersAvailableCount
      )
      const responseExtendedHeadersAvailableCount =
        maxHeadersCollected - Object.keys(responseEventCollectedHeaders).length
      const responseEventExtendedCollectedHeaders = filterExtendedHeaders(
        responseHeaders,
        NON_EXTENDED_RESPONSE_HEADERS,
        RESPONSE_HEADER_TAG_PREFIX,
        responseExtendedHeadersAvailableCount
      )
      const headersTags = Object.assign(
        mandatoryCollectedHeaders,
        requestEventCollectedHeaders,
        requestEventExtendedCollectedHeaders,
        responseEventCollectedHeaders,
        responseEventExtendedCollectedHeaders
      )
      const requestHeadersCount = Object.keys(req.headers).length
      if (requestHeadersCount > maxHeadersCollected) {
        headersTags['_dd.appsec.request.header_collection.discarded'] = requestHeadersCount - maxHeadersCollected
      }
      const responseHeadersCount = Object.keys(responseHeaders).length
      if (responseHeadersCount > maxHeadersCollected) {
        headersTags['_dd.appsec.response.header_collection.discarded'] = responseHeadersCount - maxHeadersCollected
      }
      return headersTags
    }
    function reportWafInit(wafVersion, rulesVersion, diagnosticsRules = {}, success = false) {
      if (success) {
        metricsQueue.set('_dd.appsec.waf.version', wafVersion)
      }
      incrementWafInitMetric(wafVersion, rulesVersion, success)
    }
    function logWafDiagnosticMessage(product, rcConfigId, configKey, message, level) {
      const tags = `log_type:rc::${product.toLowerCase()}::diagnostic,appsec_config_key:${configKey},rc_config_id:${rcConfigId}`
      telemetryLogCh.publish({
        message,
        level,
        tags,
      })
    }
    function reportWafConfigUpdate(product, rcConfigId, diagnostics, wafVersion) {
      if (diagnostics.error) {
        logWafDiagnosticMessage(product, rcConfigId, '', diagnostics.error, 'ERROR')
        incrementWafConfigErrorsMetric(wafVersion, diagnostics.ruleset_version)
      }
      for (const configKey of DIAGNOSTIC_KEYS) {
        const configDiagnostics = diagnostics[configKey]
        if (!configDiagnostics) continue
        if (configDiagnostics.error) {
          logWafDiagnosticMessage(product, rcConfigId, configKey, configDiagnostics.error, 'ERROR')
          incrementWafConfigErrorsMetric(wafVersion, diagnostics.ruleset_version)
          continue
        }
        if (configDiagnostics.errors) {
          for (const [errorMessage, errorIds] of Object.entries(configDiagnostics.errors)) {
            logWafDiagnosticMessage(
              product,
              rcConfigId,
              configKey,
              `"${errorMessage}": ${JSON.stringify(errorIds)}`,
              'ERROR'
            )
            incrementWafConfigErrorsMetric(wafVersion, diagnostics.ruleset_version)
          }
        }
        if (configDiagnostics.warnings) {
          for (const [warningMessage, warningIds] of Object.entries(configDiagnostics.warnings)) {
            logWafDiagnosticMessage(
              product,
              rcConfigId,
              configKey,
              `"${warningMessage}": ${JSON.stringify(warningIds)}`,
              'WARN'
            )
          }
        }
      }
    }
    function reportMetrics(metrics, raspRule) {
      const store = storage('legacy').getStore()
      const rootSpan = store?.req && web.root(store.req)
      if (!rootSpan) return
      if (metrics.rulesVersion) {
        rootSpan.setTag('_dd.appsec.event_rules.version', metrics.rulesVersion)
      }
      if (raspRule) {
        updateRaspRequestsMetricTags(metrics, store.req, raspRule)
      } else {
        updateWafRequestsMetricTags(metrics, store.req)
      }
      reportTruncationMetrics(rootSpan, metrics)
    }
    function reportTruncationMetrics(rootSpan, metrics) {
      if (metrics.maxTruncatedString) {
        rootSpan.setTag('_dd.appsec.truncated.string_length', metrics.maxTruncatedString)
      }
      if (metrics.maxTruncatedContainerSize) {
        rootSpan.setTag('_dd.appsec.truncated.container_size', metrics.maxTruncatedContainerSize)
      }
      if (metrics.maxTruncatedContainerDepth) {
        rootSpan.setTag('_dd.appsec.truncated.container_depth', metrics.maxTruncatedContainerDepth)
      }
    }
    function reportAttack({ events: attackData, actions }) {
      const store = storage('legacy').getStore()
      const req = store?.req
      const rootSpan = web.root(req)
      if (!rootSpan) return
      const currentTags = rootSpan.context()._tags
      const newTags = {
        'appsec.event': 'true',
      }
      if (!currentTags['_dd.origin']) {
        newTags['_dd.origin'] = 'appsec'
      }
      const currentJson = currentTags['_dd.appsec.json']
      const attackDataStr = JSON.stringify(attackData)
      newTags['_dd.appsec.json'] = currentJson
        ? currentJson.slice(0, -2) + ',' + attackDataStr.slice(1) + '}'
        : '{"triggers":' + attackDataStr + '}'
      if (req.socket) {
        newTags['network.client.ip'] = req.socket.remoteAddress
      }
      rootSpan.addTags(newTags)
      if (config.raspBodyCollection && isRaspAttack(attackData)) {
        reportRequestBody(rootSpan, req.body, true)
      }
      const extendedDataCollection = actions?.extended_data_collection
      if (extendedDataCollection) {
        extendedDataCollectionRequest.set(req, extendedDataCollection)
      }
    }
    function truncateRequestBody(target, depth = 0) {
      switch (typeof target) {
        case 'string':
          if (target.length > COLLECTED_REQUEST_BODY_MAX_STRING_LENGTH) {
            return { value: target.slice(0, COLLECTED_REQUEST_BODY_MAX_STRING_LENGTH), truncated: true }
          }
          return { value: target, truncated: false }
        case 'object': {
          if (target === null) {
            return { value: target, truncated: false }
          }
          if (depth >= COLLECTED_REQUEST_BODY_MAX_DEPTH) {
            return { truncated: true }
          }
          if (typeof target.toJSON === 'function') {
            try {
              return truncateRequestBody(target.toJSON(), depth + 1)
            } catch {
              return { truncated: false }
            }
          }
          if (Array.isArray(target)) {
            const maxArrayLength = Math.min(target.length, COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE)
            let wasTruncated2 = target.length > COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE
            const truncatedArray = new Array(maxArrayLength)
            for (let i = 0; i < maxArrayLength; i++) {
              const { value, truncated } = truncateRequestBody(target[i], depth + 1)
              if (truncated) wasTruncated2 = true
              truncatedArray[i] = value
            }
            return { value: truncatedArray, truncated: wasTruncated2 }
          }
          const keys = Object.keys(target)
          const maxKeysLength = Math.min(keys.length, COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE)
          let wasTruncated = keys.length > COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE
          const truncatedObject = {}
          for (let i = 0; i < maxKeysLength; i++) {
            const key = keys[i]
            const { value, truncated } = truncateRequestBody(target[key], depth + 1)
            if (truncated) wasTruncated = true
            truncatedObject[key] = value
          }
          return { value: truncatedObject, truncated: wasTruncated }
        }
        default:
          return { value: target, truncated: false }
      }
    }
    function reportRequestBody(rootSpan, requestBody, comesFromRaspAction = false) {
      if (!requestBody || Object.keys(requestBody).length === 0) return
      if (!rootSpan.meta_struct) {
        rootSpan.meta_struct = {}
      }
      if (rootSpan.meta_struct['http.request.body']) {
        const currentTags = rootSpan.context()._tags
        const sizeExceedTagValue = currentTags['_dd.appsec.rasp.request_body_size.exceeded']
        if (sizeExceedTagValue) {
          rootSpan.setTag('_dd.appsec.request_body_size.exceeded', sizeExceedTagValue)
        }
      } else {
        const { truncated, value } = truncateRequestBody(requestBody)
        rootSpan.meta_struct['http.request.body'] = value
        if (truncated) {
          const sizeExceedTagKey = comesFromRaspAction
            ? '_dd.appsec.rasp.request_body_size.exceeded'
            : '_dd.appsec.request_body_size.exceeded'
          rootSpan.setTag(sizeExceedTagKey, 'true')
        }
      }
    }
    function isRaspAttack(events) {
      return events.some((e) => e.rule?.tags?.module === 'rasp')
    }
    function isSchemaAttribute(attribute) {
      return attribute.startsWith('_dd.appsec.s.')
    }
    function reportAttributes(attributes) {
      if (!attributes) return
      const req = storage('legacy').getStore()?.req
      const rootSpan = web.root(req)
      if (!rootSpan) return
      const tags = {}
      for (let [tag, value] of Object.entries(attributes)) {
        if (isSchemaAttribute(tag)) {
          const gzippedValue = zlib.gzipSync(JSON.stringify(value))
          value = gzippedValue.toString('base64')
        }
        tags[tag] = value
      }
      rootSpan.addTags(tags)
    }
    function finishRequest(req, res, storedResponseHeaders, requestBody) {
      const rootSpan = web.root(req)
      if (!rootSpan) return
      if (metricsQueue.size) {
        rootSpan.addTags(Object.fromEntries(metricsQueue))
        keepTrace(rootSpan, ASM)
        metricsQueue.clear()
      }
      const metrics = getRequestMetrics(req)
      if (metrics?.duration) {
        rootSpan.setTag('_dd.appsec.waf.duration', metrics.duration)
      }
      if (metrics?.durationExt) {
        rootSpan.setTag('_dd.appsec.waf.duration_ext', metrics.durationExt)
      }
      if (metrics?.wafErrorCode) {
        rootSpan.setTag('_dd.appsec.waf.error', metrics.wafErrorCode)
      }
      if (metrics?.wafTimeouts) {
        rootSpan.setTag('_dd.appsec.waf.timeouts', metrics.wafTimeouts)
      }
      if (metrics?.raspDuration) {
        rootSpan.setTag('_dd.appsec.rasp.duration', metrics.raspDuration)
      }
      if (metrics?.raspDurationExt) {
        rootSpan.setTag('_dd.appsec.rasp.duration_ext', metrics.raspDurationExt)
      }
      if (metrics?.raspErrorCode) {
        rootSpan.setTag('_dd.appsec.rasp.error', metrics.raspErrorCode)
      }
      if (metrics?.raspTimeouts) {
        rootSpan.setTag('_dd.appsec.rasp.timeout', metrics.raspTimeouts)
      }
      if (metrics?.raspEvalCount) {
        rootSpan.setTag('_dd.appsec.rasp.rule.eval', metrics.raspEvalCount)
      }
      incrementWafRequestsMetric(req)
      const tags = rootSpan.context()._tags
      const extendedDataCollection = extendedDataCollectionRequest.get(req)
      const newTags = getCollectedHeaders(
        req,
        res,
        shouldCollectEventHeaders(tags),
        storedResponseHeaders,
        extendedDataCollection
      )
      if (extendedDataCollection) {
        reportRequestBody(rootSpan, requestBody)
      }
      rootSpan.addTags(newTags)
    }
    function shouldCollectEventHeaders(tags = {}) {
      if (tags['appsec.event'] === 'true') {
        return true
      }
      for (const tagName of Object.keys(tags)) {
        if (tagName.startsWith('appsec.events.')) {
          return true
        }
      }
      return false
    }
    module2.exports = {
      metricsQueue,
      init,
      filterHeaders,
      filterExtendedHeaders,
      formatHeaderName,
      reportWafInit,
      reportWafConfigUpdate,
      reportMetrics,
      reportAttack,
      reportWafUpdate: incrementWafUpdatesMetric,
      reportRaspRuleSkipped: updateRaspRuleSkippedMetricTags,
      reportAttributes,
      finishRequest,
      mapHeaderAndTags,
      truncateRequestBody,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js
var require_addresses = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      HTTP_INCOMING_BODY: 'server.request.body',
      HTTP_INCOMING_QUERY: 'server.request.query',
      HTTP_INCOMING_HEADERS: 'server.request.headers.no_cookies',
      // TODO: 'server.request.trailers',
      HTTP_INCOMING_URL: 'server.request.uri.raw',
      HTTP_INCOMING_METHOD: 'server.request.method',
      HTTP_INCOMING_PARAMS: 'server.request.path_params',
      HTTP_INCOMING_COOKIES: 'server.request.cookies',
      HTTP_INCOMING_RESPONSE_CODE: 'server.response.status',
      HTTP_INCOMING_RESPONSE_HEADERS: 'server.response.headers.no_cookies',
      // TODO: 'server.response.trailers',
      HTTP_INCOMING_GRAPHQL_RESOLVERS: 'graphql.server.all_resolvers',
      HTTP_INCOMING_GRAPHQL_RESOLVER: 'graphql.server.resolver',
      HTTP_INCOMING_RESPONSE_BODY: 'server.response.body',
      HTTP_CLIENT_IP: 'http.client_ip',
      USER_ID: 'usr.id',
      USER_LOGIN: 'usr.login',
      USER_SESSION_ID: 'usr.session_id',
      WAF_CONTEXT_PROCESSOR: 'waf.context.processor',
      HTTP_OUTGOING_URL: 'server.io.net.url',
      FS_OPERATION_PATH: 'server.io.fs.file',
      DB_STATEMENT: 'server.db.statement',
      DB_SYSTEM: 'server.db.system',
      EXEC_COMMAND: 'server.sys.exec.cmd',
      SHELL_COMMAND: 'server.sys.shell.cmd',
      LOGIN_SUCCESS: 'server.business_logic.users.login.success',
      LOGIN_FAILURE: 'server.business_logic.users.login.failure',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/blocked_templates.js
var require_blocked_templates = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/blocked_templates.js'(exports2, module2) {
    'use strict'
    var html = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>You've been blocked</title><style>a,body,div,html,span{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}body{background:-webkit-radial-gradient(26% 19%,circle,#fff,#f4f7f9);background:radial-gradient(circle at 26% 19%,#fff,#f4f7f9);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:center;align-content:center;width:100%;min-height:100vh;line-height:1;flex-direction:column}p{display:block}main{text-align:center;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:center;align-content:center;flex-direction:column}p{font-size:18px;line-height:normal;color:#646464;font-family:sans-serif;font-weight:400}a{color:#4842b7}footer{width:100%;text-align:center}footer p{font-size:16px}</style></head><body><main><p>Sorry, you cannot access this page. Please contact the customer service team.</p></main><footer><p>Security provided by <a href="https://www.datadoghq.com/product/security-platform/application-security-monitoring/" target="_blank">Datadog</a></p></footer></body></html>`
    var json = `{"errors":[{"title":"You've been blocked","detail":"Sorry, you cannot access this page. Please contact the customer service team. Security provided by Datadog."}]}`
    var graphqlJson = `{"errors":[{"message":"You've been blocked","extensions":{"detail":"Sorry, you cannot perform this operation. Please contact the customer service team. Security provided by Datadog."}}]}`
    module2.exports = {
      html,
      json,
      graphqlJson,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/blocking.js
var require_blocking = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/blocking.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var blockedTemplates = require_blocked_templates()
    var { updateBlockFailureMetric } = require_telemetry6()
    var detectedSpecificEndpoints = {}
    var templateHtml = blockedTemplates.html
    var templateJson = blockedTemplates.json
    var templateGraphqlJson = blockedTemplates.graphqlJson
    var defaultBlockingActionParameters
    var responseBlockedSet = /* @__PURE__ */ new WeakSet()
    var blockDelegations = /* @__PURE__ */ new WeakMap()
    var specificBlockingTypes = {
      GRAPHQL: 'graphql',
    }
    function getSpecificKey(method, url) {
      return `${method}+${url}`
    }
    function addSpecificEndpoint(method, url, type) {
      detectedSpecificEndpoints[getSpecificKey(method, url)] = type
    }
    function getBlockWithRedirectData(actionParameters) {
      let statusCode = actionParameters.status_code
      if (!statusCode || statusCode < 300 || statusCode >= 400) {
        statusCode = 303
      }
      const headers = {
        Location: actionParameters.location,
      }
      return { headers, statusCode }
    }
    function getSpecificBlockingData(type) {
      switch (type) {
        case specificBlockingTypes.GRAPHQL:
          return {
            type: 'application/json',
            body: templateGraphqlJson,
          }
      }
    }
    function getBlockWithContentData(req, specificType, actionParameters) {
      let type
      let body
      const specificBlockingType = specificType || detectedSpecificEndpoints[getSpecificKey(req.method, req.url)]
      if (specificBlockingType) {
        const specificBlockingContent = getSpecificBlockingData(specificBlockingType)
        type = specificBlockingContent?.type
        body = specificBlockingContent?.body
      }
      if (!type) {
        const accept = req.headers.accept?.split(',').map((str) => str.split(';', 1)[0].trim())
        if (!actionParameters || actionParameters.type === 'auto') {
          if (accept?.includes('text/html') && !accept.includes('application/json')) {
            type = 'text/html; charset=utf-8'
            body = templateHtml
          } else {
            type = 'application/json'
            body = templateJson
          }
        } else {
          if (actionParameters.type === 'html') {
            type = 'text/html; charset=utf-8'
            body = templateHtml
          } else {
            type = 'application/json'
            body = templateJson
          }
        }
      }
      const statusCode = actionParameters?.status_code || 403
      const headers = {
        'Content-Type': type,
        'Content-Length': Buffer.byteLength(body),
      }
      return { body, statusCode, headers }
    }
    function getBlockingData(req, specificType, actionParameters) {
      return actionParameters?.location
        ? getBlockWithRedirectData(actionParameters)
        : getBlockWithContentData(req, specificType, actionParameters)
    }
    function block(req, res, rootSpan, abortController, actionParameters = defaultBlockingActionParameters) {
      blockDelegations.delete(res)
      try {
        if (res.headersSent) {
          log.warn('[ASM] Cannot send blocking response when headers have already been sent')
          throw new Error('Headers have already been sent')
        }
        const { body, headers, statusCode } = getBlockingData(req, null, actionParameters)
        for (const headerName of res.getHeaderNames()) {
          res.removeHeader(headerName)
        }
        res.writeHead(statusCode, headers)
        res.constructor.prototype.end.call(res, body)
        rootSpan.setTag('appsec.blocked', 'true')
        responseBlockedSet.add(res)
        abortController?.abort()
        return true
      } catch (err) {
        rootSpan?.setTag('_dd.appsec.block.failed', 1)
        log.error('[ASM] Blocking error', err)
        updateBlockFailureMetric(req)
        return false
      }
    }
    function registerBlockDelegation(req, res) {
      const args = arguments
      return new Promise((resolve) => {
        if (blockDelegations.has(res)) return
        blockDelegations.set(res, { args, resolve })
      })
    }
    function callBlockDelegation(res) {
      const delegation = blockDelegations.get(res)
      if (delegation) {
        const result = block.apply(this, delegation.args)
        delegation.resolve(result)
        return result
      }
    }
    function getBlockingAction(actions) {
      return actions?.redirect_request || actions?.block_request
    }
    function setTemplates(config) {
      templateHtml = config.appsec.blockedTemplateHtml || blockedTemplates.html
      templateJson = config.appsec.blockedTemplateJson || blockedTemplates.json
      templateGraphqlJson = config.appsec.blockedTemplateGraphql || blockedTemplates.graphqlJson
    }
    function isBlocked(res) {
      return responseBlockedSet.has(res)
    }
    function setDefaultBlockingActionParameters(actions) {
      const blockAction = actions?.find((action) => action.id === 'block')
      defaultBlockingActionParameters = blockAction?.parameters
    }
    module2.exports = {
      addSpecificEndpoint,
      block,
      registerBlockDelegation,
      callBlockDelegation,
      specificBlockingTypes,
      getBlockingData,
      getBlockingAction,
      setTemplates,
      isBlocked,
      setDefaultBlockingActionParameters,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/waf/waf_context_wrapper.js
var require_waf_context_wrapper = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/waf/waf_context_wrapper.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var Reporter = require_reporter()
    var addresses = require_addresses()
    var { getBlockingAction } = require_blocking()
    var { wafRunFinished } = require_channels2()
    var preventDuplicateAddresses = /* @__PURE__ */ new Set([addresses.HTTP_INCOMING_QUERY])
    var WAFContextWrapper = class {
      constructor(ddwafContext, wafTimeout, wafVersion, rulesVersion, knownAddresses) {
        this.ddwafContext = ddwafContext
        this.wafTimeout = wafTimeout
        this.wafVersion = wafVersion
        this.rulesVersion = rulesVersion
        this.knownAddresses = knownAddresses
        this.addressesToSkip = /* @__PURE__ */ new Set()
        this.cachedUserIdResults = /* @__PURE__ */ new Map()
      }
      run({ persistent, ephemeral }, raspRule) {
        if (this.ddwafContext.disposed) {
          log.warn('[ASM] Calling run on a disposed context')
          if (raspRule) {
            Reporter.reportRaspRuleSkipped(raspRule, 'after-request')
          }
          return
        }
        const userId = persistent?.[addresses.USER_ID] || ephemeral?.[addresses.USER_ID]
        if (userId) {
          const cachedResults = this.cachedUserIdResults.get(userId)
          if (cachedResults) {
            return cachedResults
          }
        }
        const payload = {}
        let payloadHasData = false
        const newAddressesToSkip = new Set(this.addressesToSkip)
        if (persistent !== null && typeof persistent === 'object') {
          const persistentInputs = {}
          let hasPersistentInputs = false
          for (const key of Object.keys(persistent)) {
            if (!this.addressesToSkip.has(key) && this.knownAddresses.has(key)) {
              hasPersistentInputs = true
              persistentInputs[key] = persistent[key]
              if (preventDuplicateAddresses.has(key)) {
                newAddressesToSkip.add(key)
              }
            }
          }
          if (hasPersistentInputs) {
            payload.persistent = persistentInputs
            payloadHasData = true
          }
        }
        if (ephemeral !== null && typeof ephemeral === 'object') {
          const ephemeralInputs = {}
          let hasEphemeral = false
          for (const key of Object.keys(ephemeral)) {
            if (this.knownAddresses.has(key)) {
              hasEphemeral = true
              ephemeralInputs[key] = ephemeral[key]
            }
          }
          if (hasEphemeral) {
            payload.ephemeral = ephemeralInputs
            payloadHasData = true
          }
        }
        if (!payloadHasData) return
        const metrics = {
          rulesVersion: this.rulesVersion,
          wafVersion: this.wafVersion,
          wafTimeout: false,
          duration: 0,
          durationExt: 0,
          blockTriggered: false,
          ruleTriggered: false,
          errorCode: null,
          maxTruncatedString: null,
          maxTruncatedContainerSize: null,
          maxTruncatedContainerDepth: null,
        }
        try {
          const start = process.hrtime.bigint()
          const result = this.ddwafContext.run(payload, this.wafTimeout)
          const end = process.hrtime.bigint()
          metrics.durationExt = Number.parseInt(end - start) / 1e3
          if (typeof result.errorCode === 'number' && result.errorCode < 0) {
            const error = new Error('WAF code error')
            error.errorCode = result.errorCode
            throw error
          }
          if (result.metrics) {
            const { maxTruncatedString, maxTruncatedContainerSize, maxTruncatedContainerDepth } = result.metrics
            if (maxTruncatedString) metrics.maxTruncatedString = maxTruncatedString
            if (maxTruncatedContainerSize) metrics.maxTruncatedContainerSize = maxTruncatedContainerSize
            if (maxTruncatedContainerDepth) metrics.maxTruncatedContainerDepth = maxTruncatedContainerDepth
          }
          this.addressesToSkip = newAddressesToSkip
          const ruleTriggered = !!result.events?.length
          const blockTriggered = !!getBlockingAction(result.actions)
          if (userId && ruleTriggered && blockTriggered) {
            this.setUserIdCache(userId, result)
          }
          metrics.duration = result.duration / 1e3
          metrics.blockTriggered = blockTriggered
          metrics.ruleTriggered = ruleTriggered
          metrics.wafTimeout = result.timeout
          if (ruleTriggered) {
            Reporter.reportAttack(result)
          }
          Reporter.reportAttributes(result.attributes)
          return result
        } catch (err) {
          log.error('[ASM] Error while running the AppSec WAF', err)
          metrics.errorCode = err.errorCode ?? -127
        } finally {
          if (wafRunFinished.hasSubscribers) {
            wafRunFinished.publish({ payload })
          }
          Reporter.reportMetrics(metrics, raspRule)
        }
      }
      setUserIdCache(userId, result) {
        for (let i = 0; i < result.events.length; i++) {
          const event = result.events[i]
          for (let j = 0; j < event?.rule_matches?.length; j++) {
            const match = event.rule_matches[j]
            for (let k = 0; k < match?.parameters?.length; k++) {
              const parameter = match.parameters[k]
              if (parameter?.address === addresses.USER_ID) {
                this.cachedUserIdResults.set(userId, result)
                return
              }
            }
          }
        }
      }
      dispose() {
        this.ddwafContext.dispose()
      }
    }
    module2.exports = WAFContextWrapper
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/waf/waf_manager.js
var require_waf_manager = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/waf/waf_manager.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var Reporter = require_reporter()
    var WAFContextWrapper = require_waf_context_wrapper()
    var contexts = /* @__PURE__ */ new WeakMap()
    var WAFManager = class _WAFManager {
      static defaultWafConfigPath = 'datadog/00/ASM_DD/default/config'
      constructor(rules, config) {
        this.config = config
        this.wafTimeout = config.wafTimeout
        this.ddwaf = this._loadDDWAF(rules)
        this.rulesVersion = this.ddwaf.diagnostics.ruleset_version
        this.defaultRules = rules
        Reporter.reportWafInit(this.ddwafVersion, this.rulesVersion, this.ddwaf.diagnostics.rules, true)
      }
      _loadDDWAF(rules) {
        try {
          const { DDWAF } = require('@datadog/native-appsec')
          this.ddwafVersion = DDWAF.version()
          const { obfuscatorKeyRegex, obfuscatorValueRegex } = this.config
          return new DDWAF(rules, _WAFManager.defaultWafConfigPath, { obfuscatorKeyRegex, obfuscatorValueRegex })
        } catch (err) {
          this.ddwafVersion = this.ddwafVersion || 'unknown'
          Reporter.reportWafInit(this.ddwafVersion, 'unknown')
          log.error('[ASM] AppSec could not load native package. In-app WAF features will not be available.')
          throw err
        }
      }
      getWAFContext(req) {
        let wafContext = contexts.get(req)
        if (!wafContext) {
          wafContext = new WAFContextWrapper(
            this.ddwaf.createContext(),
            this.wafTimeout,
            this.ddwafVersion,
            this.rulesVersion,
            this.ddwaf.knownAddresses
          )
          contexts.set(req, wafContext)
        }
        return wafContext
      }
      setRulesVersion() {
        if (this.ddwaf.diagnostics.ruleset_version) {
          this.rulesVersion = this.ddwaf.diagnostics.ruleset_version
        }
      }
      setAsmDdFallbackConfig() {
        if (!this.ddwaf.configPaths.some((cp) => cp.includes('ASM_DD'))) {
          this.updateConfig(_WAFManager.defaultWafConfigPath, this.defaultRules)
        }
      }
      updateConfig(path, rules) {
        const updateResult = this.ddwaf.createOrUpdateConfig(rules, path)
        this.setRulesVersion()
        return updateResult
      }
      removeConfig(path) {
        this.ddwaf.removeConfig(path)
        this.setRulesVersion()
      }
      destroy() {
        if (this.ddwaf) {
          this.ddwaf.dispose()
        }
      }
    }
    module2.exports = WAFManager
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/waf/index.js
var require_waf2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/waf/index.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var log = require_log2()
    var Reporter = require_reporter()
    var Limiter = require_rate_limiter()
    var { keepTrace } = require_priority_sampler()
    var { ASM } = require_product()
    var web = require_web3()
    var { updateRateLimitedMetric } = require_telemetry6()
    var WafUpdateError = class extends Error {
      constructor(diagnosticErrors) {
        super('WafUpdateError')
        this.name = 'WafUpdateError'
        this.diagnosticErrors = diagnosticErrors
      }
    }
    var limiter = new Limiter(100)
    var waf = {
      wafManager: null,
      init,
      destroy,
      updateConfig,
      removeConfig,
      checkAsmDdFallback,
      run: noop,
      disposeContext: noop,
      WafUpdateError,
    }
    function init(rules, config) {
      destroy()
      limiter = new Limiter(config.rateLimit)
      const WAFManager = require_waf_manager()
      waf.wafManager = new WAFManager(rules, config)
      waf.run = run
      waf.disposeContext = disposeContext
    }
    function destroy() {
      if (waf.wafManager) {
        waf.wafManager.destroy()
        waf.wafManager = null
      }
      waf.run = noop
      waf.disposeContext = noop
    }
    function checkAsmDdFallback() {
      if (!waf.wafManager) throw new Error('Cannot update disabled WAF')
      try {
        waf.wafManager.setAsmDdFallbackConfig()
      } catch {
        log.error('[ASM] Could not apply default ruleset back as fallback')
      }
    }
    function updateConfig(product, configId, configPath, config) {
      if (!waf.wafManager) throw new Error('Cannot update disabled WAF')
      try {
        if (product === 'ASM_DD') {
          waf.wafManager.removeConfig(waf.wafManager.constructor.defaultWafConfigPath)
        }
        const updateSucceeded = waf.wafManager.updateConfig(configPath, config)
        Reporter.reportWafConfigUpdate(product, configId, waf.wafManager.ddwaf.diagnostics, waf.wafManager.ddwafVersion)
        if (!updateSucceeded) {
          throw new WafUpdateError(waf.wafManager.ddwaf.diagnostics)
        }
      } catch (err) {
        log.error('[ASM] Could not update config from RC')
        throw err
      }
    }
    function removeConfig(configPath) {
      if (!waf.wafManager) throw new Error('Cannot update disabled WAF')
      try {
        waf.wafManager.removeConfig(configPath)
      } catch (err) {
        log.error('[ASM] Could not remove config from RC')
        throw err
      }
    }
    function run(data, req, raspRule) {
      if (!req) {
        const store = storage('legacy').getStore()
        if (!store || !store.req) {
          log.warn('[ASM] Request object not available in waf.run')
          return
        }
        req = store.req
      }
      const wafContext = waf.wafManager.getWAFContext(req)
      const result = wafContext.run(data, raspRule)
      if (result?.keep) {
        if (limiter.isAllowed()) {
          const rootSpan = web.root(req)
          keepTrace(rootSpan, ASM)
        } else {
          updateRateLimitedMetric(req)
        }
      }
      return result
    }
    function disposeContext(req) {
      const wafContext = waf.wafManager.getWAFContext(req)
      if (wafContext && !wafContext.ddwafContext.disposed) {
        wafContext.dispose()
      }
    }
    function noop() {}
    module2.exports = waf
  },
})

// node_modules/dd-trace/packages/dd-trace/src/remote_config/apply_states.js
var require_apply_states = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/remote_config/apply_states.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      UNACKNOWLEDGED: 1,
      ACKNOWLEDGED: 2,
      ERROR: 3,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/recommended.json
var require_recommended = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/recommended.json'(exports2, module2) {
    module2.exports = {
      version: '2.2',
      metadata: {
        rules_version: '1.15.1',
      },
      rules: [
        {
          id: 'blk-001-001',
          name: 'Block IP Addresses',
          tags: {
            type: 'block_ip',
            category: 'security_response',
            module: 'network-acl',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'http.client_ip',
                  },
                ],
                data: 'blocked_ips',
              },
              operator: 'ip_match',
            },
          ],
          transformers: [],
          on_match: ['block'],
        },
        {
          id: 'blk-001-002',
          name: 'Block User Addresses',
          tags: {
            type: 'block_user',
            category: 'security_response',
            module: 'authentication-acl',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'usr.id',
                  },
                ],
                data: 'blocked_users',
              },
              operator: 'exact_match',
            },
          ],
          transformers: [],
          on_match: ['block'],
        },
        {
          id: 'crs-913-110',
          name: 'Acunetix',
          tags: {
            type: 'commercial_scanner',
            crs_id: '913110',
            category: 'attack_attempt',
            tool_name: 'Acunetix',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                list: [
                  'acunetix-product',
                  '(acunetix web vulnerability scanner',
                  'acunetix-scanning-agreement',
                  'acunetix-user-agreement',
                  'md5(acunetix_wvs_security_test)',
                ],
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-913-120',
          name: 'Known security scanner filename/argument',
          tags: {
            type: 'security_scanner',
            crs_id: '913120',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                list: [
                  '/.adsensepostnottherenonobook',
                  '/<invalid>hello.html',
                  '/actsensepostnottherenonotive',
                  '/acunetix-wvs-test-for-some-inexistent-file',
                  '/antidisestablishmentarianism',
                  '/appscan_fingerprint/mac_address',
                  '/arachni-',
                  '/cybercop',
                  '/nessus_is_probing_you_',
                  '/nessustest',
                  '/netsparker-',
                  '/rfiinc.txt',
                  '/thereisnowaythat-you-canbethere',
                  '/w3af/remotefileinclude.html',
                  'appscan_fingerprint',
                  'w00tw00t.at.isc.sans.dfind',
                  'w00tw00t.at.blackhats.romanian.anti-sec',
                ],
                options: {
                  enforce_word_boundary: true,
                },
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-920-260',
          name: 'Unicode Full/Half Width Abuse Attack Attempt',
          tags: {
            type: 'http_protocol_violation',
            crs_id: '920260',
            category: 'attack_attempt',
            cwe: '176',
            capec: '1000/255/153/267/71',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: '\\%u[fF]{2}[0-9a-fA-F]{2}',
                options: {
                  case_sensitive: true,
                  min_length: 6,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-921-110',
          name: 'HTTP Request Smuggling Attack',
          tags: {
            type: 'http_protocol_violation',
            crs_id: '921110',
            category: 'attack_attempt',
            cwe: '444',
            capec: '1000/210/272/220/33',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                ],
                regex:
                  '(?:get|post|head|options|connect|put|delete|trace|track|patch|propfind|propatch|mkcol|copy|move|lock|unlock)\\s+[^\\s]+\\s+http/\\d',
                options: {
                  case_sensitive: true,
                  min_length: 12,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-921-160',
          name: 'HTTP Header Injection Attack via payload (CR/LF and header-name detected)',
          tags: {
            type: 'http_protocol_violation',
            crs_id: '921160',
            category: 'attack_attempt',
            cwe: '113',
            capec: '1000/210/272/220/105',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                ],
                regex:
                  '[\\n\\r]+(?:refresh|(?:set-)?cookie|(?:x-)?(?:forwarded-(?:for|host|server)|via|remote-ip|remote-addr|originating-IP))\\s*:',
                options: {
                  case_sensitive: true,
                  min_length: 3,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-930-100',
          name: 'Obfuscated Path Traversal Attack (/../)',
          tags: {
            type: 'lfi',
            crs_id: '930100',
            category: 'attack_attempt',
            cwe: '22',
            capec: '1000/255/153/126',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                regex:
                  '(?:%(?:c(?:0%(?:[2aq]f|5c|9v)|1%(?:[19p]c|8s|af))|2(?:5(?:c(?:0%25af|1%259c)|2f|5c)|%46|f)|(?:(?:f(?:8%8)?0%8|e)0%80%a|bg%q)f|%3(?:2(?:%(?:%6|4)6|F)|5%%63)|u(?:221[56]|002f|EFC8|F025)|1u|5c)|0x(?:2f|5c)|\\/|\\x5c)(?:%(?:(?:f(?:(?:c%80|8)%8)?0%8|e)0%80%ae|2(?:(?:5(?:c0%25a|2))?e|%45)|u(?:(?:002|ff0)e|2024)|%32(?:%(?:%6|4)5|E)|c0(?:%[256aef]e|\\.))|\\.(?:%0[01])?|0x2e){2,3}(?:%(?:c(?:0%(?:[2aq]f|5c|9v)|1%(?:[19p]c|8s|af))|2(?:5(?:c(?:0%25af|1%259c)|2f|5c)|%46|f)|(?:(?:f(?:8%8)?0%8|e)0%80%a|bg%q)f|%3(?:2(?:%(?:%6|4)6|F)|5%%63)|u(?:221[56]|002f|EFC8|F025)|1u|5c)|0x(?:2f|5c)|\\/|\\x5c)',
                options: {
                  min_length: 4,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['normalizePath'],
        },
        {
          id: 'crs-930-110',
          name: 'Simple Path Traversal Attack (/../)',
          tags: {
            type: 'lfi',
            crs_id: '930110',
            category: 'attack_attempt',
            cwe: '22',
            capec: '1000/255/153/126',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                regex: '(?:(?:^|[\\x5c/])\\.{2,3}[\\x5c/]|[\\x5c/]\\.{2,3}(?:[\\x5c/]|$))',
                options: {
                  case_sensitive: true,
                  min_length: 3,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-930-120',
          name: 'OS File Access Attempt',
          tags: {
            type: 'lfi',
            crs_id: '930120',
            category: 'attack_attempt',
            cwe: '22',
            capec: '1000/255/153/126',
            confidence: '1',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                list: [
                  '/.htaccess',
                  '/.htdigest',
                  '/.htpasswd',
                  '/.addressbook',
                  '/.aptitude/config',
                  '.aws/config',
                  '.aws/credentials',
                  '/.bash_config',
                  '/.bash_history',
                  '/.bash_logout',
                  '/.bash_profile',
                  '/.bashrc',
                  '.cache/notify-osd.log',
                  '.config/odesk/odesk team.conf',
                  '/.cshrc',
                  '/.dockerignore',
                  '.drush/',
                  '/.eslintignore',
                  '/.fbcindex',
                  '/.forward',
                  '/.git',
                  '.git/',
                  '/.gitattributes',
                  '/.gitconfig',
                  '.gnupg/',
                  '.hplip/hplip.conf',
                  '/.ksh_history',
                  '/.lesshst',
                  '.lftp/',
                  '/.lhistory',
                  '/.lldb-history',
                  '.local/share/mc/',
                  '/.lynx_cookies',
                  '/.my.cnf',
                  '/.mysql_history',
                  '/.nano_history',
                  '/.node_repl_history',
                  '/.pearrc',
                  '/.pgpass',
                  '/.php_history',
                  '/.pinerc',
                  '.pki/',
                  '/.proclog',
                  '/.procmailrc',
                  '/.psql_history',
                  '/.python_history',
                  '/.rediscli_history',
                  '/.rhistory',
                  '/.rhosts',
                  '/.sh_history',
                  '/.sqlite_history',
                  '.ssh/authorized_keys',
                  '.ssh/config',
                  '.ssh/id_dsa',
                  '.ssh/id_dsa.pub',
                  '.ssh/id_rsa',
                  '.ssh/id_rsa.pub',
                  '.ssh/identity',
                  '.ssh/identity.pub',
                  '.ssh/id_ecdsa',
                  '.ssh/id_ecdsa.pub',
                  '.ssh/known_hosts',
                  '.subversion/auth',
                  '.subversion/config',
                  '.subversion/servers',
                  '.tconn/tconn.conf',
                  '/.tcshrc',
                  '.vidalia/vidalia.conf',
                  '/.viminfo',
                  '/.vimrc',
                  '/.www_acl',
                  '/.wwwacl',
                  '/.xauthority',
                  '/.zhistory',
                  '/.zshrc',
                  '/.zsh_history',
                  '/.nsconfig',
                  'data/elasticsearch',
                  'data/kafka',
                  'etc/ansible',
                  'etc/bind',
                  'etc/centos-release',
                  'etc/centos-release-upstream',
                  'etc/clam.d',
                  'etc/elasticsearch',
                  'etc/freshclam.conf',
                  'etc/gshadow',
                  'etc/gshadow-',
                  'etc/httpd',
                  'etc/kafka',
                  'etc/kibana',
                  'etc/logstash',
                  'etc/lvm',
                  'etc/mongod.conf',
                  'etc/my.cnf',
                  'etc/nuxeo.conf',
                  'etc/pki',
                  'etc/postfix',
                  'etc/scw-release',
                  'etc/subgid',
                  'etc/subgid-',
                  'etc/sudoers.d',
                  'etc/sysconfig',
                  'etc/system-release-cpe',
                  'opt/nuxeo',
                  'opt/tomcat',
                  'tmp/kafka-logs',
                  'usr/lib/rpm/rpm.log',
                  'var/data/elasticsearch',
                  'var/lib/elasticsearch',
                  'etc/.java',
                  'etc/acpi',
                  'etc/alsa',
                  'etc/alternatives',
                  'etc/apache2',
                  'etc/apm',
                  'etc/apparmor',
                  'etc/apparmor.d',
                  'etc/apport',
                  'etc/apt',
                  'etc/asciidoc',
                  'etc/avahi',
                  'etc/bash_completion.d',
                  'etc/binfmt.d',
                  'etc/bluetooth',
                  'etc/bonobo-activation',
                  'etc/brltty',
                  'etc/ca-certificates',
                  'etc/calendar',
                  'etc/chatscripts',
                  'etc/chromium-browser',
                  'etc/clamav',
                  'etc/cni',
                  'etc/console-setup',
                  'etc/coraza-waf',
                  'etc/cracklib',
                  'etc/cron.d',
                  'etc/cron.daily',
                  'etc/cron.hourly',
                  'etc/cron.monthly',
                  'etc/cron.weekly',
                  'etc/cups',
                  'etc/cups.save',
                  'etc/cupshelpers',
                  'etc/dbus-1',
                  'etc/dconf',
                  'etc/default',
                  'etc/depmod.d',
                  'etc/dhcp',
                  'etc/dictionaries-common',
                  'etc/dkms',
                  'etc/dnsmasq.d',
                  'etc/dockeretc/dpkg',
                  'etc/emacs',
                  'etc/environment.d',
                  'etc/fail2ban',
                  'etc/firebird',
                  'etc/firefox',
                  'etc/fonts',
                  'etc/fwupd',
                  'etc/gconf',
                  'etc/gdb',
                  'etc/gdm3',
                  'etc/geoclue',
                  'etc/ghostscript',
                  'etc/gimp',
                  'etc/glvnd',
                  'etc/gnome',
                  'etc/gnome-vfs-2.0',
                  'etc/gnucash',
                  'etc/gnustep',
                  'etc/groff',
                  'etc/grub.d',
                  'etc/gss',
                  'etc/gtk-2.0',
                  'etc/gtk-3.0',
                  'etc/hp',
                  'etc/ifplugd',
                  'etc/imagemagick-6',
                  'etc/init',
                  'etc/init.d',
                  'etc/initramfs-tools',
                  'etc/insserv.conf.d',
                  'etc/iproute2',
                  'etc/iptables',
                  'etc/java',
                  'etc/java-11-openjdk',
                  'etc/java-17-oracle',
                  'etc/java-8-openjdk',
                  'etc/kernel',
                  'etc/ld.so.conf.d',
                  'etc/ldap',
                  'etc/libblockdev',
                  'etc/libibverbs.d',
                  'etc/libnl-3',
                  'etc/libpaper.d',
                  'etc/libreoffice',
                  'etc/lighttpd',
                  'etc/logcheck',
                  'etc/logrotate.d',
                  'etc/lynx',
                  'etc/mail',
                  'etc/mc',
                  'etc/menu',
                  'etc/menu-methods',
                  'etc/modprobe.d',
                  'etc/modsecurity',
                  'etc/modules-load.d',
                  'etc/monit',
                  'etc/mono',
                  'etc/mplayer',
                  'etc/mpv',
                  'etc/muttrc.d',
                  'etc/mysql',
                  'etc/netplan',
                  'etc/network',
                  'etc/networkd-dispatcher',
                  'etc/networkmanager',
                  'etc/newt',
                  'etc/nghttpx',
                  'etc/nikto',
                  'etc/odbcdatasources',
                  'etc/openal',
                  'etc/openmpi',
                  'etc/opt',
                  'etc/osync',
                  'etc/packagekit',
                  'etc/pam.d',
                  'etc/pcmcia',
                  'etc/perl',
                  'etc/php',
                  'etc/pki',
                  'etc/pm',
                  'etc/polkit-1',
                  'etc/postfix',
                  'etc/ppp',
                  'etc/profile.d',
                  'etc/proftpd',
                  'etc/pulse',
                  'etc/python',
                  'etc/rc0.d',
                  'etc/rc1.d',
                  'etc/rc2.d',
                  'etc/rc3.d',
                  'etc/rc4.d',
                  'etc/rc5.d',
                  'etc/rc6.d',
                  'etc/rcs.d',
                  'etc/resolvconf',
                  'etc/rsyslog.d',
                  'etc/samba',
                  'etc/sane.d',
                  'etc/security',
                  'etc/selinux',
                  'etc/sensors.d',
                  'etc/sgml',
                  'etc/signon-ui',
                  'etc/skel',
                  'etc/snmp',
                  'etc/sound',
                  'etc/spamassassin',
                  'etc/speech-dispatcher',
                  'etc/ssh',
                  'etc/ssl',
                  'etc/sudoers.d',
                  'etc/sysctl.d',
                  'etc/sysstat',
                  'etc/systemd',
                  'etc/terminfo',
                  'etc/texmf',
                  'etc/thermald',
                  'etc/thnuclnt',
                  'etc/thunderbird',
                  'etc/timidity',
                  'etc/tmpfiles.d',
                  'etc/ubuntu-advantage',
                  'etc/udev',
                  'etc/udisks2',
                  'etc/ufw',
                  'etc/update-manager',
                  'etc/update-motd.d',
                  'etc/update-notifier',
                  'etc/upower',
                  'etc/urlview',
                  'etc/usb_modeswitch.d',
                  'etc/vim',
                  'etc/vmware',
                  'etc/vmware-installer',
                  'etc/vmware-vix',
                  'etc/vulkan',
                  'etc/w3m',
                  'etc/wireshark',
                  'etc/wpa_supplicant',
                  'etc/x11',
                  'etc/xdg',
                  'etc/xml',
                  'etc/redis.conf',
                  'etc/redis-sentinel.conf',
                  'etc/php.ini',
                  'bin/php.ini',
                  'etc/httpd/php.ini',
                  'usr/lib/php.ini',
                  'usr/lib/php/php.ini',
                  'usr/local/etc/php.ini',
                  'usr/local/lib/php.ini',
                  'usr/local/php/lib/php.ini',
                  'usr/local/php4/lib/php.ini',
                  'usr/local/php5/lib/php.ini',
                  'usr/local/apache/conf/php.ini',
                  'etc/php4.4/fcgi/php.ini',
                  'etc/php4/apache/php.ini',
                  'etc/php4/apache2/php.ini',
                  'etc/php5/apache/php.ini',
                  'etc/php5/apache2/php.ini',
                  'etc/php/php.ini',
                  'etc/php/php4/php.ini',
                  'etc/php/apache/php.ini',
                  'etc/php/apache2/php.ini',
                  'web/conf/php.ini',
                  'usr/local/zend/etc/php.ini',
                  'opt/xampp/etc/php.ini',
                  'var/local/www/conf/php.ini',
                  'etc/php/cgi/php.ini',
                  'etc/php4/cgi/php.ini',
                  'etc/php5/cgi/php.ini',
                  'home2/bin/stable/apache/php.ini',
                  'home/bin/stable/apache/php.ini',
                  'etc/httpd/conf.d/php.conf',
                  'php5/php.ini',
                  'php4/php.ini',
                  'php/php.ini',
                  'windows/php.ini',
                  'winnt/php.ini',
                  'apache/php/php.ini',
                  'xampp/apache/bin/php.ini',
                  'netserver/bin/stable/apache/php.ini',
                  'volumes/macintosh_hd1/usr/local/php/lib/php.ini',
                  'etc/mono/1.0/machine.config',
                  'etc/mono/2.0/machine.config',
                  'etc/mono/2.0/web.config',
                  'etc/mono/config',
                  'usr/local/cpanel/logs/stats_log',
                  'usr/local/cpanel/logs/access_log',
                  'usr/local/cpanel/logs/error_log',
                  'usr/local/cpanel/logs/license_log',
                  'usr/local/cpanel/logs/login_log',
                  'var/cpanel/cpanel.config',
                  'usr/local/psa/admin/logs/httpsd_access_log',
                  'usr/local/psa/admin/logs/panel.log',
                  'usr/local/psa/admin/conf/php.ini',
                  'etc/sw-cp-server/applications.d/plesk.conf',
                  'usr/local/psa/admin/conf/site_isolation_settings.ini',
                  'usr/local/sb/config',
                  'etc/sw-cp-server/applications.d/00-sso-cpserver.conf',
                  'etc/sso/sso_config.ini',
                  'etc/mysql/conf.d/old_passwords.cnf',
                  'var/mysql.log',
                  'var/mysql-bin.index',
                  'var/data/mysql-bin.index',
                  'program files/mysql/mysql server 5.0/data/{host}.err',
                  'program files/mysql/mysql server 5.0/data/mysql.log',
                  'program files/mysql/mysql server 5.0/data/mysql.err',
                  'program files/mysql/mysql server 5.0/data/mysql-bin.log',
                  'program files/mysql/mysql server 5.0/data/mysql-bin.index',
                  'program files/mysql/data/{host}.err',
                  'program files/mysql/data/mysql.log',
                  'program files/mysql/data/mysql.err',
                  'program files/mysql/data/mysql-bin.log',
                  'program files/mysql/data/mysql-bin.index',
                  'mysql/data/{host}.err',
                  'mysql/data/mysql.log',
                  'mysql/data/mysql.err',
                  'mysql/data/mysql-bin.log',
                  'mysql/data/mysql-bin.index',
                  'usr/local/mysql/data/mysql.log',
                  'usr/local/mysql/data/mysql.err',
                  'usr/local/mysql/data/mysql-bin.log',
                  'usr/local/mysql/data/mysql-slow.log',
                  'usr/local/mysql/data/mysqlderror.log',
                  'usr/local/mysql/data/{host}.err',
                  'usr/local/mysql/data/mysql-bin.index',
                  'var/lib/mysql/my.cnf',
                  'etc/mysql/my.cnf',
                  'etc/my.cnf',
                  'program files/mysql/mysql server 5.0/my.ini',
                  'program files/mysql/mysql server 5.0/my.cnf',
                  'program files/mysql/my.ini',
                  'program files/mysql/my.cnf',
                  'mysql/my.ini',
                  'mysql/my.cnf',
                  'mysql/bin/my.ini',
                  'var/postgresql/log/postgresql.log',
                  'usr/internet/pgsql/data/postmaster.log',
                  'usr/local/pgsql/data/postgresql.log',
                  'usr/local/pgsql/data/pg_log',
                  'postgresql/log/pgadmin.log',
                  'var/lib/pgsql/data/postgresql.conf',
                  'var/postgresql/db/postgresql.conf',
                  'var/nm2/postgresql.conf',
                  'usr/local/pgsql/data/postgresql.conf',
                  'usr/local/pgsql/data/pg_hba.conf',
                  'usr/internet/pgsql/data/pg_hba.conf',
                  'usr/local/pgsql/data/passwd',
                  'usr/local/pgsql/bin/pg_passwd',
                  'etc/postgresql/postgresql.conf',
                  'etc/postgresql/pg_hba.conf',
                  'home/postgres/data/postgresql.conf',
                  'home/postgres/data/pg_version',
                  'home/postgres/data/pg_ident.conf',
                  'home/postgres/data/pg_hba.conf',
                  'program files/postgresql/8.3/data/pg_hba.conf',
                  'program files/postgresql/8.3/data/pg_ident.conf',
                  'program files/postgresql/8.3/data/postgresql.conf',
                  'program files/postgresql/8.4/data/pg_hba.conf',
                  'program files/postgresql/8.4/data/pg_ident.conf',
                  'program files/postgresql/8.4/data/postgresql.conf',
                  'program files/postgresql/9.0/data/pg_hba.conf',
                  'program files/postgresql/9.0/data/pg_ident.conf',
                  'program files/postgresql/9.0/data/postgresql.conf',
                  'program files/postgresql/9.1/data/pg_hba.conf',
                  'program files/postgresql/9.1/data/pg_ident.conf',
                  'program files/postgresql/9.1/data/postgresql.conf',
                  'wamp/logs/access.log',
                  'wamp/logs/apache_error.log',
                  'wamp/logs/genquery.log',
                  'wamp/logs/mysql.log',
                  'wamp/logs/slowquery.log',
                  'wamp/bin/apache/apache2.2.22/logs/access.log',
                  'wamp/bin/apache/apache2.2.22/logs/error.log',
                  'wamp/bin/apache/apache2.2.21/logs/access.log',
                  'wamp/bin/apache/apache2.2.21/logs/error.log',
                  'wamp/bin/mysql/mysql5.5.24/data/mysql-bin.index',
                  'wamp/bin/mysql/mysql5.5.16/data/mysql-bin.index',
                  'wamp/bin/apache/apache2.2.21/conf/httpd.conf',
                  'wamp/bin/apache/apache2.2.22/conf/httpd.conf',
                  'wamp/bin/apache/apache2.2.21/wampserver.conf',
                  'wamp/bin/apache/apache2.2.22/wampserver.conf',
                  'wamp/bin/apache/apache2.2.22/conf/wampserver.conf',
                  'wamp/bin/mysql/mysql5.5.24/my.ini',
                  'wamp/bin/mysql/mysql5.5.24/wampserver.conf',
                  'wamp/bin/mysql/mysql5.5.16/my.ini',
                  'wamp/bin/mysql/mysql5.5.16/wampserver.conf',
                  'wamp/bin/php/php5.3.8/php.ini',
                  'wamp/bin/php/php5.4.3/php.ini',
                  'xampp/apache/logs/access.log',
                  'xampp/apache/logs/error.log',
                  'xampp/mysql/data/mysql-bin.index',
                  'xampp/mysql/data/mysql.err',
                  'xampp/mysql/data/{host}.err',
                  'xampp/sendmail/sendmail.log',
                  'xampp/apache/conf/httpd.conf',
                  'xampp/filezillaftp/filezilla server.xml',
                  'xampp/mercurymail/mercury.ini',
                  'xampp/php/php.ini',
                  'xampp/phpmyadmin/config.inc.php',
                  'xampp/sendmail/sendmail.ini',
                  'xampp/webalizer/webalizer.conf',
                  'opt/lampp/etc/httpd.conf',
                  'xampp/htdocs/aca.txt',
                  'xampp/htdocs/admin.php',
                  'xampp/htdocs/leer.txt',
                  'usr/local/apache/logs/audit_log',
                  'usr/local/apache2/logs/audit_log',
                  'logs/security_debug_log',
                  'logs/security_log',
                  'usr/local/apache/conf/modsec.conf',
                  'usr/local/apache2/conf/modsec.conf',
                  'winnt/system32/logfiles/msftpsvc',
                  'winnt/system32/logfiles/msftpsvc1',
                  'winnt/system32/logfiles/msftpsvc2',
                  'windows/system32/logfiles/msftpsvc',
                  'windows/system32/logfiles/msftpsvc1',
                  'windows/system32/logfiles/msftpsvc2',
                  'etc/logrotate.d/proftpd',
                  'www/logs/proftpd.system.log',
                  'etc/pam.d/proftpd',
                  'etc/proftp.conf',
                  'etc/protpd/proftpd.conf',
                  'etc/vhcs2/proftpd/proftpd.conf',
                  'etc/proftpd/modules.conf',
                  'etc/vsftpd.chroot_list',
                  'etc/logrotate.d/vsftpd.log',
                  'etc/vsftpd/vsftpd.conf',
                  'etc/vsftpd.conf',
                  'etc/chrootusers',
                  'var/adm/log/xferlog',
                  'etc/wu-ftpd/ftpaccess',
                  'etc/wu-ftpd/ftphosts',
                  'etc/wu-ftpd/ftpusers',
                  'logs/pure-ftpd.log',
                  'usr/sbin/pure-config.pl',
                  'usr/etc/pure-ftpd.conf',
                  'etc/pure-ftpd/pure-ftpd.conf',
                  'usr/local/etc/pure-ftpd.conf',
                  'usr/local/etc/pureftpd.pdb',
                  'usr/local/pureftpd/etc/pureftpd.pdb',
                  'usr/local/pureftpd/sbin/pure-config.pl',
                  'usr/local/pureftpd/etc/pure-ftpd.conf',
                  'etc/pure-ftpd.conf',
                  'etc/pure-ftpd/pure-ftpd.pdb',
                  'etc/pureftpd.pdb',
                  'etc/pureftpd.passwd',
                  'etc/pure-ftpd/pureftpd.pdb',
                  'usr/ports/ftp/pure-ftpd/pure-ftpd.conf',
                  'usr/ports/ftp/pure-ftpd/pureftpd.pdb',
                  'usr/ports/ftp/pure-ftpd/pureftpd.passwd',
                  'usr/ports/net/pure-ftpd/pure-ftpd.conf',
                  'usr/ports/net/pure-ftpd/pureftpd.pdb',
                  'usr/ports/net/pure-ftpd/pureftpd.passwd',
                  'usr/pkgsrc/net/pureftpd/pure-ftpd.conf',
                  'usr/pkgsrc/net/pureftpd/pureftpd.pdb',
                  'usr/pkgsrc/net/pureftpd/pureftpd.passwd',
                  'usr/ports/contrib/pure-ftpd/pure-ftpd.conf',
                  'usr/ports/contrib/pure-ftpd/pureftpd.pdb',
                  'usr/ports/contrib/pure-ftpd/pureftpd.passwd',
                  'usr/sbin/mudlogd',
                  'etc/muddleftpd/mudlog',
                  'etc/muddleftpd.com',
                  'etc/muddleftpd/mudlogd.conf',
                  'etc/muddleftpd/muddleftpd.conf',
                  'usr/sbin/mudpasswd',
                  'etc/muddleftpd/muddleftpd.passwd',
                  'etc/muddleftpd/passwd',
                  'etc/logrotate.d/ftp',
                  'etc/ftpchroot',
                  'etc/ftphosts',
                  'etc/ftpusers',
                  'winnt/system32/logfiles/smtpsvc',
                  'winnt/system32/logfiles/smtpsvc1',
                  'winnt/system32/logfiles/smtpsvc2',
                  'winnt/system32/logfiles/smtpsvc3',
                  'winnt/system32/logfiles/smtpsvc4',
                  'winnt/system32/logfiles/smtpsvc5',
                  'windows/system32/logfiles/smtpsvc',
                  'windows/system32/logfiles/smtpsvc1',
                  'windows/system32/logfiles/smtpsvc2',
                  'windows/system32/logfiles/smtpsvc3',
                  'windows/system32/logfiles/smtpsvc4',
                  'windows/system32/logfiles/smtpsvc5',
                  'etc/osxhttpd/osxhttpd.conf',
                  'system/library/webobjects/adaptors/apache2.2/apache.conf',
                  'etc/apache2/sites-available/default',
                  'etc/apache2/sites-available/default-ssl',
                  'etc/apache2/sites-enabled/000-default',
                  'etc/apache2/sites-enabled/default',
                  'etc/apache2/apache2.conf',
                  'etc/apache2/ports.conf',
                  'usr/local/etc/apache/httpd.conf',
                  'usr/pkg/etc/httpd/httpd.conf',
                  'usr/pkg/etc/httpd/httpd-default.conf',
                  'usr/pkg/etc/httpd/httpd-vhosts.conf',
                  'etc/httpd/mod_php.conf',
                  'etc/httpd/extra/httpd-ssl.conf',
                  'etc/rc.d/rc.httpd',
                  'usr/local/apache/conf/httpd.conf.default',
                  'usr/local/apache/conf/access.conf',
                  'usr/local/apache22/conf/httpd.conf',
                  'usr/local/apache22/httpd.conf',
                  'usr/local/etc/apache22/conf/httpd.conf',
                  'usr/local/apps/apache22/conf/httpd.conf',
                  'etc/apache22/conf/httpd.conf',
                  'etc/apache22/httpd.conf',
                  'opt/apache22/conf/httpd.conf',
                  'usr/local/etc/apache2/vhosts.conf',
                  'usr/local/apache/conf/vhosts.conf',
                  'usr/local/apache2/conf/vhosts.conf',
                  'usr/local/apache/conf/vhosts-custom.conf',
                  'usr/local/apache2/conf/vhosts-custom.conf',
                  'etc/apache/default-server.conf',
                  'etc/apache2/default-server.conf',
                  'usr/local/apache2/conf/extra/httpd-ssl.conf',
                  'usr/local/apache2/conf/ssl.conf',
                  'etc/httpd/conf.d',
                  'usr/local/etc/apache22/httpd.conf',
                  'usr/local/etc/apache2/httpd.conf',
                  'etc/apache2/httpd2.conf',
                  'etc/apache2/ssl-global.conf',
                  'etc/apache2/vhosts.d/00_default_vhost.conf',
                  'apache/conf/httpd.conf',
                  'etc/apache/httpd.conf',
                  'etc/httpd/conf',
                  'http/httpd.conf',
                  'usr/local/apache1.3/conf/httpd.conf',
                  'usr/local/etc/httpd/conf',
                  'var/apache/conf/httpd.conf',
                  'var/www/conf',
                  'www/apache/conf/httpd.conf',
                  'www/conf/httpd.conf',
                  'etc/init.d',
                  'etc/apache/access.conf',
                  'etc/rc.conf',
                  'www/logs/freebsddiary-error.log',
                  'www/logs/freebsddiary-access_log',
                  'library/webserver/documents/index.html',
                  'library/webserver/documents/index.htm',
                  'library/webserver/documents/default.html',
                  'library/webserver/documents/default.htm',
                  'library/webserver/documents/index.php',
                  'library/webserver/documents/default.php',
                  'usr/local/etc/webmin/miniserv.conf',
                  'etc/webmin/miniserv.conf',
                  'usr/local/etc/webmin/miniserv.users',
                  'etc/webmin/miniserv.users',
                  'winnt/system32/logfiles/w3svc/inetsvn1.log',
                  'winnt/system32/logfiles/w3svc1/inetsvn1.log',
                  'winnt/system32/logfiles/w3svc2/inetsvn1.log',
                  'winnt/system32/logfiles/w3svc3/inetsvn1.log',
                  'windows/system32/logfiles/w3svc/inetsvn1.log',
                  'windows/system32/logfiles/w3svc1/inetsvn1.log',
                  'windows/system32/logfiles/w3svc2/inetsvn1.log',
                  'windows/system32/logfiles/w3svc3/inetsvn1.log',
                  'apache/logs/error.log',
                  'apache/logs/access.log',
                  'apache2/logs/error.log',
                  'apache2/logs/access.log',
                  'logs/error.log',
                  'logs/access.log',
                  'etc/httpd/logs/access_log',
                  'etc/httpd/logs/access.log',
                  'etc/httpd/logs/error_log',
                  'etc/httpd/logs/error.log',
                  'usr/local/apache/logs/access_log',
                  'usr/local/apache/logs/access.log',
                  'usr/local/apache/logs/error_log',
                  'usr/local/apache/logs/error.log',
                  'usr/local/apache2/logs/access_log',
                  'usr/local/apache2/logs/access.log',
                  'usr/local/apache2/logs/error_log',
                  'usr/local/apache2/logs/error.log',
                  'var/www/logs/access_log',
                  'var/www/logs/access.log',
                  'var/www/logs/error_log',
                  'var/www/logs/error.log',
                  'opt/lampp/logs/access_log',
                  'opt/lampp/logs/error_log',
                  'opt/xampp/logs/access_log',
                  'opt/xampp/logs/error_log',
                  'opt/lampp/logs/access.log',
                  'opt/lampp/logs/error.log',
                  'opt/xampp/logs/access.log',
                  'opt/xampp/logs/error.log',
                  'program files/apache group/apache/logs/access.log',
                  'program files/apache group/apache/logs/error.log',
                  'program files/apache software foundation/apache2.2/logs/error.log',
                  'program files/apache software foundation/apache2.2/logs/access.log',
                  'opt/apache/apache.conf',
                  'opt/apache/conf/apache.conf',
                  'opt/apache2/apache.conf',
                  'opt/apache2/conf/apache.conf',
                  'opt/httpd/apache.conf',
                  'opt/httpd/conf/apache.conf',
                  'etc/httpd/apache.conf',
                  'etc/apache2/apache.conf',
                  'etc/httpd/conf/apache.conf',
                  'usr/local/apache/apache.conf',
                  'usr/local/apache/conf/apache.conf',
                  'usr/local/apache2/apache.conf',
                  'usr/local/apache2/conf/apache.conf',
                  'usr/local/php/apache.conf.php',
                  'usr/local/php4/apache.conf.php',
                  'usr/local/php5/apache.conf.php',
                  'usr/local/php/apache.conf',
                  'usr/local/php4/apache.conf',
                  'usr/local/php5/apache.conf',
                  'private/etc/httpd/apache.conf',
                  'opt/apache/apache2.conf',
                  'opt/apache/conf/apache2.conf',
                  'opt/apache2/apache2.conf',
                  'opt/apache2/conf/apache2.conf',
                  'opt/httpd/apache2.conf',
                  'opt/httpd/conf/apache2.conf',
                  'etc/httpd/apache2.conf',
                  'etc/httpd/conf/apache2.conf',
                  'usr/local/apache/apache2.conf',
                  'usr/local/apache/conf/apache2.conf',
                  'usr/local/apache2/apache2.conf',
                  'usr/local/apache2/conf/apache2.conf',
                  'usr/local/php/apache2.conf.php',
                  'usr/local/php4/apache2.conf.php',
                  'usr/local/php5/apache2.conf.php',
                  'usr/local/php/apache2.conf',
                  'usr/local/php4/apache2.conf',
                  'usr/local/php5/apache2.conf',
                  'private/etc/httpd/apache2.conf',
                  'usr/local/apache/conf/httpd.conf',
                  'usr/local/apache2/conf/httpd.conf',
                  'etc/httpd/conf/httpd.conf',
                  'etc/apache/apache.conf',
                  'etc/apache/conf/httpd.conf',
                  'etc/apache2/httpd.conf',
                  'usr/apache2/conf/httpd.conf',
                  'usr/apache/conf/httpd.conf',
                  'usr/local/etc/apache/conf/httpd.conf',
                  'usr/local/apache/httpd.conf',
                  'usr/local/apache2/httpd.conf',
                  'usr/local/httpd/conf/httpd.conf',
                  'usr/local/etc/apache2/conf/httpd.conf',
                  'usr/local/etc/httpd/conf/httpd.conf',
                  'usr/local/apps/apache2/conf/httpd.conf',
                  'usr/local/apps/apache/conf/httpd.conf',
                  'usr/local/php/httpd.conf.php',
                  'usr/local/php4/httpd.conf.php',
                  'usr/local/php5/httpd.conf.php',
                  'usr/local/php/httpd.conf',
                  'usr/local/php4/httpd.conf',
                  'usr/local/php5/httpd.conf',
                  'etc/apache2/conf/httpd.conf',
                  'etc/http/conf/httpd.conf',
                  'etc/httpd/httpd.conf',
                  'etc/http/httpd.conf',
                  'etc/httpd.conf',
                  'opt/apache/conf/httpd.conf',
                  'opt/apache2/conf/httpd.conf',
                  'var/www/conf/httpd.conf',
                  'private/etc/httpd/httpd.conf',
                  'private/etc/httpd/httpd.conf.default',
                  'etc/apache2/vhosts.d/default_vhost.include',
                  'etc/apache2/conf.d/charset',
                  'etc/apache2/conf.d/security',
                  'etc/apache2/envvars',
                  'etc/apache2/mods-available/autoindex.conf',
                  'etc/apache2/mods-available/deflate.conf',
                  'etc/apache2/mods-available/dir.conf',
                  'etc/apache2/mods-available/mem_cache.conf',
                  'etc/apache2/mods-available/mime.conf',
                  'etc/apache2/mods-available/proxy.conf',
                  'etc/apache2/mods-available/setenvif.conf',
                  'etc/apache2/mods-available/ssl.conf',
                  'etc/apache2/mods-enabled/alias.conf',
                  'etc/apache2/mods-enabled/deflate.conf',
                  'etc/apache2/mods-enabled/dir.conf',
                  'etc/apache2/mods-enabled/mime.conf',
                  'etc/apache2/mods-enabled/negotiation.conf',
                  'etc/apache2/mods-enabled/php5.conf',
                  'etc/apache2/mods-enabled/status.conf',
                  'program files/apache group/apache/conf/httpd.conf',
                  'program files/apache group/apache2/conf/httpd.conf',
                  'program files/xampp/apache/conf/apache.conf',
                  'program files/xampp/apache/conf/apache2.conf',
                  'program files/xampp/apache/conf/httpd.conf',
                  'program files/apache group/apache/apache.conf',
                  'program files/apache group/apache/conf/apache.conf',
                  'program files/apache group/apache2/conf/apache.conf',
                  'program files/apache group/apache/apache2.conf',
                  'program files/apache group/apache/conf/apache2.conf',
                  'program files/apache group/apache2/conf/apache2.conf',
                  'program files/apache software foundation/apache2.2/conf/httpd.conf',
                  'volumes/macintosh_hd1/opt/httpd/conf/httpd.conf',
                  'volumes/macintosh_hd1/opt/apache/conf/httpd.conf',
                  'volumes/macintosh_hd1/opt/apache2/conf/httpd.conf',
                  'volumes/macintosh_hd1/usr/local/php/httpd.conf.php',
                  'volumes/macintosh_hd1/usr/local/php4/httpd.conf.php',
                  'volumes/macintosh_hd1/usr/local/php5/httpd.conf.php',
                  'volumes/webbackup/opt/apache2/conf/httpd.conf',
                  'volumes/webbackup/private/etc/httpd/httpd.conf',
                  'volumes/webbackup/private/etc/httpd/httpd.conf.default',
                  'usr/local/etc/apache/vhosts.conf',
                  'usr/local/jakarta/tomcat/conf/jakarta.conf',
                  'usr/local/jakarta/tomcat/conf/server.xml',
                  'usr/local/jakarta/tomcat/conf/context.xml',
                  'usr/local/jakarta/tomcat/conf/workers.properties',
                  'usr/local/jakarta/tomcat/conf/logging.properties',
                  'usr/local/jakarta/dist/tomcat/conf/jakarta.conf',
                  'usr/local/jakarta/dist/tomcat/conf/server.xml',
                  'usr/local/jakarta/dist/tomcat/conf/context.xml',
                  'usr/local/jakarta/dist/tomcat/conf/workers.properties',
                  'usr/local/jakarta/dist/tomcat/conf/logging.properties',
                  'usr/share/tomcat6/conf/server.xml',
                  'usr/share/tomcat6/conf/context.xml',
                  'usr/share/tomcat6/conf/workers.properties',
                  'usr/share/tomcat6/conf/logging.properties',
                  'var/cpanel/tomcat.options',
                  'usr/local/jakarta/tomcat/logs/catalina.out',
                  'usr/local/jakarta/tomcat/logs/catalina.err',
                  'opt/tomcat/logs/catalina.out',
                  'opt/tomcat/logs/catalina.err',
                  'usr/share/logs/catalina.out',
                  'usr/share/logs/catalina.err',
                  'usr/share/tomcat/logs/catalina.out',
                  'usr/share/tomcat/logs/catalina.err',
                  'usr/share/tomcat6/logs/catalina.out',
                  'usr/share/tomcat6/logs/catalina.err',
                  'usr/local/apache/logs/mod_jk.log',
                  'usr/local/jakarta/tomcat/logs/mod_jk.log',
                  'usr/local/jakarta/dist/tomcat/logs/mod_jk.log',
                  'opt/[jboss]/server/default/conf/jboss-minimal.xml',
                  'opt/[jboss]/server/default/conf/jboss-service.xml',
                  'opt/[jboss]/server/default/conf/jndi.properties',
                  'opt/[jboss]/server/default/conf/log4j.xml',
                  'opt/[jboss]/server/default/conf/login-config.xml',
                  'opt/[jboss]/server/default/conf/standardjaws.xml',
                  'opt/[jboss]/server/default/conf/standardjboss.xml',
                  'opt/[jboss]/server/default/conf/server.log.properties',
                  'opt/[jboss]/server/default/deploy/jboss-logging.xml',
                  'usr/local/[jboss]/server/default/conf/jboss-minimal.xml',
                  'usr/local/[jboss]/server/default/conf/jboss-service.xml',
                  'usr/local/[jboss]/server/default/conf/jndi.properties',
                  'usr/local/[jboss]/server/default/conf/log4j.xml',
                  'usr/local/[jboss]/server/default/conf/login-config.xml',
                  'usr/local/[jboss]/server/default/conf/standardjaws.xml',
                  'usr/local/[jboss]/server/default/conf/standardjboss.xml',
                  'usr/local/[jboss]/server/default/conf/server.log.properties',
                  'usr/local/[jboss]/server/default/deploy/jboss-logging.xml',
                  'private/tmp/[jboss]/server/default/conf/jboss-minimal.xml',
                  'private/tmp/[jboss]/server/default/conf/jboss-service.xml',
                  'private/tmp/[jboss]/server/default/conf/jndi.properties',
                  'private/tmp/[jboss]/server/default/conf/log4j.xml',
                  'private/tmp/[jboss]/server/default/conf/login-config.xml',
                  'private/tmp/[jboss]/server/default/conf/standardjaws.xml',
                  'private/tmp/[jboss]/server/default/conf/standardjboss.xml',
                  'private/tmp/[jboss]/server/default/conf/server.log.properties',
                  'private/tmp/[jboss]/server/default/deploy/jboss-logging.xml',
                  'tmp/[jboss]/server/default/conf/jboss-minimal.xml',
                  'tmp/[jboss]/server/default/conf/jboss-service.xml',
                  'tmp/[jboss]/server/default/conf/jndi.properties',
                  'tmp/[jboss]/server/default/conf/log4j.xml',
                  'tmp/[jboss]/server/default/conf/login-config.xml',
                  'tmp/[jboss]/server/default/conf/standardjaws.xml',
                  'tmp/[jboss]/server/default/conf/standardjboss.xml',
                  'tmp/[jboss]/server/default/conf/server.log.properties',
                  'tmp/[jboss]/server/default/deploy/jboss-logging.xml',
                  'program files/[jboss]/server/default/conf/jboss-minimal.xml',
                  'program files/[jboss]/server/default/conf/jboss-service.xml',
                  'program files/[jboss]/server/default/conf/jndi.properties',
                  'program files/[jboss]/server/default/conf/log4j.xml',
                  'program files/[jboss]/server/default/conf/login-config.xml',
                  'program files/[jboss]/server/default/conf/standardjaws.xml',
                  'program files/[jboss]/server/default/conf/standardjboss.xml',
                  'program files/[jboss]/server/default/conf/server.log.properties',
                  'program files/[jboss]/server/default/deploy/jboss-logging.xml',
                  '[jboss]/server/default/conf/jboss-minimal.xml',
                  '[jboss]/server/default/conf/jboss-service.xml',
                  '[jboss]/server/default/conf/jndi.properties',
                  '[jboss]/server/default/conf/log4j.xml',
                  '[jboss]/server/default/conf/login-config.xml',
                  '[jboss]/server/default/conf/standardjaws.xml',
                  '[jboss]/server/default/conf/standardjboss.xml',
                  '[jboss]/server/default/conf/server.log.properties',
                  '[jboss]/server/default/deploy/jboss-logging.xml',
                  'opt/[jboss]/server/default/log/server.log',
                  'opt/[jboss]/server/default/log/boot.log',
                  'usr/local/[jboss]/server/default/log/server.log',
                  'usr/local/[jboss]/server/default/log/boot.log',
                  'private/tmp/[jboss]/server/default/log/server.log',
                  'private/tmp/[jboss]/server/default/log/boot.log',
                  'tmp/[jboss]/server/default/log/server.log',
                  'tmp/[jboss]/server/default/log/boot.log',
                  'program files/[jboss]/server/default/log/server.log',
                  'program files/[jboss]/server/default/log/boot.log',
                  '[jboss]/server/default/log/server.log',
                  '[jboss]/server/default/log/boot.log',
                  'var/lighttpd.log',
                  'var/logs/access.log',
                  'usr/local/apache2/logs/lighttpd.error.log',
                  'usr/local/apache2/logs/lighttpd.log',
                  'usr/local/apache/logs/lighttpd.error.log',
                  'usr/local/apache/logs/lighttpd.log',
                  'usr/local/lighttpd/log/lighttpd.error.log',
                  'usr/local/lighttpd/log/access.log',
                  'usr/home/user/var/log/lighttpd.error.log',
                  'usr/home/user/var/log/apache.log',
                  'home/user/lighttpd/lighttpd.conf',
                  'usr/home/user/lighttpd/lighttpd.conf',
                  'etc/lighttpd/lighthttpd.conf',
                  'usr/local/etc/lighttpd.conf',
                  'usr/local/lighttpd/conf/lighttpd.conf',
                  'usr/local/etc/lighttpd.conf.new',
                  'var/www/.lighttpdpassword',
                  'logs/access_log',
                  'logs/error_log',
                  'etc/nginx/nginx.conf',
                  'usr/local/etc/nginx/nginx.conf',
                  'usr/local/nginx/conf/nginx.conf',
                  'usr/local/zeus/web/global.cfg',
                  'usr/local/zeus/web/log/errors',
                  'opt/lsws/conf/httpd_conf.xml',
                  'usr/local/lsws/conf/httpd_conf.xml',
                  'opt/lsws/logs/error.log',
                  'opt/lsws/logs/access.log',
                  'usr/local/lsws/logs/error.log',
                  'usr/local/logs/access.log',
                  'usr/local/samba/lib/log.user',
                  'usr/local/logs/samba.log',
                  'etc/samba/netlogon',
                  'etc/smbpasswd',
                  'etc/smb.conf',
                  'etc/samba/dhcp.conf',
                  'etc/samba/smb.conf',
                  'etc/samba/samba.conf',
                  'etc/samba/smb.conf.user',
                  'etc/samba/smbpasswd',
                  'etc/samba/smbusers',
                  'etc/samba/private/smbpasswd',
                  'usr/local/etc/smb.conf',
                  'usr/local/samba/lib/smb.conf.user',
                  'etc/dhcp3/dhclient.conf',
                  'etc/dhcp3/dhcpd.conf',
                  'etc/dhcp/dhclient.conf',
                  'program files/vidalia bundle/polipo/polipo.conf',
                  'etc/tor/tor-tsocks.conf',
                  'etc/stunnel/stunnel.conf',
                  'etc/tsocks.conf',
                  'etc/tinyproxy/tinyproxy.conf',
                  'etc/miredo-server.conf',
                  'etc/miredo.conf',
                  'etc/miredo/miredo-server.conf',
                  'etc/miredo/miredo.conf',
                  'etc/wicd/dhclient.conf.template.default',
                  'etc/wicd/manager-settings.conf',
                  'etc/wicd/wired-settings.conf',
                  'etc/wicd/wireless-settings.conf',
                  'etc/ipfw.rules',
                  'etc/ipfw.conf',
                  'etc/firewall.rules',
                  'winnt/system32/logfiles/firewall/pfirewall.log',
                  'winnt/system32/logfiles/firewall/pfirewall.log.old',
                  'windows/system32/logfiles/firewall/pfirewall.log',
                  'windows/system32/logfiles/firewall/pfirewall.log.old',
                  'etc/clamav/clamd.conf',
                  'etc/clamav/freshclam.conf',
                  'etc/x11/xorg.conf',
                  'etc/x11/xorg.conf-vesa',
                  'etc/x11/xorg.conf-vmware',
                  'etc/x11/xorg.conf.beforevmwaretoolsinstall',
                  'etc/x11/xorg.conf.orig',
                  'etc/bluetooth/input.conf',
                  'etc/bluetooth/main.conf',
                  'etc/bluetooth/network.conf',
                  'etc/bluetooth/rfcomm.conf',
                  'etc/bash_completion.d/debconf',
                  'root/.bash_logout',
                  'root/.bash_history',
                  'root/.bash_config',
                  'root/.bashrc',
                  'etc/bash.bashrc',
                  'var/adm/syslog',
                  'var/adm/sulog',
                  'var/adm/utmp',
                  'var/adm/utmpx',
                  'var/adm/wtmp',
                  'var/adm/wtmpx',
                  'var/adm/lastlog/username',
                  'usr/spool/lp/log',
                  'var/adm/lp/lpd-errs',
                  'usr/lib/cron/log',
                  'var/adm/loginlog',
                  'var/adm/pacct',
                  'var/adm/dtmp',
                  'var/adm/acct/sum/loginlog',
                  'var/adm/x0msgs',
                  'var/adm/crash/vmcore',
                  'var/adm/crash/unix',
                  'etc/newsyslog.conf',
                  'var/adm/qacct',
                  'var/adm/ras/errlog',
                  'var/adm/ras/bootlog',
                  'var/adm/cron/log',
                  'etc/utmp',
                  'etc/security/lastlog',
                  'etc/security/failedlogin',
                  'usr/spool/mqueue/syslog',
                  'var/adm/messages',
                  'var/adm/aculogs',
                  'var/adm/aculog',
                  'var/adm/vold.log',
                  'var/adm/log/asppp.log',
                  'var/lp/logs/lpsched',
                  'var/lp/logs/lpnet',
                  'var/lp/logs/requests',
                  'var/cron/log',
                  'var/saf/_log',
                  'var/saf/port/log',
                  'tmp/access.log',
                  'etc/sensors.conf',
                  'etc/sensors3.conf',
                  'etc/host.conf',
                  'etc/pam.conf',
                  'etc/resolv.conf',
                  'etc/apt/apt.conf',
                  'etc/inetd.conf',
                  'etc/syslog.conf',
                  'etc/sysctl.conf',
                  'etc/sysctl.d/10-console-messages.conf',
                  'etc/sysctl.d/10-network-security.conf',
                  'etc/sysctl.d/10-process-security.conf',
                  'etc/sysctl.d/wine.sysctl.conf',
                  'etc/security/access.conf',
                  'etc/security/group.conf',
                  'etc/security/limits.conf',
                  'etc/security/namespace.conf',
                  'etc/security/pam_env.conf',
                  'etc/security/sepermit.conf',
                  'etc/security/time.conf',
                  'etc/ssh/sshd_config',
                  'etc/adduser.conf',
                  'etc/deluser.conf',
                  'etc/avahi/avahi-daemon.conf',
                  'etc/ca-certificates.conf',
                  'etc/ca-certificates.conf.dpkg-old',
                  'etc/casper.conf',
                  'etc/chkrootkit.conf',
                  'etc/debconf.conf',
                  'etc/dns2tcpd.conf',
                  'etc/e2fsck.conf',
                  'etc/esound/esd.conf',
                  'etc/etter.conf',
                  'etc/fuse.conf',
                  'etc/foremost.conf',
                  'etc/hdparm.conf',
                  'etc/kernel-img.conf',
                  'etc/kernel-pkg.conf',
                  'etc/ld.so.conf',
                  'etc/ltrace.conf',
                  'etc/mail/sendmail.conf',
                  'etc/manpath.config',
                  'etc/kbd/config',
                  'etc/ldap/ldap.conf',
                  'etc/logrotate.conf',
                  'etc/mtools.conf',
                  'etc/smi.conf',
                  'etc/updatedb.conf',
                  'etc/pulse/client.conf',
                  'usr/share/adduser/adduser.conf',
                  'etc/hostname',
                  'etc/networks',
                  'etc/timezone',
                  'etc/modules',
                  'etc/passwd',
                  'etc/shadow',
                  'etc/fstab',
                  'etc/motd',
                  'etc/hosts',
                  'etc/group',
                  'etc/alias',
                  'etc/crontab',
                  'etc/crypttab',
                  'etc/exports',
                  'etc/mtab',
                  'etc/hosts.allow',
                  'etc/hosts.deny',
                  'etc/os-release',
                  'etc/password.master',
                  'etc/profile',
                  'etc/default/grub',
                  'etc/resolvconf/update-libc.d/sendmail',
                  'etc/inittab',
                  'etc/issue',
                  'etc/issue.net',
                  'etc/login.defs',
                  'etc/sudoers',
                  'etc/sysconfig/network-scripts/ifcfg-eth0',
                  'etc/redhat-release',
                  'etc/scw-release',
                  'etc/system-release-cpe',
                  'etc/debian_version',
                  'etc/fedora-release',
                  'etc/mandrake-release',
                  'etc/slackware-release',
                  'etc/suse-release',
                  'etc/security/group',
                  'etc/security/passwd',
                  'etc/security/user',
                  'etc/security/environ',
                  'etc/security/limits',
                  'etc/security/opasswd',
                  'boot/grub/grub.cfg',
                  'boot/grub/menu.lst',
                  'root/.ksh_history',
                  'root/.xauthority',
                  'usr/lib/security/mkuser.default',
                  'var/lib/squirrelmail/prefs/squirrelmail.log',
                  'etc/squirrelmail/apache.conf',
                  'etc/squirrelmail/config_local.php',
                  'etc/squirrelmail/default_pref',
                  'etc/squirrelmail/index.php',
                  'etc/squirrelmail/config_default.php',
                  'etc/squirrelmail/config.php',
                  'etc/squirrelmail/filters_setup.php',
                  'etc/squirrelmail/sqspell_config.php',
                  'etc/squirrelmail/config/config.php',
                  'etc/httpd/conf.d/squirrelmail.conf',
                  'usr/share/squirrelmail/config/config.php',
                  'private/etc/squirrelmail/config/config.php',
                  'srv/www/htdos/squirrelmail/config/config.php',
                  'var/www/squirrelmail/config/config.php',
                  'var/www/html/squirrelmail/config/config.php',
                  'var/www/html/squirrelmail-1.2.9/config/config.php',
                  'usr/share/squirrelmail/plugins/squirrel_logger/setup.php',
                  'usr/local/squirrelmail/www/readme',
                  'windows/system32/drivers/etc/hosts',
                  'windows/system32/drivers/etc/lmhosts.sam',
                  'windows/system32/drivers/etc/networks',
                  'windows/system32/drivers/etc/protocol',
                  'windows/system32/drivers/etc/services',
                  '/boot.ini',
                  'windows/debug/netsetup.log',
                  'windows/comsetup.log',
                  'windows/repair/setup.log',
                  'windows/setupact.log',
                  'windows/setupapi.log',
                  'windows/setuperr.log',
                  'windows/updspapi.log',
                  'windows/wmsetup.log',
                  'windows/windowsupdate.log',
                  'windows/odbc.ini',
                  'usr/local/psa/admin/htdocs/domains/databases/phpmyadmin/libraries/config.default.php',
                  'etc/apache2/conf.d/phpmyadmin.conf',
                  'etc/phpmyadmin/config.inc.php',
                  'etc/openldap/ldap.conf',
                  'etc/cups/acroread.conf',
                  'etc/cups/cupsd.conf',
                  'etc/cups/cupsd.conf.default',
                  'etc/cups/pdftops.conf',
                  'etc/cups/printers.conf',
                  'windows/system32/macromed/flash/flashinstall.log',
                  'windows/system32/macromed/flash/install.log',
                  'etc/cvs-cron.conf',
                  'etc/cvs-pserver.conf',
                  'etc/subversion/config',
                  'etc/modprobe.d/vmware-tools.conf',
                  'etc/updatedb.conf.beforevmwaretoolsinstall',
                  'etc/vmware-tools/config',
                  'etc/vmware-tools/tpvmlp.conf',
                  'etc/vmware-tools/vmware-tools-libraries.conf',
                  'var/log',
                  'var/log/sw-cp-server/error_log',
                  'var/log/sso/sso.log',
                  'var/log/dpkg.log',
                  'var/log/btmp',
                  'var/log/utmp',
                  'var/log/wtmp',
                  'var/log/mysql/mysql-bin.log',
                  'var/log/mysql/mysql-bin.index',
                  'var/log/mysql/data/mysql-bin.index',
                  'var/log/mysql.log',
                  'var/log/mysql.err',
                  'var/log/mysqlderror.log',
                  'var/log/mysql/mysql.log',
                  'var/log/mysql/mysql-slow.log',
                  'var/log/mysql-bin.index',
                  'var/log/data/mysql-bin.index',
                  'var/log/postgresql/postgresql.log',
                  'var/log/postgres/pg_backup.log',
                  'var/log/postgres/postgres.log',
                  'var/log/postgresql.log',
                  'var/log/pgsql/pgsql.log',
                  'var/log/postgresql/postgresql-8.1-main.log',
                  'var/log/postgresql/postgresql-8.3-main.log',
                  'var/log/postgresql/postgresql-8.4-main.log',
                  'var/log/postgresql/postgresql-9.0-main.log',
                  'var/log/postgresql/postgresql-9.1-main.log',
                  'var/log/pgsql8.log',
                  'var/log/postgresql/postgres.log',
                  'var/log/pgsql_log',
                  'var/log/postgresql/main.log',
                  'var/log/cron',
                  'var/log/postgres.log',
                  'var/log/proftpd',
                  'var/log/proftpd/xferlog.legacy',
                  'var/log/proftpd.access_log',
                  'var/log/proftpd.xferlog',
                  'var/log/vsftpd.log',
                  'var/log/xferlog',
                  'var/log/pure-ftpd/pure-ftpd.log',
                  'var/log/pureftpd.log',
                  'var/log/muddleftpd',
                  'var/log/muddleftpd.conf',
                  'var/log/ftp-proxy/ftp-proxy.log',
                  'var/log/ftp-proxy',
                  'var/log/ftplog',
                  'var/log/exim_mainlog',
                  'var/log/exim/mainlog',
                  'var/log/maillog',
                  'var/log/exim_paniclog',
                  'var/log/exim/paniclog',
                  'var/log/exim/rejectlog',
                  'var/log/exim_rejectlog',
                  'var/log/webmin/miniserv.log',
                  'var/log/httpd/access_log',
                  'var/log/httpd/error_log',
                  'var/log/httpd/access.log',
                  'var/log/httpd/error.log',
                  'var/log/apache/access_log',
                  'var/log/apache/access.log',
                  'var/log/apache/error_log',
                  'var/log/apache/error.log',
                  'var/log/apache2/access_log',
                  'var/log/apache2/access.log',
                  'var/log/apache2/error_log',
                  'var/log/apache2/error.log',
                  'var/log/access_log',
                  'var/log/access.log',
                  'var/log/error_log',
                  'var/log/error.log',
                  'var/log/tomcat6/catalina.out',
                  'var/log/lighttpd.error.log',
                  'var/log/lighttpd.access.log',
                  'var/logs/access.log',
                  'var/log/lighttpd/',
                  'var/log/lighttpd/error.log',
                  'var/log/lighttpd/access.www.log',
                  'var/log/lighttpd/error.www.log',
                  'var/log/lighttpd/access.log',
                  'var/log/lighttpd/{domain}/access.log',
                  'var/log/lighttpd/{domain}/error.log',
                  'var/log/nginx/access_log',
                  'var/log/nginx/error_log',
                  'var/log/nginx/access.log',
                  'var/log/nginx/error.log',
                  'var/log/nginx.access_log',
                  'var/log/nginx.error_log',
                  'var/log/samba/log.smbd',
                  'var/log/samba/log.nmbd',
                  'var/log/samba.log',
                  'var/log/samba.log1',
                  'var/log/samba.log2',
                  'var/log/log.smb',
                  'var/log/ipfw.log',
                  'var/log/ipfw',
                  'var/log/ipfw/ipfw.log',
                  'var/log/ipfw.today',
                  'var/log/poplog',
                  'var/log/authlog',
                  'var/log/news.all',
                  'var/log/news/news.all',
                  'var/log/news/news.crit',
                  'var/log/news/news.err',
                  'var/log/news/news.notice',
                  'var/log/news/suck.err',
                  'var/log/news/suck.notice',
                  'var/log/messages',
                  'var/log/messages.1',
                  'var/log/user.log',
                  'var/log/user.log.1',
                  'var/log/auth.log',
                  'var/log/pm-powersave.log',
                  'var/log/xorg.0.log',
                  'var/log/daemon.log',
                  'var/log/daemon.log.1',
                  'var/log/kern.log',
                  'var/log/kern.log.1',
                  'var/log/mail.err',
                  'var/log/mail.info',
                  'var/log/mail.warn',
                  'var/log/ufw.log',
                  'var/log/boot.log',
                  'var/log/syslog',
                  'var/log/syslog.1',
                  'var/log/squirrelmail.log',
                  'var/log/apache2/squirrelmail.log',
                  'var/log/apache2/squirrelmail.err.log',
                  'var/log/mail.log',
                  'var/log/vmware/hostd.log',
                  'var/log/vmware/hostd-1.log',
                  '/wp-config.php',
                  '/wp-config.bak',
                  '/wp-config.old',
                  '/wp-config.temp',
                  '/wp-config.tmp',
                  '/wp-config.txt',
                  '/config.yml',
                  '/config_dev.yml',
                  '/config_prod.yml',
                  '/config_test.yml',
                  '/parameters.yml',
                  '/routing.yml',
                  '/security.yml',
                  '/services.yml',
                  'sites/default/default.settings.php',
                  'sites/default/settings.php',
                  'sites/default/settings.local.php',
                  'app/etc/local.xml',
                  '/sftp-config.json',
                  '/web.config',
                  'includes/config.php',
                  'includes/configure.php',
                  '/config.inc.php',
                  '/localsettings.php',
                  'inc/config.php',
                  'typo3conf/localconf.php',
                  'config/app.php',
                  'config/custom.php',
                  'config/database.php',
                  '/configuration.php',
                  '/config.php',
                  'var/mail/www-data',
                  'etc/network/',
                  'etc/init/',
                  'inetpub/wwwroot/global.asa',
                  'system32/inetsrv/config/applicationhost.config',
                  'system32/inetsrv/config/administration.config',
                  'system32/inetsrv/config/redirection.config',
                  'system32/config/default',
                  'system32/config/sam',
                  'system32/config/system',
                  'system32/config/software',
                  'winnt/repair/sam._',
                  '/package.json',
                  '/package-lock.json',
                  '/gruntfile.js',
                  '/npm-debug.log',
                  '/ormconfig.json',
                  '/tsconfig.json',
                  '/webpack.config.js',
                  '/yarn.lock',
                  'proc/0',
                  'proc/1',
                  'proc/2',
                  'proc/3',
                  'proc/4',
                  'proc/5',
                  'proc/6',
                  'proc/7',
                  'proc/8',
                  'proc/9',
                  'proc/acpi',
                  'proc/asound',
                  'proc/bootconfig',
                  'proc/buddyinfo',
                  'proc/bus',
                  'proc/cgroups',
                  'proc/cmdline',
                  'proc/config.gz',
                  'proc/consoles',
                  'proc/cpuinfo',
                  'proc/crypto',
                  'proc/devices',
                  'proc/diskstats',
                  'proc/dma',
                  'proc/docker',
                  'proc/driver',
                  'proc/dynamic_debug',
                  'proc/execdomains',
                  'proc/fb',
                  'proc/filesystems',
                  'proc/fs',
                  'proc/interrupts',
                  'proc/iomem',
                  'proc/ioports',
                  'proc/ipmi',
                  'proc/irq',
                  'proc/kallsyms',
                  'proc/kcore',
                  'proc/keys',
                  'proc/keys',
                  'proc/key-users',
                  'proc/kmsg',
                  'proc/kpagecgroup',
                  'proc/kpagecount',
                  'proc/kpageflags',
                  'proc/latency_stats',
                  'proc/loadavg',
                  'proc/locks',
                  'proc/mdstat',
                  'proc/meminfo',
                  'proc/misc',
                  'proc/modules',
                  'proc/mounts',
                  'proc/mpt',
                  'proc/mtd',
                  'proc/mtrr',
                  'proc/net',
                  'proc/net/tcp',
                  'proc/net/udp',
                  'proc/pagetypeinfo',
                  'proc/partitions',
                  'proc/pressure',
                  'proc/sched_debug',
                  'proc/schedstat',
                  'proc/scsi',
                  'proc/self',
                  'proc/self/cmdline',
                  'proc/self/environ',
                  'proc/self/fd/0',
                  'proc/self/fd/1',
                  'proc/self/fd/10',
                  'proc/self/fd/11',
                  'proc/self/fd/12',
                  'proc/self/fd/13',
                  'proc/self/fd/14',
                  'proc/self/fd/15',
                  'proc/self/fd/2',
                  'proc/self/fd/3',
                  'proc/self/fd/4',
                  'proc/self/fd/5',
                  'proc/self/fd/6',
                  'proc/self/fd/7',
                  'proc/self/fd/8',
                  'proc/self/fd/9',
                  'proc/self/mounts',
                  'proc/self/stat',
                  'proc/self/status',
                  'proc/slabinfo',
                  'proc/softirqs',
                  'proc/stat',
                  'proc/swaps',
                  'proc/sys',
                  'proc/sysrq-trigger',
                  'proc/sysvipc',
                  'proc/thread-self',
                  'proc/timer_list',
                  'proc/timer_stats',
                  'proc/tty',
                  'proc/uptime',
                  'proc/version',
                  'proc/version_signature',
                  'proc/vmallocinfo',
                  'proc/vmstat',
                  'proc/zoneinfo',
                  'sys/block',
                  'sys/bus',
                  'sys/class',
                  'sys/dev',
                  'sys/devices',
                  'sys/firmware',
                  'sys/fs',
                  'sys/hypervisor',
                  'sys/kernel',
                  'sys/module',
                  'sys/power',
                  'windows\\win.ini',
                  'default\\ntuser.dat',
                  '/var/run/secrets/kubernetes.io/serviceaccount',
                ],
                options: {
                  enforce_word_boundary: true,
                },
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase', 'normalizePath'],
        },
        {
          id: 'crs-931-110',
          name: 'RFI: Common RFI Vulnerable Parameter Name used w/ URL Payload',
          tags: {
            type: 'rfi',
            crs_id: '931110',
            category: 'attack_attempt',
            cwe: '98',
            capec: '1000/152/175/253/193',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                ],
                regex:
                  '(?:\\binclude\\s*\\([^)]*|mosConfig_absolute_path|_CONF\\[path\\]|_SERVER\\[DOCUMENT_ROOT\\]|GALLERY_BASEDIR|path\\[docroot\\]|appserv_root|config\\[root_dir\\])=(?:file|ftps?|https?)://',
                options: {
                  min_length: 15,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-931-120',
          name: 'RFI: URL Payload Used w/Trailing Question Mark Character (?)',
          tags: {
            type: 'rfi',
            crs_id: '931120',
            category: 'attack_attempt',
            cwe: '98',
            capec: '1000/152/175/253/193',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '^(?i:file|ftps?)://.*?\\?+$',
                options: {
                  case_sensitive: true,
                  min_length: 4,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-932-160',
          name: 'Remote Command Execution: Unix Shell Code Found',
          tags: {
            type: 'command_injection',
            crs_id: '932160',
            category: 'attack_attempt',
            cwe: '77',
            capec: '1000/152/248/88',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                options: {
                  enforce_word_boundary: true,
                },
                list: [
                  '${cdpath}',
                  '${dirstack}',
                  '${home}',
                  '${hostname}',
                  '${ifs}',
                  '${oldpwd}',
                  '${ostype}',
                  '${path}',
                  '${pwd}',
                  '$cdpath',
                  '$dirstack',
                  '$home',
                  '$hostname',
                  '$ifs',
                  '$oldpwd',
                  '$ostype',
                  '$pwd',
                  'dev/fd/',
                  'dev/null',
                  'dev/stderr',
                  'dev/stdin',
                  'dev/stdout',
                  'dev/tcp/',
                  'dev/udp/',
                  'dev/zero',
                  'etc/master.passwd',
                  'etc/pwd.db',
                  'etc/shells',
                  'etc/spwd.db',
                  'proc/self/',
                  'bin/7z',
                  'bin/7za',
                  'bin/7zr',
                  'bin/ab',
                  'bin/agetty',
                  'bin/ansible-playbook',
                  'bin/apt',
                  'bin/apt-get',
                  'bin/ar',
                  'bin/aria2c',
                  'bin/arj',
                  'bin/arp',
                  'bin/as',
                  'bin/ascii-xfr',
                  'bin/ascii85',
                  'bin/ash',
                  'bin/aspell',
                  'bin/at',
                  'bin/atobm',
                  'bin/awk',
                  'bin/base32',
                  'bin/base64',
                  'bin/basenc',
                  'bin/bash',
                  'bin/bpftrace',
                  'bin/bridge',
                  'bin/bundler',
                  'bin/bunzip2',
                  'bin/busctl',
                  'bin/busybox',
                  'bin/byebug',
                  'bin/bzcat',
                  'bin/bzcmp',
                  'bin/bzdiff',
                  'bin/bzegrep',
                  'bin/bzexe',
                  'bin/bzfgrep',
                  'bin/bzgrep',
                  'bin/bzip2',
                  'bin/bzip2recover',
                  'bin/bzless',
                  'bin/bzmore',
                  'bin/bzz',
                  'bin/c89',
                  'bin/c99',
                  'bin/cancel',
                  'bin/capsh',
                  'bin/cat',
                  'bin/cc',
                  'bin/certbot',
                  'bin/check_by_ssh',
                  'bin/check_cups',
                  'bin/check_log',
                  'bin/check_memory',
                  'bin/check_raid',
                  'bin/check_ssl_cert',
                  'bin/check_statusfile',
                  'bin/chmod',
                  'bin/choom',
                  'bin/chown',
                  'bin/chroot',
                  'bin/clang',
                  'bin/clang++',
                  'bin/cmp',
                  'bin/cobc',
                  'bin/column',
                  'bin/comm',
                  'bin/composer',
                  'bin/core_perl/zipdetails',
                  'bin/cowsay',
                  'bin/cowthink',
                  'bin/cp',
                  'bin/cpan',
                  'bin/cpio',
                  'bin/cpulimit',
                  'bin/crash',
                  'bin/crontab',
                  'bin/csh',
                  'bin/csplit',
                  'bin/csvtool',
                  'bin/cupsfilter',
                  'bin/curl',
                  'bin/cut',
                  'bin/dash',
                  'bin/date',
                  'bin/dd',
                  'bin/dev/fd/',
                  'bin/dev/null',
                  'bin/dev/stderr',
                  'bin/dev/stdin',
                  'bin/dev/stdout',
                  'bin/dev/tcp/',
                  'bin/dev/udp/',
                  'bin/dev/zero',
                  'bin/dialog',
                  'bin/diff',
                  'bin/dig',
                  'bin/dmesg',
                  'bin/dmidecode',
                  'bin/dmsetup',
                  'bin/dnf',
                  'bin/docker',
                  'bin/dosbox',
                  'bin/dpkg',
                  'bin/du',
                  'bin/dvips',
                  'bin/easy_install',
                  'bin/eb',
                  'bin/echo',
                  'bin/ed',
                  'bin/efax',
                  'bin/emacs',
                  'bin/env',
                  'bin/eqn',
                  'bin/es',
                  'bin/esh',
                  'bin/etc/group',
                  'bin/etc/master.passwd',
                  'bin/etc/passwd',
                  'bin/etc/pwd.db',
                  'bin/etc/shadow',
                  'bin/etc/shells',
                  'bin/etc/spwd.db',
                  'bin/ex',
                  'bin/exiftool',
                  'bin/expand',
                  'bin/expect',
                  'bin/expr',
                  'bin/facter',
                  'bin/fetch',
                  'bin/file',
                  'bin/find',
                  'bin/finger',
                  'bin/fish',
                  'bin/flock',
                  'bin/fmt',
                  'bin/fold',
                  'bin/fping',
                  'bin/ftp',
                  'bin/gawk',
                  'bin/gcc',
                  'bin/gcore',
                  'bin/gdb',
                  'bin/gem',
                  'bin/genie',
                  'bin/genisoimage',
                  'bin/ghc',
                  'bin/ghci',
                  'bin/gimp',
                  'bin/ginsh',
                  'bin/git',
                  'bin/grc',
                  'bin/grep',
                  'bin/gtester',
                  'bin/gunzip',
                  'bin/gzexe',
                  'bin/gzip',
                  'bin/hd',
                  'bin/head',
                  'bin/hexdump',
                  'bin/highlight',
                  'bin/hping3',
                  'bin/iconv',
                  'bin/id',
                  'bin/iftop',
                  'bin/install',
                  'bin/ionice',
                  'bin/ip',
                  'bin/irb',
                  'bin/ispell',
                  'bin/jjs',
                  'bin/join',
                  'bin/journalctl',
                  'bin/jq',
                  'bin/jrunscript',
                  'bin/knife',
                  'bin/ksh',
                  'bin/ksshell',
                  'bin/latex',
                  'bin/ld',
                  'bin/ldconfig',
                  'bin/less',
                  'bin/lftp',
                  'bin/ln',
                  'bin/loginctl',
                  'bin/logsave',
                  'bin/look',
                  'bin/lp',
                  'bin/ls',
                  'bin/ltrace',
                  'bin/lua',
                  'bin/lualatex',
                  'bin/luatex',
                  'bin/lwp-download',
                  'bin/lwp-request',
                  'bin/lz',
                  'bin/lz4',
                  'bin/lz4c',
                  'bin/lz4cat',
                  'bin/lzcat',
                  'bin/lzcmp',
                  'bin/lzdiff',
                  'bin/lzegrep',
                  'bin/lzfgrep',
                  'bin/lzgrep',
                  'bin/lzless',
                  'bin/lzma',
                  'bin/lzmadec',
                  'bin/lzmainfo',
                  'bin/lzmore',
                  'bin/mail',
                  'bin/make',
                  'bin/man',
                  'bin/mawk',
                  'bin/mkfifo',
                  'bin/mknod',
                  'bin/more',
                  'bin/mosquitto',
                  'bin/mount',
                  'bin/msgattrib',
                  'bin/msgcat',
                  'bin/msgconv',
                  'bin/msgfilter',
                  'bin/msgmerge',
                  'bin/msguniq',
                  'bin/mtr',
                  'bin/mv',
                  'bin/mysql',
                  'bin/nano',
                  'bin/nasm',
                  'bin/nawk',
                  'bin/nc',
                  'bin/ncat',
                  'bin/neofetch',
                  'bin/nice',
                  'bin/nl',
                  'bin/nm',
                  'bin/nmap',
                  'bin/node',
                  'bin/nohup',
                  'bin/npm',
                  'bin/nroff',
                  'bin/nsenter',
                  'bin/octave',
                  'bin/od',
                  'bin/openssl',
                  'bin/openvpn',
                  'bin/openvt',
                  'bin/opkg',
                  'bin/paste',
                  'bin/pax',
                  'bin/pdb',
                  'bin/pdflatex',
                  'bin/pdftex',
                  'bin/pdksh',
                  'bin/perf',
                  'bin/perl',
                  'bin/pg',
                  'bin/php',
                  'bin/php-cgi',
                  'bin/php5',
                  'bin/php7',
                  'bin/pic',
                  'bin/pico',
                  'bin/pidstat',
                  'bin/pigz',
                  'bin/pip',
                  'bin/pkexec',
                  'bin/pkg',
                  'bin/pr',
                  'bin/printf',
                  'bin/proc/self/',
                  'bin/pry',
                  'bin/ps',
                  'bin/psed',
                  'bin/psftp',
                  'bin/psql',
                  'bin/ptx',
                  'bin/puppet',
                  'bin/pxz',
                  'bin/python',
                  'bin/python2',
                  'bin/python3',
                  'bin/rake',
                  'bin/rbash',
                  'bin/rc',
                  'bin/readelf',
                  'bin/red',
                  'bin/redcarpet',
                  'bin/restic',
                  'bin/rev',
                  'bin/rlogin',
                  'bin/rlwrap',
                  'bin/rpm',
                  'bin/rpmquery',
                  'bin/rsync',
                  'bin/ruby',
                  'bin/run-mailcap',
                  'bin/run-parts',
                  'bin/rview',
                  'bin/rvim',
                  'bin/sash',
                  'bin/sbin/capsh',
                  'bin/sbin/logsave',
                  'bin/sbin/service',
                  'bin/sbin/start-stop-daemon',
                  'bin/scp',
                  'bin/screen',
                  'bin/script',
                  'bin/sed',
                  'bin/service',
                  'bin/setarch',
                  'bin/sftp',
                  'bin/sg',
                  'bin/sh',
                  'bin/shuf',
                  'bin/sleep',
                  'bin/slsh',
                  'bin/smbclient',
                  'bin/snap',
                  'bin/socat',
                  'bin/soelim',
                  'bin/sort',
                  'bin/split',
                  'bin/sqlite3',
                  'bin/ss',
                  'bin/ssh',
                  'bin/ssh-keygen',
                  'bin/ssh-keyscan',
                  'bin/sshpass',
                  'bin/start-stop-daemon',
                  'bin/stdbuf',
                  'bin/strace',
                  'bin/strings',
                  'bin/su',
                  'bin/sysctl',
                  'bin/systemctl',
                  'bin/systemd-resolve',
                  'bin/tac',
                  'bin/tail',
                  'bin/tar',
                  'bin/task',
                  'bin/taskset',
                  'bin/tbl',
                  'bin/tclsh',
                  'bin/tcpdump',
                  'bin/tcsh',
                  'bin/tee',
                  'bin/telnet',
                  'bin/tex',
                  'bin/tftp',
                  'bin/tic',
                  'bin/time',
                  'bin/timedatectl',
                  'bin/timeout',
                  'bin/tmux',
                  'bin/top',
                  'bin/troff',
                  'bin/tshark',
                  'bin/ul',
                  'bin/uname',
                  'bin/uncompress',
                  'bin/unexpand',
                  'bin/uniq',
                  'bin/unlz4',
                  'bin/unlzma',
                  'bin/unpigz',
                  'bin/unrar',
                  'bin/unshare',
                  'bin/unxz',
                  'bin/unzip',
                  'bin/unzstd',
                  'bin/update-alternatives',
                  'bin/uudecode',
                  'bin/uuencode',
                  'bin/valgrind',
                  'bin/vi',
                  'bin/view',
                  'bin/vigr',
                  'bin/vim',
                  'bin/vimdiff',
                  'bin/vipw',
                  'bin/virsh',
                  'bin/volatility',
                  'bin/wall',
                  'bin/watch',
                  'bin/wc',
                  'bin/wget',
                  'bin/whiptail',
                  'bin/who',
                  'bin/whoami',
                  'bin/whois',
                  'bin/wireshark',
                  'bin/wish',
                  'bin/xargs',
                  'bin/xelatex',
                  'bin/xetex',
                  'bin/xmodmap',
                  'bin/xmore',
                  'bin/xpad',
                  'bin/xxd',
                  'bin/xz',
                  'bin/xzcat',
                  'bin/xzcmp',
                  'bin/xzdec',
                  'bin/xzdiff',
                  'bin/xzegrep',
                  'bin/xzfgrep',
                  'bin/xzgrep',
                  'bin/xzless',
                  'bin/xzmore',
                  'bin/yarn',
                  'bin/yelp',
                  'bin/yes',
                  'bin/yum',
                  'bin/zathura',
                  'bin/zip',
                  'bin/zipcloak',
                  'bin/zipcmp',
                  'bin/zipdetails',
                  'bin/zipgrep',
                  'bin/zipinfo',
                  'bin/zipmerge',
                  'bin/zipnote',
                  'bin/zipsplit',
                  'bin/ziptool',
                  'bin/zsh',
                  'bin/zsoelim',
                  'bin/zstd',
                  'bin/zstdcat',
                  'bin/zstdgrep',
                  'bin/zstdless',
                  'bin/zstdmt',
                  'bin/zypper',
                ],
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase', 'cmdLine'],
        },
        {
          id: 'crs-932-171',
          name: 'Remote Command Execution: Shellshock (CVE-2014-6271)',
          tags: {
            type: 'command_injection',
            crs_id: '932171',
            category: 'attack_attempt',
            cwe: '77',
            capec: '1000/152/248/88',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '^\\(\\s*\\)\\s+{',
                options: {
                  case_sensitive: true,
                  min_length: 4,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-932-180',
          name: 'Restricted File Upload Attempt',
          tags: {
            type: 'command_injection',
            crs_id: '932180',
            category: 'attack_attempt',
            cwe: '706',
            capec: '1000/225/122/17/177',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x-filename'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x_filename'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x-file-name'],
                  },
                ],
                list: [
                  '.htaccess',
                  '.htdigest',
                  '.htpasswd',
                  'wp-config.php',
                  'config.yml',
                  'config_dev.yml',
                  'config_prod.yml',
                  'config_test.yml',
                  'parameters.yml',
                  'routing.yml',
                  'security.yml',
                  'services.yml',
                  'default.settings.php',
                  'settings.php',
                  'settings.local.php',
                  'local.xml',
                  '.env',
                ],
                options: {
                  enforce_word_boundary: true,
                },
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-933-111',
          name: 'PHP Injection Attack: PHP Script File Upload Found',
          tags: {
            type: 'unrestricted_file_upload',
            crs_id: '933111',
            category: 'attack_attempt',
            cwe: '434',
            capec: '1000/225/122/17/650',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x-filename'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x_filename'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x.filename'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x-file-name'],
                  },
                ],
                regex: '.*\\.(?:php\\d*|phtml)\\..*$',
                options: {
                  case_sensitive: true,
                  min_length: 5,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-933-130',
          name: 'PHP Injection Attack: Global Variables Found',
          tags: {
            type: 'php_code_injection',
            crs_id: '933130',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/225/122/17/650',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                options: {
                  enforce_word_boundary: true,
                },
                list: [
                  '$globals',
                  '$_cookie',
                  '$_env',
                  '$_files',
                  '$_get',
                  '$_post',
                  '$_request',
                  '$_server',
                  '$_session',
                  '$argc',
                  '$argv',
                  '$http_\\u200bresponse_\\u200bheader',
                  '$php_\\u200berrormsg',
                  '$http_cookie_vars',
                  '$http_env_vars',
                  '$http_get_vars',
                  '$http_post_files',
                  '$http_post_vars',
                  '$http_raw_post_data',
                  '$http_request_vars',
                  '$http_server_vars',
                ],
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-933-131',
          name: 'PHP Injection Attack: HTTP Headers Values Found',
          tags: {
            type: 'php_code_injection',
            crs_id: '933131',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/225/122/17/650',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?:HTTP_(?:ACCEPT(?:_(?:ENCODING|LANGUAGE|CHARSET))?|(?:X_FORWARDED_FO|REFERE)R|(?:USER_AGEN|HOS)T|CONNECTION|KEEP_ALIVE)|PATH_(?:TRANSLATED|INFO)|ORIG_PATH_INFO|QUERY_STRING|REQUEST_URI|AUTH_TYPE)',
                options: {
                  case_sensitive: true,
                  min_length: 9,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-933-140',
          name: 'PHP Injection Attack: I/O Stream Found',
          tags: {
            type: 'php_code_injection',
            crs_id: '933140',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/225/122/17/650',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: 'php://(?:std(?:in|out|err)|(?:in|out)put|fd|memory|temp|filter)',
                options: {
                  min_length: 8,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-933-150',
          name: 'PHP Injection Attack: High-Risk PHP Function Name Found',
          tags: {
            type: 'php_code_injection',
            crs_id: '933150',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/225/122/17/650',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                list: [
                  '__halt_compiler',
                  'apache_child_terminate',
                  'base64_decode',
                  'bzdecompress',
                  'call_user_func',
                  'call_user_func_array',
                  'call_user_method',
                  'call_user_method_array',
                  'convert_uudecode',
                  'file_get_contents',
                  'file_put_contents',
                  'fsockopen',
                  'get_class_methods',
                  'get_class_vars',
                  'get_defined_constants',
                  'get_defined_functions',
                  'get_defined_vars',
                  'gzdecode',
                  'gzinflate',
                  'gzuncompress',
                  'include_once',
                  'invokeargs',
                  'pcntl_exec',
                  'pcntl_fork',
                  'pfsockopen',
                  'posix_getcwd',
                  'posix_getpwuid',
                  'posix_getuid',
                  'posix_uname',
                  'reflectionfunction',
                  'require_once',
                  'shell_exec',
                  'str_rot13',
                  'sys_get_temp_dir',
                  'wp_remote_fopen',
                  'wp_remote_get',
                  'wp_remote_head',
                  'wp_remote_post',
                  'wp_remote_request',
                  'wp_safe_remote_get',
                  'wp_safe_remote_head',
                  'wp_safe_remote_post',
                  'wp_safe_remote_request',
                  'zlib_decode',
                ],
                options: {
                  enforce_word_boundary: true,
                },
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-933-160',
          name: 'PHP Injection Attack: High-Risk PHP Function Call Found',
          tags: {
            type: 'php_code_injection',
            crs_id: '933160',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/225/122/17/650',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: `\\b(?:s(?:e(?:t(?:_(?:e(?:xception|rror)_handler|magic_quotes_runtime|include_path)|defaultstub)|ssion_s(?:et_save_handler|tart))|qlite_(?:(?:(?:unbuffered|single|array)_)?query|create_(?:aggregate|function)|p?open|exec)|tr(?:eam_(?:context_create|socket_client)|ipc?slashes|rev)|implexml_load_(?:string|file)|ocket_c(?:onnect|reate)|h(?:ow_sourc|a1_fil)e|pl_autoload_register|ystem)|p(?:r(?:eg_(?:replace(?:_callback(?:_array)?)?|match(?:_all)?|split)|oc_(?:(?:terminat|clos|nic)e|get_status|open)|int_r)|o(?:six_(?:get(?:(?:e[gu]|g)id|login|pwnam)|mk(?:fifo|nod)|ttyname|kill)|pen)|hp(?:_(?:strip_whitespac|unam)e|version|info)|g_(?:(?:execut|prepar)e|connect|query)|a(?:rse_(?:ini_file|str)|ssthru)|utenv)|r(?:unkit_(?:function_(?:re(?:defin|nam)e|copy|add)|method_(?:re(?:defin|nam)e|copy|add)|constant_(?:redefine|add))|e(?:(?:gister_(?:shutdown|tick)|name)_function|ad(?:(?:gz)?file|_exif_data|dir))|awurl(?:de|en)code)|i(?:mage(?:createfrom(?:(?:jpe|pn)g|x[bp]m|wbmp|gif)|(?:jpe|pn)g|g(?:d2?|if)|2?wbmp|xbm)|s_(?:(?:(?:execut|write?|read)ab|fi)le|dir)|ni_(?:get(?:_all)?|set)|terator_apply|ptcembed)|g(?:et(?:_(?:c(?:urrent_use|fg_va)r|meta_tags)|my(?:[gpu]id|inode)|(?:lastmo|cw)d|imagesize|env)|z(?:(?:(?:defla|wri)t|encod|fil)e|compress|open|read)|lob)|a(?:rray_(?:u(?:intersect(?:_u?assoc)?|diff(?:_u?assoc)?)|intersect_u(?:assoc|key)|diff_u(?:assoc|key)|filter|reduce|map)|ssert(?:_options)?|tob)|h(?:tml(?:specialchars(?:_decode)?|_entity_decode|entities)|(?:ash(?:_(?:update|hmac))?|ighlight)_file|e(?:ader_register_callback|x2bin))|f(?:i(?:le(?:(?:[acm]tim|inod)e|(?:_exist|perm)s|group)?|nfo_open)|tp_(?:nb_(?:ge|pu)|connec|ge|pu)t|(?:unction_exis|pu)ts|write|open)|o(?:b_(?:get_(?:c(?:ontents|lean)|flush)|end_(?:clean|flush)|clean|flush|start)|dbc_(?:result(?:_all)?|exec(?:ute)?|connect)|pendir)|m(?:b_(?:ereg(?:_(?:replace(?:_callback)?|match)|i(?:_replace)?)?|parse_str)|(?:ove_uploaded|d5)_file|ethod_exists|ysql_query|kdir)|e(?:x(?:if_(?:t(?:humbnail|agname)|imagetype|read_data)|ec)|scapeshell(?:arg|cmd)|rror_reporting|val)|c(?:url_(?:file_create|exec|init)|onvert_uuencode|reate_function|hr)|u(?:n(?:serialize|pack)|rl(?:de|en)code|[ak]?sort)|b(?:(?:son_(?:de|en)|ase64_en)code|zopen|toa)|(?:json_(?:de|en)cod|debug_backtrac|tmpfil)e|var_dump)(?:\\s|/\\*.*\\*/|//.*|#.*|\\"|')*\\((?:(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:\\$\\w+|[A-Z\\d]\\w*|\\w+\\(.*\\)|\\\\?"(?:[^"]|\\\\"|""|"\\+")*\\\\?"|\\\\?'(?:[^']|''|'\\+')*\\\\?')(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:(?:::|\\.|->)(?:\\s|/\\*.*\\*/|//.*|#.*)*\\w+(?:\\(.*\\))?)?,)*(?:(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:\\$\\w+|[A-Z\\d]\\w*|\\w+\\(.*\\)|\\\\?"(?:[^"]|\\\\"|""|"\\+")*\\\\?"|\\\\?'(?:[^']|''|'\\+')*\\\\?')(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:(?:::|\\.|->)(?:\\s|/\\*.*\\*/|//.*|#.*)*\\w+(?:\\(.*\\))?)?)?\\)\\s*(?:[;\\.)}\\]|\\\\]|\\?>|%>|$)`,
                options: {
                  case_sensitive: true,
                  min_length: 5,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-933-170',
          name: 'PHP Injection Attack: Serialized Object Injection',
          tags: {
            type: 'php_code_injection',
            crs_id: '933170',
            category: 'attack_attempt',
            cwe: '502',
            capec: '1000/152/586',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '[oOcC]:\\d+:\\".+?\\":\\d+:{[\\W\\w]*}',
                options: {
                  case_sensitive: true,
                  min_length: 12,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-933-200',
          name: 'PHP Injection Attack: Wrapper scheme detected',
          tags: {
            type: 'php_code_injection',
            crs_id: '933200',
            category: 'attack_attempt',
            cwe: '502',
            capec: '1000/152/586',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?:(?:bzip|ssh)2|z(?:lib|ip)|(?:ph|r)ar|expect|glob|ogg)://',
                options: {
                  case_sensitive: true,
                  min_length: 6,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-934-100',
          name: 'Node.js Injection Attack 1/2',
          tags: {
            type: 'js_code_injection',
            crs_id: '934100',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '\\b(?:(?:l(?:(?:utimes|chmod)(?:Sync)?|(?:stat|ink)Sync)|w(?:rite(?:(?:File|v)(?:Sync)?|Sync)|atchFile)|u(?:n(?:watchFile|linkSync)|times(?:Sync)?)|s(?:(?:ymlink|tat)Sync|pawn(?:File|Sync))|ex(?:ec(?:File(?:Sync)?|Sync)|istsSync)|a(?:ppendFile|ccess)(?:Sync)?|(?:Caveat|Inode)s|open(?:dir)?Sync|new\\s+Function|Availability|\\beval)\\s*\\(|m(?:ain(?:Module\\s*(?:\\W*\\s*(?:constructor|require)|\\[)|\\s*(?:\\W*\\s*(?:constructor|require)|\\[))|kd(?:temp(?:Sync)?|irSync)\\s*\\(|odule\\.exports\\s*=)|c(?:(?:(?:h(?:mod|own)|lose)Sync|reate(?:Write|Read)Stream|p(?:Sync)?)\\s*\\(|o(?:nstructor\\s*(?:\\W*\\s*_load|\\[)|pyFile(?:Sync)?\\s*\\())|f(?:(?:(?:s(?:(?:yncS)?|tatS)|datas(?:yncS)?)ync|ch(?:mod|own)(?:Sync)?)\\s*\\(|u(?:nction\\s*\\(\\s*\\)\\s*{|times(?:Sync)?\\s*\\())|r(?:e(?:(?:ad(?:(?:File|link|dir)?Sync|v(?:Sync)?)|nameSync)\\s*\\(|quire\\s*(?:\\W*\\s*main\\b|\\[))|m(?:Sync)?\\s*\\()|process\\s*(?:\\W*\\s*(?:mainModule|binding)|\\[)|t(?:his\\.constructor|runcateSync\\s*\\()|_(?:\\$\\$ND_FUNC\\$\\$_|_js_function)|global\\s*(?:\\W*\\s*process|\\[)|String\\s*\\.\\s*fromCharCode|binding\\s*\\[)',
                options: {
                  case_sensitive: true,
                  min_length: 3,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-934-101',
          name: 'Node.js Injection Attack 2/2',
          tags: {
            type: 'js_code_injection',
            crs_id: '934101',
            category: 'attack_attempt',
            confidence: '1',
            cwe: '94',
            capec: '1000/152/242',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\b(?:w(?:atch|rite)|(?:spaw|ope)n|exists|close|fork|read)\\s*\\(',
                options: {
                  case_sensitive: true,
                  min_length: 5,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-941-110',
          name: 'XSS Filter - Category 1: Script Tag Vector',
          tags: {
            type: 'xss',
            crs_id: '941110',
            category: 'attack_attempt',
            cwe: '80',
            capec: '1000/152/242/63/591',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['referer'],
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '<script[^>]*>[\\s\\S]*?',
                options: {
                  case_sensitive: false,
                  min_length: 8,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls', 'urlDecodeUni'],
        },
        {
          id: 'crs-941-120',
          name: 'XSS Filter - Category 2: Event Handler Vector',
          tags: {
            type: 'xss',
            crs_id: '941120',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['referer'],
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '\\bon(?:d(?:r(?:ag(?:en(?:ter|d)|leave|start|over)?|op)|urationchange|blclick)|s(?:e(?:ek(?:ing|ed)|arch|lect)|u(?:spend|bmit)|talled|croll|how)|m(?:ouse(?:(?:lea|mo)ve|o(?:ver|ut)|enter|down|up)|essage)|p(?:a(?:ge(?:hide|show)|(?:st|us)e)|lay(?:ing)?|rogress|aste|ointer(?:cancel|down|enter|leave|move|out|over|rawupdate|up))|c(?:anplay(?:through)?|o(?:ntextmenu|py)|hange|lick|ut)|a(?:nimation(?:iteration|start|end)|(?:fterprin|bor)t|uxclick|fterscriptexecute)|t(?:o(?:uch(?:cancel|start|move|end)|ggle)|imeupdate)|f(?:ullscreen(?:change|error)|ocus(?:out|in)?|inish)|(?:(?:volume|hash)chang|o(?:ff|n)lin)e|b(?:efore(?:unload|print)|lur)|load(?:ed(?:meta)?data|start|end)?|r(?:es(?:ize|et)|atechange)|key(?:press|down|up)|w(?:aiting|heel)|in(?:valid|put)|e(?:nded|rror)|unload)[\\s\\x0B\\x09\\x0C\\x3B\\x2C\\x28\\x3B]*?=[^=]',
                options: {
                  min_length: 8,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls', 'urlDecodeUni'],
        },
        {
          id: 'crs-941-140',
          name: 'XSS Filter - Category 4: Javascript URI Vector',
          tags: {
            type: 'xss',
            crs_id: '941140',
            category: 'attack_attempt',
            cwe: '84',
            capec: '1000/152/242/63/591/244',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['referer'],
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '[a-z]+=(?:[^:=]+:.+;)*?[^:=]+:url\\(javascript',
                options: {
                  min_length: 18,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls', 'urlDecodeUni'],
        },
        {
          id: 'crs-941-170',
          name: 'NoScript XSS InjectionChecker: Attribute Injection',
          tags: {
            type: 'xss',
            crs_id: '941170',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['referer'],
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: `(?:\\W|^)(?:javascript:(?:[\\s\\S]+[=\\x5c\\(\\[\\.<]|[\\s\\S]*?(?:\\bname\\b|\\x5c[ux]\\d)))|@\\W*?i\\W*?m\\W*?p\\W*?o\\W*?r\\W*?t\\W*?(?:/\\*[\\s\\S]*?)?(?:[\\"']|\\W*?u\\W*?r\\W*?l[\\s\\S]*?\\()|[^-]*?-\\W*?m\\W*?o\\W*?z\\W*?-\\W*?b\\W*?i\\W*?n\\W*?d\\W*?i\\W*?n\\W*?g[^:]*?:\\W*?u\\W*?r\\W*?l[\\s\\S]*?\\(`,
                options: {
                  min_length: 6,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls', 'urlDecodeUni'],
        },
        {
          id: 'crs-941-180',
          name: 'Node-Validator Deny List Keywords',
          tags: {
            type: 'xss',
            crs_id: '941180',
            category: 'attack_attempt',
            cwe: '79',
            capec: '1000/152/242/63/591',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                options: {
                  enforce_word_boundary: true,
                },
                list: [
                  'document.cookie',
                  'document.write',
                  '.parentnode',
                  '.innerhtml',
                  'window.location',
                  '-moz-binding',
                ],
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['removeNulls', 'lowercase'],
        },
        {
          id: 'crs-941-200',
          name: 'IE XSS Filters - Attack Detected via vmlframe tag',
          tags: {
            type: 'xss',
            crs_id: '941200',
            category: 'attack_attempt',
            cwe: '80',
            capec: '1000/152/242/63/591',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?i:<.*[:]?vmlframe.*?[\\s/+]*?src[\\s/+]*=)',
                options: {
                  case_sensitive: true,
                  min_length: 13,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-210',
          name: 'IE XSS Filters - Obfuscated Attack Detected via javascript injection',
          tags: {
            type: 'xss',
            crs_id: '941210',
            category: 'attack_attempt',
            cwe: '80',
            capec: '1000/152/242/63/591',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?i:(?:j|&#x?0*(?:74|4A|106|6A);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:a|&#x?0*(?:65|41|97|61);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:v|&#x?0*(?:86|56|118|76);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:a|&#x?0*(?:65|41|97|61);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:s|&#x?0*(?:83|53|115|73);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:c|&#x?0*(?:67|43|99|63);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:r|&#x?0*(?:82|52|114|72);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:i|&#x?0*(?:73|49|105|69);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:p|&#x?0*(?:80|50|112|70);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:t|&#x?0*(?:84|54|116|74);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?::|&(?:#x?0*(?:58|3A);?|colon;)).)',
                options: {
                  case_sensitive: true,
                  min_length: 12,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-220',
          name: 'IE XSS Filters - Obfuscated Attack Detected via vbscript injection',
          tags: {
            type: 'xss',
            crs_id: '941220',
            category: 'attack_attempt',
            cwe: '80',
            capec: '1000/152/242/63/591',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?i:(?:v|&#x?0*(?:86|56|118|76);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:b|&#x?0*(?:66|42|98|62);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:s|&#x?0*(?:83|53|115|73);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:c|&#x?0*(?:67|43|99|63);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:r|&#x?0*(?:82|52|114|72);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:i|&#x?0*(?:73|49|105|69);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:p|&#x?0*(?:80|50|112|70);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:t|&#x?0*(?:84|54|116|74);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?::|&(?:#x?0*(?:58|3A);?|colon;)).)',
                options: {
                  case_sensitive: true,
                  min_length: 10,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-230',
          name: 'IE XSS Filters - Attack Detected via embed tag',
          tags: {
            type: 'xss',
            crs_id: '941230',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '<EMBED[\\s/+].*?(?:src|type).*?=',
                options: {
                  min_length: 11,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-240',
          name: 'IE XSS Filters - Attack Detected via import tag',
          tags: {
            type: 'xss',
            crs_id: '941240',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '<[?]?import[\\s/+\\S]*?implementation[\\s/+]*?=',
                options: {
                  case_sensitive: true,
                  min_length: 22,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase', 'removeNulls'],
        },
        {
          id: 'crs-941-270',
          name: 'IE XSS Filters - Attack Detected via link tag',
          tags: {
            type: 'xss',
            crs_id: '941270',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '<LINK[\\s/+].*?href[\\s/+]*=',
                options: {
                  min_length: 11,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-280',
          name: 'IE XSS Filters - Attack Detected via base tag',
          tags: {
            type: 'xss',
            crs_id: '941280',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '<BASE[\\s/+].*?href[\\s/+]*=',
                options: {
                  min_length: 11,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-290',
          name: 'IE XSS Filters - Attack Detected via applet tag',
          tags: {
            type: 'xss',
            crs_id: '941290',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '<APPLET[\\s/+>]',
                options: {
                  min_length: 8,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-300',
          name: 'IE XSS Filters - Attack Detected via object tag',
          tags: {
            type: 'xss',
            crs_id: '941300',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '<OBJECT[\\s/+].*?(?:type|codetype|classid|code|data)[\\s/+]*=',
                options: {
                  min_length: 13,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-941-350',
          name: 'UTF-7 Encoding IE XSS - Attack Detected',
          tags: {
            type: 'xss',
            crs_id: '941350',
            category: 'attack_attempt',
            cwe: '87',
            capec: '1000/152/242/63/591/199',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\+ADw-.*(?:\\+AD4-|>)|<.*\\+AD4-',
                options: {
                  case_sensitive: true,
                  min_length: 6,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-941-360',
          name: 'JSFuck / Hieroglyphy obfuscation detected',
          tags: {
            type: 'xss',
            crs_id: '941360',
            category: 'attack_attempt',
            cwe: '87',
            capec: '1000/152/242/63/591/199',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '![!+ ]\\[\\]',
                options: {
                  case_sensitive: true,
                  min_length: 4,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-941-390',
          name: 'Javascript method detected',
          tags: {
            type: 'xss',
            crs_id: '941390',
            category: 'attack_attempt',
            confidence: '1',
            cwe: '79',
            capec: '1000/152/242/63/591',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\b(?i:eval|settimeout|setinterval|new\\s+Function|alert|prompt)[\\s+]*\\([^\\)]',
                options: {
                  case_sensitive: true,
                  min_length: 5,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-942-100',
          name: 'SQL Injection Attack Detected via libinjection',
          tags: {
            type: 'sql_injection',
            crs_id: '942100',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
              },
              operator: 'is_sqli',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'crs-942-160',
          name: 'Detects blind sqli tests using sleep() or benchmark()',
          tags: {
            type: 'sql_injection',
            crs_id: '942160',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66/7',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?i:sleep\\(\\s*?\\d*?\\s*?\\)|benchmark\\(.*?\\,.*?\\))',
                options: {
                  case_sensitive: true,
                  min_length: 7,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-942-240',
          name: 'Detects MySQL charset switch and MSSQL DoS attempts',
          tags: {
            type: 'sql_injection',
            crs_id: '942240',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66/7',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?:[\\"\'`](?:;*?\\s*?waitfor\\s+(?:delay|time)\\s+[\\"\'`]|;.*?:\\s*?goto)|alter\\s*?\\w+.*?cha(?:racte)?r\\s+set\\s+\\w+)',
                options: {
                  min_length: 7,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-942-250',
          name: 'Detects MATCH AGAINST, MERGE and EXECUTE IMMEDIATE injections',
          tags: {
            type: 'sql_injection',
            crs_id: '942250',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?i:merge.*?using\\s*?\\(|execute\\s*?immediate\\s*?[\\"\'`]|match\\s*?[\\w(?:),+-]+\\s*?against\\s*?\\()',
                options: {
                  case_sensitive: true,
                  min_length: 11,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-942-270',
          name: 'Basic SQL injection',
          tags: {
            type: 'sql_injection',
            crs_id: '942270',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: 'union.*?select.*?from',
                options: {
                  min_length: 15,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-942-280',
          name: 'SQL Injection with delay functions',
          tags: {
            type: 'sql_injection',
            crs_id: '942280',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66/7',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?:;\\s*?shutdown\\s*?(?:[#;{]|\\/\\*|--)|waitfor\\s*?delay\\s?[\\"\'`]+\\s?\\d|select\\s*?pg_sleep)',
                options: {
                  min_length: 10,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-942-290',
          name: 'Finds basic MongoDB SQL injection attempts',
          tags: {
            type: 'nosql_injection',
            crs_id: '942290',
            category: 'attack_attempt',
            cwe: '943',
            capec: '1000/152/248/676',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?i:(?:\\[?\\$(?:(?:s(?:lic|iz)|wher)e|e(?:lemMatch|xists|q)|n(?:o[rt]|in?|e)|l(?:ike|te?)|t(?:ext|ype)|a(?:ll|nd)|jsonSchema|between|regex|x?or|div|mod)\\]?)\\b)',
                options: {
                  case_sensitive: true,
                  min_length: 3,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['keys_only'],
        },
        {
          id: 'crs-942-360',
          name: 'Detects concatenated basic SQL injection and SQLLFI attempts',
          tags: {
            type: 'sql_injection',
            crs_id: '942360',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66/470',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?:^[\\W\\d]+\\s*?(?:alter\\s*(?:a(?:(?:pplication\\s*rol|ggregat)e|s(?:ymmetric\\s*ke|sembl)y|u(?:thorization|dit)|vailability\\s*group)|c(?:r(?:yptographic\\s*provider|edential)|o(?:l(?:latio|um)|nversio)n|ertificate|luster)|s(?:e(?:rv(?:ice|er)|curity|quence|ssion|arch)|y(?:mmetric\\s*key|nonym)|togroup|chema)|m(?:a(?:s(?:ter\\s*key|k)|terialized)|e(?:ssage\\s*type|thod)|odule)|l(?:o(?:g(?:file\\s*group|in)|ckdown)|a(?:ngua|r)ge|ibrary)|t(?:(?:abl(?:espac)?|yp)e|r(?:igger|usted)|hreshold|ext)|p(?:a(?:rtition|ckage)|ro(?:cedur|fil)e|ermission)|d(?:i(?:mension|skgroup)|atabase|efault|omain)|r(?:o(?:l(?:lback|e)|ute)|e(?:sourc|mot)e)|f(?:u(?:lltext|nction)|lashback|oreign)|e(?:xte(?:nsion|rnal)|(?:ndpoi|ve)nt)|in(?:dex(?:type)?|memory|stance)|b(?:roker\\s*priority|ufferpool)|x(?:ml\\s*schema|srobject)|w(?:ork(?:load)?|rapper)|hi(?:erarchy|stogram)|o(?:perator|utline)|(?:nicknam|queu)e|us(?:age|er)|group|java|view)|union\\s*(?:(?:distin|sele)ct|all))\\b|\\b(?:(?:(?:trunc|cre|upd)at|renam)e|(?:inser|selec)t|de(?:lete|sc)|alter|load)\\s+(?:group_concat|load_file|char)\\b\\s*\\(?|[\\s(]load_file\\s*?\\(|[\\"\'`]\\s+regexp\\W)',
                options: {
                  min_length: 5,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-942-500',
          name: 'MySQL in-line comment detected',
          tags: {
            type: 'sql_injection',
            crs_id: '942500',
            category: 'attack_attempt',
            cwe: '89',
            capec: '1000/152/248/66',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?i:/\\*[!+](?:[\\w\\s=_\\-(?:)]+)?\\*/)',
                options: {
                  case_sensitive: true,
                  min_length: 5,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-943-100',
          name: 'Possible Session Fixation Attack: Setting Cookie Values in HTML',
          tags: {
            type: 'http_protocol_violation',
            crs_id: '943100',
            category: 'attack_attempt',
            cwe: '384',
            capec: '1000/225/21/593/61',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?i:\\.cookie\\b.*?;\\W*?(?:expires|domain)\\W*?=|\\bhttp-equiv\\W+set-cookie\\b)',
                options: {
                  case_sensitive: true,
                  min_length: 15,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-944-100',
          name: 'Remote Command Execution: Suspicious Java class detected',
          tags: {
            type: 'java_code_injection',
            crs_id: '944100',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: 'java\\.lang\\.(?:runtime|processbuilder)',
                options: {
                  case_sensitive: true,
                  min_length: 17,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-944-110',
          name: 'Remote Command Execution: Java process spawn (CVE-2017-9805)',
          tags: {
            type: 'java_code_injection',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?:unmarshaller|base64data|java\\.).*(?:runtime|processbuilder)',
                options: {
                  case_sensitive: false,
                  min_length: 13,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'crs-944-130',
          name: 'Suspicious Java class detected',
          tags: {
            type: 'java_code_injection',
            crs_id: '944130',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                list: [
                  'com.opensymphony.xwork2',
                  'com.sun.org.apache',
                  'java.io.bufferedinputstream',
                  'java.io.bufferedreader',
                  'java.io.bytearrayinputstream',
                  'java.io.bytearrayoutputstream',
                  'java.io.chararrayreader',
                  'java.io.datainputstream',
                  'java.io.file',
                  'java.io.fileoutputstream',
                  'java.io.filepermission',
                  'java.io.filewriter',
                  'java.io.filterinputstream',
                  'java.io.filteroutputstream',
                  'java.io.filterreader',
                  'java.io.inputstream',
                  'java.io.inputstreamreader',
                  'java.io.linenumberreader',
                  'java.io.objectoutputstream',
                  'java.io.outputstream',
                  'java.io.pipedoutputstream',
                  'java.io.pipedreader',
                  'java.io.printstream',
                  'java.io.pushbackinputstream',
                  'java.io.reader',
                  'java.io.stringreader',
                  'java.lang.class',
                  'java.lang.integer',
                  'java.lang.number',
                  'java.lang.object',
                  'java.lang.process',
                  'java.lang.reflect',
                  'java.lang.runtime',
                  'java.lang.string',
                  'java.lang.stringbuilder',
                  'java.lang.system',
                  'javax.script.scriptenginemanager',
                  'org.apache.commons',
                  'org.apache.struts',
                  'org.apache.struts2',
                  'org.omg.corba',
                  'java.beans.xmldecode',
                ],
                options: {
                  enforce_word_boundary: true,
                },
              },
              operator: 'phrase_match',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'crs-944-260',
          name: 'Remote Command Execution: Malicious class-loading payload',
          tags: {
            type: 'java_code_injection',
            crs_id: '944260',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            confidence: '1',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?:class\\.module\\.classLoader\\.resources\\.context\\.parent\\.pipeline|springframework\\.context\\.support\\.FileSystemXmlApplicationContext)',
                options: {
                  case_sensitive: true,
                  min_length: 58,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-000-001',
          name: 'Look for Cassandra injections',
          tags: {
            type: 'nosql_injection',
            category: 'attack_attempt',
            cwe: '943',
            capec: '1000/152/248/676',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                regex: '\\ballow\\s+filtering\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeComments'],
        },
        {
          id: 'dog-000-002',
          name: 'OGNL - Look for formatting injection patterns',
          tags: {
            type: 'java_code_injection',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                regex: '[#%$]{(?:[^}]+[^\\w\\s}\\-_][^}]+|\\d+-\\d+)}',
                options: {
                  case_sensitive: true,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-000-003',
          name: 'OGNL - Detect OGNL exploitation primitives',
          tags: {
            type: 'java_code_injection',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '[@#]ognl',
                options: {
                  case_sensitive: true,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-000-004',
          name: 'Spring4Shell - Attempts to exploit the Spring4shell vulnerability',
          tags: {
            type: 'exploit_detection',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            confidence: '1',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.body',
                  },
                ],
                regex: '^class\\.module\\.classLoader\\.',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: ['keys_only'],
        },
        {
          id: 'dog-000-005',
          name: 'Node.js: Prototype pollution through __proto__',
          tags: {
            type: 'js_code_injection',
            category: 'attack_attempt',
            cwe: '1321',
            capec: '1000/152/242',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                ],
                regex: '^__proto__$',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['keys_only'],
        },
        {
          id: 'dog-000-006',
          name: 'Node.js: Prototype pollution through constructor.prototype',
          tags: {
            type: 'js_code_injection',
            category: 'attack_attempt',
            cwe: '1321',
            capec: '1000/152/242',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                ],
                regex: '^constructor$',
              },
              operator: 'match_regex',
            },
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                ],
                regex: '^prototype$',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['keys_only'],
        },
        {
          id: 'dog-000-007',
          name: 'Server side template injection: Velocity & Freemarker',
          tags: {
            type: 'java_code_injection',
            category: 'attack_attempt',
            cwe: '1336',
            capec: '1000/152/242/19',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '#(?:set|foreach|macro|parse|if)\\(.*\\)|<#assign.*>',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-68x',
          name: 'xorbot',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'xorbot',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bmasjesu\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-001',
          name: 'BurpCollaborator OOB domain',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            tool_name: 'BurpCollaborator',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\b(?:burpcollaborator\\.net|oastify\\.com)\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-002',
          name: 'Qualys OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'Qualys',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\bqualysperiscope\\.com\\b|\\.oscomm\\.',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-003',
          name: 'Probely OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'Probely',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\bprbly\\.win\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-004',
          name: 'Known malicious out-of-band interaction domain',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '\\b(?:webhook\\.site|\\.canarytokens\\.com|vii\\.one|act1on3\\.ru|gdsburp\\.com|arcticwolf\\.net|oob\\.li|htbiw\\.com|h4\\.vc|mochan\\.cloud|imshopping\\.com|bootstrapnodejs\\.com|mooo-ng\\.com|securitytrails\\.com|canyouhackit\\.io|7bae\\.xyz)\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-005',
          name: 'Known suspicious out-of-band interaction domain',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\b(?:\\.ngrok\\.io|requestbin\\.com|requestbin\\.net)\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-006',
          name: 'Rapid7 OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'Rapid7',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\bappspidered\\.rapid7\\.',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-007',
          name: 'Interact.sh OOB domain',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            tool_name: 'interact.sh',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '\\b(?:interact\\.sh|oast\\.(?:pro|live|site|online|fun|me)|indusfacefinder\\.in|where\\.land|syhunt\\.net|tssrt\\.de|boardofcyber\\.io|assetnote-callback\\.com|praetorianlabs\\.dev|netspi\\.sh)\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-008',
          name: 'Netsparker OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'Netsparker',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\b(?:\\.|(?:\\\\|&#)(?:0*46|x0*2e);)?r87(?:\\.|(?:\\\\|&#)(?:0*46|x0*2e);)(?:me|com)\\b',
                options: {
                  case_sensitive: false,
                  min_length: 7,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-009',
          name: 'WhiteHat Security OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'WhiteHatSecurity',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\bwhsec(?:\\.|(?:\\\\|&#)(?:0*46|x0*2e);)us\\b',
                options: {
                  case_sensitive: false,
                  min_length: 8,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-010',
          name: 'Nessus OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'Nessus',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\b\\.nessus\\.org\\b',
                options: {
                  case_sensitive: false,
                  min_length: 8,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-011',
          name: 'Watchtowr OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'Watchtowr',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\bwatchtowr\\.com\\b',
                options: {
                  case_sensitive: false,
                  min_length: 8,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-012',
          name: 'AppCheck NG OOB domain',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            tool_name: 'AppCheckNG',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\bptst\\.io\\b',
                options: {
                  case_sensitive: false,
                  min_length: 7,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-013',
          name: 'Public PoC for CVE-2025-24813',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: '/iSee857/session',
                options: {
                  case_sensitive: false,
                  min_length: 16,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-913-014',
          name: 'Exploit attempt for Next.js Middleware Exploit (CVE-2025-29927)',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x-middleware-subrequest'],
                  },
                ],
                regex: '.*',
                options: {
                  min_length: 1,
                },
              },
              operator: 'match_regex',
            },
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['x-middleware-subrequest'],
                  },
                ],
                regex: '[0-9a-fA-F]{40}|\\[\\w+\\]',
              },
              operator: '!match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-920-001',
          name: 'JWT authentication bypass',
          tags: {
            type: 'http_protocol_violation',
            category: 'attack_attempt',
            cwe: '287',
            capec: '1000/225/115',
            confidence: '0',
            module: 'waf',
          },
          max_version: '1.24.9',
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.cookies',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['authorization'],
                  },
                ],
                regex:
                  '^(?:Bearer )?ey[A-Za-z0-9+_\\-/]*([QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDogI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]IiA6ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciIDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgOiJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciOiJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]IjogI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]IiA6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciIDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6I[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]Ijoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f])[A-Za-z0-9+-/]*\\.[A-Za-z0-9+_\\-/]+\\.(?:[A-Za-z0-9+_\\-/]+)?$',
                options: {
                  case_sensitive: true,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-931-001',
          name: 'RFI: URL Payload to well known RFI target',
          tags: {
            type: 'rfi',
            category: 'attack_attempt',
            cwe: '98',
            capec: '1000/152/175/253/193',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '^(?i:file|ftps?|https?).*/rfiinc\\.txt\\?+$',
                options: {
                  case_sensitive: true,
                  min_length: 17,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-932-100',
          name: 'Shell spawn executing network command',
          tags: {
            type: 'command_injection',
            category: 'attack_attempt',
            cwe: '77',
            capec: '1000/152/248/88',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: `(?:(?:['"\\x60({|;&]|(?:^|['"\\x60({|;&])(?:cmd(?:\\.exe)?\\s+(?:/\\w(?::\\w+)?\\s+)*))(?:ping|curl|wget|telnet)|\\bnslookup)[\\s,]`,
                options: {
                  case_sensitive: true,
                  min_length: 5,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-932-110',
          name: 'Python: Subprocess-based command injection',
          tags: {
            type: 'command_injection',
            category: 'attack_attempt',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?s)\\bsubprocess\\b.*\\b(?:check_output|run|Popen|call|check_call)\\b',
                options: {
                  case_sensitive: true,
                  min_length: 14,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-934-001',
          name: 'XXE - XML file loads external entity',
          tags: {
            type: 'xxe',
            category: 'attack_attempt',
            cwe: '91',
            capec: '1000/152/248/250',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?:<\\?xml[^>]*>.*)<!ENTITY[^>]+SYSTEM\\s+[^>]+>',
                options: {
                  case_sensitive: false,
                  min_length: 24,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'dog-941-001',
          name: 'XSS in source property',
          tags: {
            type: 'xss',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['referer'],
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: `<(?:iframe|esi:include)(?:(?:\\s|/)*\\w+=["'\\w]+)*(?:\\s|/)*src(?:doc)?=["']?(?:data:|javascript:|http:|dns:|//)[^\\s'"]+['"]?`,
                options: {
                  min_length: 14,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls', 'urlDecodeUni'],
        },
        {
          id: 'dog-942-001',
          name: 'Blind XSS callback domains',
          tags: {
            type: 'xss',
            category: 'attack_attempt',
            cwe: '83',
            capec: '1000/152/242/63/591/243',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: 'https?:\\/\\/(?:.*\\.)?(?:bxss\\.(?:in|me)|xss\\.ht|js\\.rip)',
                options: {
                  case_sensitive: false,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-001',
          name: 'Detect common directory discovery scans',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'phrase_match',
              parameters: {
                options: {
                  enforce_word_boundary: true,
                },
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                list: [
                  '/wordpress/',
                  '/etc/',
                  '/login.php',
                  '/install.php',
                  '/administrator',
                  '/admin.php',
                  '/wp-config',
                  '/phpmyadmin',
                  '/fckeditor',
                  '/mysql',
                  '/manager/html',
                  '.htaccess',
                  '/config.php',
                  '/configuration',
                  '/cgi-bin/php',
                  '/search.php',
                  '/tinymce',
                  '/tiny_mce',
                  '/settings.php',
                  '../../..',
                  '/install/',
                  '/download.php',
                  '/webdav',
                  '/forum.php',
                  '/user.php',
                  '/style.php',
                  '/jmx-console',
                  '/modules.php',
                  '/include.php',
                  '/default.asp',
                  '/help.php',
                  '/database.yml',
                  '/database.yml.pgsql',
                  '/database.yml.sqlite3',
                  '/database.yml.sqlite',
                  '/database.yml.mysql',
                  '.%2e/',
                  '/view.php',
                  '/header.php',
                  '/search.asp',
                  '%5c%5c',
                  '/server/php/',
                  '/invoker/jmxinvokerservlet',
                  '/phpmyadmin/index.php',
                  '/data/admin/allowurl.txt',
                  '/verify.php',
                  '/misc/ajax.js',
                  '/.idea',
                  '/module.php',
                  '/backup.rar',
                  '/backup.tar',
                  '/backup.zip',
                  '/backup.7z',
                  '/backup.gz',
                  '/backup.tgz',
                  '/backup.tar.gz',
                  'waitfor%20delay',
                  '/calendar.php',
                  '/news.php',
                  '/dompdf.php',
                  '))))))))))))))))',
                  '/web.config',
                  'tree.php',
                  '/cgi-bin-sdb/printenv',
                  '/comments.php',
                  '/detail.asp',
                  '/license.txt',
                  '/admin.asp',
                  '/auth.php',
                  '/list.php',
                  '/content.php',
                  '/mod.php',
                  '/mini.php',
                  '/install.pgsql',
                  '/install.mysql',
                  '/install.sqlite',
                  '/install.sqlite3',
                  '/install.txt',
                  '/install.md',
                  '/doku.php',
                  '/main.asp',
                  '/myadmin',
                  '/force-download.php',
                  '/iisprotect/admin',
                  '/.gitignore',
                  '/print.php',
                  '/common.php',
                  '/mainfile.php',
                  '/functions.php',
                  '/scripts/setup.php',
                  '/faq.php',
                  '/op/op.login.php',
                  '/home.php',
                  '/includes/hnmain.inc.php3',
                  '/preview.php',
                  '/dump.rar',
                  '/dump.tar',
                  '/dump.zip',
                  '/dump.7z',
                  '/dump.gz',
                  '/dump.tgz',
                  '/dump.tar.gz',
                  '/thumbnail.php',
                  '/sendcard.php',
                  '/global.asax',
                  '/directory.php',
                  '/footer.php',
                  '/error.asp',
                  '/forum.asp',
                  '/save.php',
                  '/htmlsax3.php',
                  '/adm/krgourl.php',
                  '/includes/converter.inc.php',
                  '/nucleus/libs/pluginadmin.php',
                  '/base_qry_common.php',
                  '/fileadmin',
                  '/bitrix/admin/',
                  '/adm.php',
                  '/util/barcode.php',
                  '/action.php',
                  '/rss.asp',
                  '/downloads.php',
                  '/page.php',
                  '/snarf_ajax.php',
                  '/fck/editor',
                  '/sendmail.php',
                  '/detail.php',
                  '/iframe.php',
                  '/swfupload.swf',
                  '/jenkins/login',
                  '/phpmyadmin/main.php',
                  '/phpmyadmin/scripts/setup.php',
                  '/user/index.php',
                  '/checkout.php',
                  '/process.php',
                  '/ks_inc/ajax.js',
                  '/export.php',
                  '/register.php',
                  '/cart.php',
                  '/console.php',
                  '/friend.php',
                  '/readmsg.php',
                  '/install.asp',
                  '/dagent/downloadreport.asp',
                  '/system/index.php',
                  '/core/changelog.txt',
                  '/js/util.js',
                  '/interna.php',
                  '/gallery.php',
                  '/links.php',
                  '/data/admin/ver.txt',
                  '/language/zh-cn.xml',
                  '/productdetails.asp',
                  '/admin/template/article_more/config.htm',
                  '/components/com_moofaq/includes/file_includer.php',
                  '/licence.txt',
                  '/rss.xsl',
                  '/vtigerservice.php',
                  '/mysql/main.php',
                  '/passwiki.php',
                  '/scr/soustab.php',
                  '/global.php',
                  '/email.php',
                  '/user.asp',
                  '/msd',
                  '/products.php',
                  '/cultbooking.php',
                  '/cron.php',
                  '/static/js/admincp.js',
                  '/comment.php',
                  '/maintainers',
                  '/modules/plain/adminpart/addplain.php',
                  '/wp-content/plugins/ungallery/source_vuln.php',
                  '/upgrade.txt',
                  '/category.php',
                  '/index_logged.php',
                  '/members.asp',
                  '/script/html.js',
                  '/images/ad.js',
                  '/awstats/awstats.pl',
                  '/includes/esqueletos/skel_null.php',
                  '/modules/profile/user.php',
                  '/window_top.php',
                  '/openbrowser.php',
                  '/thread.php',
                  'tinfoil_xss',
                  '/includes/include.php',
                  '/urheber.php',
                  '/header.inc.php',
                  '/mysqldumper',
                  '/display.php',
                  '/website.php',
                  '/stats.php',
                  '/assets/plugins/mp3_id/mp3_id.php',
                  '/siteminderagent/forms/smpwservices.fcc',
                  '/eval-stdin.php',
                ],
              },
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'nfd-000-002',
          name: 'Detect failed attempt to fetch readme files',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: 'readme\\.[\\.a-z0-9]+$',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-003',
          name: 'Detect failed attempt to fetch Java EE resource files',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: '^(?:.*web\\-inf)(?:.*web\\.xml).*$',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-004',
          name: 'Detect failed attempt to fetch code files',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: '\\.(java|pyc?|rb|class)\\b',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-005',
          name: 'Detect failed attempt to fetch source code archives',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex:
                  '\\.(sql|log|ndb|gz|zip|tar\\.gz|tar|regVV|reg|conf|bz2|ini|db|war|bat|inc|btr|server|ds|conf|config|admin|master|sln|bak)\\b(?:[^.]|$)',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-006',
          name: 'Detect failed attempt to fetch sensitive files',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex:
                  '\\.(cgi|bat|dll|exe|key|cert|crt|pem|der|pkcs|pkcs|pkcs[0-9]*|nsf|jsa|war|java|class|vb|vba|so|git|svn|hg|cvs)([?#&/]|$)',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-007',
          name: 'Detect failed attempt to fetch archives',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: '/[\\d\\-_]*\\.(rar|tar|zip|7z|gz|tgz|tar.gz)',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-008',
          name: 'Detect failed attempt to trigger incorrect application behavior',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex:
                  '(/(administrator/components/com.*\\.php|response\\.write\\(.+\\))|select\\(.+\\)from|\\(.*sleep\\(.+\\)|(%[a-zA-Z0-9]{2}[a-zA-Z]{0,1})+\\))',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-009',
          name: 'Detect failed attempt to leak the structure of the application',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: '/(login\\.rol|LICENSE|[\\w-]+\\.(plx|pwd))$',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'nfd-000-010',
          name: 'Detect failed attempts to find API documentation',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.response.status',
                  },
                ],
                regex: '^404$',
                options: {
                  case_sensitive: true,
                },
              },
            },
            {
              operator: 'match_regex',
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                regex: '(?:^|/)(?:swagger|api[-/]?docs?|openapi)\\b',
                options: {
                  case_sensitive: false,
                },
              },
            },
          ],
          transformers: [],
        },
        {
          id: 'rasp-930-100',
          name: 'Local file inclusion exploit',
          tags: {
            type: 'lfi',
            category: 'vulnerability_trigger',
            cwe: '22',
            capec: '1000/255/153/126',
            confidence: '1',
            module: 'rasp',
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: 'server.io.fs.file',
                  },
                ],
                params: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
              },
              operator: 'lfi_detector@v2',
            },
          ],
          transformers: [],
          on_match: ['stack_trace'],
        },
        {
          id: 'rasp-932-100',
          name: 'Shell command injection exploit',
          tags: {
            type: 'command_injection',
            category: 'vulnerability_trigger',
            cwe: '77',
            capec: '1000/152/248/88',
            confidence: '1',
            module: 'rasp',
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: 'server.sys.shell.cmd',
                  },
                ],
                params: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
              },
              operator: 'shi_detector',
            },
          ],
          transformers: [],
          on_match: ['stack_trace'],
        },
        {
          id: 'rasp-932-110',
          name: 'OS command injection exploit',
          tags: {
            type: 'command_injection',
            category: 'vulnerability_trigger',
            cwe: '77',
            capec: '1000/152/248/88',
            confidence: '1',
            module: 'rasp',
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: 'server.sys.exec.cmd',
                  },
                ],
                params: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
              },
              operator: 'cmdi_detector',
            },
          ],
          transformers: [],
          on_match: ['stack_trace'],
        },
        {
          id: 'rasp-934-100',
          name: 'Server-side request forgery exploit',
          tags: {
            type: 'ssrf',
            category: 'vulnerability_trigger',
            cwe: '918',
            capec: '1000/225/115/664',
            confidence: '0',
            module: 'rasp',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.io.net.url',
                  },
                ],
                regex:
                  '^(jar:)?https?:\\/\\/\\W*([0-9oq]{1,5}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|[0-9]{1,10}|(\\[)?[:0-9a-f\\.x]{2,}(\\])?|metadata\\.google\\.internal|(?:[a-z0-9:@\\.\\-]*\\.)?(?:burpcollaborator\\.net|localtest\\.me|mail\\.ebc\\.apple\\.com|bugbounty\\.dod\\.network|.*\\.[nx]ip\\.io|oastify\\.com|oast\\.(?:pro|live|site|online|fun|me)|sslip\\.io|requestbin\\.com|requestbin\\.net|hookbin\\.com|webhook\\.site|canarytokens\\.com|interact\\.sh|ngrok\\.io|bugbounty\\.click|prbly\\.win|qualysperiscope\\.com|vii\\.one|act1on3\\.ru|ifconfig\\.pro|dnslog\\.\\w+))(:[0-9]{1,5})?(\\/[^:@]*)?$',
                options: {
                  case_sensitive: false,
                },
              },
              operator: 'match_regex',
            },
            {
              parameters: {
                resource: [
                  {
                    address: 'server.io.net.url',
                  },
                ],
                params: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                options: {
                  'path-inspection': true,
                },
              },
              operator: 'ssrf_detector',
            },
          ],
          transformers: [],
          on_match: ['stack_trace'],
        },
        {
          id: 'rasp-942-100',
          name: 'SQL injection exploit',
          tags: {
            type: 'sql_injection',
            category: 'vulnerability_trigger',
            cwe: '89',
            capec: '1000/152/248/66',
            confidence: '1',
            module: 'rasp',
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: 'server.db.statement',
                  },
                ],
                params: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                db_type: [
                  {
                    address: 'server.db.system',
                  },
                ],
              },
              operator: 'sqli_detector@v2',
            },
          ],
          transformers: [],
          on_match: ['stack_trace'],
        },
        {
          id: 'sqr-000-001',
          name: 'SSRF: Try to access the credential manager of the main cloud services',
          tags: {
            type: 'ssrf',
            category: 'attack_attempt',
            cwe: '918',
            capec: '1000/225/115/664',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(?i)^\\W*((http|ftp)s?://)?\\W*((::f{4}:)?(169|(0x)?0*a9|0+251)\\.?(254|(0x)?0*fe|0+376)[0-9a-fx\\.:]+|metadata\\.google\\.internal|metadata\\.goog)\\W*/',
                options: {
                  min_length: 4,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'sqr-000-002',
          name: 'Server-side Javascript injection: Try to detect obvious JS injection',
          tags: {
            type: 'js_code_injection',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: `require\\(['"][\\w\\.]+['"]\\)|process\\.\\w+\\([\\w\\.]*\\)|\\.toString\\(\\)`,
                options: {
                  min_length: 4,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['removeNulls'],
        },
        {
          id: 'sqr-000-008',
          name: 'Windows: Detect attempts to exfiltrate .ini files',
          tags: {
            type: 'command_injection',
            category: 'attack_attempt',
            cwe: '78',
            capec: '1000/152/248/88',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?i)[&|]\\s*type\\s+%\\w+%\\\\+\\w+\\.ini\\s*[&|]',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'sqr-000-009',
          name: 'Linux: Detect attempts to exfiltrate passwd files',
          tags: {
            type: 'command_injection',
            category: 'attack_attempt',
            cwe: '78',
            capec: '1000/152/248/88',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?i)[&|]\\s*cat\\s*\\/etc\\/[\\w\\.\\/]*passwd\\s*[&|]',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['cmdLine'],
        },
        {
          id: 'sqr-000-010',
          name: 'Windows: Detect attempts to timeout a shell',
          tags: {
            type: 'command_injection',
            category: 'attack_attempt',
            cwe: '78',
            capec: '1000/152/248/88',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '(?i)[&|]\\s*timeout\\s+/t\\s+\\d+\\s*[&|]',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'sqr-000-011',
          name: 'SSRF: Try to access internal OMI service (CVE-2021-38647)',
          tags: {
            type: 'ssrf',
            category: 'attack_attempt',
            cwe: '918',
            capec: '1000/225/115/664',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: 'http(s?):\\/\\/([A-Za-z0-9\\.\\-\\_]+|\\[[A-Fa-f0-9\\:]+\\]|):5986\\/wsman',
                options: {
                  min_length: 4,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'sqr-000-012',
          name: 'SSRF: Detect SSRF attempt on internal service',
          tags: {
            type: 'ssrf',
            category: 'attack_attempt',
            cwe: '918',
            capec: '1000/225/115/664',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '^(jar:)?(http|https):\\/\\/([0-9oq]{1,5}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|[0-9]{1,10})(:[0-9]{1,5})?(\\/[^:@]*)?$',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'sqr-000-013',
          name: 'SSRF: Detect SSRF attempts using IPv6 or octal/hexdecimal obfuscation',
          tags: {
            type: 'ssrf',
            category: 'attack_attempt',
            cwe: '918',
            capec: '1000/225/115/664',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '^(jar:)?(http|https):\\/\\/((\\[)?[:0-9a-f\\.x]{2,}(\\])?)(:[0-9]{1,5})?(\\/[^:@]*)?$',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'sqr-000-014',
          name: 'SSRF: Detect SSRF domain redirection bypass',
          tags: {
            type: 'ssrf',
            category: 'attack_attempt',
            cwe: '918',
            capec: '1000/225/115/664',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'grpc.server.request.message',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex:
                  '(http|https):\\/\\/(?:.*\\.)?(?:burpcollaborator\\.net|localtest\\.me|mail\\.ebc\\.apple\\.com|bugbounty\\.dod\\.network|.*\\.[nx]ip\\.io|oastify\\.com|oast\\.(?:pro|live|site|online|fun|me)|sslip\\.io|requestbin\\.com|requestbin\\.net|hookbin\\.com|webhook\\.site|canarytokens\\.com|interact\\.sh|ngrok\\.io|bugbounty\\.click|prbly\\.win|qualysperiscope\\.com|vii\\.one|act1on3\\.ru|dnslog\\.\\w+)',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'sqr-000-015',
          name: 'SSRF: Detect SSRF attempt using non HTTP protocol',
          tags: {
            type: 'ssrf',
            category: 'attack_attempt',
            cwe: '918',
            capec: '1000/225/115/664',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '^(jar:)?((file|netdoc):\\/\\/[\\\\\\/]+|(dict|gopher|ldap|sftp|tftp):\\/\\/.*:[0-9]{1,5})',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['lowercase'],
        },
        {
          id: 'sqr-000-017',
          name: 'Log4shell: Attempt to exploit log4j CVE-2021-44228',
          tags: {
            type: 'exploit_detection',
            category: 'attack_attempt',
            cwe: '94',
            capec: '1000/152/242',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.uri.raw',
                  },
                  {
                    address: 'server.request.query',
                  },
                  {
                    address: 'server.request.body',
                  },
                  {
                    address: 'server.request.path_params',
                  },
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                regex: '\\${[^j]*j[^n]*n[^d]*d[^i]*i[^:]*:[^}]*}',
              },
              operator: 'match_regex',
            },
          ],
          transformers: ['unicode_normalize'],
        },
        {
          id: 'ua0-600-0xx',
          name: 'Joomla exploitation tool',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Joomla exploitation tool',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: 'JDatabaseDriverMysqli',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-10x',
          name: 'Nessus',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Nessus',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)^Nessus(/|([ :]+SOAP))',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-12x',
          name: 'Arachni',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Arachni',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^Arachni\\/v',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-13x',
          name: 'Jorgee',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Jorgee',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bJorgee\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-14x',
          name: 'Probely',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Probely',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bProbely\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-15x',
          name: 'Metis',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Metis',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bmetis\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-16x',
          name: 'SQL power injector',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'SQLPowerInjector',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: 'sql power injector',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-18x',
          name: 'N-Stealth',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'N-Stealth',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bn-stealth\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-19x',
          name: 'Brutus',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Brutus',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bbrutus\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-1xx',
          name: 'Shellshock exploitation tool',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\(\\) \\{ :; *\\}',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-20x',
          name: 'Netsparker',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Netsparker',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bnetsparker\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-22x',
          name: 'JAASCois',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'JAASCois',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bjaascois\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-26x',
          name: 'Nsauditor',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Nsauditor',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bnsauditor\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-27x',
          name: 'Paros',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Paros',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)Mozilla/.* Paros/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-28x',
          name: 'DirBuster',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'DirBuster',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bdirbuster\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-29x',
          name: 'Pangolin',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Pangolin',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bpangolin\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-2xx',
          name: 'Qualys',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Qualys',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bqualys\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-30x',
          name: 'SQLNinja',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'SQLNinja',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bsqlninja\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-31x',
          name: 'Nikto',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Nikto',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\(Nikto/[\\d\\.]+\\)',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-33x',
          name: 'BlackWidow',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'BlackWidow',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bblack\\s?widow\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-34x',
          name: 'Grendel-Scan',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Grendel-Scan',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bgrendel-scan\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-35x',
          name: 'Havij',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Havij',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bhavij\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-36x',
          name: 'w3af',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'w3af',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bw3af\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-37x',
          name: 'Nmap',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Nmap',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: 'nmap (nse|scripting engine|icap-client/)',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-39x',
          name: 'Nessus Scripted',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Nessus',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: "(?i)^'?[a-z0-9_]+\\.nasl'?$",
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-3xx',
          name: 'Evil Scanner',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'EvilScanner',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bevilScanner\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-40x',
          name: 'WebFuck',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'WebFuck',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bWebFuck\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-42x',
          name: 'OpenVAS',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'OpenVAS',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)OpenVAS\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-43x',
          name: 'Spider-Pig',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Spider-Pig',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: 'Powered by Spider-Pig by tinfoilsecurity\\.com',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-44x',
          name: 'Zgrab',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Zgrab',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: 'Mozilla/\\d+.\\d+ zgrab',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-45x',
          name: 'Zmeu',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Zmeu',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bZmEu\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-47x',
          name: 'GoogleSecurityScanner',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'GoogleSecurityScanner',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bGoogleSecurityScanner\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-48x',
          name: 'Commix',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Commix',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^commix\\/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-49x',
          name: 'Gobuster',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Gobuster',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^gobuster\\/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-4xx',
          name: 'CGIchk',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'CGIchk',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bcgichk\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-51x',
          name: 'FFUF',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'FFUF',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)^Fuzz Faster U Fool\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-52x',
          name: 'Nuclei',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Nuclei',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)^Nuclei\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-53x',
          name: 'Tsunami',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Tsunami',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bTsunamiSecurityScanner\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-54x',
          name: 'Nimbostratus',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Nimbostratus',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bnimbostratus-bot\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-55x',
          name: 'Datadog test scanner: user-agent',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Datadog Canary Test',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'grpc.server.request.metadata',
                    key_path: ['dd-canary'],
                  },
                ],
                regex: '^dd-test-scanner-log(?:$|/|\\s)',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-56x',
          name: 'Datadog test scanner - blocking version: user-agent',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Datadog Canary Test',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'grpc.server.request.metadata',
                    key_path: ['dd-canary'],
                  },
                ],
                regex: '^dd-test-scanner-log-block(?:$|/|\\s)',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
          on_match: ['block'],
        },
        {
          id: 'ua0-600-57x',
          name: 'AlertLogic',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'AlertLogic',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bAlertLogic-MDR-',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-58x',
          name: 'wfuzz',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'wfuzz',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bwfuzz\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-59x',
          name: 'Detectify',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Detectify',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bdetectify\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-5xx',
          name: 'Blind SQL Injection Brute Forcer',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'BSQLBF',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)\\bbsqlbf\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-60x',
          name: 'masscan',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'masscan',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^masscan/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-61x',
          name: 'WPScan',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'WPScan',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^wpscan\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-62x',
          name: 'Aon pentesting services',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Aon',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^Aon/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-63x',
          name: 'FeroxBuster',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'feroxbuster',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^feroxbuster/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-64x',
          name: 'ddg_win',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'ddg_win',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bddg_win\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-65x',
          name: 'ISS',
          tags: {
            type: 'commercial_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'iss',
            confidence: '0',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bisscyberriskcrawler/\\d\\.\\d',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-66x',
          name: 'BountyBot',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'bountybot',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bbountybot\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-67x',
          name: 'ZumBot',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'zumbot',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '\\bzumbot\\b',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-6xx',
          name: 'Stealthy scanner',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex:
                  'mozilla/4\\.0 \\(compatible(; msie (?:6\\.0; (?:win32|Windows NT 5\\.0)|4\\.0; Windows NT))?\\)',
                options: {
                  case_sensitive: false,
                },
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-7xx',
          name: 'SQLmap',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'SQLmap',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '^sqlmap/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
        {
          id: 'ua0-600-9xx',
          name: 'Skipfish',
          tags: {
            type: 'attack_tool',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Skipfish',
            confidence: '1',
            module: 'waf',
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                ],
                regex: '(?i)mozilla/5\\.0 sf/',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
        },
      ],
      rules_compat: [
        {
          id: 'api-001-100',
          name: 'JWT: No expiry is present',
          tags: {
            type: 'jwt',
            category: 'api_security',
            confidence: '0',
            module: 'business-logic',
          },
          min_version: '1.25.0',
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.jwt',
                    key_path: ['payload', 'exp'],
                  },
                ],
              },
              operator: '!exists',
            },
          ],
          transformers: [],
          output: {
            event: false,
            keep: false,
            attributes: {
              '_dd.appsec.api.jwt.no_expiry': {
                value: 1,
              },
            },
          },
        },
        {
          id: 'api-001-110',
          name: 'JWT: Collect algorithm used',
          tags: {
            type: 'jwt',
            category: 'api_security',
            confidence: '0',
            module: 'business-logic',
          },
          min_version: '1.25.0',
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.jwt',
                    key_path: ['header', 'alg'],
                  },
                ],
              },
              operator: 'exists',
            },
          ],
          transformers: [],
          output: {
            event: false,
            keep: false,
            attributes: {
              '_dd.appsec.api.jwt_alg': {
                address: 'server.request.jwt',
                key_path: ['header', 'alg'],
              },
            },
          },
        },
        {
          id: 'api-001-120',
          name: 'JWT: No audience is specified',
          tags: {
            type: 'jwt',
            category: 'api_security',
            confidence: '0',
            module: 'business-logic',
          },
          min_version: '1.25.0',
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.jwt',
                    key_path: ['payload', 'aud'],
                  },
                ],
              },
              operator: '!exists',
            },
          ],
          transformers: [],
          output: {
            event: false,
            keep: false,
            attributes: {
              '_dd.appsec.api.jwt.no_audience': {
                value: 1,
              },
            },
          },
        },
        {
          id: 'api-001-130',
          name: 'JWT: None algorithm used',
          tags: {
            type: 'jwt',
            category: 'api_security',
            confidence: '0',
            module: 'business-logic',
          },
          min_version: '1.25.0',
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.jwt',
                    key_path: ['header', 'alg'],
                  },
                ],
                list: [
                  'none',
                  'nonE',
                  'noNe',
                  'noNE',
                  'nOne',
                  'nOnE',
                  'nONe',
                  'nONE',
                  'None',
                  'NonE',
                  'NoNe',
                  'NoNE',
                  'NOne',
                  'NOnE',
                  'NONe',
                  'NONE',
                ],
              },
              operator: 'exact_match',
            },
          ],
          transformers: [],
          output: {
            event: false,
            keep: true,
            attributes: {
              '_dd.appsec.api.jwt.none_alg': {
                value: 1,
              },
            },
          },
        },
        {
          id: 'ua0-600-551',
          name: 'Datadog test scanner - scalar trace-tagging version: user-agent',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Datadog Canary Test',
            confidence: '1',
            module: 'waf',
          },
          min_version: '1.25.0',
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'grpc.server.request.metadata',
                    key_path: ['dd-canary'],
                  },
                ],
                regex: '^dd-test-scanner-tag-scalar(?:$|/|\\s)',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
          output: {
            event: false,
            attributes: {
              '_dd.appsec.test.scanner.scalar': {
                value: 1,
              },
            },
          },
        },
        {
          id: 'ua0-600-552',
          name: 'Datadog test scanner - reference trace-tagging version: user-agent',
          tags: {
            type: 'security_scanner',
            category: 'attack_attempt',
            cwe: '200',
            capec: '1000/118/169',
            tool_name: 'Datadog Canary Test',
            confidence: '1',
            module: 'waf',
          },
          min_version: '1.25.0',
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['user-agent'],
                  },
                  {
                    address: 'grpc.server.request.metadata',
                    key_path: ['dd-canary'],
                  },
                ],
                regex: '^dd-test-scanner-tag-ref(?:$|/|\\s)',
              },
              operator: 'match_regex',
            },
          ],
          transformers: [],
          output: {
            event: false,
            attributes: {
              '_dd.appsec.test.scanner.reference': {
                address: 'server.request.headers.no_cookies',
                key_path: ['user-agent'],
              },
            },
          },
        },
      ],
      processors: [
        {
          id: 'http-endpoint-fingerprint',
          generator: 'http_endpoint_fingerprint',
          conditions: [],
          parameters: {
            mappings: [
              {
                method: [
                  {
                    address: 'server.request.method',
                  },
                ],
                uri_raw: [
                  {
                    address: 'server.request.uri.raw',
                  },
                ],
                body: [
                  {
                    address: 'server.request.body',
                  },
                ],
                query: [
                  {
                    address: 'server.request.query',
                  },
                ],
                output: '_dd.appsec.fp.http.endpoint',
              },
            ],
          },
          evaluate: true,
          output: true,
        },
        {
          id: 'extract-content',
          generator: 'extract_schema',
          conditions: [
            {
              operator: 'equals',
              parameters: {
                inputs: [
                  {
                    address: 'waf.context.processor',
                    key_path: ['extract-schema'],
                  },
                ],
                type: 'boolean',
                value: true,
              },
            },
          ],
          parameters: {
            mappings: [
              {
                inputs: [
                  {
                    address: 'server.request.body',
                  },
                ],
                output: '_dd.appsec.s.req.body',
              },
              {
                inputs: [
                  {
                    address: 'server.request.cookies',
                  },
                ],
                output: '_dd.appsec.s.req.cookies',
              },
              {
                inputs: [
                  {
                    address: 'server.request.query',
                  },
                ],
                output: '_dd.appsec.s.req.query',
              },
              {
                inputs: [
                  {
                    address: 'server.request.path_params',
                  },
                ],
                output: '_dd.appsec.s.req.params',
              },
              {
                inputs: [
                  {
                    address: 'server.response.body',
                  },
                ],
                output: '_dd.appsec.s.res.body',
              },
              {
                inputs: [
                  {
                    address: 'graphql.server.all_resolvers',
                  },
                ],
                output: '_dd.appsec.s.graphql.all_resolvers',
              },
              {
                inputs: [
                  {
                    address: 'graphql.server.resolver',
                  },
                ],
                output: '_dd.appsec.s.graphql.resolver',
              },
            ],
            scanners: [
              {
                tags: {
                  category: 'payment',
                },
              },
              {
                tags: {
                  category: 'pii',
                },
              },
            ],
          },
          evaluate: false,
          output: true,
        },
        {
          id: 'extract-headers',
          generator: 'extract_schema',
          conditions: [
            {
              operator: 'equals',
              parameters: {
                inputs: [
                  {
                    address: 'waf.context.processor',
                    key_path: ['extract-schema'],
                  },
                ],
                type: 'boolean',
                value: true,
              },
            },
          ],
          parameters: {
            mappings: [
              {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                output: '_dd.appsec.s.req.headers',
              },
              {
                inputs: [
                  {
                    address: 'server.response.headers.no_cookies',
                  },
                ],
                output: '_dd.appsec.s.res.headers',
              },
            ],
            scanners: [
              {
                tags: {
                  category: 'credentials',
                },
              },
              {
                tags: {
                  category: 'pii',
                },
              },
            ],
          },
          evaluate: false,
          output: true,
        },
        {
          id: 'http-header-fingerprint',
          generator: 'http_header_fingerprint',
          conditions: [],
          parameters: {
            mappings: [
              {
                headers: [
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                output: '_dd.appsec.fp.http.header',
              },
            ],
          },
          evaluate: true,
          output: true,
        },
        {
          id: 'decode-auth-jwt',
          generator: 'jwt_decode',
          min_version: '1.25.0',
          parameters: {
            mappings: [
              {
                inputs: [
                  {
                    address: 'server.request.headers.no_cookies',
                    key_path: ['authorization'],
                  },
                ],
                output: 'server.request.jwt',
              },
            ],
          },
          evaluate: true,
          output: false,
        },
        {
          id: 'http-network-fingerprint',
          generator: 'http_network_fingerprint',
          conditions: [],
          parameters: {
            mappings: [
              {
                headers: [
                  {
                    address: 'server.request.headers.no_cookies',
                  },
                ],
                output: '_dd.appsec.fp.http.network',
              },
            ],
          },
          evaluate: true,
          output: true,
        },
        {
          id: 'session-fingerprint',
          generator: 'session_fingerprint',
          conditions: [],
          parameters: {
            mappings: [
              {
                cookies: [
                  {
                    address: 'server.request.cookies',
                  },
                ],
                session_id: [
                  {
                    address: 'usr.session_id',
                  },
                ],
                user_id: [
                  {
                    address: 'usr.id',
                  },
                ],
                output: '_dd.appsec.fp.session',
              },
            ],
          },
          evaluate: true,
          output: true,
        },
      ],
      scanners: [
        {
          id: '406f8606-52c4-4663-8db9-df70f9e8766c',
          name: 'ZIP Code',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:zip|postal)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '^[0-9]{5}(?:-[0-9]{4})?$',
              options: {
                case_sensitive: true,
                min_length: 5,
              },
            },
          },
          tags: {
            type: 'zipcode',
            category: 'address',
          },
        },
        {
          id: 'JU1sRk3mSzqSUJn6GrVn7g',
          name: 'American Express Card Scanner (4+4+4+3 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b3[47]\\d{2}(?:(?:\\s\\d{4}\\s\\d{4}\\s\\d{3})|(?:\\,\\d{4}\\,\\d{4}\\,\\d{3})|(?:-\\d{4}-\\d{4}-\\d{3})|(?:\\.\\d{4}\\.\\d{4}\\.\\d{3}))\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'amex',
            category: 'payment',
          },
        },
        {
          id: 'edmH513UTQWcRiQ9UnzHlw-mod',
          name: 'American Express Card Scanner (4+6|5+5|6 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b3[47]\\d{2}(?:(?:\\s\\d{5,6}\\s\\d{5,6})|(?:\\.\\d{5,6}\\.\\d{5,6})|(?:-\\d{5,6}-\\d{5,6})|(?:,\\d{5,6},\\d{5,6}))\\b',
              options: {
                case_sensitive: false,
                min_length: 17,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'amex',
            category: 'payment',
          },
        },
        {
          id: 'e6K4h_7qTLaMiAbaNXoSZA',
          name: 'American Express Card Scanner (8+7 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b3[47]\\d{6}(?:(?:\\s\\d{7})|(?:\\,\\d{7})|(?:-\\d{7})|(?:\\.\\d{7}))\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'amex',
            category: 'payment',
          },
        },
        {
          id: 'K2rZflWzRhGM9HiTc6whyQ',
          name: 'American Express Card Scanner (1x15 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b3[47]\\d{13}\\b',
              options: {
                case_sensitive: false,
                min_length: 15,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'amex',
            category: 'payment',
          },
        },
        {
          id: '9d7756e343cefa22a5c098e1092590f806eb5446',
          name: 'Basic Authentication Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\bauthorization\\b',
              options: {
                case_sensitive: false,
                min_length: 13,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '^basic\\s+[A-Za-z0-9+/=]+',
              options: {
                case_sensitive: false,
                min_length: 7,
              },
            },
          },
          tags: {
            type: 'basic_auth',
            category: 'credentials',
          },
        },
        {
          id: 'mZy8XjZLReC9smpERXWnnw',
          name: 'Bearer Authentication Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\bauthorization\\b',
              options: {
                case_sensitive: false,
                min_length: 13,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '^bearer\\s+[-a-z0-9._~+/]{4,}',
              options: {
                case_sensitive: false,
                min_length: 11,
              },
            },
          },
          tags: {
            type: 'bearer_token',
            category: 'credentials',
          },
        },
        {
          id: '450239afc250a19799b6c03dc0e16fd6a4b2a1af',
          name: 'Canadian Social Insurance Number Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:social[\\s_]?(?:insurance(?:\\s+number)?)?|SIN|Canadian[\\s_]?(?:social[\\s_]?(?:insurance)?|insurance[\\s_]?number)?)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b\\d{3}-\\d{3}-\\d{3}\\b',
              options: {
                case_sensitive: false,
                min_length: 11,
              },
            },
          },
          tags: {
            type: 'canadian_sin',
            category: 'pii',
          },
        },
        {
          id: '87a879ff33693b46c8a614d8211f5a2c289beca0',
          name: 'Digest Authentication Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\bauthorization\\b',
              options: {
                case_sensitive: false,
                min_length: 13,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '^digest\\s+',
              options: {
                case_sensitive: false,
                min_length: 7,
              },
            },
          },
          tags: {
            type: 'digest_auth',
            category: 'credentials',
          },
        },
        {
          id: 'qWumeP1GQUa_E4ffAnT-Yg',
          name: 'American Express Card Scanner (1x14 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '(?:30[0-59]\\d|3[689]\\d{2})(?:\\d{10})',
              options: {
                case_sensitive: false,
                min_length: 14,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'diners',
            category: 'payment',
          },
        },
        {
          id: 'NlTWWM5LS6W0GSqBLuvtRw',
          name: 'Diners Card Scanner (4+4+4+2 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:30[0-59]\\d|3[689]\\d{2})(?:(?:\\s\\d{4}\\s\\d{4}\\s\\d{2})|(?:\\,\\d{4}\\,\\d{4}\\,\\d{2})|(?:-\\d{4}-\\d{4}-\\d{2})|(?:\\.\\d{4}\\.\\d{4}\\.\\d{2}))\\b',
              options: {
                case_sensitive: false,
                min_length: 17,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'diners',
            category: 'payment',
          },
        },
        {
          id: 'Xr5VdbQSTXitYGGiTfxBpw',
          name: 'Diners Card Scanner (4+6+4 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:30[0-59]\\d|3[689]\\d{2})(?:(?:\\s\\d{6}\\s\\d{4})|(?:\\.\\d{6}\\.\\d{4})|(?:-\\d{6}-\\d{4})|(?:,\\d{6},\\d{4}))\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'diners',
            category: 'payment',
          },
        },
        {
          id: 'gAbunN_WQNytxu54DjcbAA-mod',
          name: 'Diners Card Scanner (8+6 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:30[0-59]\\d{5}|3[689]\\d{6})\\s?(?:(?:\\s\\d{6})|(?:\\,\\d{6})|(?:-\\d{6})|(?:\\.\\d{6}))\\b',
              options: {
                case_sensitive: false,
                min_length: 14,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'diners',
            category: 'payment',
          },
        },
        {
          id: '9cs4qCfEQBeX17U7AepOvQ',
          name: 'MasterCard Scanner (2x8 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:6221(?:2[6-9]|[3-9][0-9])\\d{2}(?:,\\d{8}|\\s\\d{8}|-\\d{8}|\\.\\d{8})|6229(?:[01][0-9]|2[0-5])\\d{2}(?:,\\d{8}|\\s\\d{8}|-\\d{8}|\\.\\d{8})|(?:6011|65\\d{2}|64[4-9]\\d|622[2-8])\\d{4}(?:,\\d{8}|\\s\\d{8}|-\\d{8}|\\.\\d{8}))\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'discover',
            category: 'payment',
          },
        },
        {
          id: 'YBIDWJIvQWW_TFOyU0CGJg',
          name: 'Discover Card Scanner (4x4 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:(?:(?:6221(?:2[6-9]|[3-9][0-9])\\d{2}(?:,\\d{4}){2})|(?:6221\\s(?:2[6-9]|[3-9][0-9])\\d{2}(?:\\s\\d{4}){2})|(?:6221\\.(?:2[6-9]|[3-9][0-9])\\d{2}(?:\\.\\d{4}){2})|(?:6221-(?:2[6-9]|[3-9][0-9])\\d{2}(?:-\\d{4}){2}))|(?:(?:6229(?:[01][0-9]|2[0-5])\\d{2}(?:,\\d{4}){2})|(?:6229\\s(?:[01][0-9]|2[0-5])\\d{2}(?:\\s\\d{4}){2})|(?:6229\\.(?:[01][0-9]|2[0-5])\\d{2}(?:\\.\\d{4}){2})|(?:6229-(?:[01][0-9]|2[0-5])\\d{2}(?:-\\d{4}){2}))|(?:(?:6011|65\\d{2}|64[4-9]\\d|622[2-8])(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})))\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'discover',
            category: 'payment',
          },
        },
        {
          id: '12cpbjtVTMaMutFhh9sojQ',
          name: 'Discover Card Scanner (1x16 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:6221(?:2[6-9]|[3-9][0-9])\\d{10}|6229(?:[01][0-9]|2[0-5])\\d{10}|(?:6011|65\\d{2}|64[4-9]\\d|622[2-8])\\d{12})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'discover',
            category: 'payment',
          },
        },
        {
          id: 'PuXiVTCkTHOtj0Yad1ppsw',
          name: 'Standard E-mail Address',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:(?:e[-\\s]?)?mail|address|sender|\\bto\\b|from|recipient)\\b',
              options: {
                case_sensitive: false,
                min_length: 2,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                "\\b[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*(%40|@)(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,6}\\b",
              options: {
                case_sensitive: false,
                min_length: 5,
              },
            },
          },
          tags: {
            type: 'email',
            category: 'pii',
          },
        },
        {
          id: '8VS2RKxzR8a_95L5fuwaXQ',
          name: 'IBAN',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:iban|account|sender|receiver)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:NO\\d{2}(?:[ \\-]?\\d{4}){2}[ \\-]?\\d{3}|BE\\d{2}(?:[ \\-]?\\d{4}){3}|(?:DK|FO|FI|GL|SD)\\d{2}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{2}|NL\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){2}[ \\-]?\\d{2}|MK\\d{2}[ \\-]?\\d{3}[A-Z0-9](?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]\\d{2}|SI\\d{17}|(?:AT|BA|EE|LT|XK)\\d{18}|(?:LU|KZ|EE|LT)\\d{5}[A-Z0-9]{13}|LV\\d{2}[A-Z]{4}[A-Z0-9]{13}|(?:LI|CH)\\d{2}[ \\-]?\\d{4}[ \\-]?\\d[A-Z0-9]{3}(?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]|HR\\d{2}(?:[ \\-]?\\d{4}){4}[ \\-]?\\d|GE\\d{2}[ \\-]?[A-Z0-9]{2}\\d{2}\\d{14}|VA\\d{20}|BG\\d{2}[A-Z]{4}\\d{6}[A-Z0-9]{8}|BH\\d{2}[A-Z]{4}[A-Z0-9]{14}|GB\\d{2}[A-Z]{4}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{2}|IE\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{2}|(?:CR|DE|ME|RS)\\d{2}(?:[ \\-]?\\d{4}){4}[ \\-]?\\d{2}|(?:AE|TL|IL)\\d{2}(?:[ \\-]?\\d{4}){4}[ \\-]?\\d{3}|GI\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){3}[ \\-]?[A-Z0-9]{3}|IQ\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{3}|MD\\d{2}(?:[ \\-]?[A-Z0-9]{4}){5}|SA\\d{2}[ \\-]?\\d{2}[A-Z0-9]{2}(?:[ \\-]?[A-Z0-9]{4}){4}|RO\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){4}|(?:PK|VG)\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{4}){4}|AD\\d{2}(?:[ \\-]?\\d{4}){2}(?:[ \\-]?[A-Z0-9]{4}){3}|(?:CZ|SK|ES|SE|TN)\\d{2}(?:[ \\-]?\\d{4}){5}|(?:LY|PT|ST)\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d|TR\\d{2}[ \\-]?\\d{4}[ \\-]?\\d[A-Z0-9]{3}(?:[ \\-]?[A-Z0-9]{4}){3}[ \\-]?[A-Z0-9]{2}|IS\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d{2}|(?:IT|SM)\\d{2}[ \\-]?[A-Z]\\d{3}[ \\-]?\\d{4}[ \\-]?\\d{3}[A-Z0-9](?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]{3}|GR\\d{2}[ \\-]?\\d{4}[ \\-]?\\d{3}[A-Z0-9](?:[ \\-]?[A-Z0-9]{4}){3}[A-Z0-9]{3}|(?:FR|MC)\\d{2}(?:[ \\-]?\\d{4}){2}[ \\-]?\\d{2}[A-Z0-9]{2}(?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]\\d{2}|MR\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d{3}|(?:SV|DO)\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){5}|BY\\d{2}[ \\-]?[A-Z]{4}[ \\-]?\\d{4}(?:[ \\-]?[A-Z0-9]{4}){4}|GT\\d{2}(?:[ \\-]?[A-Z0-9]{4}){6}|AZ\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{5}){4}|LB\\d{2}[ \\-]?\\d{4}(?:[ \\-]?[A-Z0-9]{5}){4}|(?:AL|CY)\\d{2}(?:[ \\-]?\\d{4}){2}(?:[ \\-]?[A-Z0-9]{4}){4}|(?:HU|PL)\\d{2}(?:[ \\-]?\\d{4}){6}|QA\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){5}[ \\-]?[A-Z0-9]|PS\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d|UA\\d{2}[ \\-]?\\d{4}[ \\-]?\\d{2}[A-Z0-9]{2}(?:[ \\-]?[A-Z0-9]{4}){4}[ \\-]?[A-Z0-9]|BR\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d{3}[A-Z0-9][ \\-]?[A-Z0-9]|EG\\d{2}(?:[ \\-]?\\d{4}){6}\\d|MU\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){4}\\d{3}[A-Z][ \\-]?[A-Z]{2}|(?:KW|JO)\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){5}[ \\-]?[A-Z0-9]{2}|MT\\d{2}[ \\-]?[A-Z]{4}[ \\-]?\\d{4}[ \\-]?\\d[A-Z0-9]{3}(?:[ \\-]?[A-Z0-9]{3}){4}[ \\-]?[A-Z0-9]{3}|SC\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){5}[ \\-]?[A-Z]{3}|LC\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){6})\\b',
              options: {
                case_sensitive: false,
                min_length: 15,
              },
            },
          },
          tags: {
            type: 'iban',
            category: 'payment',
          },
        },
        {
          id: 'h6WJcecQTwqvN9KeEtwDvg',
          name: 'JCB Card Scanner (1x16 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b35(?:2[89]|[3-9][0-9])(?:\\d{12})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'jcb',
            category: 'payment',
          },
        },
        {
          id: 'gcEaMu_VSJ2-bGCEkgyC0w',
          name: 'JCB Card Scanner (2x8 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b35(?:2[89]|[3-9][0-9])\\d{4}(?:(?:,\\d{8})|(?:-\\d{8})|(?:\\s\\d{8})|(?:\\.\\d{8}))\\b',
              options: {
                case_sensitive: false,
                min_length: 17,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'jcb',
            category: 'payment',
          },
        },
        {
          id: 'imTliuhXT5GAeRNhqChXQQ',
          name: 'JCB Card Scanner (4x4 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b35(?:2[89]|[3-9][0-9])(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'jcb',
            category: 'payment',
          },
        },
        {
          id: '9osY3xc9Q7ONAV0zw9Uz4A',
          name: 'JSON Web Token',
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\bey[I-L][\\w=-]+\\.ey[I-L][\\w=-]+(\\.[\\w.+\\/=-]+)?\\b',
              options: {
                case_sensitive: false,
                min_length: 20,
              },
            },
          },
          tags: {
            type: 'json_web_token',
            category: 'credentials',
          },
        },
        {
          id: 'd1Q9D3YMRxuVKf6CZInJPw',
          name: 'Maestro Card Scanner (1x16 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:5[06-9]\\d{2}|6\\d{3})(?:\\d{12})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'maestro',
            category: 'payment',
          },
        },
        {
          id: 'M3YIQKKjRVmoeQuM3pjzrw',
          name: 'Maestro Card Scanner (2x8 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:5[06-9]\\d{6}|6\\d{7})(?:\\s\\d{8}|\\.\\d{8}|-\\d{8}|,\\d{8})\\b',
              options: {
                case_sensitive: false,
                min_length: 17,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'maestro',
            category: 'payment',
          },
        },
        {
          id: 'hRxiQBlSSVKcjh5U7LZYLA',
          name: 'Maestro Card Scanner (4x4 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:5[06-9]\\d{2}|6\\d{3})(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'maestro',
            category: 'payment',
          },
        },
        {
          id: 'NwhIYNS4STqZys37WlaIKA',
          name: 'MasterCard Scanner (2x8 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:(?:5[1-5]\\d{2})|(?:222[1-9])|(?:22[3-9]\\d)|(?:2[3-6]\\d{2})|(?:27[0-1]\\d)|(?:2720))(?:(?:\\d{4}(?:(?:,\\d{8})|(?:-\\d{8})|(?:\\s\\d{8})|(?:\\.\\d{8}))))\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'mastercard',
            category: 'payment',
          },
        },
        {
          id: 'axxJkyjhRTOuhjwlsA35Vw',
          name: 'MasterCard Scanner (4x4 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:(?:5[1-5]\\d{2})|(?:222[1-9])|(?:22[3-9]\\d)|(?:2[3-6]\\d{2})|(?:27[0-1]\\d)|(?:2720))(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'mastercard',
            category: 'payment',
          },
        },
        {
          id: '76EhmoK3TPqJcpM-fK0pLw',
          name: 'MasterCard Scanner (1x16 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '\\b(?:(?:5[1-5]\\d{2})|(?:222[1-9])|(?:22[3-9]\\d)|(?:2[3-6]\\d{2})|(?:27[0-1]\\d)|(?:2720))(?:\\d{12})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'mastercard',
            category: 'payment',
          },
        },
        {
          id: 'c542c147-3883-43d6-a067-178e4a7bd65d',
          name: 'Password',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\bpass(?:[_-]?word|wd)?\\b|\\bpwd\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          tags: {
            type: 'password',
            category: 'credentials',
          },
        },
        {
          id: '18b608bd7a764bff5b2344c0',
          name: 'Phone number',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\bphone|number|mobile\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex:
                '^(?:\\(\\+\\d{1,3}\\)|\\+\\d{1,3}|00\\d{1,3})?[-\\s\\.]?(?:\\(\\d{3}\\)[-\\s\\.]?)?(?:\\d[-\\s\\.]?){6,10}$',
              options: {
                case_sensitive: false,
                min_length: 6,
              },
            },
          },
          tags: {
            type: 'phone',
            category: 'pii',
          },
        },
        {
          id: 'de0899e0cbaaa812bb624cf04c912071012f616d-mod',
          name: 'UK National Insurance Number Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '^nin$|\\binsurance\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b[A-Z]{2}[\\s-]?\\d{6}[\\s-]?[A-Z]?\\b',
              options: {
                case_sensitive: false,
                min_length: 8,
              },
            },
          },
          tags: {
            type: 'uk_nin',
            category: 'pii',
          },
        },
        {
          id: 'd962f7ddb3f55041e39195a60ff79d4814a7c331',
          name: 'US Passport Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\bpassport\\b',
              options: {
                case_sensitive: false,
                min_length: 8,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b[0-9A-Z]{9}\\b|\\b[0-9]{6}[A-Z][0-9]{2}\\b',
              options: {
                case_sensitive: false,
                min_length: 8,
              },
            },
          },
          tags: {
            type: 'passport_number',
            category: 'pii',
          },
        },
        {
          id: '7771fc3b-b205-4b93-bcef-28608c5c1b54',
          name: 'United States Social Security Number Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:SSN|(?:(?:social)?[\\s_]?(?:security)?[\\s_]?(?:number)?)?)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b\\d{3}[-\\s\\.]{1}\\d{2}[-\\s\\.]{1}\\d{4}\\b',
              options: {
                case_sensitive: false,
                min_length: 11,
              },
            },
          },
          tags: {
            type: 'us_ssn',
            category: 'pii',
          },
        },
        {
          id: 'ac6d683cbac77f6e399a14990793dd8fd0fca333',
          name: 'US Vehicle Identification Number Scanner',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:vehicle[_\\s-]*identification[_\\s-]*number|vin)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b[A-HJ-NPR-Z0-9]{17}\\b',
              options: {
                case_sensitive: false,
                min_length: 17,
              },
            },
          },
          tags: {
            type: 'vin',
            category: 'pii',
          },
        },
        {
          id: 'wJIgOygRQhKkR69b_9XbRQ',
          name: 'Visa Card Scanner (2x8 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b4\\d{3}(?:(?:\\d{4}(?:(?:,\\d{8})|(?:-\\d{8})|(?:\\s\\d{8})|(?:\\.\\d{8}))))\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'visa',
            category: 'payment',
          },
        },
        {
          id: '0o71SJxXQNK7Q6gMbBesFQ',
          name: 'Visa Card Scanner (4x4 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b4\\d{3}(?:(?:,\\d{4}){3}|(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3})\\b',
              options: {
                case_sensitive: false,
                min_length: 16,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'visa',
            category: 'payment',
          },
        },
        {
          id: 'QrHD6AfgQm6z-j0wStxTvA',
          name: 'Visa Card Scanner (1x15 & 1x16 & 1x19 digits)',
          key: {
            operator: 'match_regex',
            parameters: {
              regex: '\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b',
              options: {
                case_sensitive: false,
                min_length: 3,
              },
            },
          },
          value: {
            operator: 'match_regex',
            parameters: {
              regex: '4[0-9]{12}(?:[0-9]{3})?',
              options: {
                case_sensitive: false,
                min_length: 13,
              },
            },
          },
          tags: {
            type: 'card',
            card_type: 'visa',
            category: 'payment',
          },
        },
      ],
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js
var require_rule_manager = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var waf = require_waf2()
    var { DIAGNOSTIC_KEYS } = require_diagnostics()
    var { ACKNOWLEDGED, ERROR } = require_apply_states()
    var Reporter = require_reporter()
    var blocking = require_blocking()
    var ASM_PRODUCTS = /* @__PURE__ */ new Set(['ASM', 'ASM_DD', 'ASM_DATA'])
    var appliedActions = /* @__PURE__ */ new Map()
    function loadRules(config) {
      const defaultRules = config.rules ? JSON.parse(fs.readFileSync(config.rules)) : require_recommended()
      waf.init(defaultRules, config)
      blocking.setDefaultBlockingActionParameters(defaultRules?.actions)
    }
    function updateWafFromRC({ toUnapply, toApply, toModify }) {
      const newActions = new SpyMap(appliedActions)
      let wafUpdated = false
      let wafUpdatedFailed = false
      for (const item of toUnapply) {
        if (!ASM_PRODUCTS.has(item.product)) continue
        try {
          waf.removeConfig(item.path)
          item.apply_state = ACKNOWLEDGED
          wafUpdated = true
          if (item.product === 'ASM') {
            newActions.delete(item.id)
          }
        } catch (e) {
          item.apply_state = ERROR
          item.apply_error = e.toString()
          wafUpdatedFailed = true
        }
      }
      for (const item of [...toApply, ...toModify]) {
        if (!ASM_PRODUCTS.has(item.product)) continue
        try {
          waf.updateConfig(item.product, item.id, item.path, item.file)
          item.apply_state = ACKNOWLEDGED
          wafUpdated = true
          if (item.product === 'ASM' && item.file?.actions?.length) {
            newActions.set(item.id, item.file.actions)
          }
        } catch (e) {
          item.apply_state = ERROR
          item.apply_error =
            e instanceof waf.WafUpdateError ? JSON.stringify(extractErrors(e.diagnosticErrors)) : e.toString()
          wafUpdatedFailed = true
        }
      }
      waf.checkAsmDdFallback()
      if (wafUpdated) {
        Reporter.reportWafUpdate(waf.wafManager.ddwafVersion, waf.wafManager.rulesVersion, !wafUpdatedFailed)
      }
      if (newActions.modified) {
        appliedActions = newActions
        blocking.setDefaultBlockingActionParameters(concatArrays(newActions))
      }
    }
    var SpyMap = class extends Map {
      constructor(iterable) {
        super(iterable)
        this.modified = false
      }
      set(key, value) {
        this.modified = true
        return super.set(key, value)
      }
      delete(key) {
        const result = super.delete(key)
        if (result) this.modified = true
        return result
      }
      clear() {
        this.modified = false
        return super.clear()
      }
    }
    function concatArrays(files) {
      return [...files.values()].flat()
    }
    function extractErrors(diagnostics) {
      if (!diagnostics) return
      if (diagnostics.error) return diagnostics
      const result = {}
      let isResultPopulated = false
      for (const diagnosticKey of DIAGNOSTIC_KEYS) {
        if (diagnostics[diagnosticKey]?.error) {
          ;(result[diagnosticKey] ??= {}).error = diagnostics[diagnosticKey]?.error
          isResultPopulated = true
        }
        if (diagnostics[diagnosticKey]?.errors) {
          ;(result[diagnosticKey] ??= {}).errors = diagnostics[diagnosticKey]?.errors
          isResultPopulated = true
        }
      }
      return isResultPopulated ? result : null
    }
    function clearAllRules() {
      waf.destroy()
      appliedActions.clear()
      blocking.setDefaultBlockingActionParameters(void 0)
    }
    module2.exports = {
      loadRules,
      updateWafFromRC,
      clearAllRules,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/activation.js
var require_activation = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/activation.js'(exports2, module2) {
    'use strict'
    var Activation = {
      ONECLICK: 'OneClick',
      ENABLED: 'Enabled',
      DISABLED: 'Disabled',
      fromConfig(config) {
        switch (config.appsec.enabled) {
          // ASM is activated by an env var DD_APPSEC_ENABLED=true
          case true:
            return Activation.ENABLED
          // ASM is disabled by an env var DD_APPSEC_ENABLED=false
          case false:
            return Activation.DISABLED
          // ASM is activated by one click remote config
          case void 0:
            return Activation.ONECLICK
          // Any other value should never occur
          default:
            return Activation.DISABLED
        }
      },
    }
    module2.exports = Activation
  },
})

// node_modules/dd-trace/packages/dd-trace/src/remote_config/scheduler.js
var require_scheduler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/remote_config/scheduler.js'(exports2, module2) {
    'use strict'
    var Scheduler = class {
      _timer = null
      constructor(callback, interval) {
        this._callback = callback
        this._interval = interval
      }
      start() {
        if (this._timer) return
        this.runAfterDelay(0)
      }
      runAfterDelay(interval = this._interval) {
        this._timer = setTimeout(this._callback, interval, () => this.runAfterDelay())
        this._timer.unref && this._timer.unref()
      }
      stop() {
        clearTimeout(this._timer)
        this._timer = null
      }
    }
    module2.exports = Scheduler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/remote_config/manager.js
var require_manager2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/remote_config/manager.js'(exports2, module2) {
    'use strict'
    var { URL: URL2, format } = require('url')
    var uuid = require_crypto_randomuuid()
    var { EventEmitter } = require('events')
    var tracerVersion = require_package().version
    var request = require_request()
    var log = require_log2()
    var { getExtraServices } = require_extra_services()
    var { UNACKNOWLEDGED, ACKNOWLEDGED, ERROR } = require_apply_states()
    var Scheduler = require_scheduler()
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2()
    var tagger = require_tagger()
    var defaults = require_config_defaults()
    var clientId = uuid()
    var DEFAULT_CAPABILITY = Buffer.alloc(1).toString('base64')
    var kPreUpdate = /* @__PURE__ */ Symbol('kPreUpdate')
    var kSupportsAckCallback = /* @__PURE__ */ Symbol('kSupportsAckCallback')
    var RemoteConfigManager = class _RemoteConfigManager extends EventEmitter {
      static kPreUpdate = kPreUpdate
      constructor(config) {
        super()
        const pollInterval = Math.floor(config.remoteConfig.pollInterval * 1e3)
        this.url =
          config.url ||
          new URL2(
            format({
              protocol: 'http:',
              hostname: config.hostname || defaults.hostname,
              port: config.port,
            })
          )
        tagger.add(config.tags, {
          '_dd.rc.client_id': clientId,
        })
        const tags = config.repositoryUrl
          ? {
              ...config.tags,
              [GIT_REPOSITORY_URL]: config.repositoryUrl,
              [GIT_COMMIT_SHA]: config.commitSHA,
            }
          : config.tags
        this._handlers = /* @__PURE__ */ new Map()
        const appliedConfigs = (this.appliedConfigs = /* @__PURE__ */ new Map())
        this.scheduler = new Scheduler((cb) => this.poll(cb), pollInterval)
        this.state = {
          client: {
            state: {
              // updated by `parseConfig()` and `poll()`
              root_version: 1,
              targets_version: 0,
              // Use getter so `apply_*` can be updated async and still affect the content of `config_states`
              get config_states() {
                const configs = []
                for (const conf of appliedConfigs.values()) {
                  configs.push({
                    id: conf.id,
                    version: conf.version,
                    product: conf.product,
                    apply_state: conf.apply_state,
                    apply_error: conf.apply_error,
                  })
                }
                return configs
              },
              has_error: false,
              error: '',
              backend_client_state: '',
            },
            id: clientId,
            products: [],
            // updated by `updateProducts()`
            is_tracer: true,
            client_tracer: {
              runtime_id: config.tags['runtime-id'],
              language: 'node',
              tracer_version: tracerVersion,
              service: config.service,
              env: config.env,
              app_version: config.version,
              extra_services: [],
              tags: Object.entries(tags).map((pair) => pair.join(':')),
            },
            capabilities: DEFAULT_CAPABILITY,
            // updated by `updateCapabilities()`
          },
          cached_target_files: [],
          // updated by `parseConfig()`
        }
      }
      updateCapabilities(mask, value) {
        const hex = Buffer.from(this.state.client.capabilities, 'base64').toString('hex')
        let num = BigInt(`0x${hex}`)
        if (value) {
          num |= mask
        } else {
          num &= ~mask
        }
        let str = num.toString(16)
        if (str.length % 2) str = `0${str}`
        this.state.client.capabilities = Buffer.from(str, 'hex').toString('base64')
      }
      setProductHandler(product, handler) {
        this._handlers.set(product, handler)
        this.updateProducts()
        if (this.state.client.products.length === 1) {
          this.scheduler.start()
        }
      }
      removeProductHandler(product) {
        this._handlers.delete(product)
        this.updateProducts()
        if (this.state.client.products.length === 0) {
          this.scheduler.stop()
        }
      }
      updateProducts() {
        this.state.client.products = [...this._handlers.keys()]
      }
      getPayload() {
        this.state.client.client_tracer.extra_services = getExtraServices()
        return JSON.stringify(this.state)
      }
      poll(cb) {
        const options = {
          url: this.url,
          method: 'POST',
          path: '/v0.7/config',
          headers: {
            'Content-Type': 'application/json; charset=utf-8',
          },
        }
        request(this.getPayload(), options, (err, data, statusCode) => {
          if (statusCode === 404) return cb()
          if (err) {
            log.errorWithoutTelemetry('[RC] Error in request', err)
            return cb()
          }
          if (this.state.client.state.has_error) {
            this.state.client.state.has_error = false
            this.state.client.state.error = ''
          }
          if (data && data !== '{}') {
            try {
              this.parseConfig(JSON.parse(data))
            } catch (err2) {
              log.error('[RC] Could not parse remote config response', err2)
              this.state.client.state.has_error = true
              this.state.client.state.error = err2.toString()
            }
          }
          cb()
        })
      }
      // `client_configs` is the list of config paths to have applied
      // `targets` is the signed index with metadata for config files
      // `target_files` is the list of config files containing the actual config data
      parseConfig({ client_configs: clientConfigs = [], targets, target_files: targetFiles = [] }) {
        const toUnapply = []
        const toApply = []
        const toModify = []
        for (const appliedConfig of this.appliedConfigs.values()) {
          if (!clientConfigs.includes(appliedConfig.path)) {
            toUnapply.push(appliedConfig)
          }
        }
        targets = fromBase64JSON(targets)
        if (targets) {
          for (const path of clientConfigs) {
            const meta = targets.signed.targets[path]
            if (!meta) throw new Error(`Unable to find target for path ${path}`)
            const current = this.appliedConfigs.get(path)
            const newConf = {}
            if (current) {
              if (current.hashes.sha256 === meta.hashes.sha256) continue
              toModify.push(newConf)
            } else {
              toApply.push(newConf)
            }
            const file = targetFiles.find((file2) => file2.path === path)
            if (!file) throw new Error(`Unable to find file for path ${path}`)
            const { product, id } = parseConfigPath(path)
            Object.assign(newConf, {
              path,
              product,
              id,
              version: meta.custom.v,
              apply_state: UNACKNOWLEDGED,
              apply_error: '',
              length: meta.length,
              hashes: meta.hashes,
              file: fromBase64JSON(file.raw),
            })
          }
          this.state.client.state.targets_version = targets.signed.version
          this.state.client.state.backend_client_state = targets.signed.custom.opaque_backend_state
        }
        if (toUnapply.length || toApply.length || toModify.length) {
          this.emit(_RemoteConfigManager.kPreUpdate, { toUnapply, toApply, toModify })
          this.dispatch(toUnapply, 'unapply')
          this.dispatch(toApply, 'apply')
          this.dispatch(toModify, 'modify')
          this.state.cached_target_files = []
          for (const conf of this.appliedConfigs.values()) {
            const hashes = []
            for (const hash of Object.entries(conf.hashes)) {
              hashes.push({ algorithm: hash[0], hash: hash[1] })
            }
            this.state.cached_target_files.push({
              path: conf.path,
              length: conf.length,
              hashes,
            })
          }
        }
      }
      dispatch(list, action) {
        for (const item of list) {
          this._callHandlerFor(action, item)
          if (action === 'unapply') {
            this.appliedConfigs.delete(item.path)
          } else {
            this.appliedConfigs.set(item.path, item)
          }
        }
      }
      _callHandlerFor(action, item) {
        if (item.apply_state !== UNACKNOWLEDGED && action !== 'unapply') return
        const handler = this._handlers.get(item.product)
        if (!handler) return
        try {
          if (supportsAckCallback(handler)) {
            handler(action, item.file, item.id, (err) => {
              if (err) {
                item.apply_state = ERROR
                item.apply_error = err.toString()
              } else if (item.apply_state !== ERROR) {
                item.apply_state = ACKNOWLEDGED
              }
            })
          } else {
            const result = handler(action, item.file, item.id)
            if (result instanceof Promise) {
              result.then(
                () => {
                  item.apply_state = ACKNOWLEDGED
                },
                (err) => {
                  item.apply_state = ERROR
                  item.apply_error = err.toString()
                }
              )
            } else {
              item.apply_state = ACKNOWLEDGED
            }
          }
        } catch (err) {
          item.apply_state = ERROR
          item.apply_error = err.toString()
        }
      }
    }
    function fromBase64JSON(str) {
      if (!str) return null
      return JSON.parse(Buffer.from(str, 'base64').toString())
    }
    var configPathRegex = /^(?:datadog\/\d+|employee)\/([^/]+)\/([^/]+)\/[^/]+$/
    function parseConfigPath(configPath) {
      const match = configPathRegex.exec(configPath)
      if (!match || !match[1] || !match[2]) {
        throw new Error(`Unable to parse path ${configPath}`)
      }
      return {
        product: match[1],
        id: match[2],
      }
    }
    function supportsAckCallback(handler) {
      if (kSupportsAckCallback in handler) return handler[kSupportsAckCallback]
      const numOfArgs = handler.length
      let result = false
      if (numOfArgs >= 4) {
        result = true
      } else if (numOfArgs !== 0) {
        const source = handler.toString()
        result = source.slice(0, source.indexOf(')')).includes('...')
      }
      handler[kSupportsAckCallback] = result
      return result
    }
    module2.exports = RemoteConfigManager
  },
})

// node_modules/dd-trace/packages/dd-trace/src/remote_config/capabilities.js
var require_capabilities = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/remote_config/capabilities.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      ASM_ACTIVATION: 1n << 1n,
      ASM_IP_BLOCKING: 1n << 2n,
      ASM_DD_RULES: 1n << 3n,
      ASM_EXCLUSIONS: 1n << 4n,
      ASM_REQUEST_BLOCKING: 1n << 5n,
      ASM_RESPONSE_BLOCKING: 1n << 6n,
      ASM_USER_BLOCKING: 1n << 7n,
      ASM_CUSTOM_RULES: 1n << 8n,
      ASM_CUSTOM_BLOCKING_RESPONSE: 1n << 9n,
      ASM_TRUSTED_IPS: 1n << 10n,
      ASM_API_SECURITY_SAMPLE_RATE: 1n << 11n,
      // deprecated
      APM_TRACING_SAMPLE_RATE: 1n << 12n,
      APM_TRACING_LOGS_INJECTION: 1n << 13n,
      APM_TRACING_HTTP_HEADER_TAGS: 1n << 14n,
      APM_TRACING_CUSTOM_TAGS: 1n << 15n,
      ASM_PROCESSOR_OVERRIDES: 1n << 16n,
      ASM_CUSTOM_DATA_SCANNERS: 1n << 17n,
      ASM_EXCLUSION_DATA: 1n << 18n,
      APM_TRACING_ENABLED: 1n << 19n,
      ASM_RASP_SQLI: 1n << 21n,
      ASM_RASP_LFI: 1n << 22n,
      ASM_RASP_SSRF: 1n << 23n,
      ASM_RASP_SHI: 1n << 24n,
      APM_TRACING_SAMPLE_RULES: 1n << 29n,
      ASM_AUTO_USER_INSTRUM_MODE: 1n << 31n,
      ASM_ENDPOINT_FINGERPRINT: 1n << 32n,
      ASM_SESSION_FINGERPRINT: 1n << 33n,
      ASM_NETWORK_FINGERPRINT: 1n << 34n,
      ASM_HEADER_FINGERPRINT: 1n << 35n,
      ASM_RASP_CMDI: 1n << 37n,
      ASM_DD_MULTICONFIG: 1n << 42n,
      ASM_TRACE_TAGGING_RULES: 1n << 43n,
      ASM_EXTENDED_DATA_COLLECTION: 1n << 44n,
      FFE_FLAG_CONFIGURATION_RULES: 1n << 46n,
      /*
        DO NOT ADD ARBITRARY CAPABILITIES IN YOUR CODE
        UNLESS THEY ARE ALREADY DEFINED IN THE BACKEND SOURCE OF TRUTH
        DOING SO TRIGGERS BACKEND ALERTS
      */
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/user_tracking.js
var require_user_tracking = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/user_tracking.js'(exports2, module2) {
    'use strict'
    var crypto = require('crypto')
    var log = require_log2()
    var telemetry = require_telemetry6()
    var addresses = require_addresses()
    var { keepTrace } = require_priority_sampler()
    var waf = require_waf2()
    var { ASM } = require_product()
    var USER_ID_FIELDS = ['id', '_id', 'email', 'username', 'login', 'user']
    var collectionMode
    function setCollectionMode(mode, overwrite = true) {
      if (!overwrite && collectionMode) return
      switch (mode) {
        case 'safe':
          log.warn('[ASM] Using deprecated value "safe" in config.appsec.eventTracking.mode')
        case 'anon':
        case 'anonymization':
          collectionMode = 'anonymization'
          break
        case 'extended':
          log.warn('[ASM] Using deprecated value "extended" in config.appsec.eventTracking.mode')
        case 'ident':
        case 'identification':
          collectionMode = 'identification'
          break
        default:
          collectionMode = 'disabled'
      }
    }
    function obfuscateIfNeeded(str) {
      return collectionMode === 'anonymization'
        ? 'anon_' + crypto.createHash('sha256').update(str).digest().toString('hex', 0, 16).toLowerCase()
        : str
    }
    function getUserId(user) {
      if (!user) return
      for (const field of USER_ID_FIELDS) {
        let id = user[field]
        if (id && typeof id.toString === 'function') {
          id = id.toString()
          if (typeof id !== 'string' || id.startsWith('[object ')) {
            continue
          }
          return obfuscateIfNeeded(id)
        }
      }
    }
    function trackLogin(framework, login, user, success, rootSpan) {
      if (!collectionMode || collectionMode === 'disabled') return
      if (typeof login !== 'string') {
        log.error('[ASM] Invalid login provided to AppSec trackLogin')
        telemetry.incrementMissingUserLoginMetric(framework, success ? 'login_success' : 'login_failure')
        return
      }
      login = obfuscateIfNeeded(login)
      const userId = getUserId(user)
      let newTags
      const persistent = {
        [addresses.USER_LOGIN]: login,
      }
      const currentTags = rootSpan.context()._tags
      const isSdkCalled = currentTags[`_dd.appsec.events.users.login.${success ? 'success' : 'failure'}.sdk`] === 'true'
      function shouldSetTag(tag) {
        return !(isSdkCalled && currentTags[tag])
      }
      if (success) {
        newTags = {
          'appsec.events.users.login.success.track': 'true',
          '_dd.appsec.events.users.login.success.auto.mode': collectionMode,
          '_dd.appsec.usr.login': login,
        }
        if (shouldSetTag('appsec.events.users.login.success.usr.login')) {
          newTags['appsec.events.users.login.success.usr.login'] = login
        }
        if (userId) {
          newTags['_dd.appsec.usr.id'] = userId
          if (shouldSetTag('usr.id')) {
            newTags['usr.id'] = userId
            persistent[addresses.USER_ID] = userId
          }
        }
        persistent[addresses.LOGIN_SUCCESS] = null
      } else {
        newTags = {
          'appsec.events.users.login.failure.track': 'true',
          '_dd.appsec.events.users.login.failure.auto.mode': collectionMode,
          '_dd.appsec.usr.login': login,
        }
        if (shouldSetTag('appsec.events.users.login.failure.usr.login')) {
          newTags['appsec.events.users.login.failure.usr.login'] = login
        }
        if (userId) {
          newTags['_dd.appsec.usr.id'] = userId
          if (shouldSetTag('appsec.events.users.login.failure.usr.id')) {
            newTags['appsec.events.users.login.failure.usr.id'] = userId
          }
        }
        persistent[addresses.LOGIN_FAILURE] = null
      }
      keepTrace(rootSpan, ASM)
      rootSpan.addTags(newTags)
      return waf.run({ persistent })
    }
    function trackUser(user, rootSpan) {
      if (!collectionMode || collectionMode === 'disabled') return
      const userId = getUserId(user)
      if (!userId) {
        log.error('[ASM] No valid user ID found in AppSec trackUser')
        telemetry.incrementMissingUserIdMetric('passport', 'authenticated_request')
        return
      }
      rootSpan.setTag('_dd.appsec.usr.id', userId)
      const isSdkCalled = rootSpan.context()._tags['_dd.appsec.user.collection_mode'] === 'sdk'
      if (!isSdkCalled) {
        rootSpan.addTags({
          'usr.id': userId,
          '_dd.appsec.user.collection_mode': collectionMode,
        })
        return waf.run({
          persistent: {
            [addresses.USER_ID]: userId,
          },
        })
      }
    }
    module2.exports = {
      setCollectionMode,
      trackLogin,
      trackUser,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/remote_config/index.js
var require_remote_config = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/remote_config/index.js'(exports2, module2) {
    'use strict'
    var Activation = require_activation()
    var RemoteConfigManager = require_manager2()
    var RemoteConfigCapabilities = require_capabilities()
    var { setCollectionMode } = require_user_tracking()
    var log = require_log2()
    var { updateConfig } = require_telemetry3()
    var rc
    function enable(config, appsec) {
      rc = new RemoteConfigManager(config)
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_CUSTOM_TAGS, true)
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_HTTP_HEADER_TAGS, true)
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_LOGS_INJECTION, true)
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_SAMPLE_RATE, true)
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_ENABLED, true)
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_SAMPLE_RULES, true)
      rc.updateCapabilities(RemoteConfigCapabilities.FFE_FLAG_CONFIGURATION_RULES, true)
      const activation = Activation.fromConfig(config)
      if (activation !== Activation.DISABLED) {
        if (activation === Activation.ONECLICK) {
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_ACTIVATION, true)
        }
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_AUTO_USER_INSTRUM_MODE, true)
        let autoUserInstrumModeId
        rc.setProductHandler('ASM_FEATURES', (action, rcConfig, configId) => {
          if (!rcConfig) return
          if (typeof rcConfig.auto_user_instrum?.mode === 'string') {
            if (action === 'apply' || action === 'modify') {
              if (autoUserInstrumModeId && configId !== autoUserInstrumModeId) {
                log.error('[RC] Multiple auto_user_instrum received in ASM_FEATURES. Discarding config')
                throw 'Multiple auto_user_instrum.mode received in ASM_FEATURES'
              }
              setCollectionMode(rcConfig.auto_user_instrum.mode)
              autoUserInstrumModeId = configId
            } else if (configId === autoUserInstrumModeId) {
              setCollectionMode(config.appsec.eventTracking.mode)
              autoUserInstrumModeId = null
            }
          }
          if (activation === Activation.ONECLICK) {
            enableOrDisableAppsec(action, rcConfig, config, appsec)
          }
        })
      }
      return rc
    }
    function enableOrDisableAppsec(action, rcConfig, config, appsec) {
      if (typeof rcConfig.asm?.enabled === 'boolean') {
        const isRemoteConfigControlling = action === 'apply' || action === 'modify'
        const shouldEnable = isRemoteConfigControlling ? rcConfig.asm.enabled : config.appsec.enabled
        if (shouldEnable) {
          appsec.enable(config)
        } else {
          appsec.disable()
        }
        updateConfig(
          [
            {
              name: 'appsec.enabled',
              origin: isRemoteConfigControlling ? 'remote_config' : config.getOrigin('appsec.enabled'),
              value: shouldEnable,
            },
          ],
          config
        )
      }
    }
    function enableWafUpdate(appsecConfig) {
      if (rc && appsecConfig && !appsecConfig.rules) {
        const RuleManager = require_rule_manager()
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_IP_BLOCKING, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_USER_BLOCKING, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_RULES, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSIONS, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_REQUEST_BLOCKING, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RESPONSE_BLOCKING, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_RULES, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_BLOCKING_RESPONSE, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRUSTED_IPS, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_PROCESSOR_OVERRIDES, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_DATA_SCANNERS, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSION_DATA, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_ENDPOINT_FINGERPRINT, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_SESSION_FINGERPRINT, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_NETWORK_FINGERPRINT, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_HEADER_FINGERPRINT, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_MULTICONFIG, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRACE_TAGGING_RULES, true)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXTENDED_DATA_COLLECTION, true)
        if (appsecConfig.rasp?.enabled) {
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SQLI, true)
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SSRF, true)
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_LFI, true)
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SHI, true)
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_CMDI, true)
        }
        rc.setProductHandler('ASM_DATA', noop)
        rc.setProductHandler('ASM_DD', noop)
        rc.setProductHandler('ASM', noop)
        rc.on(RemoteConfigManager.kPreUpdate, RuleManager.updateWafFromRC)
      }
    }
    function disableWafUpdate() {
      if (rc) {
        const RuleManager = require_rule_manager()
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_IP_BLOCKING, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_USER_BLOCKING, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_RULES, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSIONS, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_REQUEST_BLOCKING, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RESPONSE_BLOCKING, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_RULES, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_BLOCKING_RESPONSE, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRUSTED_IPS, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_PROCESSOR_OVERRIDES, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_DATA_SCANNERS, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSION_DATA, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_ENDPOINT_FINGERPRINT, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_SESSION_FINGERPRINT, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_NETWORK_FINGERPRINT, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_HEADER_FINGERPRINT, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_MULTICONFIG, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRACE_TAGGING_RULES, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXTENDED_DATA_COLLECTION, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SQLI, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SSRF, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_LFI, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SHI, false)
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_CMDI, false)
        rc.removeProductHandler('ASM_DATA')
        rc.removeProductHandler('ASM_DD')
        rc.removeProductHandler('ASM')
        rc.off(RemoteConfigManager.kPreUpdate, RuleManager.updateWafFromRC)
      }
    }
    function noop() {}
    module2.exports = {
      enable,
      enableWafUpdate,
      disableWafUpdate,
    }
  },
})

// node_modules/dd-trace/vendor/dist/@isaacs/ttlcache/index.js
var require_ttlcache = __commonJS({
  'node_modules/dd-trace/vendor/dist/@isaacs/ttlcache/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var t = {}
      ;((t.d = (e2, i2) => {
        for (var s2 in i2)
          t.o(i2, s2) && !t.o(e2, s2) && Object.defineProperty(e2, s2, { enumerable: true, get: i2[s2] })
      }),
        (t.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2)),
        (t.r = (t2) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(t2, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(t2, '__esModule', { value: true }))
        }))
      var e = {}
      ;(t.r(e), t.d(e, { TTLCache: () => a }))
      let i =
          'object' == typeof performance && performance && 'function' == typeof performance.now ? performance : Date,
        s = () => i.now(),
        r = (t2) => t2 === 1 / 0 || (!!t2 && t2 === Math.floor(t2) && t2 > 0 && isFinite(t2))
      class a {
        expirations = /* @__PURE__ */ Object.create(null)
        data = /* @__PURE__ */ new Map()
        expirationMap = /* @__PURE__ */ new Map()
        ttl
        max
        updateAgeOnGet
        updateAgeOnHas
        noUpdateTTL
        noDisposeOnSet
        checkAgeOnGet
        checkAgeOnHas
        dispose
        timer
        timerExpiration
        immortalKeys = /* @__PURE__ */ new Set()
        constructor({
          max: t2 = 1 / 0,
          ttl: e2,
          updateAgeOnGet: i2 = false,
          checkAgeOnGet: s2 = false,
          updateAgeOnHas: a2 = false,
          checkAgeOnHas: o = false,
          noUpdateTTL: h = false,
          dispose: n,
          noDisposeOnSet: l = false,
        } = {}) {
          if (void 0 !== e2 && !r(e2)) throw TypeError('ttl must be positive integer or Infinity if set')
          if (!r(t2)) throw TypeError('max must be positive integer or Infinity')
          if (
            ((this.ttl = e2),
            (this.max = t2),
            (this.updateAgeOnGet = !!i2),
            (this.checkAgeOnGet = !!s2),
            (this.updateAgeOnHas = !!a2),
            (this.checkAgeOnHas = !!o),
            (this.noUpdateTTL = !!h),
            (this.noDisposeOnSet = !!l),
            void 0 !== n)
          ) {
            if ('function' != typeof n) throw TypeError('dispose must be function if set')
            this.dispose = n
          } else this.dispose = (t3, e3, i3) => {}
          ;((this.timer = void 0), (this.timerExpiration = void 0))
        }
        setTimer(t2, e2) {
          if (this.timerExpiration && this.timerExpiration < t2) return
          this.timer && clearTimeout(this.timer)
          let i2 = setTimeout(
            () => {
              for (let t3 in ((this.timer = void 0),
              (this.timerExpiration = void 0),
              this.purgeStale(),
              this.expirations)) {
                let e3 = Number(t3)
                this.setTimer(e3, e3 - s())
                break
              }
            },
            Math.max(0, e2)
          )
          ;(i2.unref && i2.unref(), (this.timerExpiration = t2), (this.timer = i2))
        }
        cancelTimer() {
          this.timer && (clearTimeout(this.timer), (this.timerExpiration = void 0), (this.timer = void 0))
        }
        cancelTimers() {
          return (
            process.emitWarning(
              'TTLCache.cancelTimers has been renamed to TTLCache.cancelTimer (no "s"), and will be removed in the next major version update'
            ),
            this.cancelTimer()
          )
        }
        clear() {
          let t2 = this.dispose !== a.prototype.dispose ? [...this] : []
          for (let [e2, i2] of (this.data.clear(),
          this.expirationMap.clear(),
          this.cancelTimer(),
          (this.expirations = /* @__PURE__ */ Object.create(null)),
          t2))
            this.dispose(i2, e2, 'delete')
        }
        setTTL(t2, e2 = this.ttl) {
          let i2 = this.expirationMap.get(t2)
          if (void 0 !== i2) {
            let e3 = this.expirations[i2]
            !e3 || e3.length <= 1 ? delete this.expirations[i2] : (this.expirations[i2] = e3.filter((e4) => e4 !== t2))
          }
          if (e2 && e2 !== 1 / 0) {
            this.immortalKeys.delete(t2)
            let i3 = Math.floor(s() + e2)
            ;(this.expirationMap.set(t2, i3),
              this.expirations[i3] || ((this.expirations[i3] = []), this.setTimer(i3, e2)),
              this.expirations[i3].push(t2))
          } else (this.immortalKeys.add(t2), this.expirationMap.set(t2, 1 / 0))
        }
        set(
          t2,
          e2,
          { ttl: i2 = this.ttl, noUpdateTTL: s2 = this.noUpdateTTL, noDisposeOnSet: a2 = this.noDisposeOnSet } = {}
        ) {
          if (!r(i2)) throw TypeError('ttl must be positive integer or Infinity')
          if (this.expirationMap.has(t2)) {
            s2 || this.setTTL(t2, i2)
            let r2 = this.data.get(t2),
              o = !a2 && this.data.has(t2)
            r2 !== e2 && (this.data.set(t2, e2), o && this.dispose(r2, t2, 'set'))
          } else (this.setTTL(t2, i2), this.data.set(t2, e2))
          for (; this.size > this.max; ) this.purgeToCapacity()
          return this
        }
        has(
          t2,
          { checkAgeOnHas: e2 = this.checkAgeOnHas, ttl: i2 = this.ttl, updateAgeOnHas: s2 = this.updateAgeOnHas } = {}
        ) {
          return (
            !!this.data.has(t2) &&
            (e2 && 0 === this.getRemainingTTL(t2) ? (this.delete(t2), false) : (s2 && this.setTTL(t2, i2), true))
          )
        }
        getRemainingTTL(t2) {
          let e2 = this.expirationMap.get(t2)
          return e2 === 1 / 0 ? e2 : void 0 !== e2 ? Math.max(0, Math.ceil(e2 - s())) : 0
        }
        get(
          t2,
          { updateAgeOnGet: e2 = this.updateAgeOnGet, ttl: i2 = this.ttl, checkAgeOnGet: s2 = this.checkAgeOnGet } = {}
        ) {
          let r2 = this.data.get(t2)
          return s2 && 0 === this.getRemainingTTL(t2) ? void this.delete(t2) : (e2 && this.setTTL(t2, i2), r2)
        }
        delete(t2) {
          let e2 = this.expirationMap.get(t2)
          if (void 0 !== e2) {
            let i2 = this.data.get(t2)
            ;(this.data.delete(t2), this.expirationMap.delete(t2), this.immortalKeys.delete(t2))
            let s2 = this.expirations[e2]
            return (
              s2 &&
                (s2.length <= 1 ? delete this.expirations[e2] : (this.expirations[e2] = s2.filter((e3) => e3 !== t2))),
              this.dispose(i2, t2, 'delete'),
              0 === this.size && this.cancelTimer(),
              true
            )
          }
          return false
        }
        purgeToCapacity() {
          for (let t2 in this.expirations) {
            let e2 = this.expirations[t2]
            if (this.size - e2.length >= this.max) {
              delete this.expirations[t2]
              let i2 = []
              for (let t3 of e2) (i2.push([t3, this.data.get(t3)]), this.data.delete(t3), this.expirationMap.delete(t3))
              for (let [t3, e3] of i2) this.dispose(e3, t3, 'evict')
            } else {
              let t3 = this.size - this.max,
                i2 = []
              for (let s2 of e2.splice(0, t3))
                (i2.push([s2, this.data.get(s2)]), this.data.delete(s2), this.expirationMap.delete(s2))
              for (let [t4, e3] of i2) this.dispose(e3, t4, 'evict')
              return
            }
          }
        }
        get size() {
          return this.data.size
        }
        purgeStale() {
          let t2 = Math.ceil(s())
          for (let e2 in this.expirations) {
            if ('Infinity' === e2 || Number(e2) > t2) return
            let i2 = [...(this.expirations[e2] || [])],
              s2 = []
            for (let t3 of (delete this.expirations[e2], i2))
              (s2.push([t3, this.data.get(t3)]), this.data.delete(t3), this.expirationMap.delete(t3))
            for (let [t3, e3] of s2) this.dispose(e3, t3, 'stale')
          }
          0 === this.size && this.cancelTimer()
        }
        *entries() {
          for (let t2 in this.expirations) for (let e2 of this.expirations[t2]) yield [e2, this.data.get(e2)]
          for (let t2 of this.immortalKeys) yield [t2, this.data.get(t2)]
        }
        *keys() {
          for (let t2 in this.expirations) for (let e2 of this.expirations[t2]) yield e2
          for (let t2 of this.immortalKeys) yield t2
        }
        *values() {
          for (let t2 in this.expirations) for (let e2 of this.expirations[t2]) yield this.data.get(e2)
          for (let t2 of this.immortalKeys) yield this.data.get(t2)
        }
        [Symbol.iterator]() {
          return this.entries()
        }
      }
      module2.exports = e
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/api_security_sampler.js
var require_api_security_sampler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/api_security_sampler.js'(exports2, module2) {
    'use strict'
    var { TTLCache } = require_ttlcache()
    var web = require_web3()
    var log = require_log2()
    var { AUTO_REJECT, USER_REJECT } = require_priority()
    var { keepTrace } = require_priority_sampler()
    var { ASM } = require_product()
    var MAX_SIZE = 4096
    var enabled
    var asmStandaloneEnabled
    var sampledRequests
    var NoopTTLCache = class {
      clear() {}
      set(_key, _value) {}
      has(_key) {
        return false
      }
    }
    function configure({ appsec, apmTracingEnabled }) {
      enabled = appsec.apiSecurity.enabled
      asmStandaloneEnabled = apmTracingEnabled === false
      sampledRequests =
        appsec.apiSecurity.sampleDelay === 0
          ? new NoopTTLCache()
          : new TTLCache({ max: MAX_SIZE, ttl: appsec.apiSecurity.sampleDelay * 1e3 })
    }
    function disable() {
      enabled = false
      sampledRequests?.clear()
    }
    function sampleRequest(req, res, force = false) {
      if (!enabled) return false
      const key = computeKey(req, res)
      if (!key || isSampled(key)) return false
      const rootSpan = web.root(req)
      if (!rootSpan) return false
      if (asmStandaloneEnabled) {
        keepTrace(rootSpan, ASM)
      } else {
        let priority = getSpanPriority(rootSpan)
        if (!priority) {
          rootSpan._prioritySampler?.sample(rootSpan)
          priority = getSpanPriority(rootSpan)
        }
        if (priority === AUTO_REJECT || priority === USER_REJECT) {
          return false
        }
      }
      if (force) {
        sampledRequests.set(key, void 0)
      }
      return true
    }
    function isSampled(key) {
      return sampledRequests.has(key)
    }
    function computeKey(req, res) {
      const route = web.getContext(req)?.paths?.join('') || ''
      const method = req.method
      const status = res.statusCode
      if (!method || !status) {
        log.warn('[ASM] Unsupported groupkey for API security')
        return null
      }
      return method + route + status
    }
    function getSpanPriority(span) {
      const spanContext = span.context?.()
      return spanContext._sampling?.priority
    }
    module2.exports = {
      configure,
      disable,
      sampleRequest,
      isSampled,
      computeKey,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/graphql.js
var require_graphql4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/graphql.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var { addSpecificEndpoint, specificBlockingTypes, getBlockingData, getBlockingAction } = require_blocking()
    var log = require_log2()
    var waf = require_waf2()
    var addresses = require_addresses()
    var web = require_web3()
    var {
      startGraphqlResolve,
      graphqlMiddlewareChannel,
      apolloHttpServerChannel,
      apolloChannel,
      apolloServerCoreChannel,
    } = require_channels2()
    var { updateBlockFailureMetric } = require_telemetry6()
    var graphqlRequestData = /* @__PURE__ */ new WeakMap()
    function enable() {
      enableApollo()
      enableGraphql()
    }
    function disable() {
      disableApollo()
      disableGraphql()
    }
    function onGraphqlStartResolve({ context, resolverInfo }) {
      const req = storage('legacy').getStore()?.req
      if (!req) return
      if (!resolverInfo || typeof resolverInfo !== 'object') return
      const result = waf.run({ ephemeral: { [addresses.HTTP_INCOMING_GRAPHQL_RESOLVER]: resolverInfo } }, req)
      const blockingAction = getBlockingAction(result?.actions)
      if (blockingAction) {
        const requestData = graphqlRequestData.get(req)
        if (requestData?.isInGraphqlRequest) {
          requestData.blocked = true
          requestData.wafAction = blockingAction
          context?.abortController?.abort()
        }
      }
    }
    function enterInApolloMiddleware(data) {
      const req = data?.req || storage('legacy').getStore()?.req
      if (!req) return
      graphqlRequestData.set(req, {
        blocked: false,
      })
    }
    function enterInApolloServerCoreRequest() {
      const req = storage('legacy').getStore()?.req
      if (!req) return
      graphqlRequestData.set(req, {
        isInGraphqlRequest: true,
        blocked: false,
      })
    }
    function enterInApolloRequest() {
      const req = storage('legacy').getStore()?.req
      const requestData = graphqlRequestData.get(req)
      if (requestData) {
        requestData.isInGraphqlRequest = true
        addSpecificEndpoint(req.method, req.originalUrl || req.url, specificBlockingTypes.GRAPHQL)
      }
    }
    function beforeWriteApolloGraphqlResponse({ abortController, abortData }) {
      const req = storage('legacy').getStore()?.req
      if (!req) return
      const requestData = graphqlRequestData.get(req)
      if (requestData?.blocked) {
        const rootSpan = web.root(req)
        if (!rootSpan) return
        try {
          const blockingData = getBlockingData(req, specificBlockingTypes.GRAPHQL, requestData.wafAction)
          abortData.statusCode = blockingData.statusCode
          abortData.headers = blockingData.headers
          abortData.message = blockingData.body
          rootSpan.setTag('appsec.blocked', 'true')
          abortController?.abort()
        } catch (err) {
          rootSpan.setTag('_dd.appsec.block.failed', 1)
          log.error('[ASM] Blocking error', err)
          updateBlockFailureMetric(req)
        }
      }
      graphqlRequestData.delete(req)
    }
    function enableApollo() {
      graphqlMiddlewareChannel.subscribe({
        start: enterInApolloMiddleware,
      })
      apolloServerCoreChannel.subscribe({
        start: enterInApolloServerCoreRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse,
      })
      apolloChannel.subscribe({
        start: enterInApolloRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse,
      })
      apolloHttpServerChannel.subscribe({
        start: enterInApolloMiddleware,
      })
    }
    function disableApollo() {
      graphqlMiddlewareChannel.unsubscribe({
        start: enterInApolloMiddleware,
      })
      apolloServerCoreChannel.unsubscribe({
        start: enterInApolloServerCoreRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse,
      })
      apolloChannel.unsubscribe({
        start: enterInApolloRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse,
      })
      apolloHttpServerChannel.unsubscribe({
        start: enterInApolloMiddleware,
      })
    }
    function enableGraphql() {
      startGraphqlResolve.subscribe(onGraphqlStartResolve)
    }
    function disableGraphql() {
      if (startGraphqlResolve.hasSubscribers) startGraphqlResolve.unsubscribe(onGraphqlStartResolve)
    }
    module2.exports = {
      enable,
      disable,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/filter.js
var require_filter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/filter.js'(exports2, module2) {
    'use strict'
    var NODE_MODULES = 'node_modules'
    var isPrivateModule = function (file) {
      return file && !file.includes(NODE_MODULES)
    }
    var isDdTrace = function (file) {
      return Boolean(file?.includes('dd-trace'))
    }
    module2.exports = {
      isPrivateModule,
      isDdTrace,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/csi-methods.js
var require_csi_methods = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/csi-methods.js'(exports2, module2) {
    'use strict'
    var csiMethods = [
      { src: 'concat' },
      { src: 'join' },
      { src: 'parse' },
      { src: 'plusOperator', operator: true },
      { src: 'random' },
      { src: 'replace' },
      { src: 'slice' },
      { src: 'substr' },
      { src: 'substring' },
      { src: 'toLowerCase', dst: 'stringCase' },
      { src: 'toUpperCase', dst: 'stringCase' },
      { src: 'tplOperator', operator: true },
      { src: 'trim' },
      { src: 'trimEnd' },
      { src: 'trimStart', dst: 'trim' },
      { src: 'eval', allowedWithoutCallee: true },
    ]
    module2.exports = {
      csiMethods,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/verbosity.js
var require_verbosity = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/verbosity.js'(exports2, module2) {
    'use strict'
    var Verbosity = {
      OFF: 0,
      MANDATORY: 1,
      INFORMATION: 2,
      DEBUG: 3,
    }
    function isDebugAllowed(value) {
      return value >= Verbosity.DEBUG
    }
    function isInfoAllowed(value) {
      return value >= Verbosity.INFORMATION
    }
    function getVerbosity(verbosity) {
      if (verbosity) {
        verbosity = verbosity.toUpperCase()
        return Verbosity[verbosity] === void 0 ? Verbosity.INFORMATION : Verbosity[verbosity]
      }
      return Verbosity.INFORMATION
    }
    function getName(verbosityValue) {
      for (const name in Verbosity) {
        if (Verbosity[name] === verbosityValue) {
          return name
        }
      }
      return 'OFF'
    }
    module2.exports = {
      Verbosity,
      isDebugAllowed,
      isInfoAllowed,
      getVerbosity,
      getName,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/span-tags.js
var require_span_tags = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/span-tags.js'(exports2, module2) {
    'use strict'
    function addMetricsToSpan(rootSpan, metrics, tagPrefix) {
      if (!rootSpan?.addTags || !metrics) return
      const flattenMap = /* @__PURE__ */ new Map()
      metrics
        .filter((data) => data?.metric)
        .forEach((data) => {
          const name = taggedMetricName(data)
          let total = flattenMap.get(name)
          const value = flatten(data)
          if (total) {
            total += value
          } else {
            total = value
          }
          flattenMap.set(name, total)
        })
      for (const [key, value] of flattenMap) {
        const tagName = `${tagPrefix}.${key}`
        rootSpan.addTags({
          [tagName]: value,
        })
      }
    }
    function flatten(metricData) {
      const { points } = metricData
      return points ? points.map((point) => point[1]).reduce((total, value) => total + value, 0) : 0
    }
    function taggedMetricName(data) {
      const metric = data.metric
      const tags = filterTags(data.tags)
      return tags?.length ? `${metric}.${processTagValue(tags)}` : metric
    }
    function filterTags(tags) {
      return tags?.filter((tag) => !tag.startsWith('version'))
    }
    function processTagValue(tags) {
      return tags
        .map((tag) => (tag.includes(':') ? tag.split(':')[1] : tag))
        .join('_')
        .replaceAll('.', '_')
    }
    module2.exports = {
      addMetricsToSpan,
      filterTags,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/tags.js
var require_tags4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/tags.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      IAST_ENABLED_TAG_KEY: '_dd.iast.enabled',
      IAST_JSON_TAG_KEY: '_dd.iast.json',
      IAST_TRACE_METRIC_PREFIX: '_dd.iast.telemetry',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/namespaces.js
var require_namespaces = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/namespaces.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var { Namespace } = require_metrics()
    var { addMetricsToSpan } = require_span_tags()
    var { IAST_TRACE_METRIC_PREFIX } = require_tags4()
    var DD_IAST_METRICS_NAMESPACE = /* @__PURE__ */ Symbol('_dd.iast.request.metrics.namespace')
    function initRequestNamespace(context) {
      if (!context) return
      const namespace = new IastNamespace()
      context[DD_IAST_METRICS_NAMESPACE] = namespace
      return namespace
    }
    function getNamespaceFromContext(context) {
      return context?.[DD_IAST_METRICS_NAMESPACE]
    }
    function finalizeRequestNamespace(context, rootSpan) {
      try {
        const namespace = getNamespaceFromContext(context)
        if (!namespace) return
        addMetricsToSpan(rootSpan, [...namespace.metrics.values()], IAST_TRACE_METRIC_PREFIX)
        merge(namespace)
        namespace.clear()
      } catch (e) {
        log.error('[ASM] Error merging request metrics', e)
      } finally {
        if (context) {
          delete context[DD_IAST_METRICS_NAMESPACE]
        }
      }
    }
    function merge(namespace) {
      for (const [metricName, metricsByTagMap] of namespace.iastMetrics) {
        for (const [tags, metric] of metricsByTagMap) {
          const { type, points } = metric
          if (points?.length && type === 'count') {
            const gMetric = globalNamespace.getMetric(metricName, tags)
            points.forEach((point) => gMetric.inc(point[1]))
          }
        }
      }
    }
    var IastNamespace = class extends Namespace {
      constructor(maxMetricTagsSize = 100) {
        super('iast')
        this.maxMetricTagsSize = maxMetricTagsSize
        this.iastMetrics = /* @__PURE__ */ new Map()
      }
      getIastMetrics(name) {
        let metrics = this.iastMetrics.get(name)
        if (!metrics) {
          metrics = /* @__PURE__ */ new Map()
          this.iastMetrics.set(name, metrics)
        }
        return metrics
      }
      getMetric(name, tags, type = 'count') {
        const metrics = this.getIastMetrics(name)
        let metric = metrics.get(tags)
        if (!metric) {
          metric = super[type](name, Array.isArray(tags) ? [...tags] : tags)
          if (metrics.size === this.maxMetricTagsSize) {
            metrics.clear()
            log.error('[ASM] Tags cache max size reached for metric %s', name)
          }
          metrics.set(tags, metric)
        }
        return metric
      }
      count(name, tags) {
        return this.getMetric(name, tags, 'count')
      }
      clear() {
        this.iastMetrics.clear()
        this.distributions.clear()
        this.metrics.clear()
      }
    }
    var globalNamespace = new IastNamespace()
    module2.exports = {
      initRequestNamespace,
      getNamespaceFromContext,
      finalizeRequestNamespace,
      globalNamespace,
      DD_IAST_METRICS_NAMESPACE,
      IastNamespace,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/index.js
var require_telemetry7 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/index.js'(exports2, module2) {
    'use strict'
    var telemetryMetrics = require_metrics()
    var { Verbosity, getVerbosity } = require_verbosity()
    var { initRequestNamespace, finalizeRequestNamespace, globalNamespace } = require_namespaces()
    var Telemetry = class {
      configure(config, verbosity) {
        const telemetryAndMetricsEnabled = config?.telemetry?.enabled && config.telemetry.metrics
        this.verbosity = telemetryAndMetricsEnabled ? getVerbosity(verbosity) : Verbosity.OFF
        this.enabled = this.verbosity !== Verbosity.OFF
        if (this.enabled) {
          telemetryMetrics.manager.set('iast', globalNamespace)
        }
      }
      stop() {
        this.enabled = false
        telemetryMetrics.manager.delete('iast')
      }
      isEnabled() {
        return this.enabled
      }
      onRequestStart(context) {
        if (this.isEnabled()) {
          initRequestNamespace(context)
        }
      }
      onRequestEnd(context, rootSpan) {
        if (this.isEnabled()) {
          finalizeRequestNamespace(context, rootSpan)
        }
      }
    }
    module2.exports = new Telemetry()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/iast-metric.js
var require_iast_metric = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/telemetry/iast-metric.js'(exports2, module2) {
    'use strict'
    var { getNamespaceFromContext, globalNamespace } = require_namespaces()
    var Scope = {
      GLOBAL: 'GLOBAL',
      REQUEST: 'REQUEST',
    }
    var PropagationType = {
      STRING: 'STRING',
      JSON: 'JSON',
      URL: 'URL',
    }
    var TagKey = {
      VULNERABILITY_TYPE: 'vulnerability_type',
      SOURCE_TYPE: 'source_type',
      PROPAGATION_TYPE: 'propagation_type',
    }
    function formatTags(tags, tagKey) {
      return tags.map((tagValue) => (tagValue ? [`${tagKey}:${tagValue.toLowerCase()}`] : void 0))
    }
    function getNamespace(scope, context) {
      let namespace = globalNamespace
      if (scope === Scope.REQUEST) {
        namespace = getNamespaceFromContext(context) || globalNamespace
      }
      return namespace
    }
    var IastMetric = class {
      constructor(name, scope, tagKey) {
        this.name = name
        this.scope = scope
        this.tagKey = tagKey
      }
      formatTags(...tags) {
        return formatTags(tags, this.tagKey)
      }
      inc(context, tags, value = 1) {
        const namespace = getNamespace(this.scope, context)
        namespace.count(this.name, tags).inc(value)
      }
    }
    var NoTaggedIastMetric = class extends IastMetric {
      constructor(name, scope) {
        super(name, scope)
        this.tags = []
      }
      inc(context, value = 1) {
        const namespace = getNamespace(this.scope, context)
        namespace.count(this.name, this.tags).inc(value)
      }
    }
    function getExecutedMetric(tagKey) {
      return tagKey === TagKey.VULNERABILITY_TYPE ? EXECUTED_SINK : EXECUTED_SOURCE
    }
    function getInstrumentedMetric(tagKey) {
      return tagKey === TagKey.VULNERABILITY_TYPE ? INSTRUMENTED_SINK : INSTRUMENTED_SOURCE
    }
    var INSTRUMENTED_PROPAGATION = new NoTaggedIastMetric('instrumented.propagation', Scope.GLOBAL)
    var INSTRUMENTED_SOURCE = new IastMetric('instrumented.source', Scope.GLOBAL, TagKey.SOURCE_TYPE)
    var INSTRUMENTED_SINK = new IastMetric('instrumented.sink', Scope.GLOBAL, TagKey.VULNERABILITY_TYPE)
    var EXECUTED_SOURCE = new IastMetric('executed.source', Scope.REQUEST, TagKey.SOURCE_TYPE)
    var EXECUTED_SINK = new IastMetric('executed.sink', Scope.REQUEST, TagKey.VULNERABILITY_TYPE)
    var REQUEST_TAINTED = new NoTaggedIastMetric('request.tainted', Scope.REQUEST)
    var EXECUTED_PROPAGATION = new NoTaggedIastMetric('executed.propagation', Scope.REQUEST)
    var EXECUTED_TAINTED = new NoTaggedIastMetric('executed.tainted', Scope.REQUEST)
    var SUPPRESSED_VULNERABILITIES = new IastMetric(
      'suppressed.vulnerabilities',
      Scope.REQUEST,
      TagKey.VULNERABILITY_TYPE
    )
    module2.exports = {
      INSTRUMENTED_PROPAGATION,
      INSTRUMENTED_SOURCE,
      INSTRUMENTED_SINK,
      EXECUTED_PROPAGATION,
      EXECUTED_SOURCE,
      EXECUTED_SINK,
      EXECUTED_TAINTED,
      REQUEST_TAINTED,
      SUPPRESSED_VULNERABILITIES,
      PropagationType,
      TagKey,
      IastMetric,
      NoTaggedIastMetric,
      getExecutedMetric,
      getInstrumentedMetric,
      formatTags,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/rewriter-telemetry.js
var require_rewriter_telemetry = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/rewriter-telemetry.js'(exports2, module2) {
    'use strict'
    var iastTelemetry = require_telemetry7()
    var { Verbosity } = require_verbosity()
    var { INSTRUMENTED_PROPAGATION } = require_iast_metric()
    function incrementTelemetryIfNeeded(metrics) {
      if (iastTelemetry.verbosity !== Verbosity.OFF && metrics?.instrumentedPropagation) {
        INSTRUMENTED_PROPAGATION.inc(void 0, metrics.instrumentedPropagation)
      }
    }
    module2.exports = { incrementTelemetryIfNeeded }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/constants.js
var require_constants3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/constants.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      LOG_MESSAGE: 'LOG',
      REWRITTEN_MESSAGE: 'REWRITTEN',
    }
  },
})

// node_modules/dd-trace/packages/datadog-instrumentations/src/orchestrion-config/index.js
var require_orchestrion_config = __commonJS({
  'node_modules/dd-trace/packages/datadog-instrumentations/src/orchestrion-config/index.js'(exports2, module2) {
    'use strict'
    module2.exports = `
version: 1
dc_module: dc-polyfill
instrumentations:
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/runnables/base.js
    function_query:
      name: invoke
      type: method
      kind: async
      class: RunnableSequence
    operator: tracePromise
    channel_name: "RunnableSequence_invoke"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/runnables/base.js
    function_query:
      name: batch
      type: method
      kind: async
      class: RunnableSequence
    operator: tracePromise
    channel_name: "RunnableSequence_batch"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/language_models/chat_models.js
    function_query:
      name: generate
      type: method
      kind: async
      class: BaseChatModel
    operator: tracePromise
    channel_name: "BaseChatModel_generate"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/language_models/llms.js
    function_query:
      name: generate
      type: method
      kind: async
    operator: tracePromise
    channel_name: "BaseLLM_generate"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/embeddings.js
    function_query:
      name: constructor
      type: method
      kind: sync
      class: Embeddings
    operator: traceSync
    channel_name: "Embeddings_constructor"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/tools/index.js
    function_query:
      name: invoke
      type: method
      kind: async
      class: StructuredTool
    operator: tracePromise
    channel_name: "Tool_invoke"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/vectorstores.js
    function_query:
      name: similaritySearch
      type: method
      kind: async
      class: VectorStore
    operator: tracePromise
    channel_name: "VectorStore_similaritySearch"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/vectorstores.js
    function_query:
      name: similaritySearchWithScore
      type: method
      kind: async
      class: VectorStore
    operator: tracePromise
    channel_name: "VectorStore_similaritySearchWithScore"
`
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/rewriter.js
var require_rewriter2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/rewriter.js'(exports2, module2) {
    'use strict'
    var Module = require('module')
    var { pathToFileURL } = require('url')
    var { MessageChannel: MessageChannel2 } = require('worker_threads')
    var shimmer = require_datadog_shimmer()
    var { isPrivateModule, isDdTrace } = require_filter()
    var { csiMethods } = require_csi_methods()
    var { getName } = require_verbosity()
    var telemetry = require_telemetry7()
    var { incrementTelemetryIfNeeded } = require_rewriter_telemetry()
    var dc = require_dc_polyfill()
    var log = require_log2()
    var { isMainThread } = require('worker_threads')
    var { LOG_MESSAGE, REWRITTEN_MESSAGE } = require_constants3()
    var orchestrionConfig = require_orchestrion_config()
    var { getEnvironmentVariable } = require_config_helper()
    var config
    var hardcodedSecretCh = dc.channel('datadog:secrets:result')
    var rewriter
    var unwrapCompile = () => {}
    var getPrepareStackTrace
    var cacheRewrittenSourceMap
    var kSymbolPrepareStackTrace
    function noop() {}
    function isFlagPresent(flag) {
      return (
        getEnvironmentVariable('NODE_OPTIONS')?.includes(flag) || process.execArgv?.some((arg) => arg.includes(flag))
      )
    }
    var getRewriterOriginalPathAndLineFromSourceMap = function (path, line, column) {
      return { path, line, column }
    }
    function setGetOriginalPathAndLineFromSourceMapFunction(
      chainSourceMap,
      { getOriginalPathAndLineFromSourceMap: getOriginalPathAndLineFromSourceMap2 }
    ) {
      if (!getOriginalPathAndLineFromSourceMap2) return
      getRewriterOriginalPathAndLineFromSourceMap = chainSourceMap
        ? (path, line, column) => {
            return !globalThis.__DD_ESBUILD_IAST_WITH_SM && isPrivateModule(path) && !isDdTrace(path)
              ? { path, line, column }
              : getOriginalPathAndLineFromSourceMap2(path, line, column)
          }
        : getOriginalPathAndLineFromSourceMap2
    }
    function getRewriter(telemetryVerbosity) {
      if (!rewriter) {
        try {
          const iastRewriter = require('@datadog/wasm-js-rewriter')
          const Rewriter = iastRewriter.Rewriter
          getPrepareStackTrace = iastRewriter.getPrepareStackTrace
          kSymbolPrepareStackTrace = iastRewriter.kSymbolPrepareStackTrace
          cacheRewrittenSourceMap = iastRewriter.cacheRewrittenSourceMap
          const chainSourceMap = isFlagPresent('--enable-source-maps')
          setGetOriginalPathAndLineFromSourceMapFunction(chainSourceMap, iastRewriter)
          rewriter = new Rewriter({
            csiMethods,
            telemetryVerbosity: getName(telemetryVerbosity),
            chainSourceMap,
            orchestrion: orchestrionConfig,
          })
        } catch (e) {
          log.error('Unable to initialize Rewriter', e)
        }
      }
      return rewriter
    }
    var originalPrepareStackTrace
    function getPrepareStackTraceAccessor() {
      if (!getPrepareStackTrace) {
        getPrepareStackTrace = require('@datadog/wasm-js-rewriter/js/stack-trace').getPrepareStackTrace
      }
      originalPrepareStackTrace = Error.prepareStackTrace
      let actual = getPrepareStackTrace(originalPrepareStackTrace)
      return {
        configurable: true,
        get() {
          return actual
        },
        set(value) {
          actual = getPrepareStackTrace(value)
          originalPrepareStackTrace = value
        },
      }
    }
    function getCompileMethodFn(compileMethod) {
      let delegate = function (content, filename) {
        try {
          if (isDdTrace(filename)) {
            return compileMethod.apply(this, [content, filename])
          }
          if (!isPrivateModule(filename) || !config.iast?.enabled) {
            return compileMethod.apply(this, [content, filename])
          }
          const rewritten = rewriter.rewrite(content, filename, ['iast'])
          incrementTelemetryIfNeeded(rewritten.metrics)
          if (rewritten?.literalsResult && hardcodedSecretCh.hasSubscribers) {
            hardcodedSecretCh.publish(rewritten.literalsResult)
          }
          if (rewritten?.content) {
            return compileMethod.apply(this, [rewritten.content, filename])
          }
        } catch (e) {
          log.error('Error rewriting file %s', filename, e)
        }
        return compileMethod.apply(this, [content, filename])
      }
      const shim = function () {
        return delegate.apply(this, arguments)
      }
      unwrapCompile = function () {
        delegate = compileMethod
      }
      return shim
    }
    function esmRewritePostProcess(rewritten, filename) {
      const { literalsResult, metrics } = rewritten
      if (metrics?.status === 'modified') {
        if (filename.startsWith('file://')) {
          filename = filename.slice(7)
        }
        cacheRewrittenSourceMap(filename, rewritten.content)
      }
      incrementTelemetryIfNeeded(metrics)
      if (literalsResult && hardcodedSecretCh.hasSubscribers) {
        hardcodedSecretCh.publish(literalsResult)
      }
    }
    var shimmedPrepareStackTrace = false
    function shimPrepareStackTrace() {
      if (shimmedPrepareStackTrace) {
        return
      }
      const pstDescriptor = Object.getOwnPropertyDescriptor(global.Error, 'prepareStackTrace')
      if (!pstDescriptor || pstDescriptor.configurable || pstDescriptor.writable) {
        Object.defineProperty(global.Error, 'prepareStackTrace', getPrepareStackTraceAccessor())
      }
      shimmedPrepareStackTrace = true
    }
    function enableRewriter(telemetryVerbosity) {
      try {
        if (config.iast?.enabled) {
          const rewriter2 = getRewriter(telemetryVerbosity)
          if (rewriter2) {
            shimPrepareStackTrace()
            if (!globalThis.__DD_ESBUILD_IAST_WITH_SM && !globalThis.__DD_ESBUILD_IAST_WITH_NO_SM) {
              shimmer.wrap(Module.prototype, '_compile', (compileMethod) => getCompileMethodFn(compileMethod))
            }
          }
          enableEsmRewriter(telemetryVerbosity)
        }
      } catch (e) {
        log.error('Error enabling Rewriter', e)
      }
    }
    function isEsmConfigured() {
      const hasLoaderArg = isFlagPresent('--loader') || isFlagPresent('--experimental-loader')
      if (hasLoaderArg) return true
      if (require.cache[`${process.cwd()}/node_modules/import-in-the-middle/hook.js`]) {
        return true
      }
      return Object.keys(require.cache).some((file) => file.endsWith('import-in-the-middle/hook.js'))
    }
    var enableEsmRewriter = function (telemetryVerbosity) {
      if (isMainThread && Module.register && isEsmConfigured()) {
        shimPrepareStackTrace()
        const { port1, port2 } = new MessageChannel2()
        port1.on('message', (message) => {
          const { type, data } = message
          switch (type) {
            case LOG_MESSAGE:
              log[data.level]?.(...data.messages)
              break
            case REWRITTEN_MESSAGE:
              esmRewritePostProcess(data.rewritten, data.url)
              break
          }
        })
        port1.unref()
        port2.unref()
        try {
          Module.register('./rewriter-esm.mjs', {
            parentURL: pathToFileURL(__filename),
            transferList: [port2],
            data: {
              port: port2,
              csiMethods,
              telemetryVerbosity,
              chainSourceMap: isFlagPresent('--enable-source-maps'),
              orchestrionConfig,
              iastEnabled: config?.iast?.enabled,
            },
          })
        } catch (e) {
          log.error('Error enabling ESM Rewriter', e)
          port1.close()
          port2.close()
        }
        cacheRewrittenSourceMap = require('@datadog/wasm-js-rewriter/js/source-map').cacheRewrittenSourceMap
        enableEsmRewriter = noop
      }
    }
    function disable() {
      unwrapCompile()
      if (!Error.prepareStackTrace?.[kSymbolPrepareStackTrace]) return
      try {
        delete Error.prepareStackTrace
        Error.prepareStackTrace = originalPrepareStackTrace
        shimmedPrepareStackTrace = false
      } catch (e) {
        log.warn('Error disabling Rewriter', e)
      }
    }
    function getOriginalPathAndLineFromSourceMap({ path, line, column }) {
      return getRewriterOriginalPathAndLineFromSourceMap(path, line, column)
    }
    function enable(configArg) {
      config = configArg
      enableRewriter(telemetry.verbosity || 'OFF')
    }
    module2.exports = {
      enable,
      disable,
      getOriginalPathAndLineFromSourceMap,
      getRewriter,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/stack_trace.js
var require_stack_trace = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/stack_trace.js'(exports2, module2) {
    'use strict'
    var { ddBasePath } = require_util()
    var { getOriginalPathAndLineFromSourceMap } = require_rewriter2()
    var LIBRARY_FRAMES_BUFFER = 20
    var STACK_TRACE_NAMESPACES = {
      RASP: 'exploit',
      IAST: 'vulnerability',
    }
    function prepareStackTrace(_, callsites) {
      return callsites
    }
    function getCallSiteList(maxDepth = 100, constructorOpt) {
      const previousPrepareStackTrace = Error.prepareStackTrace
      const previousStackTraceLimit = Error.stackTraceLimit
      Error.stackTraceLimit = maxDepth + LIBRARY_FRAMES_BUFFER
      try {
        Error.prepareStackTrace = prepareStackTrace
        const obj = {}
        Error.captureStackTrace(obj, constructorOpt)
        return obj.stack
      } finally {
        Error.prepareStackTrace = previousPrepareStackTrace
        Error.stackTraceLimit = previousStackTraceLimit
      }
    }
    function filterOutFramesFromLibrary(callSiteList) {
      return callSiteList.filter((callSite) => {
        if (globalThis.__DD_ESBUILD_IAST_WITH_NO_SM) {
          return true
        }
        if (globalThis.__DD_ESBUILD_IAST_WITH_SM) {
          const callSiteLocation = {
            path: callSite.getTranslatedFileName?.() ?? callSite.getFileName(),
            line: callSite.getTranslatedLineNumber?.() ?? callSite.getLineNumber(),
            column: callSite.getTranslatedColumnNumber?.() ?? callSite.getColumnNumber(),
          }
          const { path } = getOriginalPathAndLineFromSourceMap(callSiteLocation)
          return !path?.startsWith(ddBasePath)
        }
        return !callSite.getFileName()?.startsWith(ddBasePath)
      })
    }
    function getCallsiteFrames(
      maxDepth = 32,
      constructorOpt = getCallsiteFrames,
      callSiteListGetter = getCallSiteList
    ) {
      if (maxDepth < 1) maxDepth = Infinity
      const callSiteList = callSiteListGetter(maxDepth, constructorOpt)
      const filteredFrames = filterOutFramesFromLibrary(callSiteList)
      const half = filteredFrames.length > maxDepth ? Math.round(maxDepth / 2) : Infinity
      const indexedFrames = []
      for (let i = 0; i < Math.min(filteredFrames.length, maxDepth); i++) {
        const index = i < half ? i : i + filteredFrames.length - maxDepth
        const callSite = filteredFrames[index]
        indexedFrames.push({
          id: index,
          file: callSite.getTranslatedFileName?.() ?? callSite.getFileName(),
          line: callSite.getTranslatedLineNumber?.() ?? callSite.getLineNumber(),
          column: callSite.getTranslatedColumnNumber?.() ?? callSite.getColumnNumber(),
          function: callSite.getFunctionName(),
          class_name: callSite.getTypeName(),
          isNative: callSite.isNative(),
        })
      }
      return indexedFrames
    }
    function reportStackTrace(rootSpan, stackId, frames, namespace = STACK_TRACE_NAMESPACES.RASP) {
      if (!rootSpan) return
      if (!Array.isArray(frames)) return
      if (!rootSpan.meta_struct) {
        rootSpan.meta_struct = {}
      }
      if (!rootSpan.meta_struct['_dd.stack']) {
        rootSpan.meta_struct['_dd.stack'] = {}
      }
      if (!rootSpan.meta_struct['_dd.stack'][namespace]) {
        rootSpan.meta_struct['_dd.stack'][namespace] = []
      }
      rootSpan.meta_struct['_dd.stack'][namespace].push({
        id: stackId,
        language: 'nodejs',
        frames,
      })
    }
    function canReportStackTrace(rootSpan, maxStackTraces, namespace = STACK_TRACE_NAMESPACES.RASP) {
      if (!rootSpan) return false
      return maxStackTraces < 1 || (rootSpan.meta_struct?.['_dd.stack']?.[namespace]?.length ?? 0) < maxStackTraces
    }
    module2.exports = {
      getCallsiteFrames,
      reportStackTrace,
      canReportStackTrace,
      STACK_TRACE_NAMESPACES,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/utils.js
var require_utils9 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/utils.js'(exports2, module2) {
    'use strict'
    var web = require_web3()
    var { getCallsiteFrames, reportStackTrace, canReportStackTrace } = require_stack_trace()
    var { getBlockingAction } = require_blocking()
    var log = require_log2()
    var { updateRaspRuleMatchMetricTags } = require_telemetry6()
    var abortOnUncaughtException = process.execArgv?.includes('--abort-on-uncaught-exception')
    if (abortOnUncaughtException) {
      log.warn('[ASM] The --abort-on-uncaught-exception flag is enabled. The RASP module will not block operations.')
    }
    var RULE_TYPES = {
      COMMAND_INJECTION: 'command_injection',
      LFI: 'lfi',
      SQL_INJECTION: 'sql_injection',
      SSRF: 'ssrf',
    }
    var ALLOWED_ROOTSPAN_NAMES = /* @__PURE__ */ new Set(['express.request', 'fastify.request'])
    var DatadogRaspAbortError = class extends Error {
      constructor(req, res, blockingAction, raspRule, ruleTriggered) {
        super('DatadogRaspAbortError')
        this.name = 'DatadogRaspAbortError'
        this.req = req
        this.res = res
        this.blockingAction = blockingAction
        this.raspRule = raspRule
        this.ruleTriggered = ruleTriggered
        Object.defineProperties(this, {
          req: { enumerable: false },
          res: { enumerable: false },
        })
      }
    }
    function handleResult(result, req, res, abortController, config, raspRule) {
      const generateStackTraceAction = result?.actions?.generate_stack
      const { enabled, maxDepth, maxStackTraces } = config.appsec.stackTrace
      const rootSpan = web.root(req)
      const ruleTriggered = !!result?.events?.length
      if (generateStackTraceAction && enabled && canReportStackTrace(rootSpan, maxStackTraces)) {
        const frames = getCallsiteFrames(maxDepth, handleResult)
        reportStackTrace(rootSpan, generateStackTraceAction.stack_id, frames)
      }
      if (abortController && !abortOnUncaughtException) {
        const blockingAction = getBlockingAction(result?.actions)
        const rootSpanName = rootSpan?.context?.()?._name
        if (blockingAction && ALLOWED_ROOTSPAN_NAMES.has(rootSpanName)) {
          const abortError = new DatadogRaspAbortError(req, res, blockingAction, raspRule, ruleTriggered)
          abortController.abort(abortError)
          return
        }
      }
      if (ruleTriggered) {
        updateRaspRuleMatchMetricTags(req, raspRule, false, false)
      }
    }
    module2.exports = {
      handleResult,
      RULE_TYPES,
      DatadogRaspAbortError,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/ssrf.js
var require_ssrf = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/ssrf.js'(exports2, module2) {
    'use strict'
    var { format } = require('url')
    var { httpClientRequestStart } = require_channels2()
    var { storage } = require_datadog_core()
    var addresses = require_addresses()
    var waf = require_waf2()
    var { RULE_TYPES, handleResult } = require_utils9()
    var config
    function enable(_config) {
      config = _config
      httpClientRequestStart.subscribe(analyzeSsrf)
    }
    function disable() {
      if (httpClientRequestStart.hasSubscribers) httpClientRequestStart.unsubscribe(analyzeSsrf)
    }
    function analyzeSsrf(ctx) {
      const store = storage('legacy').getStore()
      const req = store?.req
      const outgoingUrl = (ctx.args.options?.uri && format(ctx.args.options.uri)) ?? ctx.args.uri
      if (!req || !outgoingUrl) return
      const ephemeral = {
        [addresses.HTTP_OUTGOING_URL]: outgoingUrl,
      }
      const raspRule = { type: RULE_TYPES.SSRF }
      const result = waf.run({ ephemeral }, req, raspRule)
      const res = store?.res
      handleResult(result, req, res, ctx.abortController, config, raspRule)
    }
    module2.exports = { enable, disable }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/sql_injection.js
var require_sql_injection = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/sql_injection.js'(exports2, module2) {
    'use strict'
    var { pgQueryStart, pgPoolQueryStart, wafRunFinished, mysql2OuterQueryStart } = require_channels2()
    var { storage } = require_datadog_core()
    var addresses = require_addresses()
    var waf = require_waf2()
    var { RULE_TYPES, handleResult } = require_utils9()
    var DB_SYSTEM_POSTGRES = 'postgresql'
    var DB_SYSTEM_MYSQL = 'mysql'
    var reqQueryMap = /* @__PURE__ */ new WeakMap()
    var config
    function enable(_config) {
      config = _config
      pgQueryStart.subscribe(analyzePgSqlInjection)
      pgPoolQueryStart.subscribe(analyzePgSqlInjection)
      wafRunFinished.subscribe(clearQuerySet)
      mysql2OuterQueryStart.subscribe(analyzeMysql2SqlInjection)
    }
    function disable() {
      if (pgQueryStart.hasSubscribers) pgQueryStart.unsubscribe(analyzePgSqlInjection)
      if (pgPoolQueryStart.hasSubscribers) pgPoolQueryStart.unsubscribe(analyzePgSqlInjection)
      if (wafRunFinished.hasSubscribers) wafRunFinished.unsubscribe(clearQuerySet)
      if (mysql2OuterQueryStart.hasSubscribers) mysql2OuterQueryStart.unsubscribe(analyzeMysql2SqlInjection)
    }
    function analyzeMysql2SqlInjection(ctx) {
      const query = ctx.sql
      if (!query) return
      analyzeSqlInjection(query, DB_SYSTEM_MYSQL, ctx.abortController)
    }
    function analyzePgSqlInjection(ctx) {
      const query = ctx.query?.text
      if (!query) return
      analyzeSqlInjection(query, DB_SYSTEM_POSTGRES, ctx.abortController)
    }
    function analyzeSqlInjection(query, dbSystem, abortController) {
      const store = storage('legacy').getStore()
      if (!store) return
      const { req, res } = store
      if (!req) return
      let executedQueries = reqQueryMap.get(req)
      if (executedQueries?.has(query)) return
      if (!executedQueries) {
        executedQueries = /* @__PURE__ */ new Set()
        reqQueryMap.set(req, executedQueries)
      }
      executedQueries.add(query)
      const ephemeral = {
        [addresses.DB_STATEMENT]: query,
        [addresses.DB_SYSTEM]: dbSystem,
      }
      const raspRule = { type: RULE_TYPES.SQL_INJECTION }
      const result = waf.run({ ephemeral }, req, raspRule)
      handleResult(result, req, res, abortController, config, raspRule)
    }
    function hasInputAddress(payload) {
      return hasAddressesObjectInputAddress(payload.ephemeral) || hasAddressesObjectInputAddress(payload.persistent)
    }
    function hasAddressesObjectInputAddress(addressesObject) {
      return (
        addressesObject &&
        Object.keys(addressesObject).some(
          (address) => address.startsWith('server.request') || address.startsWith('graphql.server')
        )
      )
    }
    function clearQuerySet({ payload }) {
      if (!payload) return
      const store = storage('legacy').getStore()
      if (!store) return
      const { req } = store
      if (!req) return
      const executedQueries = reqQueryMap.get(req)
      if (!executedQueries) return
      if (hasInputAddress(payload)) {
        executedQueries.clear()
      }
    }
    module2.exports = { enable, disable }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/fs-plugin.js
var require_fs_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/fs-plugin.js'(exports2, module2) {
    'use strict'
    var Plugin = require_plugin()
    var { storage } = require_datadog_core()
    var log = require_log2()
    var RASP_MODULE = 'rasp'
    var IAST_MODULE = 'iast'
    var enabledFor = {
      [RASP_MODULE]: false,
      [IAST_MODULE]: false,
    }
    var fsPlugin
    function getStoreToStart(fsProps, store = storage('legacy').getStore()) {
      if (store && !store.fs?.opExcluded) {
        return {
          ...store,
          fs: {
            ...store.fs,
            ...fsProps,
            parentStore: store,
          },
        }
      }
      return store
    }
    var AppsecFsPlugin = class extends Plugin {
      enable() {
        this.addBind('apm:fs:operation:start', this._onFsOperationStart)
        this.addBind('apm:fs:operation:finish', this._onFsOperationFinishOrRenderEnd)
        this.addBind('tracing:datadog:express:response:render:start', this._onResponseRenderStart)
        this.addBind('tracing:datadog:express:response:render:end', this._onFsOperationFinishOrRenderEnd)
        super.configure(true)
      }
      disable() {
        super.configure(false)
      }
      _onFsOperationStart() {
        const store = storage('legacy').getStore()
        if (store) {
          return getStoreToStart({ root: store.fs?.root === void 0 }, store)
        }
      }
      _onResponseRenderStart() {
        return getStoreToStart({ opExcluded: true })
      }
      _onFsOperationFinishOrRenderEnd() {
        const store = storage('legacy').getStore()
        if (store?.fs) {
          return store.fs.parentStore
        }
        return store
      }
    }
    function enable(mod2) {
      if (enabledFor[mod2] !== false) return
      enabledFor[mod2] = true
      if (!fsPlugin) {
        fsPlugin = new AppsecFsPlugin()
        fsPlugin.enable()
      }
      log.info('[ASM] Enabled AppsecFsPlugin for %s', mod2)
    }
    function disable(mod2) {
      if (!mod2 || !enabledFor[mod2]) return
      enabledFor[mod2] = false
      const allDisabled = Object.values(enabledFor).every((val) => val === false)
      if (allDisabled) {
        fsPlugin?.disable()
        fsPlugin = void 0
      }
      log.info('[ASM] Disabled AppsecFsPlugin for %s', mod2)
    }
    module2.exports = {
      enable,
      disable,
      AppsecFsPlugin,
      RASP_MODULE,
      IAST_MODULE,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/lfi.js
var require_lfi = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/lfi.js'(exports2, module2) {
    'use strict'
    var { isAbsolute } = require('path')
    var { fsOperationStart, incomingHttpRequestStart, expressResponseRenderStart } = require_channels2()
    var { storage } = require_datadog_core()
    var { enable: enableFsPlugin, disable: disableFsPlugin, RASP_MODULE } = require_fs_plugin()
    var { FS_OPERATION_PATH } = require_addresses()
    var waf = require_waf2()
    var { RULE_TYPES, handleResult } = require_utils9()
    var config
    var enabled
    var analyzeSubscribed
    function enable(_config) {
      config = _config
      if (enabled) return
      enabled = true
      incomingHttpRequestStart.subscribe(onFirstReceivedRequest)
    }
    function disable() {
      if (fsOperationStart.hasSubscribers) fsOperationStart.unsubscribe(analyzeLfi)
      if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(onFirstReceivedRequest)
      if (expressResponseRenderStart.hasSubscribers) expressResponseRenderStart.unsubscribe(analyzeLfiInResponseRender)
      disableFsPlugin(RASP_MODULE)
      enabled = false
      analyzeSubscribed = false
    }
    function onFirstReceivedRequest() {
      process.nextTick(() => {
        incomingHttpRequestStart.unsubscribe(onFirstReceivedRequest)
      })
      enableFsPlugin(RASP_MODULE)
      if (!analyzeSubscribed) {
        fsOperationStart.subscribe(analyzeLfi)
        expressResponseRenderStart.subscribe(analyzeLfiInResponseRender)
        analyzeSubscribed = true
      }
    }
    function analyzeLfiInResponseRender(ctx) {
      const store = storage('legacy').getStore()
      if (!store) return
      analyzeLfiPath(ctx.view, ctx.req, store.res, ctx.abortController)
    }
    function analyzeLfi(ctx) {
      const store = storage('legacy').getStore()
      if (!store) return
      const { req, fs, res } = store
      if (!req || !fs) return
      getPaths(ctx, fs).forEach((path) => {
        analyzeLfiPath(path, req, res, ctx.abortController)
      })
    }
    function analyzeLfiPath(path, req, res, abortController) {
      const ephemeral = {
        [FS_OPERATION_PATH]: path,
      }
      const raspRule = { type: RULE_TYPES.LFI }
      const result = waf.run({ ephemeral }, req, raspRule)
      handleResult(result, req, res, abortController, config, raspRule)
    }
    function getPaths(ctx, fs) {
      const pathArguments = [
        ctx.dest,
        ctx.existingPath,
        ctx.file,
        ctx.newPath,
        ctx.oldPath,
        ctx.path,
        ctx.prefix,
        ctx.src,
        ctx.target,
      ]
      return pathArguments.map((path) => pathToStr(path)).filter((path) => shouldAnalyze(path, fs))
    }
    function pathToStr(path) {
      if (!path) return
      if (
        typeof path === 'string' || // eslint-disable-next-line unicorn/no-instanceof-builtins
        path instanceof String ||
        path instanceof Buffer ||
        path instanceof URL
      ) {
        return path.toString()
      }
    }
    function shouldAnalyze(path, fs) {
      if (!path) return
      const notExcludedRootOp = !fs.opExcluded && fs.root
      return notExcludedRootOp && (isAbsolute(path) || path.includes('../') || shouldAnalyzeURLFile(path, fs))
    }
    function shouldAnalyzeURLFile(path, fs) {
      if (path.startsWith('file://')) {
        return shouldAnalyze(path.slice(7), fs)
      }
    }
    module2.exports = {
      enable,
      disable,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/command_injection.js
var require_command_injection = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/command_injection.js'(exports2, module2) {
    'use strict'
    var { childProcessExecutionTracingChannel } = require_channels2()
    var { RULE_TYPES, handleResult } = require_utils9()
    var { storage } = require_datadog_core()
    var addresses = require_addresses()
    var waf = require_waf2()
    var config
    function enable(_config) {
      config = _config
      childProcessExecutionTracingChannel.subscribe({
        start: analyzeCommandInjection,
      })
    }
    function disable() {
      if (childProcessExecutionTracingChannel.start.hasSubscribers) {
        childProcessExecutionTracingChannel.unsubscribe({
          start: analyzeCommandInjection,
        })
      }
    }
    function analyzeCommandInjection({ file, fileArgs, shell, abortController }) {
      if (!file) return
      const store = storage('legacy').getStore()
      const req = store?.req
      if (!req) return
      const ephemeral = {}
      const raspRule = { type: RULE_TYPES.COMMAND_INJECTION }
      const params = fileArgs ? [file, ...fileArgs] : file
      if (shell) {
        ephemeral[addresses.SHELL_COMMAND] = params
        raspRule.variant = 'shell'
      } else {
        const commandParams = Array.isArray(params) ? params : [params]
        ephemeral[addresses.EXEC_COMMAND] = commandParams
        raspRule.variant = 'exec'
      }
      const result = waf.run({ ephemeral }, req, raspRule)
      const res = store?.res
      handleResult(result, req, res, abortController, config, raspRule)
    }
    module2.exports = {
      enable,
      disable,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/index.js
var require_rasp2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/rasp/index.js'(exports2, module2) {
    'use strict'
    var web = require_web3()
    var {
      setUncaughtExceptionCaptureCallbackStart,
      expressMiddlewareError,
      fastifyMiddlewareError,
      routerMiddlewareError,
    } = require_channels2()
    var { block, registerBlockDelegation, isBlocked } = require_blocking()
    var ssrf = require_ssrf()
    var sqli = require_sql_injection()
    var lfi = require_lfi()
    var cmdi = require_command_injection()
    var { updateRaspRuleMatchMetricTags } = require_telemetry6()
    var { DatadogRaspAbortError } = require_utils9()
    function removeAllListeners(emitter, event) {
      const listeners = emitter.listeners(event)
      emitter.removeAllListeners(event)
      let cleaned = false
      return function () {
        if (cleaned === true) {
          return
        }
        cleaned = true
        for (const listener of listeners) {
          emitter.on(event, listener)
        }
      }
    }
    function findDatadogRaspAbortError(err, deep = 10) {
      if (err instanceof DatadogRaspAbortError) {
        return err
      }
      if (err?.cause && deep > 0) {
        return findDatadogRaspAbortError(err.cause, deep - 1)
      }
    }
    function handleUncaughtExceptionMonitor(error) {
      if (!blockOnDatadogRaspAbortError({ error, isTopLevel: true })) return
      if (process.hasUncaughtExceptionCaptureCallback()) {
        let previousCb
        const cb = ({ currentCallback, abortController }) => {
          setUncaughtExceptionCaptureCallbackStart.unsubscribe(cb)
          if (!currentCallback) {
            abortController.abort()
            return
          }
          previousCb = currentCallback
        }
        setUncaughtExceptionCaptureCallbackStart.subscribe(cb)
        process.setUncaughtExceptionCaptureCallback(null)
        if (previousCb) {
          process.setUncaughtExceptionCaptureCallback(() => {
            process.setUncaughtExceptionCaptureCallback(null)
            process.setUncaughtExceptionCaptureCallback(previousCb)
          })
        }
      } else {
        const cleanUp = removeAllListeners(process, 'uncaughtException')
        const handler = () => {
          process.removeListener('uncaughtException', handler)
        }
        setTimeout(() => {
          process.removeListener('uncaughtException', handler)
          cleanUp()
        })
        process.on('uncaughtException', handler)
      }
    }
    function blockOnDatadogRaspAbortError({ error, isTopLevel }) {
      const abortError = findDatadogRaspAbortError(error)
      if (!abortError) return false
      const { req, res, blockingAction, raspRule, ruleTriggered } = abortError
      if (!isBlocked(res)) {
        const blockFn = isTopLevel ? block : registerBlockDelegation
        const blocked = blockFn(req, res, web.root(req), null, blockingAction)
        if (ruleTriggered) {
          Promise.resolve(blocked).then((blocked2) => {
            updateRaspRuleMatchMetricTags(req, raspRule, true, blocked2)
          })
        }
      }
      return true
    }
    function enable(config) {
      ssrf.enable(config)
      sqli.enable(config)
      lfi.enable(config)
      cmdi.enable(config)
      process.on('uncaughtExceptionMonitor', handleUncaughtExceptionMonitor)
      expressMiddlewareError.subscribe(blockOnDatadogRaspAbortError)
      fastifyMiddlewareError.subscribe(blockOnDatadogRaspAbortError)
      routerMiddlewareError.subscribe(blockOnDatadogRaspAbortError)
    }
    function disable() {
      ssrf.disable()
      sqli.disable()
      lfi.disable()
      cmdi.disable()
      process.off('uncaughtExceptionMonitor', handleUncaughtExceptionMonitor)
      expressMiddlewareError.unsubscribe(blockOnDatadogRaspAbortError)
      fastifyMiddlewareError.unsubscribe(blockOnDatadogRaspAbortError)
      routerMiddlewareError.unsubscribe(blockOnDatadogRaspAbortError)
    }
    module2.exports = {
      enable,
      disable,
      handleUncaughtExceptionMonitor,
      // exported only for testing purpose
      blockOnDatadogRaspAbortError,
      // exported only for testing purpose
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/index.js
var require_appsec = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/index.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var RuleManager = require_rule_manager()
    var remoteConfig = require_remote_config()
    var {
      bodyParser,
      cookieParser,
      multerParser,
      fastifyBodyParser,
      fastifyCookieParser,
      incomingHttpRequestStart,
      incomingHttpRequestEnd,
      passportVerify,
      passportUser,
      expressSession,
      queryParser,
      nextBodyParsed,
      nextQueryParsed,
      expressProcessParams,
      fastifyQueryParams,
      responseBody,
      responseWriteHead,
      responseSetHeader,
      routerParam,
      fastifyResponseChannel,
      fastifyPathParams,
    } = require_channels2()
    var waf = require_waf2()
    var addresses = require_addresses()
    var Reporter = require_reporter()
    var appsecTelemetry = require_telemetry6()
    var apiSecuritySampler = require_api_security_sampler()
    var web = require_web3()
    var { extractIp } = require_ip_extractor()
    var { HTTP_CLIENT_IP } = require_tags()
    var { isBlocked, block, callBlockDelegation, setTemplates, getBlockingAction } = require_blocking()
    var UserTracking = require_user_tracking()
    var { storage } = require_datadog_core()
    var graphql = require_graphql4()
    var rasp = require_rasp2()
    var { isInServerlessEnvironment } = require_serverless()
    var responseAnalyzedSet = /* @__PURE__ */ new WeakSet()
    var storedResponseHeaders = /* @__PURE__ */ new WeakMap()
    var storedBodies = /* @__PURE__ */ new WeakMap()
    var isEnabled = false
    var config
    function enable(_config) {
      if (isEnabled) return
      try {
        appsecTelemetry.enable(_config)
        graphql.enable()
        if (_config.appsec.rasp.enabled) {
          rasp.enable(_config)
        }
        setTemplates(_config)
        RuleManager.loadRules(_config.appsec)
        remoteConfig.enableWafUpdate(_config.appsec)
        Reporter.init(_config.appsec)
        apiSecuritySampler.configure(_config)
        UserTracking.setCollectionMode(_config.appsec.eventTracking.mode, false)
        bodyParser.subscribe(onRequestBodyParsed)
        multerParser.subscribe(onRequestBodyParsed)
        cookieParser.subscribe(onRequestCookieParser)
        incomingHttpRequestStart.subscribe(incomingHttpStartTranslator)
        incomingHttpRequestEnd.subscribe(incomingHttpEndTranslator)
        passportVerify.subscribe(onPassportVerify)
        passportUser.subscribe(onPassportDeserializeUser)
        expressSession.subscribe(onExpressSession)
        queryParser.subscribe(onRequestQueryParsed)
        nextBodyParsed.subscribe(onRequestBodyParsed)
        nextQueryParsed.subscribe(onRequestQueryParsed)
        expressProcessParams.subscribe(onRequestProcessParams)
        fastifyBodyParser.subscribe(onRequestBodyParsed)
        fastifyQueryParams.subscribe(onRequestQueryParsed)
        fastifyCookieParser.subscribe(onRequestCookieParser)
        fastifyPathParams.subscribe(onRequestProcessParams)
        routerParam.subscribe(onRequestProcessParams)
        responseBody.subscribe(onResponseBody)
        fastifyResponseChannel.subscribe(onResponseBody)
        responseWriteHead.subscribe(onResponseWriteHead)
        responseSetHeader.subscribe(onResponseSetHeader)
        isEnabled = true
        config = _config
      } catch (err) {
        if (!isInServerlessEnvironment()) {
          log.error('[ASM] Unable to start AppSec', err)
        }
        disable()
      }
    }
    function onRequestBodyParsed({ req, res, body, abortController }) {
      if (body === void 0 || body === null) return
      if (!req) {
        const store = storage('legacy').getStore()
        req = store?.req
      }
      const rootSpan = web.root(req)
      if (!rootSpan) return
      if (!req.body) {
        storedBodies.set(req, body)
      }
      const results = waf.run(
        {
          persistent: {
            [addresses.HTTP_INCOMING_BODY]: body,
          },
        },
        req
      )
      handleResults(results?.actions, req, res, rootSpan, abortController)
    }
    function onRequestCookieParser({ req, res, abortController, cookies }) {
      if (!cookies || typeof cookies !== 'object') return
      const rootSpan = web.root(req)
      if (!rootSpan) return
      const results = waf.run(
        {
          persistent: {
            [addresses.HTTP_INCOMING_COOKIES]: cookies,
          },
        },
        req
      )
      handleResults(results?.actions, req, res, rootSpan, abortController)
    }
    function incomingHttpStartTranslator({ req, res, abortController }) {
      const rootSpan = web.root(req)
      if (!rootSpan) return
      const clientIp = extractIp(config, req)
      rootSpan.addTags({
        '_dd.appsec.enabled': 1,
        '_dd.runtime_family': 'nodejs',
        [HTTP_CLIENT_IP]: clientIp,
      })
      const requestHeaders = { ...req.headers }
      delete requestHeaders.cookie
      const persistent = {
        [addresses.HTTP_INCOMING_URL]: req.url,
        [addresses.HTTP_INCOMING_HEADERS]: requestHeaders,
        [addresses.HTTP_INCOMING_METHOD]: req.method,
      }
      if (clientIp) {
        persistent[addresses.HTTP_CLIENT_IP] = clientIp
      }
      const results = waf.run({ persistent }, req)
      handleResults(results?.actions, req, res, rootSpan, abortController)
    }
    function incomingHttpEndTranslator({ req, res }) {
      const persistent = {}
      if (req.body !== void 0 && req.body !== null) {
        persistent[addresses.HTTP_INCOMING_BODY] = req.body
      }
      if (req.cookies !== null && typeof req.cookies === 'object') {
        persistent[addresses.HTTP_INCOMING_COOKIES] = req.cookies
      }
      const query = req.query
      if (query !== null && typeof query === 'object') {
        persistent[addresses.HTTP_INCOMING_QUERY] = query
      }
      if (apiSecuritySampler.sampleRequest(req, res, true)) {
        persistent[addresses.WAF_CONTEXT_PROCESSOR] = { 'extract-schema': true }
      }
      if (Object.keys(persistent).length) {
        waf.run({ persistent }, req)
      }
      waf.disposeContext(req)
      const storedHeaders = storedResponseHeaders.get(req) || {}
      const body = req.body || storedBodies.get(req)
      Reporter.finishRequest(req, res, storedHeaders, body)
      if (storedHeaders) {
        storedResponseHeaders.delete(req)
      }
      storedBodies.delete(req)
    }
    function onPassportVerify({ framework, login, user, success, abortController }) {
      const store = storage('legacy').getStore()
      const rootSpan = store?.req && web.root(store.req)
      if (!rootSpan) {
        log.warn('[ASM] No rootSpan found in onPassportVerify')
        return
      }
      const results = UserTracking.trackLogin(framework, login, user, success, rootSpan)
      handleResults(results?.actions, store.req, store.req.res, rootSpan, abortController)
    }
    function onPassportDeserializeUser({ user, abortController }) {
      const store = storage('legacy').getStore()
      const rootSpan = store?.req && web.root(store.req)
      if (!rootSpan) {
        log.warn('[ASM] No rootSpan found in onPassportDeserializeUser')
        return
      }
      const results = UserTracking.trackUser(user, rootSpan)
      handleResults(results?.actions, store.req, store.req.res, rootSpan, abortController)
    }
    function onExpressSession({ req, res, sessionId, abortController }) {
      const rootSpan = web.root(req)
      if (!rootSpan) {
        log.warn('[ASM] No rootSpan found in onExpressSession')
        return
      }
      const isSdkCalled = rootSpan.context()._tags['usr.session_id']
      if (isSdkCalled) return
      const results = waf.run(
        {
          persistent: {
            [addresses.USER_SESSION_ID]: sessionId,
          },
        },
        req
      )
      handleResults(results?.actions, req, res, rootSpan, abortController)
    }
    function onRequestQueryParsed({ req, res, query, abortController }) {
      if (!query || typeof query !== 'object') return
      if (!req) {
        const store = storage('legacy').getStore()
        req = store?.req
      }
      const rootSpan = web.root(req)
      if (!rootSpan) return
      const results = waf.run(
        {
          persistent: {
            [addresses.HTTP_INCOMING_QUERY]: query,
          },
        },
        req
      )
      handleResults(results?.actions, req, res, rootSpan, abortController)
    }
    function onRequestProcessParams({ req, res, abortController, params }) {
      const rootSpan = web.root(req)
      if (!rootSpan) return
      if (!params || typeof params !== 'object' || !Object.keys(params).length) return
      const results = waf.run(
        {
          persistent: {
            [addresses.HTTP_INCOMING_PARAMS]: params,
          },
        },
        req
      )
      handleResults(results?.actions, req, res, rootSpan, abortController)
    }
    function onResponseBody({ req, res, body }) {
      if (!body || typeof body !== 'object') return
      if (!apiSecuritySampler.sampleRequest(req, res)) return
      waf.run(
        {
          persistent: {
            [addresses.HTTP_INCOMING_RESPONSE_BODY]: body,
          },
        },
        req
      )
    }
    function onResponseWriteHead({ req, res, abortController, statusCode, responseHeaders }) {
      if (Object.keys(responseHeaders).length) {
        storedResponseHeaders.set(req, responseHeaders)
      }
      if (isBlocked(res) || callBlockDelegation(res)) {
        abortController?.abort()
        return
      }
      if (responseAnalyzedSet.has(res)) {
        return
      }
      const rootSpan = web.root(req)
      if (!rootSpan) return
      responseHeaders = { ...responseHeaders }
      delete responseHeaders['set-cookie']
      const results = waf.run(
        {
          persistent: {
            [addresses.HTTP_INCOMING_RESPONSE_CODE]: String(statusCode),
            [addresses.HTTP_INCOMING_RESPONSE_HEADERS]: responseHeaders,
          },
        },
        req
      )
      responseAnalyzedSet.add(res)
      handleResults(results?.actions, req, res, rootSpan, abortController)
    }
    function onResponseSetHeader({ res, abortController }) {
      if (isBlocked(res)) {
        abortController?.abort()
      }
    }
    function handleResults(actions, req, res, rootSpan, abortController) {
      if (!actions || !req || !res || !rootSpan || !abortController) return
      const blockingAction = getBlockingAction(actions)
      if (blockingAction) {
        block(req, res, rootSpan, abortController, blockingAction)
      }
    }
    function disable() {
      isEnabled = false
      config = null
      RuleManager.clearAllRules()
      appsecTelemetry.disable()
      graphql.disable()
      rasp.disable()
      remoteConfig.disableWafUpdate()
      apiSecuritySampler.disable()
      if (bodyParser.hasSubscribers) bodyParser.unsubscribe(onRequestBodyParsed)
      if (multerParser.hasSubscribers) multerParser.unsubscribe(onRequestBodyParsed)
      if (cookieParser.hasSubscribers) cookieParser.unsubscribe(onRequestCookieParser)
      if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(incomingHttpStartTranslator)
      if (incomingHttpRequestEnd.hasSubscribers) incomingHttpRequestEnd.unsubscribe(incomingHttpEndTranslator)
      if (passportVerify.hasSubscribers) passportVerify.unsubscribe(onPassportVerify)
      if (passportUser.hasSubscribers) passportUser.unsubscribe(onPassportDeserializeUser)
      if (expressSession.hasSubscribers) expressSession.unsubscribe(onExpressSession)
      if (queryParser.hasSubscribers) queryParser.unsubscribe(onRequestQueryParsed)
      if (nextBodyParsed.hasSubscribers) nextBodyParsed.unsubscribe(onRequestBodyParsed)
      if (nextQueryParsed.hasSubscribers) nextQueryParsed.unsubscribe(onRequestQueryParsed)
      if (expressProcessParams.hasSubscribers) expressProcessParams.unsubscribe(onRequestProcessParams)
      if (fastifyBodyParser.hasSubscribers) fastifyBodyParser.unsubscribe(onRequestBodyParsed)
      if (fastifyQueryParams.hasSubscribers) fastifyQueryParams.unsubscribe(onRequestQueryParsed)
      if (fastifyCookieParser.hasSubscribers) fastifyCookieParser.unsubscribe(onRequestCookieParser)
      if (fastifyPathParams.hasSubscribers) fastifyPathParams.unsubscribe(onRequestProcessParams)
      if (routerParam.hasSubscribers) routerParam.unsubscribe(onRequestProcessParams)
      if (responseBody.hasSubscribers) responseBody.unsubscribe(onResponseBody)
      if (fastifyResponseChannel.hasSubscribers) fastifyResponseChannel.unsubscribe(onResponseBody)
      if (responseWriteHead.hasSubscribers) responseWriteHead.unsubscribe(onResponseWriteHead)
      if (responseSetHeader.hasSubscribers) responseSetHeader.unsubscribe(onResponseSetHeader)
    }
    module2.exports = {
      enable,
      disable,
      incomingHttpStartTranslator,
      incomingHttpEndTranslator,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities.js
var require_vulnerabilities = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      COMMAND_INJECTION: 'COMMAND_INJECTION',
      CODE_INJECTION: 'CODE_INJECTION',
      HARDCODED_PASSWORD: 'HARDCODED_PASSWORD',
      HARDCODED_SECRET: 'HARDCODED_SECRET',
      HSTS_HEADER_MISSING: 'HSTS_HEADER_MISSING',
      INSECURE_COOKIE: 'INSECURE_COOKIE',
      LDAP_INJECTION: 'LDAP_INJECTION',
      NO_HTTPONLY_COOKIE: 'NO_HTTPONLY_COOKIE',
      NO_SAMESITE_COOKIE: 'NO_SAMESITE_COOKIE',
      NOSQL_MONGODB_INJECTION: 'NOSQL_MONGODB_INJECTION',
      PATH_TRAVERSAL: 'PATH_TRAVERSAL',
      SQL_INJECTION: 'SQL_INJECTION',
      SSRF: 'SSRF',
      TEMPLATE_INJECTION: 'TEMPLATE_INJECTION',
      UNVALIDATED_REDIRECT: 'UNVALIDATED_REDIRECT',
      UNTRUSTED_DESERIALIZATION: 'UNTRUSTED_DESERIALIZATION',
      WEAK_CIPHER: 'WEAK_CIPHER',
      WEAK_HASH: 'WEAK_HASH',
      WEAK_RANDOMNESS: 'WEAK_RANDOMNESS',
      XCONTENTTYPE_HEADER_MISSING: 'XCONTENTTYPE_HEADER_MISSING',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/range-utils.js
var require_range_utils = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/range-utils.js'(
    exports2,
    module2
  ) {
    'use strict'
    function contains(rangeContainer, rangeContained) {
      if (rangeContainer.start > rangeContained.start) {
        return false
      }
      return rangeContainer.end >= rangeContained.end
    }
    function intersects(rangeA, rangeB) {
      return rangeB.start < rangeA.end && rangeB.end > rangeA.start
    }
    function remove(range, rangeToRemove) {
      if (!intersects(range, rangeToRemove)) {
        return [range]
      } else if (contains(rangeToRemove, range)) {
        return []
      }
      const result = []
      if (rangeToRemove.start > range.start) {
        const offset = rangeToRemove.start - range.start
        result.push({ start: range.start, end: range.start + offset })
      }
      if (rangeToRemove.end < range.end) {
        const offset = range.end - rangeToRemove.end
        result.push({ start: rangeToRemove.end, end: rangeToRemove.end + offset })
      }
      return result
    }
    module2.exports = {
      contains,
      intersects,
      remove,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/command-sensitive-analyzer.js
var require_command_sensitive_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/command-sensitive-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var log = require_log2()
    var COMMAND_PATTERN = String.raw`^(?:\s*(?:sudo|doas)\s+)?\b\S+\b\s(.*)`
    var pattern = new RegExp(COMMAND_PATTERN, 'gmi')
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        pattern.lastIndex = 0
        const regexResult = pattern.exec(evidence.value)
        if (regexResult && regexResult.length > 1) {
          const start = regexResult.index + (regexResult[0].length - regexResult[1].length)
          const end = start + regexResult[1].length
          return [{ start, end }]
        }
      } catch (e) {
        log.debug('[ASM] Error extracting sensitive ranges', e)
      }
      return []
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/hardcoded-password-analyzer.js
var require_hardcoded_password_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/hardcoded-password-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    module2.exports = function extractSensitiveRanges(evidence, valuePattern) {
      const { value } = evidence
      if (valuePattern.test(value)) {
        return [
          {
            start: 0,
            end: value.length,
          },
        ]
      }
      return []
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-regex.js
var require_sensitive_regex = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-regex.js'(
    exports2,
    module2
  ) {
    'use strict'
    var DEFAULT_IAST_REDACTION_NAME_PATTERN =
      '(?:p(?:ass)?w(?:or)?d|pass(?:_?phrase)?|secret|(?:api_?|private_?|public_?|access_?|secret_?)key(?:_?id)?|token|consumer_?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?|(?:sur|last)name|user(?:name)?|address|e?mail)'
    var DEFAULT_IAST_REDACTION_VALUE_PATTERN = String.raw`(?:bearer\s+[a-z0-9\._\-]+|glpat-[\w\-]{20}|gh[opsu]_[0-9a-zA-Z]{36}|ey[I-L][\w=\-]+\.ey[I-L][\w=\-]+(?:\.[\w.+/=\-]+)?|(?:[\-]{5}BEGIN[a-z\s]+PRIVATE\sKEY[\-]{5}[^\-]+[\-]{5}END[a-z\s]+PRIVATE\sKEY[\-]{5}|ssh-rsa\s*[a-z0-9/\.+]{100,})|[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,})`
    module2.exports = {
      DEFAULT_IAST_REDACTION_NAME_PATTERN,
      DEFAULT_IAST_REDACTION_VALUE_PATTERN,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/utils.js
var require_utils10 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/utils.js'(exports2, module2) {
    'use strict'
    var crypto = require('crypto')
    var { DEFAULT_IAST_REDACTION_VALUE_PATTERN } = require_sensitive_regex()
    var STRINGIFY_RANGE_KEY = 'DD_' + crypto.randomBytes(20).toString('hex')
    var STRINGIFY_SENSITIVE_KEY = STRINGIFY_RANGE_KEY + 'SENSITIVE'
    var STRINGIFY_SENSITIVE_NOT_STRING_KEY = STRINGIFY_SENSITIVE_KEY + 'NOTSTRING'
    var KEYS_REGEX_WITH_SENSITIVE_RANGES = new RegExp(
      String.raw`(?:"(${STRINGIFY_RANGE_KEY}_\d+_))|(?:"(${STRINGIFY_SENSITIVE_KEY}_\d+_(\d+)_))|("${STRINGIFY_SENSITIVE_NOT_STRING_KEY}_\d+_([\s0-9.a-zA-Z]*)")`,
      'gm'
    )
    var KEYS_REGEX_WITHOUT_SENSITIVE_RANGES = new RegExp(String.raw`"(${STRINGIFY_RANGE_KEY}_\d+_)`, 'gm')
    var sensitiveValueRegex = new RegExp(DEFAULT_IAST_REDACTION_VALUE_PATTERN, 'gmi')
    function iterateObject(target, fn, levelKeys = [], depth = 10, visited = /* @__PURE__ */ new Set()) {
      Object.keys(target).forEach((key) => {
        const nextLevelKeys = [...levelKeys, key]
        const val = target[key]
        if (typeof val !== 'object' || !visited.has(val)) {
          visited.add(val)
          fn(val, nextLevelKeys, target, key)
          if (val !== null && typeof val === 'object' && depth > 0) {
            iterateObject(val, fn, nextLevelKeys, depth - 1, visited)
          }
        }
      })
    }
    function stringifyWithRanges(obj, objRanges, loadSensitiveRanges = false) {
      let value
      const ranges = []
      const sensitiveRanges = []
      objRanges = objRanges || {}
      if (objRanges || loadSensitiveRanges) {
        const cloneObj = Array.isArray(obj) ? [] : {}
        let counter = 0
        const allRanges = {}
        const sensitiveKeysMapping = {}
        iterateObject(obj, (val, levelKeys, parent, key) => {
          let currentLevelClone = cloneObj
          for (let i = 0; i < levelKeys.length - 1; i++) {
            let levelKey = levelKeys[i]
            if (!currentLevelClone[levelKey]) {
              const sensitiveKey = sensitiveKeysMapping[levelKey]
              if (currentLevelClone[sensitiveKey]) {
                levelKey = sensitiveKey
              }
            }
            currentLevelClone = currentLevelClone[levelKey]
          }
          if (loadSensitiveRanges) {
            const sensitiveKey = sensitiveKeysMapping[key]
            if (sensitiveKey) {
              key = sensitiveKey
            } else {
              sensitiveValueRegex.lastIndex = 0
              if (sensitiveValueRegex.test(key)) {
                const current = counter++
                const id = `${STRINGIFY_SENSITIVE_KEY}_${current}_${key.length}_`
                key = `${id}${key}`
              }
            }
          }
          if (typeof val === 'string') {
            const ranges2 = objRanges[levelKeys.join('.')]
            if (ranges2) {
              const current = counter++
              const id = `${STRINGIFY_RANGE_KEY}_${current}_`
              allRanges[id] = ranges2
              currentLevelClone[key] = `${id}${val}`
            } else {
              currentLevelClone[key] = val
            }
            if (loadSensitiveRanges) {
              const current = counter++
              const id = `${STRINGIFY_SENSITIVE_KEY}_${current}_${val.length}_`
              currentLevelClone[key] = `${id}${currentLevelClone[key]}`
            }
          } else if (typeof val !== 'object' || val === null) {
            if (loadSensitiveRanges) {
              const current = counter++
              const id = `${STRINGIFY_SENSITIVE_NOT_STRING_KEY}_${current}_`
              currentLevelClone[key] = id + val
            } else {
              currentLevelClone[key] = val
            }
          } else {
            currentLevelClone[key] = Array.isArray(val) ? [] : {}
          }
        })
        value = JSON.stringify(cloneObj, null, 2)
        if (counter > 0) {
          const keysRegex = loadSensitiveRanges ? KEYS_REGEX_WITH_SENSITIVE_RANGES : KEYS_REGEX_WITHOUT_SENSITIVE_RANGES
          keysRegex.lastIndex = 0
          let regexRes = keysRegex.exec(value)
          while (regexRes) {
            const offset = regexRes.index + 1
            if (regexRes[1]) {
              const rangesId = regexRes[1]
              value = value.replace(rangesId, '')
              const updatedRanges = allRanges[rangesId].map((range) => {
                return {
                  ...range,
                  start: range.start + offset,
                  end: range.end + offset,
                }
              })
              ranges.push(...updatedRanges)
            } else if (regexRes[2]) {
              const sensitiveId = regexRes[2]
              sensitiveRanges.push({
                start: offset,
                end: offset + Number.parseInt(regexRes[3]),
              })
              value = value.replace(sensitiveId, '')
            } else if (regexRes[4]) {
              const sensitiveId = regexRes[4]
              const originalValue = regexRes[5]
              sensitiveRanges.push({
                start: regexRes.index,
                end: regexRes.index + originalValue.length,
              })
              value = value.replace(sensitiveId, originalValue)
            }
            keysRegex.lastIndex = 0
            regexRes = keysRegex.exec(value)
          }
        }
      } else {
        value = JSON.stringify(obj, null, 2)
      }
      return { value, ranges, sensitiveRanges }
    }
    module2.exports = { stringifyWithRanges }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/json-sensitive-analyzer.js
var require_json_sensitive_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/json-sensitive-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var { stringifyWithRanges } = require_utils10()
    module2.exports = function extractSensitiveRanges(evidence) {
      const { value, ranges, sensitiveRanges } = stringifyWithRanges(evidence.value, evidence.rangesToApply, true)
      evidence.value = value
      evidence.ranges = ranges
      return sensitiveRanges
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/ldap-sensitive-analyzer.js
var require_ldap_sensitive_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/ldap-sensitive-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var log = require_log2()
    var LDAP_PATTERN = String.raw`\(.*?(?:~=|=|<=|>=)(?<LITERAL>[^)]+)\)`
    var pattern = new RegExp(LDAP_PATTERN, 'gmi')
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        pattern.lastIndex = 0
        const tokens = []
        let regexResult = pattern.exec(evidence.value)
        while (regexResult != null) {
          if (!regexResult.groups.LITERAL) continue
          const start = regexResult.index + (regexResult[0].length - regexResult.groups.LITERAL.length - 1)
          const end = start + regexResult.groups.LITERAL.length
          tokens.push({ start, end })
          regexResult = pattern.exec(evidence.value)
        }
        return tokens
      } catch (e) {
        log.debug('[ASM] Error extracting sensitive ranges', e)
      }
      return []
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/sql-sensitive-analyzer.js
var require_sql_sensitive_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/sql-sensitive-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var log = require_log2()
    var STRING_LITERAL = "'(?:''|[^'])*'"
    var POSTGRESQL_ESCAPED_LITERAL = String.raw`\$([^$]*)\$.*?\$\1\$`
    var MYSQL_STRING_LITERAL = String.raw`"(?:\\"|[^"])*"|'(?:\\'|[^'])*'`
    var LINE_COMMENT = '--.*$'
    var BLOCK_COMMENT = String.raw`/\*[\s\S]*\*/`
    var EXPONENT = String.raw`(?:E[-+]?\d+[fd]?)?`
    var INTEGER_NUMBER = String.raw`(?<!\w)\d+`
    var DECIMAL_NUMBER = String.raw`\d*\.\d+`
    var HEX_NUMBER = "x'[0-9a-f]+'|0x[0-9a-f]+"
    var BIN_NUMBER = "b'[0-9a-f]+'|0b[0-9a-f]+"
    var NUMERIC_LITERAL = `[-+]?(?:${[
      HEX_NUMBER,
      BIN_NUMBER,
      DECIMAL_NUMBER + EXPONENT,
      INTEGER_NUMBER + EXPONENT,
    ].join('|')})`
    var ORACLE_ESCAPED_LITERAL = String.raw`q'<.*?>'|q'\(.*?\)'|q'\{.*?\}'|q'\[.*?\]'|q'(?<ESCAPE>.).*?\k<ESCAPE>'`
    var patterns = {
      ANSI: new RegExp(
        // Default
        [NUMERIC_LITERAL, STRING_LITERAL, LINE_COMMENT, BLOCK_COMMENT].join('|'),
        'gmi'
      ),
      MYSQL: new RegExp([NUMERIC_LITERAL, MYSQL_STRING_LITERAL, LINE_COMMENT, BLOCK_COMMENT].join('|'), 'gmi'),
      POSTGRES: new RegExp(
        [NUMERIC_LITERAL, POSTGRESQL_ESCAPED_LITERAL, STRING_LITERAL, LINE_COMMENT, BLOCK_COMMENT].join('|'),
        'gmi'
      ),
      ORACLE: new RegExp(
        [NUMERIC_LITERAL, ORACLE_ESCAPED_LITERAL, STRING_LITERAL, LINE_COMMENT, BLOCK_COMMENT].join('|'),
        'gmi'
      ),
    }
    patterns.SQLITE = patterns.MYSQL
    patterns.MARIADB = patterns.MYSQL
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        let pattern = patterns[evidence.dialect]
        if (!pattern) {
          pattern = patterns.ANSI
        }
        pattern.lastIndex = 0
        const tokens = []
        let regexResult = pattern.exec(evidence.value)
        while (regexResult != null) {
          let start = regexResult.index
          let end = regexResult.index + regexResult[0].length
          const startChar = evidence.value.charAt(start)
          if (startChar === "'" || startChar === '"') {
            start++
            end--
          } else if (end > start + 1) {
            const nextChar = evidence.value.charAt(start + 1)
            if (startChar === '/' && nextChar === '*') {
              start += 2
              end -= 2
            } else if (startChar === '-' && startChar === nextChar) {
              start += 2
            } else if (startChar.toLowerCase() === 'q' && nextChar === "'") {
              start += 3
              end -= 2
            } else if (startChar === '$') {
              const match = regexResult[0]
              const size = match.indexOf('$', 1) + 1
              if (size > 1) {
                start += size
                end -= size
              }
            }
          }
          tokens.push({ start, end })
          regexResult = pattern.exec(evidence.value)
        }
        return tokens
      } catch (e) {
        log.debug('[ASM] Error extracting sensitive ranges', e)
      }
      return []
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/tainted-range-based-sensitive-analyzer.js
var require_tainted_range_based_sensitive_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/tainted-range-based-sensitive-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    module2.exports = function extractSensitiveRanges(evidence) {
      const newRanges = []
      if (evidence.ranges[0].start > 0) {
        newRanges.push({
          start: 0,
          end: evidence.ranges[0].start,
        })
      }
      for (let i = 0; i < evidence.ranges.length; i++) {
        const currentRange = evidence.ranges[i]
        const nextRange = evidence.ranges[i + 1]
        const start = currentRange.end
        const end = nextRange?.start || evidence.value.length
        if (start < end) {
          newRanges.push({ start, end })
        }
      }
      return newRanges
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/url-sensitive-analyzer.js
var require_url_sensitive_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/url-sensitive-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var log = require_log2()
    var AUTHORITY = '^(?:[^:]+:)?//([^@]+)@'
    var QUERY_FRAGMENT = '[?#&]([^=&;]+)=([^?#&]+)'
    var pattern = new RegExp([AUTHORITY, QUERY_FRAGMENT].join('|'), 'gmi')
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        const ranges = []
        let regexResult = pattern.exec(evidence.value)
        while (regexResult != null) {
          if (typeof regexResult[1] === 'string') {
            const end = regexResult.index + (regexResult[0].length - 1)
            const start = end - regexResult[1].length
            ranges.push({ start, end })
          }
          if (typeof regexResult[3] === 'string') {
            const end = regexResult.index + regexResult[0].length
            const start = end - regexResult[3].length
            ranges.push({ start, end })
          }
          regexResult = pattern.exec(evidence.value)
        }
        return ranges
      } catch (e) {
        log.debug('[ASM] Error extracting sensitive ranges', e)
      }
      return []
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-handler.js
var require_sensitive_handler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-handler.js'(
    exports2,
    module2
  ) {
    'use strict'
    var log = require_log2()
    var vulnerabilities = require_vulnerabilities()
    var { contains, intersects, remove } = require_range_utils()
    var commandSensitiveAnalyzer = require_command_sensitive_analyzer()
    var hardcodedPasswordAnalyzer = require_hardcoded_password_analyzer()
    var jsonSensitiveAnalyzer = require_json_sensitive_analyzer()
    var ldapSensitiveAnalyzer = require_ldap_sensitive_analyzer()
    var sqlSensitiveAnalyzer = require_sql_sensitive_analyzer()
    var taintedRangeBasedSensitiveAnalyzer = require_tainted_range_based_sensitive_analyzer()
    var urlSensitiveAnalyzer = require_url_sensitive_analyzer()
    var { DEFAULT_IAST_REDACTION_NAME_PATTERN, DEFAULT_IAST_REDACTION_VALUE_PATTERN } = require_sensitive_regex()
    var REDACTED_SOURCE_BUFFER = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    var SensitiveHandler = class {
      constructor() {
        this._namePattern = new RegExp(DEFAULT_IAST_REDACTION_NAME_PATTERN, 'gmi')
        this._valuePattern = new RegExp(DEFAULT_IAST_REDACTION_VALUE_PATTERN, 'gmi')
        this._sensitiveAnalyzers = /* @__PURE__ */ new Map()
        this._sensitiveAnalyzers.set(vulnerabilities.CODE_INJECTION, taintedRangeBasedSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.COMMAND_INJECTION, commandSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.HARDCODED_PASSWORD, (evidence) => {
          return hardcodedPasswordAnalyzer(evidence, this._valuePattern)
        })
        this._sensitiveAnalyzers.set(vulnerabilities.LDAP_INJECTION, ldapSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.NOSQL_MONGODB_INJECTION, jsonSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.SQL_INJECTION, sqlSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.SSRF, urlSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.TEMPLATE_INJECTION, taintedRangeBasedSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.UNTRUSTED_DESERIALIZATION, taintedRangeBasedSensitiveAnalyzer)
        this._sensitiveAnalyzers.set(vulnerabilities.UNVALIDATED_REDIRECT, urlSensitiveAnalyzer)
      }
      isSensibleName(name) {
        this._namePattern.lastIndex = 0
        return this._namePattern.test(name)
      }
      isSensibleValue(value) {
        this._valuePattern.lastIndex = 0
        return this._valuePattern.test(value)
      }
      isSensibleSource(source) {
        return source != null && (this.isSensibleName(source.name) || this.isSensibleValue(source.value))
      }
      scrubEvidence(vulnerabilityType, evidence, sourcesIndexes, sources) {
        const sensitiveAnalyzer = this._sensitiveAnalyzers.get(vulnerabilityType)
        if (sensitiveAnalyzer) {
          const sensitiveRanges = sensitiveAnalyzer(evidence)
          if (evidence.ranges || sensitiveRanges?.length) {
            return this.toRedactedJson(evidence, sensitiveRanges, sourcesIndexes, sources)
          }
        }
        return null
      }
      toRedactedJson(evidence, sensitive, sourcesIndexes, sources) {
        const valueParts = []
        const redactedSources = []
        const redactedSourcesContext = []
        const { value, ranges } = evidence
        let start = 0
        let nextTaintedIndex = 0
        let sourceIndex
        let nextTainted = ranges?.shift()
        let nextSensitive = sensitive.shift()
        for (let i = 0; i < value.length; i++) {
          if (nextTainted != null && nextTainted.start === i) {
            this.writeValuePart(valueParts, value.slice(start, i), sourceIndex)
            sourceIndex = sourcesIndexes[nextTaintedIndex]
            while (nextSensitive != null && contains(nextTainted, nextSensitive)) {
              const redactionStart = nextSensitive.start - nextTainted.start
              const redactionEnd = nextSensitive.end - nextTainted.start
              if (redactionStart === redactionEnd) {
                this.writeRedactedValuePart(valueParts, 0)
              } else {
                this.redactSource(
                  sources,
                  redactedSources,
                  redactedSourcesContext,
                  sourceIndex,
                  redactionStart,
                  redactionEnd
                )
              }
              nextSensitive = sensitive.shift()
            }
            if (nextSensitive != null && intersects(nextSensitive, nextTainted)) {
              const redactionStart = nextSensitive.start - nextTainted.start
              const redactionEnd = nextSensitive.end - nextTainted.start
              this.redactSource(
                sources,
                redactedSources,
                redactedSourcesContext,
                sourceIndex,
                redactionStart,
                redactionEnd
              )
              const entries = remove(nextSensitive, nextTainted)
              nextSensitive = entries.length > 0 ? entries[0] : null
            }
            if (this.isSensibleSource(sources[sourceIndex]) && !sources[sourceIndex].redacted) {
              redactedSources.push(sourceIndex)
              sources[sourceIndex].pattern = ''.padEnd(sources[sourceIndex].value.length, REDACTED_SOURCE_BUFFER)
              sources[sourceIndex].redacted = true
            }
            if (redactedSources.includes(sourceIndex)) {
              const partValue = value.slice(i, i + (nextTainted.end - nextTainted.start))
              this.writeRedactedValuePart(
                valueParts,
                partValue.length,
                sourceIndex,
                partValue,
                sources[sourceIndex],
                redactedSourcesContext[sourceIndex],
                this.isSensibleSource(sources[sourceIndex])
              )
              redactedSourcesContext[sourceIndex] = []
            } else {
              const substringEnd = Math.min(nextTainted.end, value.length)
              this.writeValuePart(valueParts, value.slice(nextTainted.start, substringEnd), sourceIndex)
            }
            start = i + (nextTainted.end - nextTainted.start)
            i = start - 1
            nextTainted = ranges.shift()
            nextTaintedIndex++
            sourceIndex = null
          } else if (nextSensitive != null && nextSensitive.start === i) {
            this.writeValuePart(valueParts, value.slice(start, i), sourceIndex)
            if (nextTainted != null && intersects(nextSensitive, nextTainted)) {
              sourceIndex = sourcesIndexes[nextTaintedIndex]
              const redactionStart = nextSensitive.start - nextTainted.start
              const redactionEnd = nextSensitive.end - nextTainted.start
              this.redactSource(
                sources,
                redactedSources,
                redactedSourcesContext,
                sourceIndex,
                redactionStart,
                redactionEnd
              )
              for (const entry of remove(nextSensitive, nextTainted)) {
                if (entry.start === i) {
                  nextSensitive = entry
                } else {
                  sensitive.unshift(entry)
                }
              }
            }
            const _length = nextSensitive.end - nextSensitive.start
            this.writeRedactedValuePart(valueParts, _length)
            start = i + _length
            i = start - 1
            nextSensitive = sensitive.shift()
          }
        }
        if (start < value.length) {
          this.writeValuePart(valueParts, value.slice(start))
        }
        return { redactedValueParts: valueParts, redactedSources }
      }
      redactSource(sources, redactedSources, redactedSourcesContext, sourceIndex, start, end) {
        if (sourceIndex != null) {
          if (!sources[sourceIndex].redacted) {
            redactedSources.push(sourceIndex)
            sources[sourceIndex].pattern = ''.padEnd(sources[sourceIndex].value.length, REDACTED_SOURCE_BUFFER)
            sources[sourceIndex].redacted = true
          }
          if (!redactedSourcesContext[sourceIndex]) {
            redactedSourcesContext[sourceIndex] = []
          }
          redactedSourcesContext[sourceIndex].push({
            start,
            end,
          })
        }
      }
      writeValuePart(valueParts, value, source) {
        if (value.length > 0) {
          if (source == null) {
            valueParts.push({ value })
          } else {
            valueParts.push({ value, source })
          }
        }
      }
      writeRedactedValuePart(
        valueParts,
        length,
        sourceIndex,
        partValue,
        source,
        sourceRedactionContext,
        isSensibleSource
      ) {
        if (sourceIndex == null) {
          valueParts.push({ redacted: true })
        } else {
          const placeholder = source.value.includes(partValue) ? source.pattern : '*'.repeat(length)
          if (isSensibleSource) {
            valueParts.push({ redacted: true, source: sourceIndex, pattern: placeholder })
          } else {
            let _value = partValue
            const dedupedSourceRedactionContexts = []
            sourceRedactionContext.forEach((_sourceRedactionContext) => {
              const isPresentInDeduped = dedupedSourceRedactionContexts.some(
                (_dedupedSourceRedactionContext) =>
                  _dedupedSourceRedactionContext.start === _sourceRedactionContext.start &&
                  _dedupedSourceRedactionContext.end === _sourceRedactionContext.end
              )
              if (!isPresentInDeduped) {
                dedupedSourceRedactionContexts.push(_sourceRedactionContext)
              }
            })
            let offset = 0
            dedupedSourceRedactionContexts.forEach((_sourceRedactionContext) => {
              if (_sourceRedactionContext.start > 0) {
                valueParts.push({
                  source: sourceIndex,
                  value: _value.substring(0, _sourceRedactionContext.start - offset),
                })
                _value = _value.substring(_sourceRedactionContext.start - offset)
                offset = _sourceRedactionContext.start
              }
              const sensitive = _value.substring(
                _sourceRedactionContext.start - offset,
                _sourceRedactionContext.end - offset
              )
              const indexOfPartValueInPattern = source.value.indexOf(sensitive)
              const pattern =
                indexOfPartValueInPattern === -1
                  ? placeholder.substring(_sourceRedactionContext.start, _sourceRedactionContext.end)
                  : placeholder.substring(indexOfPartValueInPattern, indexOfPartValueInPattern + sensitive.length)
              valueParts.push({
                redacted: true,
                source: sourceIndex,
                pattern,
              })
              _value = _value.slice(pattern.length)
              offset += pattern.length
            })
            if (_value.length) {
              valueParts.push({
                source: sourceIndex,
                value: _value,
              })
            }
          }
        }
      }
      setRedactionPatterns(redactionNamePattern, redactionValuePattern) {
        if (redactionNamePattern) {
          try {
            this._namePattern = new RegExp(redactionNamePattern, 'gmi')
          } catch {
            log.warn('[ASM] Redaction name pattern is not valid')
          }
        }
        if (redactionValuePattern) {
          try {
            this._valuePattern = new RegExp(redactionValuePattern, 'gmi')
          } catch {
            log.warn('[ASM] Redaction value pattern is not valid')
          }
        }
      }
    }
    module2.exports = new SensitiveHandler()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/index.js
var require_vulnerabilities_formatter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/index.js'(exports2, module2) {
    'use strict'
    var sensitiveHandler = require_sensitive_handler()
    var { stringifyWithRanges } = require_utils10()
    var VulnerabilityFormatter = class {
      _redactVulnearbilities = true
      setRedactVulnerabilities(shouldRedactVulnerabilities, redactionNamePattern, redactionValuePattern) {
        this._redactVulnearbilities = shouldRedactVulnerabilities
        sensitiveHandler.setRedactionPatterns(redactionNamePattern, redactionValuePattern)
      }
      extractSourcesFromVulnerability(vulnerability) {
        if (!vulnerability.evidence.ranges) {
          return []
        }
        return vulnerability.evidence.ranges.map((range) => ({
          origin: range.iinfo.type,
          name: range.iinfo.parameterName,
          value: range.iinfo.parameterValue,
        }))
      }
      getRedactedValueParts(type, evidence, sourcesIndexes, sources) {
        const scrubbingResult = sensitiveHandler.scrubEvidence(type, evidence, sourcesIndexes, sources)
        if (scrubbingResult) {
          const { redactedValueParts, redactedSources } = scrubbingResult
          redactedSources.forEach((i) => {
            delete sources[i].value
          })
          return { valueParts: redactedValueParts }
        }
        return this.getUnredactedValueParts(evidence, sourcesIndexes)
      }
      getUnredactedValueParts(evidence, sourcesIndexes) {
        const valueParts = []
        let fromIndex = 0
        if (evidence.value == null) return { valueParts }
        if (typeof evidence.value === 'object' && evidence.rangesToApply) {
          const { value, ranges } = stringifyWithRanges(evidence.value, evidence.rangesToApply)
          evidence.value = value
          evidence.ranges = ranges
        }
        if (!evidence.ranges) {
          return { value: evidence.value }
        }
        evidence.ranges.forEach((range, rangeIndex) => {
          if (fromIndex < range.start) {
            valueParts.push({ value: evidence.value.slice(fromIndex, range.start) })
          }
          valueParts.push({ value: evidence.value.slice(range.start, range.end), source: sourcesIndexes[rangeIndex] })
          fromIndex = range.end
        })
        if (fromIndex < evidence.value.length) {
          valueParts.push({ value: evidence.value.slice(fromIndex) })
        }
        return { valueParts }
      }
      formatEvidence(type, evidence, sourcesIndexes, sources) {
        if (evidence.value === void 0) {
          return
        }
        return this._redactVulnearbilities
          ? this.getRedactedValueParts(type, evidence, sourcesIndexes, sources)
          : this.getUnredactedValueParts(evidence, sourcesIndexes)
      }
      formatVulnerability(vulnerability, sourcesIndexes, sources) {
        const { type, hash, evidence, location } = vulnerability
        const formattedVulnerability = {
          type,
          hash,
          evidence: this.formatEvidence(type, evidence, sourcesIndexes, sources),
          location,
        }
        return formattedVulnerability
      }
      toJson(vulnerabilitiesToFormat) {
        const sources = []
        const vulnerabilities = vulnerabilitiesToFormat.map((vulnerability) => {
          const vulnerabilitySources = this.extractSourcesFromVulnerability(vulnerability)
          const sourcesIndexes = []
          vulnerabilitySources.forEach((source) => {
            let sourceIndex = sources.findIndex(
              (existingSource) =>
                existingSource.origin === source.origin &&
                existingSource.name === source.name &&
                existingSource.value === source.value
            )
            if (sourceIndex === -1) {
              sourceIndex = sources.length
              sources.push(source)
            }
            sourcesIndexes.push(sourceIndex)
          })
          return this.formatVulnerability(vulnerability, sourcesIndexes, sources)
        })
        return {
          sources,
          vulnerabilities,
        }
      }
    }
    module2.exports = new VulnerabilityFormatter()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerability-reporter.js
var require_vulnerability_reporter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerability-reporter.js'(exports2, module2) {
    'use strict'
    var { LRUCache } = require_lru_cache()
    var vulnerabilitiesFormatter = require_vulnerabilities_formatter()
    var { IAST_ENABLED_TAG_KEY, IAST_JSON_TAG_KEY } = require_tags4()
    var { keepTrace } = require_priority_sampler()
    var { reportStackTrace, getCallsiteFrames, canReportStackTrace, STACK_TRACE_NAMESPACES } = require_stack_trace()
    var { getOriginalPathAndLineFromSourceMap } = require_rewriter2()
    var { ASM } = require_product()
    var VULNERABILITIES_KEY = 'vulnerabilities'
    var VULNERABILITY_HASHES_MAX_SIZE = 1e3
    var VULNERABILITY_HASHES = new LRUCache({ max: VULNERABILITY_HASHES_MAX_SIZE })
    var RESET_VULNERABILITY_CACHE_INTERVAL = 60 * 60 * 1e3
    var tracer2
    var resetVulnerabilityCacheTimer
    var deduplicationEnabled = true
    var stackTraceEnabled = true
    var stackTraceMaxDepth
    var maxStackTraces
    function canAddVulnerability(vulnerability) {
      const hasRequiredFields = vulnerability?.evidence && vulnerability?.type && vulnerability?.location
      if (!hasRequiredFields) return false
      const isDuplicated = deduplicationEnabled && isDuplicatedVulnerability(vulnerability)
      return !isDuplicated
    }
    function addVulnerability(iastContext, vulnerability, callSiteFrames) {
      if (!canAddVulnerability(vulnerability)) return
      VULNERABILITY_HASHES.set(`${vulnerability.type}${vulnerability.hash}`, true)
      let span = iastContext?.rootSpan
      if (!span && tracer2) {
        span = tracer2.startSpan('vulnerability', {
          type: 'vulnerability',
        })
        vulnerability.location.spanId = span.context().toSpanId()
        span.addTags({
          [IAST_ENABLED_TAG_KEY]: 1,
        })
      }
      if (!span) return
      keepTrace(span, ASM)
      if (stackTraceEnabled && canReportStackTrace(span, maxStackTraces, STACK_TRACE_NAMESPACES.IAST)) {
        const originalCallSiteList = callSiteFrames.map((callsite) => replaceCallSiteFromSourceMap(callsite))
        reportStackTrace(span, vulnerability.location.stackId, originalCallSiteList, STACK_TRACE_NAMESPACES.IAST)
      }
      if (iastContext?.rootSpan) {
        iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || []
        iastContext[VULNERABILITIES_KEY].push(vulnerability)
      } else {
        sendVulnerabilities([vulnerability], span)
        span.finish()
      }
    }
    function isValidVulnerability(vulnerability) {
      return (
        vulnerability &&
        vulnerability.type &&
        vulnerability.evidence &&
        vulnerability.location &&
        vulnerability.location.spanId
      )
    }
    function sendVulnerabilities(vulnerabilities, span) {
      if (vulnerabilities?.length && span?.addTags) {
        const validatedVulnerabilities = vulnerabilities.filter(isValidVulnerability)
        const jsonToSend = vulnerabilitiesFormatter.toJson(validatedVulnerabilities)
        if (jsonToSend.vulnerabilities.length > 0) {
          const tags = {
            // TODO: Store this outside of the span and set the tag in the exporter.
            [IAST_JSON_TAG_KEY]: JSON.stringify(jsonToSend),
          }
          span.addTags(tags)
        }
      }
      return IAST_JSON_TAG_KEY
    }
    function clearCache() {
      VULNERABILITY_HASHES.clear()
    }
    function startClearCacheTimer() {
      resetVulnerabilityCacheTimer = setInterval(clearCache, RESET_VULNERABILITY_CACHE_INTERVAL)
      resetVulnerabilityCacheTimer.unref()
    }
    function stopClearCacheTimer() {
      if (resetVulnerabilityCacheTimer) {
        clearInterval(resetVulnerabilityCacheTimer)
        resetVulnerabilityCacheTimer = null
      }
    }
    function isDuplicatedVulnerability(vulnerability) {
      return VULNERABILITY_HASHES.get(`${vulnerability.type}${vulnerability.hash}`)
    }
    function getVulnerabilityCallSiteFrames() {
      return getCallsiteFrames(stackTraceMaxDepth, getVulnerabilityCallSiteFrames)
    }
    function replaceCallSiteFromSourceMap(callsite) {
      if (callsite) {
        const { path, line, column } = getOriginalPathAndLineFromSourceMap(callsite)
        if (path) {
          callsite.file = path
          callsite.path = path
        }
        if (line) {
          callsite.line = line
        }
        if (column) {
          callsite.column = column
        }
      }
      return callsite
    }
    function start(config, _tracer) {
      deduplicationEnabled = config.iast.deduplicationEnabled
      stackTraceEnabled = config.iast.stackTrace.enabled
      stackTraceMaxDepth = config.appsec.stackTrace.maxDepth
      maxStackTraces = config.appsec.stackTrace.maxStackTraces
      vulnerabilitiesFormatter.setRedactVulnerabilities(
        config.iast.redactionEnabled,
        config.iast.redactionNamePattern,
        config.iast.redactionValuePattern
      )
      if (deduplicationEnabled) {
        startClearCacheTimer()
      }
      tracer2 = _tracer
    }
    function stop() {
      stopClearCacheTimer()
    }
    module2.exports = {
      addVulnerability,
      sendVulnerabilities,
      getVulnerabilityCallSiteFrames,
      replaceCallSiteFromSourceMap,
      clearCache,
      start,
      stop,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/path-line.js
var require_path_line = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/path-line.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var process2 = require('process')
    var { fileURLToPath } = require('url')
    var { ddBasePath } = require_util()
    var { getOriginalPathAndLineFromSourceMap } = require_rewriter2()
    var pathLine = {
      getNodeModulesPaths,
      getRelativePath,
      getNonDDCallSiteFrames,
      ddBasePath,
      // Exported only for test purposes
    }
    var EXCLUDED_PATHS = [path.join(path.sep, 'node_modules', 'dc-polyfill')]
    var EXCLUDED_PATH_PREFIXES = [
      'node:diagnostics_channel',
      'diagnostics_channel',
      'node:child_process',
      'child_process',
      'node:async_hooks',
      'async_hooks',
    ]
    function getNonDDCallSiteFrames(callSiteFrames, externallyExcludedPaths) {
      if (!callSiteFrames) {
        return []
      }
      const result = []
      for (const callsite of callSiteFrames) {
        let filepath = callsite.file?.startsWith('file://') ? fileURLToPath(callsite.file) : callsite.file
        if (globalThis.__DD_ESBUILD_IAST_WITH_SM) {
          const callsiteLocation = {
            path: filepath,
            line: callsite.line,
            column: callsite.column,
          }
          const { path: originalPath, line, column } = getOriginalPathAndLineFromSourceMap(callsiteLocation)
          callsite.path = filepath = originalPath
          callsite.line = line
          callsite.column = column
        }
        if (
          !isExcluded(callsite, externallyExcludedPaths) &&
          (!filepath.includes(pathLine.ddBasePath) || globalThis.__DD_ESBUILD_IAST_WITH_NO_SM)
        ) {
          callsite.path = getRelativePath(filepath)
          callsite.isInternal = !path.isAbsolute(filepath)
          result.push(callsite)
        }
      }
      return result
    }
    function getRelativePath(filepath) {
      return filepath && path.relative(process2.cwd(), filepath)
    }
    function isExcluded(callsite, externallyExcludedPaths) {
      if (callsite.isNative) return true
      const filename = globalThis.__DD_ESBUILD_IAST_WITH_SM ? callsite.path : callsite.file
      if (!filename) {
        return true
      }
      let excludedPaths = EXCLUDED_PATHS
      if (externallyExcludedPaths) {
        excludedPaths = [...excludedPaths, ...externallyExcludedPaths]
      }
      for (const excludedPath of excludedPaths) {
        if (filename.includes(excludedPath)) {
          return true
        }
      }
      for (const EXCLUDED_PATH_PREFIX of EXCLUDED_PATH_PREFIXES) {
        if (filename.indexOf(EXCLUDED_PATH_PREFIX) === 0) {
          return true
        }
      }
      return false
    }
    function getNodeModulesPaths(...paths) {
      const nodeModulesPaths = []
      paths.forEach((p) => {
        const pathParts = p.split('/')
        nodeModulesPaths.push(path.join('node_modules', ...pathParts))
      })
      return nodeModulesPaths
    }
    module2.exports = pathLine
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/iast-context.js
var require_iast_context = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/iast-context.js'(exports2, module2) {
    'use strict'
    var IAST_CONTEXT_KEY = /* @__PURE__ */ Symbol('_dd.iast.context')
    var IAST_TRANSACTION_ID = /* @__PURE__ */ Symbol('_dd.iast.transactionId')
    function getIastContext(store, topContext) {
      let iastContext = store && store[IAST_CONTEXT_KEY]
      if (!iastContext) {
        iastContext = topContext && topContext[IAST_CONTEXT_KEY]
      }
      return iastContext
    }
    function getIastStackTraceId(iastContext) {
      if (!iastContext) return '0'
      if (!iastContext.stackTraceId) {
        iastContext.stackTraceId = 0
      }
      iastContext.stackTraceId += 1
      return String(iastContext.stackTraceId)
    }
    function saveIastContext(store, topContext, context) {
      if (store && topContext) {
        store[IAST_CONTEXT_KEY] = context
        topContext[IAST_CONTEXT_KEY] = context
        return store[IAST_CONTEXT_KEY]
      }
    }
    function cleanIastContext(store, context, iastContext) {
      if (store) {
        if (!iastContext) {
          iastContext = store[IAST_CONTEXT_KEY]
        }
        store[IAST_CONTEXT_KEY] = null
      }
      if (context) {
        if (!iastContext) {
          iastContext = context[IAST_CONTEXT_KEY]
        }
        context[IAST_CONTEXT_KEY] = null
      }
      if (iastContext) {
        if (typeof iastContext === 'object') {
          Object.keys(iastContext).forEach((key) => delete iastContext[key])
        }
        return true
      }
      return false
    }
    module2.exports = {
      getIastContext,
      saveIastContext,
      cleanIastContext,
      getIastStackTraceId,
      IAST_CONTEXT_KEY,
      IAST_TRANSACTION_ID,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/overhead-controller.js
var require_overhead_controller = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/overhead-controller.js'(exports2, module2) {
    'use strict'
    var { LRUCache } = require_lru_cache()
    var web = require_web3()
    var vulnerabilities = require_vulnerabilities()
    var OVERHEAD_CONTROLLER_CONTEXT_KEY = 'oce'
    var REPORT_VULNERABILITY = 'REPORT_VULNERABILITY'
    var INTERVAL_RESET_GLOBAL_CONTEXT = 60 * 1e3
    var GLOBAL_OCE_CONTEXT = {}
    var resetGlobalContextInterval
    var config = {}
    var availableRequest = 0
    var globalRouteMap = new LRUCache({ max: 4096 })
    var vulnerabilitiesSize = 0
    var vulnerabilityIndexes = Object.values(vulnerabilities).reduce((obj, item, index) => {
      obj[item] = index
      vulnerabilitiesSize++
      return obj
    }, {})
    function newCountersArray() {
      return new Array(vulnerabilitiesSize).fill(0)
    }
    function copyFromGlobalMap(route) {
      const vulnerabilityCounters = globalRouteMap.get(route)
      return vulnerabilityCounters ? [...vulnerabilityCounters] : newCountersArray()
    }
    function clearGlobalRouteMap() {
      globalRouteMap.clear()
    }
    var OPERATIONS = {
      REPORT_VULNERABILITY: {
        hasQuota: (context, vulnerabilityType) => {
          const reserved = context?.tokens?.[REPORT_VULNERABILITY] > 0
          if (reserved && context.route != null) {
            let copyMap = context.copyMap
            let localMap = context.localMap
            if (context.loadedRoute !== context.route) {
              context.copyMaps ??= {}
              context.copyMaps[context.route] ??= copyFromGlobalMap(context.route)
              context.localMaps ??= {}
              context.localMaps[context.route] ??= newCountersArray()
              context.loadedRoute = context.route
              copyMap = context.copyMaps[context.route]
              localMap = context.localMaps[context.route]
              context.copyMap = copyMap
              context.localMap = localMap
            }
            const vulnerabilityIndex = vulnerabilityIndexes[vulnerabilityType]
            const counter = localMap[vulnerabilityIndex]++
            const storedCounter = copyMap[vulnerabilityIndex]
            if (counter < storedCounter) {
              return false
            }
          }
          if (reserved) {
            context.tokens[REPORT_VULNERABILITY]--
          }
          return reserved
        },
        name: REPORT_VULNERABILITY,
        initialTokenBucketSize() {
          return typeof config.maxContextOperations === 'number' ? config.maxContextOperations : 2
        },
        initContext: function (context) {
          context.tokens[REPORT_VULNERABILITY] = this.initialTokenBucketSize()
        },
      },
    }
    function _getNewContext() {
      const oceContext = {
        tokens: {},
      }
      for (const operation in OPERATIONS) {
        OPERATIONS[operation].initContext(oceContext)
      }
      return oceContext
    }
    function _getContext(iastContext) {
      if (iastContext?.[OVERHEAD_CONTROLLER_CONTEXT_KEY]) {
        const oceContext = iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY]
        if (!oceContext.webContext) {
          oceContext.webContext = web.getContext(iastContext.req)
          oceContext.method = iastContext.req?.method
        }
        const currentPaths = oceContext.webContext?.paths
        if (currentPaths !== oceContext.paths || !oceContext.route) {
          oceContext.paths = currentPaths
          oceContext.route = '#' + oceContext.method + '#' + (currentPaths?.join('') || '')
        }
        return iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY]
      }
      return GLOBAL_OCE_CONTEXT
    }
    function consolidateVulnerabilities(iastContext) {
      const context = _getContext(iastContext)
      if (!context.localMaps) return
      const reserved = context.tokens?.[REPORT_VULNERABILITY] > 0
      if (reserved) {
        Object.keys(context.localMaps).forEach((route) => {
          globalRouteMap.set(route, newCountersArray())
        })
      } else {
        Object.keys(context.localMaps).forEach((route) => {
          const localMap = context.localMaps[route]
          const globalMap = globalRouteMap.get(route)
          if (!globalMap) {
            globalRouteMap.set(route, localMap)
            return
          }
          for (let i = 0; i < vulnerabilitiesSize; i++) {
            if (localMap[i] > globalMap[i]) {
              globalMap[i] = localMap[i]
            }
          }
        })
      }
    }
    function _resetGlobalContext() {
      Object.assign(GLOBAL_OCE_CONTEXT, _getNewContext())
    }
    function acquireRequest(rootSpan) {
      if (availableRequest > 0 && rootSpan) {
        const sampling = config && typeof config.requestSampling === 'number' ? config.requestSampling : 30
        if (rootSpan.context().toSpanId().slice(-2) <= sampling) {
          availableRequest--
          return true
        }
      }
      return false
    }
    function releaseRequest() {
      if (availableRequest < config.maxConcurrentRequests) {
        availableRequest++
      }
    }
    function hasQuota(operation, iastContext, vulnerabilityType) {
      const oceContext = _getContext(iastContext)
      return operation.hasQuota(oceContext, vulnerabilityType)
    }
    function initializeRequestContext(iastContext) {
      if (iastContext) iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY] = _getNewContext()
    }
    function configure(cfg) {
      config = cfg
      availableRequest = config.maxConcurrentRequests
    }
    function startGlobalContext() {
      if (resetGlobalContextInterval) return
      _resetGlobalContext()
      resetGlobalContextInterval = setInterval(() => {
        _resetGlobalContext()
      }, INTERVAL_RESET_GLOBAL_CONTEXT)
      resetGlobalContextInterval.unref?.()
    }
    function finishGlobalContext() {
      if (resetGlobalContextInterval) {
        clearInterval(resetGlobalContextInterval)
        resetGlobalContextInterval = null
      }
    }
    module2.exports = {
      OVERHEAD_CONTROLLER_CONTEXT_KEY,
      OPERATIONS,
      startGlobalContext,
      finishGlobalContext,
      _resetGlobalContext,
      initializeRequestContext,
      hasQuota,
      acquireRequest,
      releaseRequest,
      configure,
      consolidateVulnerabilities,
      clearGlobalRouteMap,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/iast-plugin.js
var require_iast_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/iast-plugin.js'(exports2, module2) {
    'use strict'
    var { channel } = require_dc_polyfill()
    var Plugin = require_plugin()
    var iastTelemetry = require_telemetry7()
    var { getInstrumentedMetric, getExecutedMetric, TagKey, EXECUTED_SOURCE, formatTags } = require_iast_metric()
    var { storage } = require_datadog_core()
    var { getIastContext } = require_iast_context()
    var instrumentations = require_instrumentations()
    var log = require_log2()
    var IastPluginSubscription = class {
      constructor(moduleName2, channelName, tagValues, tagKey = TagKey.VULNERABILITY_TYPE) {
        this.moduleName = moduleName2
        this.channelName = channelName
        tagValues = Array.isArray(tagValues) ? tagValues : [tagValues]
        this.tags = formatTags(tagValues, tagKey)
        this.executedMetric = getExecutedMetric(tagKey)
        this.instrumentedMetric = getInstrumentedMetric(tagKey)
        this.moduleInstrumented = false
      }
      increaseInstrumented() {
        if (!this.moduleInstrumented) {
          this.moduleInstrumented = true
          this.tags.forEach((tag) => this.instrumentedMetric.inc(void 0, tag))
        }
      }
      increaseExecuted(iastContext) {
        this.tags.forEach((tag) => this.executedMetric.inc(iastContext, tag))
      }
      matchesModuleInstrumented(name) {
        if (name.startsWith('node:')) {
          name = name.slice(5)
        }
        name = name === 'https' ? 'http' : name
        return this.moduleName === name
      }
    }
    var IastPlugin = class extends Plugin {
      constructor() {
        super()
        this.configured = false
        this.pluginSubs = []
      }
      _getTelemetryHandler(iastSub) {
        return () => {
          const iastContext = getIastContext(storage('legacy').getStore())
          iastSub.increaseExecuted(iastContext)
        }
      }
      _execHandlerAndIncMetric({ handler, metric, tags, iastContext = getIastContext(storage('legacy').getStore()) }) {
        try {
          const result = handler()
          if (iastTelemetry.isEnabled()) {
            if (Array.isArray(tags)) {
              tags.forEach((tag) => metric.inc(iastContext, tag))
            } else {
              metric.inc(iastContext, tags)
            }
          }
          return result
        } catch (e) {
          log.error('[ASM] Error executing handler or increasing metrics', e)
        }
      }
      addSub(iastSub, handler) {
        if (typeof iastSub === 'string') {
          super.addSub(iastSub, handler)
        } else {
          iastSub = this._getAndRegisterSubscription(iastSub)
          if (iastSub) {
            super.addSub(iastSub.channelName, handler)
            if (iastTelemetry.isEnabled()) {
              super.addSub(iastSub.channelName, this._getTelemetryHandler(iastSub))
            }
          }
        }
      }
      enable(iastConfig) {
        this.iastConfig = iastConfig
        this.configure(true)
      }
      disable() {
        this.configure(false)
      }
      onConfigure() {}
      configure(config) {
        if (typeof config !== 'object') {
          config = { enabled: config }
        }
        if (config.enabled && !this.configured) {
          this.onConfigure()
          this.configured = true
        }
        if (iastTelemetry.isEnabled()) {
          if (config.enabled) {
            this.enableTelemetry()
          } else {
            this.disableTelemetry()
          }
        }
        super.configure(config)
      }
      _getAndRegisterSubscription({ moduleName: moduleName2, channelName, tag, tagKey }) {
        if (!moduleName2) {
          if (!channelName) return
          let firstSep = channelName.indexOf(':')
          if (firstSep === -1) {
            moduleName2 = channelName
          } else {
            if (channelName.startsWith('tracing:')) {
              firstSep = channelName.indexOf(':', 'tracing:'.length + 1)
            }
            const lastSep = channelName.indexOf(':', firstSep + 1)
            moduleName2 = channelName.slice(firstSep + 1, lastSep === -1 ? channelName.length : lastSep)
          }
        }
        const iastSub = new IastPluginSubscription(moduleName2, channelName, tag, tagKey)
        this.pluginSubs.push(iastSub)
        return iastSub
      }
      enableTelemetry() {
        if (this.onInstrumentationLoadedListener) return
        this.onInstrumentationLoadedListener = ({ name }) => this._onInstrumentationLoaded(name)
        const loadChannel = channel('dd-trace:instrumentation:load')
        loadChannel.subscribe(this.onInstrumentationLoadedListener)
        for (const name in instrumentations) {
          this._onInstrumentationLoaded(name)
        }
      }
      disableTelemetry() {
        if (!this.onInstrumentationLoadedListener) return
        const loadChannel = channel('dd-trace:instrumentation:load')
        if (loadChannel.hasSubscribers) {
          loadChannel.unsubscribe(this.onInstrumentationLoadedListener)
        }
        this.onInstrumentationLoadedListener = null
      }
      _onInstrumentationLoaded(name) {
        this.pluginSubs
          .filter((sub) => sub.matchesModuleInstrumented(name))
          .forEach((sub) => sub.increaseInstrumented())
      }
    }
    var SourceIastPlugin = class extends IastPlugin {
      addSub(iastPluginSub, handler) {
        return super.addSub({ tagKey: TagKey.SOURCE_TYPE, ...iastPluginSub }, handler)
      }
      addInstrumentedSource(moduleName2, tag) {
        this._getAndRegisterSubscription({
          moduleName: moduleName2,
          tag,
          tagKey: TagKey.SOURCE_TYPE,
        })
      }
      execSource(sourceHandlerInfo) {
        this._execHandlerAndIncMetric({
          metric: EXECUTED_SOURCE,
          ...sourceHandlerInfo,
        })
      }
    }
    var SinkIastPlugin = class extends IastPlugin {
      addSub(iastPluginSub, handler) {
        return super.addSub({ tagKey: TagKey.VULNERABILITY_TYPE, ...iastPluginSub }, handler)
      }
      addNotSinkSub(iastPluginSub, handler) {
        return super.addSub(iastPluginSub, handler)
      }
    }
    module2.exports = {
      SourceIastPlugin,
      SinkIastPlugin,
      IastPlugin,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks-generator.js
var require_secure_marks_generator = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks-generator.js'(
    exports2,
    module2
  ) {
    'use strict'
    var next = 0
    function getNextSecureMark() {
      return (1 << next++) >>> 0
    }
    function reset() {
      next = 0
    }
    module2.exports = { getNextSecureMark, reset }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks.js
var require_secure_marks = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks.js'(exports2, module2) {
    'use strict'
    var vulnerabilities = require_vulnerabilities()
    var { getNextSecureMark } = require_secure_marks_generator()
    var marks = {}
    Object.keys(vulnerabilities).forEach((vulnerability) => {
      marks[vulnerability + '_MARK'] = getNextSecureMark()
    })
    var asterisk = 0
    Object.values(marks).forEach((mark) => {
      asterisk |= mark
    })
    marks.ASTERISK_MARK = asterisk
    marks.CUSTOM_SECURE_MARK = getNextSecureMark()
    function getMarkFromVulnerabilityType(vulnerabilityType) {
      vulnerabilityType = vulnerabilityType?.trim()
      const mark = vulnerabilityType === '*' ? 'ASTERISK_MARK' : vulnerabilityType + '_MARK'
      return marks[mark]
    }
    module2.exports = {
      ...marks,
      getMarkFromVulnerabilityType,
      ALL: marks,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/vulnerability-analyzer.js
var require_vulnerability_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/vulnerability-analyzer.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var { getNonDDCallSiteFrames } = require_path_line()
    var { getIastContext, getIastStackTraceId } = require_iast_context()
    var overheadController = require_overhead_controller()
    var { SinkIastPlugin } = require_iast_plugin()
    var { addVulnerability, getVulnerabilityCallSiteFrames, replaceCallSiteFromSourceMap } =
      require_vulnerability_reporter()
    var { getMarkFromVulnerabilityType } = require_secure_marks()
    var { SUPPRESSED_VULNERABILITIES } = require_iast_metric()
    var Analyzer = class extends SinkIastPlugin {
      constructor(type) {
        super()
        this._type = type
        this._secureMark = getMarkFromVulnerabilityType(type)
      }
      _isVulnerable(value, context) {
        return false
      }
      _isExcluded(location) {
        return false
      }
      _report(value, context, meta) {
        const evidence = this._getEvidence(value, context, meta)
        this._reportEvidence(value, context, evidence)
      }
      _reportEvidence(value, context, evidence) {
        const callSiteFrames = getVulnerabilityCallSiteFrames()
        const nonDDCallSiteFrames = getNonDDCallSiteFrames(callSiteFrames, this._getExcludedPaths())
        const location = this._getLocation(value, nonDDCallSiteFrames)
        if (!this._isExcluded(location)) {
          const originalLocation = this._getOriginalLocation(location)
          const spanId = context?.rootSpan?.context().toSpanId()
          const stackId = getIastStackTraceId(context)
          const vulnerability = this._createVulnerability(this._type, evidence, spanId, originalLocation, stackId)
          addVulnerability(context, vulnerability, nonDDCallSiteFrames)
        }
      }
      _reportIfVulnerable(value, context, meta) {
        if (this._isVulnerable(value, context) && this._checkOCE(context, value)) {
          this._report(value, context, meta)
          return true
        }
        return false
      }
      _getEvidence(value) {
        return { value }
      }
      _getLocation(value, callSiteFrames) {
        return callSiteFrames[0]
      }
      _getOriginalLocation(location) {
        const locationFromSourceMap = replaceCallSiteFromSourceMap(location)
        const originalLocation = {}
        if (locationFromSourceMap?.path) {
          originalLocation.path = locationFromSourceMap.path
        }
        if (locationFromSourceMap?.line) {
          originalLocation.line = locationFromSourceMap.line
        }
        if (location?.class_name) {
          originalLocation.class = location.class_name
        }
        if (location?.function) {
          originalLocation.method = location.function
        }
        return originalLocation
      }
      _getExcludedPaths() {}
      _isInvalidContext(store, iastContext) {
        return store && !iastContext
      }
      analyze(value, store = storage('legacy').getStore(), meta) {
        const iastContext = getIastContext(store)
        if (this._isInvalidContext(store, iastContext)) return
        this._reportIfVulnerable(value, iastContext, meta)
      }
      analyzeAll(...values) {
        const store = storage('legacy').getStore()
        const iastContext = getIastContext(store)
        if (this._isInvalidContext(store, iastContext)) return
        for (const value of values) {
          if (this._isVulnerable(value, iastContext)) {
            if (this._checkOCE(iastContext, value)) {
              this._report(value, iastContext)
            }
            break
          }
        }
      }
      _checkOCE(context) {
        return overheadController.hasQuota(overheadController.OPERATIONS.REPORT_VULNERABILITY, context, this._type)
      }
      _createVulnerability(type, evidence, spanId, location, stackId) {
        if (type && evidence) {
          const _spanId = spanId || 0
          return {
            type,
            evidence,
            location: {
              spanId: _spanId,
              stackId,
              ...location,
            },
            hash: this._createHash(this._createHashSource(type, evidence, location)),
          }
        }
        return null
      }
      _createHashSource(type, evidence, location) {
        return location ? `${type}:${location.path}:${location.line}` : type
      }
      _createHash(hashSource) {
        let hash = 0
        let offset = 0
        const size = hashSource.length
        for (let i = 0; i < size; i++) {
          hash = (hash << 5) - hash + hashSource.charCodeAt(offset++)
        }
        return hash
      }
      _getSuppressedMetricTag() {
        if (!this._suppressedMetricTag) {
          this._suppressedMetricTag = SUPPRESSED_VULNERABILITIES.formatTags(this._type)[0]
        }
        return this._suppressedMetricTag
      }
      _incrementSuppressedMetric(iastContext) {
        SUPPRESSED_VULNERABILITIES.inc(iastContext, this._getSuppressedMetricTag())
      }
      addSub(iastSubOrChannelName, handler) {
        const iastSub =
          typeof iastSubOrChannelName === 'string' ? { channelName: iastSubOrChannelName } : iastSubOrChannelName
        super.addSub({ tag: this._type, ...iastSub }, handler)
      }
    }
    module2.exports = Analyzer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/source-types.js
var require_source_types = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/source-types.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      HTTP_REQUEST_BODY: 'http.request.body',
      HTTP_REQUEST_COOKIE_VALUE: 'http.request.cookie.value',
      HTTP_REQUEST_COOKIE_NAME: 'http.request.cookie.name',
      HTTP_REQUEST_HEADER_NAME: 'http.request.header.name',
      HTTP_REQUEST_HEADER_VALUE: 'http.request.header',
      HTTP_REQUEST_PARAMETER: 'http.request.parameter',
      HTTP_REQUEST_PATH_PARAM: 'http.request.path.parameter',
      HTTP_REQUEST_URI: 'http.request.uri',
      KAFKA_MESSAGE_KEY: 'kafka.message.key',
      KAFKA_MESSAGE_VALUE: 'kafka.message.value',
      SQL_ROW_VALUE: 'sql.row.value',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/operations-taint-object.js
var require_operations_taint_object = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/operations-taint-object.js'(
    exports2,
    module2
  ) {
    'use strict'
    var TaintedUtils = require('@datadog/native-iast-taint-tracking')
    var { IAST_TRANSACTION_ID } = require_iast_context()
    var { HTTP_REQUEST_PARAMETER } = require_source_types()
    var log = require_log2()
    var SEPARATOR = '\0'
    function taintObject(iastContext, object, type) {
      let result = object
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      if (transactionId) {
        const queue = [{ parent: null, property: null, value: object }]
        const visited = /* @__PURE__ */ new WeakSet()
        while (queue.length > 0) {
          const { parent, property, value, key } = queue.pop()
          if (value === null) {
            continue
          }
          try {
            if (typeof value === 'string') {
              const tainted = TaintedUtils.newTaintedString(transactionId, value, property, type)
              if (parent) {
                parent[key] = tainted
              } else {
                result = tainted
              }
            } else if (
              // eslint-disable-next-line eslint-rules/eslint-safe-typeof-object
              typeof value === 'object' &&
              !visited.has(value)
            ) {
              visited.add(value)
              for (const key2 of Object.keys(value)) {
                queue.push({
                  parent: value,
                  property: property ? `${property}.${key2}` : key2,
                  value: value[key2],
                  key: key2,
                })
              }
            }
          } catch (e) {
            log.error('[ASM] Error in taintObject when visiting property : %s', property, e)
          }
        }
      }
      return result
    }
    function taintQueryWithCache(iastContext, query) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      if (!transactionId || !query) return query
      iastContext.queryCache ??= /* @__PURE__ */ new Map()
      traverseAndTaint(query, '', iastContext.queryCache, transactionId)
      return query
    }
    function traverseAndTaint(node, path, cache, transactionId) {
      if (node == null) return node
      if (typeof node === 'string') {
        const cachedValue = cache.get(path)
        if (cachedValue === node) {
          return cachedValue
        }
        const tainted = TaintedUtils.newTaintedString(transactionId, node, path, HTTP_REQUEST_PARAMETER)
        cache.set(path, tainted)
        return tainted
      }
      if (typeof node === 'object') {
        const keys = Array.isArray(node) ? node.keys() : Object.keys(node)
        for (const key of keys) {
          const childPath = path ? `${path}${SEPARATOR}${key}` : String(key)
          const tainted = traverseAndTaint(node[key], childPath, cache, transactionId)
          node[key] = tainted
        }
      }
      return node
    }
    module2.exports = {
      taintObject,
      taintQueryWithCache,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/taint-tracking-impl.js
var require_taint_tracking_impl = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/taint-tracking-impl.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var TaintedUtils = require('@datadog/native-iast-taint-tracking')
    var { storage } = require_datadog_core()
    var iastContextFunctions = require_iast_context()
    var { EXECUTED_PROPAGATION } = require_iast_metric()
    var { isDebugAllowed } = require_verbosity()
    var { taintObject } = require_operations_taint_object()
    var log = require_log2()
    var mathRandomCallCh = dc.channel('datadog:random:call')
    var evalCallCh = dc.channel('datadog:eval:call')
    var JSON_VALUE = 'json.value'
    function noop(res) {
      return res
    }
    var TaintTrackingNoop = {
      concat: noop,
      eval: noop,
      join: noop,
      parse: noop,
      plusOperator: noop,
      random: noop,
      replace: noop,
      slice: noop,
      substr: noop,
      substring: noop,
      stringCase: noop,
      tplOperator: noop,
      trim: noop,
      trimEnd: noop,
    }
    function getTransactionId(iastContext) {
      return iastContext?.[iastContextFunctions.IAST_TRANSACTION_ID]
    }
    function getContextDefault() {
      const store = storage('legacy').getStore()
      return iastContextFunctions.getIastContext(store)
    }
    function getContextDebug() {
      const iastContext = getContextDefault()
      EXECUTED_PROPAGATION.inc(iastContext)
      return iastContext
    }
    function getFilteredCsiFn(cb, filter, getContext) {
      return function csiCall(res, fn, target, ...rest) {
        try {
          if (filter(res, fn, target)) {
            return res
          }
          const context = getContext()
          const transactionId = getTransactionId(context)
          if (transactionId) {
            return cb(transactionId, res, target, ...rest)
          }
        } catch (e) {
          log.error('[ASM] Error invoking CSI %s', target, e)
        }
        return res
      }
    }
    function notString() {
      return Array.prototype.some.call(arguments, (p) => typeof p !== 'string')
    }
    function isValidCsiMethod(fn, protos) {
      return protos.includes(fn)
    }
    function getCsiFn(cb, getContext, ...protos) {
      let filter
      if (!protos || protos.length === 0) {
        filter = (res, fn, target) => notString(res, target)
      } else if (protos.length === 1) {
        const protoFn = protos[0]
        filter = (res, fn, target) => notString(res, target) || fn !== protoFn
      } else {
        filter = (res, fn, target) => notString(res, target) || !isValidCsiMethod(fn, protos)
      }
      return getFilteredCsiFn(cb, filter, getContext)
    }
    function csiMethodsDefaults(names, excluded, getContext) {
      const impl = {}
      names.forEach((name) => {
        if (excluded.includes(name)) return
        impl[name] = getCsiFn(
          (transactionId, res, target, ...rest) => TaintedUtils[name](transactionId, res, target, ...rest),
          getContext,
          String.prototype[name]
        )
      })
      return impl
    }
    function csiMethodsOverrides(getContext) {
      return {
        plusOperator: function (res, op1, op2) {
          try {
            if (notString(res) || (notString(op1) && notString(op2))) {
              return res
            }
            const iastContext = getContext()
            const transactionId = getTransactionId(iastContext)
            if (transactionId) {
              return TaintedUtils.concat(transactionId, res, op1, op2)
            }
          } catch (e) {
            log.error('[ASM] Error invoking CSI plusOperator', e)
          }
          return res
        },
        tplOperator: function (res, ...rest) {
          try {
            const iastContext = getContext()
            const transactionId = getTransactionId(iastContext)
            if (transactionId) {
              return TaintedUtils.concat(transactionId, res, ...rest)
            }
          } catch (e) {
            log.error('[ASM] Error invoking CSI tplOperator', e)
          }
          return res
        },
        stringCase: getCsiFn(
          (transactionId, res, target) => TaintedUtils.stringCase(transactionId, res, target),
          getContext,
          String.prototype.toLowerCase,
          String.prototype.toUpperCase
        ),
        trim: getCsiFn(
          (transactionId, res, target) => TaintedUtils.trim(transactionId, res, target),
          getContext,
          String.prototype.trim,
          String.prototype.trimStart
        ),
        random: function (res, fn) {
          if (mathRandomCallCh.hasSubscribers) {
            mathRandomCallCh.publish({ fn })
          }
          return res
        },
        eval: function (res, fn, target, script) {
          if (evalCallCh.hasSubscribers && fn === globalThis.eval) {
            evalCallCh.publish({ script })
          }
          return res
        },
        parse: function (res, fn, target, json) {
          if (fn === JSON.parse) {
            try {
              const iastContext = getContext()
              const transactionId = getTransactionId(iastContext)
              if (transactionId) {
                const ranges = TaintedUtils.getRanges(transactionId, json)
                if (ranges?.length > 0) {
                  const range = ranges.find((range2) => range2.iinfo?.type)
                  res = taintObject(iastContext, res, range?.iinfo.type || JSON_VALUE)
                }
              }
            } catch (e) {
              log.error('[ASM] Error invoking CSI JSON.parse', e)
            }
          }
          return res
        },
        join: function (res, fn, target, separator) {
          if (fn === Array.prototype.join) {
            try {
              const iastContext = getContext()
              const transactionId = getTransactionId(iastContext)
              if (transactionId) {
                res = TaintedUtils.arrayJoin(transactionId, res, target, separator)
              }
            } catch (e) {
              log.error('[ASM] Error invoking CSI join', e)
            }
          }
          return res
        },
      }
    }
    function createImplWith(getContext) {
      const methodNames = Object.keys(TaintTrackingNoop)
      const overrides = csiMethodsOverrides(getContext)
      return {
        ...csiMethodsDefaults(methodNames, Object.keys(overrides), getContext),
        ...overrides,
      }
    }
    function getTaintTrackingImpl(telemetryVerbosity, dummy = false) {
      if (dummy) return TaintTrackingNoop
      return isDebugAllowed(telemetryVerbosity) ? createImplWith(getContextDebug) : createImplWith(getContextDefault)
    }
    function getTaintTrackingNoop() {
      return getTaintTrackingImpl(null, true)
    }
    var lodashFns = {
      join: TaintedUtils.arrayJoin,
      toLower: TaintedUtils.stringCase,
      toUpper: TaintedUtils.stringCase,
      trim: TaintedUtils.trim,
      trimEnd: TaintedUtils.trimEnd,
      trimStart: TaintedUtils.trim,
    }
    function getLodashTaintedUtilFn(lodashFn) {
      return lodashFns[lodashFn] || ((transactionId, result) => result)
    }
    function lodashTaintTrackingHandler(message) {
      try {
        if (!message.result) return
        const context = getContextDefault()
        const transactionId = getTransactionId(context)
        if (transactionId) {
          message.result = getLodashTaintedUtilFn(message.operation)(
            transactionId,
            message.result,
            ...message.arguments
          )
        }
      } catch (e) {
        log.error('[ASM] Error invoking CSI lodash %s', message.operation, e)
      }
    }
    module2.exports = {
      getTaintTrackingImpl,
      getTaintTrackingNoop,
      lodashTaintTrackingHandler,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/operations.js
var require_operations = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/operations.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var TaintedUtils = require('@datadog/native-iast-taint-tracking')
    var { IAST_TRANSACTION_ID } = require_iast_context()
    var iastTelemetry = require_telemetry7()
    var { REQUEST_TAINTED } = require_iast_metric()
    var { isInfoAllowed } = require_verbosity()
    var { getTaintTrackingImpl, getTaintTrackingNoop, lodashTaintTrackingHandler } = require_taint_tracking_impl()
    var { taintObject, taintQueryWithCache } = require_operations_taint_object()
    var lodashOperationCh = dc.channel('datadog:lodash:operation')
    function createTransaction(id, iastContext) {
      if (id && iastContext) {
        iastContext[IAST_TRANSACTION_ID] = TaintedUtils.createTransaction(id)
      }
    }
    var onRemoveTransaction = (transactionId, iastContext) => {}
    function onRemoveTransactionInformationTelemetry(transactionId, iastContext) {
      const metrics = TaintedUtils.getMetrics(transactionId, iastTelemetry.verbosity)
      if (metrics?.requestCount) {
        REQUEST_TAINTED.inc(iastContext, metrics.requestCount)
      }
    }
    function removeTransaction(iastContext) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      if (transactionId) {
        onRemoveTransaction(transactionId, iastContext)
        TaintedUtils.removeTransaction(transactionId)
        delete iastContext[IAST_TRANSACTION_ID]
      }
    }
    function newTaintedString(iastContext, string, name, type) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      return transactionId ? TaintedUtils.newTaintedString(transactionId, string, name, type) : string
    }
    function newTaintedObject(iastContext, obj, name, type) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      return transactionId ? TaintedUtils.newTaintedObject(transactionId, obj, name, type) : obj
    }
    function isTainted(iastContext, string) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      return transactionId ? TaintedUtils.isTainted(transactionId, string) : false
    }
    function getRanges(iastContext, string) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      return transactionId ? TaintedUtils.getRanges(transactionId, string) : []
    }
    function addSecureMark(iastContext, string, mark, createNewTainted = true) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID]
      if (transactionId) {
        return TaintedUtils.addSecureMarksToTaintedString(transactionId, string, mark, createNewTainted)
      }
      return string
    }
    function enableTaintOperations(telemetryVerbosity) {
      if (isInfoAllowed(telemetryVerbosity)) {
        onRemoveTransaction = onRemoveTransactionInformationTelemetry
      }
      global._ddiast = getTaintTrackingImpl(telemetryVerbosity)
      lodashOperationCh.subscribe(lodashTaintTrackingHandler)
    }
    function disableTaintOperations() {
      global._ddiast = getTaintTrackingNoop()
      lodashOperationCh.unsubscribe(lodashTaintTrackingHandler)
    }
    function setMaxTransactions(transactions) {
      if (!transactions) {
        return
      }
      TaintedUtils.setMaxTransactions(transactions)
    }
    module2.exports = {
      addSecureMark,
      createTransaction,
      removeTransaction,
      newTaintedString,
      newTaintedObject,
      taintObject,
      taintQueryWithCache,
      isTainted,
      getRanges,
      enableTaintOperations,
      disableTaintOperations,
      setMaxTransactions,
      IAST_TRANSACTION_ID,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/injection-analyzer.js
var require_injection_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/injection-analyzer.js'(exports2, module2) {
    'use strict'
    var Analyzer = require_vulnerability_analyzer()
    var { getRanges } = require_operations()
    var { SQL_ROW_VALUE } = require_source_types()
    var InjectionAnalyzer = class extends Analyzer {
      _isVulnerable(value, iastContext) {
        let ranges = value && getRanges(iastContext, value)
        if (ranges?.length > 0) {
          ranges = this._filterSecureRanges(ranges, value)
          if (!ranges?.length) {
            this._incrementSuppressedMetric(iastContext)
          }
          return this._areRangesVulnerable(ranges)
        }
        return false
      }
      _getEvidence(value, iastContext) {
        const ranges = getRanges(iastContext, value)
        return { value, ranges }
      }
      _areRangesVulnerable(ranges) {
        return ranges?.some((range) => range.iinfo.type !== SQL_ROW_VALUE)
      }
      _filterSecureRanges(ranges, value) {
        return ranges?.filter((range) => !this._isRangeSecure(range, value))
      }
      _isRangeSecure(range, _value) {
        const { secureMarks } = range
        return (secureMarks & this._secureMark) === this._secureMark
      }
    }
    module2.exports = InjectionAnalyzer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/stored-injection-analyzer.js
var require_stored_injection_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/stored-injection-analyzer.js'(exports2, module2) {
    'use strict'
    var InjectionAnalyzer = require_injection_analyzer()
    var StoredInjectionAnalyzer = class extends InjectionAnalyzer {
      _areRangesVulnerable(ranges) {
        return ranges?.length > 0
      }
    }
    module2.exports = StoredInjectionAnalyzer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/code-injection-analyzer.js
var require_code_injection_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/code-injection-analyzer.js'(exports2, module2) {
    'use strict'
    var { CODE_INJECTION } = require_vulnerabilities()
    var StoredInjectionAnalyzer = require_stored_injection_analyzer()
    var { INSTRUMENTED_SINK } = require_iast_metric()
    var { storage } = require_datadog_core()
    var { getIastContext } = require_iast_context()
    var CodeInjectionAnalyzer = class extends StoredInjectionAnalyzer {
      constructor() {
        super(CODE_INJECTION)
        this.evalInstrumentedInc = false
      }
      onConfigure() {
        this.addSub('datadog:eval:call', ({ script }) => {
          if (!this.evalInstrumentedInc) {
            const store = storage('legacy').getStore()
            const iastContext = getIastContext(store)
            const tags = INSTRUMENTED_SINK.formatTags(CODE_INJECTION)
            for (const tag of tags) {
              INSTRUMENTED_SINK.inc(iastContext, tag)
            }
            this.evalInstrumentedInc = true
          }
          this.analyze(script)
        })
        this.addSub('datadog:vm:run-script:start', ({ code }) => this.analyze(code))
        this.addSub('datadog:vm:source-text-module:start', ({ code }) => this.analyze(code))
      }
    }
    module2.exports = new CodeInjectionAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/command-injection-analyzer.js
var require_command_injection_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/command-injection-analyzer.js'(exports2, module2) {
    'use strict'
    var InjectionAnalyzer = require_injection_analyzer()
    var { COMMAND_INJECTION } = require_vulnerabilities()
    var CommandInjectionAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(COMMAND_INJECTION)
      }
      onConfigure() {
        this.addSub('tracing:datadog:child_process:execution:start', ({ command }) => this.analyze(command))
      }
    }
    module2.exports = new CommandInjectionAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-base-analyzer.js
var require_hardcoded_base_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-base-analyzer.js'(exports2, module2) {
    'use strict'
    var Analyzer = require_vulnerability_analyzer()
    var { getRelativePath } = require_path_line()
    var HardcodedBaseAnalyzer = class extends Analyzer {
      constructor(type, allRules = [], valueOnlyRules = []) {
        super(type)
        this.allRules = allRules
        this.valueOnlyRules = valueOnlyRules
      }
      onConfigure() {
        this.addSub('datadog:secrets:result', (secrets) => {
          this.analyze(secrets)
        })
      }
      analyze(secrets) {
        if (!secrets?.file || !secrets.literals) return
        const { allRules, valueOnlyRules } = this
        const matches = []
        for (const literal of secrets.literals) {
          const { value, locations } = literal
          if (!value || !locations) continue
          for (const location of locations) {
            let match
            if (location.ident) {
              const fullValue = `${location.ident}=${value}`
              match = allRules.find((rule) => fullValue.match(rule.regex))
            } else {
              match = valueOnlyRules.find((rule) => value.match(rule.regex))
            }
            if (match) {
              matches.push({ location, ruleId: match.id })
            }
          }
        }
        if (matches.length) {
          const file = getRelativePath(secrets.file)
          matches.forEach((match) =>
            this._report({
              file,
              line: match.location.line,
              column: match.location.column,
              ident: match.location.ident,
              data: match.ruleId,
            })
          )
        }
      }
      _getEvidence(value) {
        return { value: `${value.data}` }
      }
      _getLocation(value) {
        return {
          path: value.file,
          line: value.line,
          column: value.column,
          isInternal: false,
        }
      }
    }
    module2.exports = HardcodedBaseAnalyzer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-rule-type.js
var require_hardcoded_rule_type = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-rule-type.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      ValueOnly: 'ValueOnly',
      NameAndValue: 'NameAndValue',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-rules.js
var require_hardcoded_password_rules = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-rules.js'(exports2, module2) {
    'use strict'
    var { NameAndValue } = require_hardcoded_rule_type()
    module2.exports = [
      {
        id: 'hardcoded-password',
        regex:
          /(?:pwd|pswd|pass|secret)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-z\-_.=]{10,150})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
    ]
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-analyzer.js
var require_hardcoded_password_analyzer2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var { HARDCODED_PASSWORD } = require_vulnerabilities()
    var HardcodedBaseAnalyzer = require_hardcoded_base_analyzer()
    var allRules = require_hardcoded_password_rules()
    var HardcodedPasswordAnalyzer = class extends HardcodedBaseAnalyzer {
      constructor() {
        super(HARDCODED_PASSWORD, allRules)
      }
      _getEvidence(value) {
        return { value: `${value.ident}` }
      }
    }
    module2.exports = new HardcodedPasswordAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-rules.js
var require_hardcoded_secret_rules = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-rules.js'(exports2, module2) {
    'use strict'
    var { ValueOnly, NameAndValue } = require_hardcoded_rule_type()
    module2.exports = [
      {
        id: 'adafruit-api-key',
        regex:
          /(?:adafruit)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'adobe-client-id',
        regex:
          /(?:adobe)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'adobe-client-secret',
        regex: /\b((p8e-)[a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'age-secret-key',
        regex: /AGE-SECRET-KEY-1[QPZRY9X8GF2TVDW0S3JN54KHCE6MUA7L]{58}/,
        type: ValueOnly,
      },
      {
        id: 'airtable-api-key',
        regex:
          /(?:airtable)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{17})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'algolia-api-key',
        regex:
          /(?:algolia)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'alibaba-access-key-id',
        regex: /\b((LTAI)[a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'asana-client-id',
        regex:
          /(?:asana)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9]{16})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'asana-client-secret',
        regex:
          /(?:asana)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'atlassian-api-token',
        regex:
          /(?:atlassian|confluence|jira)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'authress-service-client-access-key',
        regex:
          /\b((?:sc|ext|scauth|authress)_[a-z0-9]{5,30}\.[a-z0-9]{4,6}\.acc[_-][a-z0-9-]{10,32}\.[a-z0-9+/_=-]{30,120})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'aws-access-token',
        regex: /\b((A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16})(?:['"\s\x60;]|$)/,
        type: ValueOnly,
      },
      {
        id: 'beamer-api-token',
        regex:
          /(?:beamer)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(b_[a-z0-9=_-]{44})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'bitbucket-client-id',
        regex:
          /(?:bitbucket)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'bitbucket-client-secret',
        regex:
          /(?:bitbucket)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'bittrex-access-key',
        regex:
          /(?:bittrex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'clojars-api-token',
        regex: /(CLOJARS_)[a-z0-9]{60}/i,
        type: ValueOnly,
      },
      {
        id: 'codecov-access-token',
        regex:
          /(?:codecov)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'coinbase-access-token',
        regex:
          /(?:coinbase)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'confluent-access-token',
        regex:
          /(?:confluent)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{16})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'confluent-secret-key',
        regex:
          /(?:confluent)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'contentful-delivery-api-token',
        regex:
          /(?:contentful)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{43})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'databricks-api-token',
        regex: /\b(dapi[a-h0-9]{32})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'datadog-access-token',
        regex:
          /(?:datadog)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'defined-networking-api-token',
        regex:
          /(?:dnkey)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(dnkey-[a-z0-9=_-]{26}-[a-z0-9=_-]{52})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'digitalocean-access-token',
        regex: /\b(doo_v1_[a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'digitalocean-pat',
        regex: /\b(dop_v1_[a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'digitalocean-refresh-token',
        regex: /\b(dor_v1_[a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'discord-api-token',
        regex:
          /(?:discord)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'discord-client-id',
        regex:
          /(?:discord)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9]{18})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'discord-client-secret',
        regex:
          /(?:discord)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'doppler-api-token',
        regex: /(dp\.pt\.)[a-z0-9]{43}/i,
        type: ValueOnly,
      },
      {
        id: 'droneci-access-token',
        regex:
          /(?:droneci)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'dropbox-api-token',
        regex:
          /(?:dropbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{15})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'dropbox-long-lived-api-token',
        regex:
          /(?:dropbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{11}(AAAAAAAAAA)[a-z0-9\-_=]{43})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'dropbox-short-lived-api-token',
        regex:
          /(?:dropbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(sl\.[a-z0-9\-=_]{135})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'duffel-api-token',
        regex: /duffel_(test|live)_[a-z0-9_\-=]{43}/i,
        type: ValueOnly,
      },
      {
        id: 'dynatrace-api-token',
        regex: /dt0c01\.[a-z0-9]{24}\.[a-z0-9]{64}/i,
        type: ValueOnly,
      },
      {
        id: 'easypost-api-token',
        regex: /\bEZAK[a-z0-9]{54}/i,
        type: ValueOnly,
      },
      {
        id: 'etsy-access-token',
        regex:
          /(?:etsy)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'facebook',
        regex:
          /(?:facebook)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'fastly-api-token',
        regex:
          /(?:fastly)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'finicity-api-token',
        regex:
          /(?:finicity)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'finicity-client-secret',
        regex:
          /(?:finicity)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'finnhub-access-token',
        regex:
          /(?:finnhub)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'flickr-access-token',
        regex:
          /(?:flickr)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'flutterwave-public-key',
        regex: /FLWPUBK_TEST-[a-h0-9]{32}-X/i,
        type: ValueOnly,
      },
      {
        id: 'frameio-api-token',
        regex: /fio-u-[a-z0-9\-_=]{64}/i,
        type: ValueOnly,
      },
      {
        id: 'freshbooks-access-token',
        regex:
          /(?:freshbooks)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'gcp-api-key',
        regex: /\b(AIza[0-9a-z\-_]{35})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'github-app-token',
        regex: /(ghu|ghs)_[0-9a-zA-Z]{36}/,
        type: ValueOnly,
      },
      {
        id: 'github-fine-grained-pat',
        regex: /github_pat_[0-9a-zA-Z_]{82}/,
        type: ValueOnly,
      },
      {
        id: 'github-oauth',
        regex: /gho_[0-9a-zA-Z]{36}/,
        type: ValueOnly,
      },
      {
        id: 'github-pat',
        regex: /ghp_[0-9a-zA-Z]{36}/,
        type: ValueOnly,
      },
      {
        id: 'gitlab-pat',
        regex: /glpat-[0-9a-zA-Z\-_]{20}/,
        type: ValueOnly,
      },
      {
        id: 'gitlab-ptt',
        regex: /glptt-[0-9a-f]{40}/,
        type: ValueOnly,
      },
      {
        id: 'gitlab-rrt',
        regex: /GR1348941[0-9a-zA-Z\-_]{20}/,
        type: ValueOnly,
      },
      {
        id: 'gitter-access-token',
        regex:
          /(?:gitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'gocardless-api-token',
        regex:
          /(?:gocardless)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(live_[a-z0-9\-_=]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'grafana-api-key',
        regex: /\b(eyJrIjoi[a-z0-9]{70,400}={0,2})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'grafana-cloud-api-token',
        regex: /\b(glc_[a-z0-9+/]{32,400}={0,2})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'grafana-service-account-token',
        regex: /\b(glsa_[a-z0-9]{32}_[a-f0-9]{8})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'hashicorp-tf-api-token',
        regex: /[a-z0-9]{14}\.atlasv1\.[a-z0-9\-_=]{60,70}/i,
        type: ValueOnly,
      },
      {
        id: 'heroku-api-key',
        regex:
          /(?:heroku)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'hubspot-api-key',
        regex:
          /(?:hubspot)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'intercom-api-key',
        regex:
          /(?:intercom)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{60})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'jfrog-api-key',
        regex:
          /(?:jfrog|artifactory|bintray|xray)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{73})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'jwt',
        regex: /\b(ey[a-zA-Z0-9]{17,}\.ey[a-zA-Z0-9/_-]{17,}\.(?:[a-zA-Z0-9/_-]{10,}={0,2})?)(?:['"\s\x60;]|$)/,
        type: ValueOnly,
      },
      {
        id: 'kraken-access-token',
        regex:
          /(?:kraken)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9/=_+-]{80,90})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'kucoin-access-token',
        regex:
          /(?:kucoin)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'launchdarkly-access-token',
        regex:
          /(?:launchdarkly)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'linear-api-key',
        regex: /lin_api_[a-z0-9]{40}/i,
        type: ValueOnly,
      },
      {
        id: 'linkedin-client-secret',
        regex:
          /(?:linkedin|linked-in)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{16})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'lob-pub-api-key',
        regex:
          /(?:lob)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}((test|live)_pub_[a-f0-9]{31})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'mailchimp-api-key',
        regex:
          /(?:mailchimp)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32}-us20)(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'mailgun-private-api-token',
        regex:
          /(?:mailgun)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(key-[a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'mailgun-pub-key',
        regex:
          /(?:mailgun)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(pubkey-[a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'mailgun-signing-key',
        regex:
          /(?:mailgun)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-h0-9]{32}-[a-h0-9]{8}-[a-h0-9]{8})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'mapbox-api-token',
        regex:
          /(?:mapbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(pk\.[a-z0-9]{60}\.[a-z0-9]{22})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'mattermost-access-token',
        regex:
          /(?:mattermost)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{26})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'messagebird-api-token',
        regex:
          /(?:messagebird|message-bird|message_bird)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{25})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'netlify-access-token',
        regex:
          /(?:netlify)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{40,46})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'new-relic-browser-api-token',
        regex:
          /(?:new-relic|newrelic|new_relic)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(NRJS-[a-f0-9]{19})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'new-relic-user-api-id',
        regex:
          /(?:new-relic|newrelic|new_relic)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'new-relic-user-api-key',
        regex:
          /(?:new-relic|newrelic|new_relic)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(NRAK-[a-z0-9]{27})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'npm-access-token',
        regex: /\b(npm_[a-z0-9]{36})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'nytimes-access-token',
        regex:
          /(?:nytimes|new-york-times,|newyorktimes)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'okta-access-token',
        regex:
          /(?:okta)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{42})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'openai-api-key',
        regex: /\b(sk-[a-z0-9]{20}T3BlbkFJ[a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'plaid-api-token',
        regex:
          /(?:plaid)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(access-(?:sandbox|development|production)-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'plaid-client-id',
        regex:
          /(?:plaid)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'plaid-secret-key',
        regex:
          /(?:plaid)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{30})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'planetscale-api-token',
        regex: /\b(pscale_tkn_[a-z0-9=\-_.]{32,64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'planetscale-oauth-token',
        regex: /\b(pscale_oauth_[a-z0-9=\-_.]{32,64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'planetscale-password',
        regex: /\b(pscale_pw_[a-z0-9=\-_.]{32,64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'postman-api-token',
        regex: /\b(PMAK-[a-f0-9]{24}-[a-f0-9]{34})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'prefect-api-token',
        regex: /\b(pnu_[a-z0-9]{36})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'private-key',
        regex: /-----BEGIN[ A-Z0-9_-]{0,100}PRIVATE KEY( BLOCK)?-----[\s\S]*KEY( BLOCK)?----/i,
        type: ValueOnly,
      },
      {
        id: 'pulumi-api-token',
        regex: /\b(pul-[a-f0-9]{40})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'pypi-upload-token',
        regex: /pypi-AgEIcHlwaS5vcmc[A-Za-z0-9\-_]{50,1000}/,
        type: ValueOnly,
      },
      {
        id: 'rapidapi-access-token',
        regex:
          /(?:rapidapi)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{50})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'readme-api-token',
        regex: /\b(rdme_[a-z0-9]{70})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'rubygems-api-token',
        regex: /\b(rubygems_[a-f0-9]{48})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'scalingo-api-token',
        regex: /tk-us-[a-zA-Z0-9-_]{48}/,
        type: ValueOnly,
      },
      {
        id: 'sendbird-access-id',
        regex:
          /(?:sendbird)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'sendbird-access-token',
        regex:
          /(?:sendbird)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'sendgrid-api-token',
        regex: /\b(SG\.[a-z0-9=_\-.]{66})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'sendinblue-api-token',
        regex: /\b(xkeysib-[a-f0-9]{64}-[a-z0-9]{16})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'sentry-access-token',
        regex:
          /(?:sentry)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'shippo-api-token',
        regex: /\b(shippo_(live|test)_[a-f0-9]{40})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'shopify-access-token',
        regex: /shpat_[a-fA-F0-9]{32}/,
        type: ValueOnly,
      },
      {
        id: 'shopify-custom-access-token',
        regex: /shpca_[a-fA-F0-9]{32}/,
        type: ValueOnly,
      },
      {
        id: 'shopify-private-app-access-token',
        regex: /shppa_[a-fA-F0-9]{32}/,
        type: ValueOnly,
      },
      {
        id: 'shopify-shared-secret',
        regex: /shpss_[a-fA-F0-9]{32}/,
        type: ValueOnly,
      },
      {
        id: 'sidekiq-secret',
        regex:
          /(?:BUNDLE_ENTERPRISE__CONTRIBSYS__COM|BUNDLE_GEMS__CONTRIBSYS__COM)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{8}:[a-f0-9]{8})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'slack-app-token',
        regex: /(xapp-\d-[A-Z0-9]+-\d+-[a-z0-9]+)/i,
        type: ValueOnly,
      },
      {
        id: 'slack-bot-token',
        regex: /(xoxb-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*)/,
        type: ValueOnly,
      },
      {
        id: 'slack-config-access-token',
        regex: /(xoxe.xox[bp]-\d-[A-Z0-9]{163,166})/i,
        type: ValueOnly,
      },
      {
        id: 'slack-config-refresh-token',
        regex: /(xoxe-\d-[A-Z0-9]{146})/i,
        type: ValueOnly,
      },
      {
        id: 'slack-legacy-bot-token',
        regex: /(xoxb-[0-9]{8,14}-[a-zA-Z0-9]{18,26})/,
        type: ValueOnly,
      },
      {
        id: 'slack-legacy-token',
        regex: /(xox[os]-\d+-\d+-\d+-[a-fA-F\d]+)/,
        type: ValueOnly,
      },
      {
        id: 'slack-legacy-workspace-token',
        regex: /(xox[ar]-(?:\d-)?[0-9a-zA-Z]{8,48})/,
        type: ValueOnly,
      },
      {
        id: 'slack-user-token',
        regex: /(xox[pe](?:-[0-9]{10,13}){3}-[a-zA-Z0-9-]{28,34})/,
        type: ValueOnly,
      },
      {
        id: 'slack-webhook-url',
        regex: /(https?:\/\/)?hooks.slack.com\/(services|workflows)\/[A-Za-z0-9+/]{43,46}/,
        type: ValueOnly,
      },
      {
        id: 'snyk-api-token',
        regex:
          /(?:snyk)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'square-access-token',
        regex: /\b(sq0atp-[0-9a-z\-_]{22})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'square-secret',
        regex: /\b(sq0csp-[0-9a-z\-_]{43})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'squarespace-access-token',
        regex:
          /(?:squarespace)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'stripe-access-token',
        regex: /(sk|pk)_(test|live)_[0-9a-z]{10,32}/i,
        type: ValueOnly,
      },
      {
        id: 'sumologic-access-token',
        regex:
          /(?:sumo)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'telegram-bot-api-token',
        regex: /(?:^|[^0-9])([0-9]{5,16}:A[a-z0-9_-]{34})(?:$|[^a-z0-9_-])/i,
        type: ValueOnly,
      },
      {
        id: 'travisci-access-token',
        regex:
          /(?:travis)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{22})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'trello-access-token',
        regex:
          /(?:trello)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z-0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'twilio-api-key',
        regex: /SK[0-9a-fA-F]{32}/,
        type: ValueOnly,
      },
      {
        id: 'twitch-api-token',
        regex:
          /(?:twitch)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{30})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'twitter-access-secret',
        regex:
          /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{45})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'twitter-access-token',
        regex:
          /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9]{15,25}-[a-z0-9]{20,40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'twitter-api-key',
        regex:
          /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{25})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'twitter-api-secret',
        regex:
          /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{50})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'twitter-bearer-token',
        regex:
          /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(A{22}[a-z0-9%]{80,100})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'typeform-api-token',
        regex:
          /(?:typeform)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(tfp_[a-z0-9\-_.=]{59})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'vault-batch-token',
        regex: /\b(hvb\.[a-z0-9_-]{138,212})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'vault-service-token',
        regex: /\b(hvs\.[a-z0-9_-]{90,100})(?:['"\s\x60;]|$)/i,
        type: ValueOnly,
      },
      {
        id: 'yandex-access-token',
        regex:
          /(?:yandex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(t1\.[A-Z0-9a-z_-]+[=]{0,2}\.[A-Z0-9a-z_-]{86}[=]{0,2})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'yandex-api-key',
        regex:
          /(?:yandex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(AQVN[a-z0-9_-]{35,38})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'yandex-aws-access-token',
        regex:
          /(?:yandex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(YC[a-z0-9_-]{38})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
      {
        id: 'zendesk-secret-key',
        regex:
          /(?:zendesk)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue,
      },
    ]
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-analyzer.js
var require_hardcoded_secret_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-analyzer.js'(exports2, module2) {
    'use strict'
    var { HARDCODED_SECRET } = require_vulnerabilities()
    var HardcodedBaseAnalyzer = require_hardcoded_base_analyzer()
    var { ValueOnly } = require_hardcoded_rule_type()
    var allRules = require_hardcoded_secret_rules()
    var HardcodedSecretAnalyzer = class extends HardcodedBaseAnalyzer {
      constructor() {
        super(
          HARDCODED_SECRET,
          allRules,
          allRules.filter((rule) => rule.type === ValueOnly)
        )
      }
    }
    module2.exports = new HardcodedSecretAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/missing-header-analyzer.js
var require_missing_header_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/missing-header-analyzer.js'(exports2, module2) {
    'use strict'
    var Analyzer = require_vulnerability_analyzer()
    var SC_MOVED_PERMANENTLY = 301
    var SC_MOVED_TEMPORARILY = 302
    var SC_NOT_MODIFIED = 304
    var SC_TEMPORARY_REDIRECT = 307
    var SC_NOT_FOUND = 404
    var SC_GONE = 410
    var SC_INTERNAL_SERVER_ERROR = 500
    var IGNORED_RESPONSE_STATUS_LIST = /* @__PURE__ */ new Set([
      SC_MOVED_PERMANENTLY,
      SC_MOVED_TEMPORARILY,
      SC_NOT_MODIFIED,
      SC_TEMPORARY_REDIRECT,
      SC_NOT_FOUND,
      SC_GONE,
      SC_INTERNAL_SERVER_ERROR,
    ])
    var HTML_CONTENT_TYPES = ['text/html', 'application/xhtml+xml']
    var MissingHeaderAnalyzer = class extends Analyzer {
      constructor(type, headerName) {
        super(type)
        this.headerName = headerName
      }
      onConfigure() {
        this.addSub(
          {
            channelName: 'datadog:iast:response-end',
            moduleName: 'http',
          },
          (data) => this.analyze(data)
        )
      }
      _getHeaderValues(res, storedHeaders, headerName) {
        headerName = headerName.toLowerCase()
        const headerValue = res.getHeader(headerName) || storedHeaders[headerName]
        if (Array.isArray(headerValue)) {
          return headerValue
        }
        return headerValue ? [headerValue.toString()] : []
      }
      _getLocation() {}
      _checkOCE(context) {
        return true
      }
      _createHashSource(type, evidence, location) {
        return `${type}:${this.config.tracerConfig.service}`
      }
      _getEvidence({ res, storedHeaders }) {
        const headerValues = this._getHeaderValues(res, storedHeaders, this.headerName)
        let value
        if (headerValues.length === 1) {
          value = headerValues[0]
        } else if (headerValues.length > 0) {
          value = JSON.stringify(headerValues)
        }
        return { value }
      }
      _isVulnerable({ req, res, storedHeaders }, context) {
        if (!IGNORED_RESPONSE_STATUS_LIST.has(res.statusCode) && this._isResponseHtml(res, storedHeaders)) {
          return this._isVulnerableFromRequestAndResponse(req, res, storedHeaders)
        }
        return false
      }
      _isVulnerableFromRequestAndResponse(req, res, storedHeaders) {
        return false
      }
      _isResponseHtml(res, storedHeaders) {
        const contentTypes = this._getHeaderValues(res, storedHeaders, 'content-type')
        return contentTypes.some((contentType) => {
          return (
            contentType &&
            HTML_CONTENT_TYPES.some((htmlContentType) => {
              return htmlContentType === contentType || contentType.startsWith(htmlContentType + ';')
            })
          )
        })
      }
    }
    module2.exports = { MissingHeaderAnalyzer }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hsts-header-missing-analyzer.js
var require_hsts_header_missing_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/hsts-header-missing-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var { HSTS_HEADER_MISSING } = require_vulnerabilities()
    var { MissingHeaderAnalyzer } = require_missing_header_analyzer()
    var HSTS_HEADER_NAME = 'Strict-Transport-Security'
    var HEADER_VALID_PREFIX = 'max-age'
    var HstsHeaderMissingAnalyzer = class extends MissingHeaderAnalyzer {
      constructor() {
        super(HSTS_HEADER_MISSING, HSTS_HEADER_NAME)
      }
      _isVulnerableFromRequestAndResponse(req, res, storedHeaders) {
        const headerValues = this._getHeaderValues(res, storedHeaders, HSTS_HEADER_NAME)
        return (
          this._isHttpsProtocol(req) &&
          (headerValues.length === 0 || headerValues.some((headerValue) => !this._isHeaderValid(headerValue)))
        )
      }
      _isHeaderValid(headerValue) {
        headerValue = headerValue.trim()
        if (!headerValue?.startsWith(HEADER_VALID_PREFIX)) {
          return false
        }
        const semicolonIndex = headerValue.indexOf(';')
        const timestampString = headerValue.slice(
          HEADER_VALID_PREFIX.length + 1,
          semicolonIndex === -1 ? headerValue.length : semicolonIndex
        )
        const timestamp = Number.parseInt(timestampString)
        return timestamp > 0 && timestamp == timestampString
      }
      _isHttpsProtocol(req) {
        return req.protocol === 'https' || req.headers['x-forwarded-proto'] === 'https'
      }
    }
    module2.exports = new HstsHeaderMissingAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/cookie-analyzer.js
var require_cookie_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/cookie-analyzer.js'(exports2, module2) {
    'use strict'
    var Analyzer = require_vulnerability_analyzer()
    var { getNodeModulesPaths } = require_path_line()
    var EXCLUDED_PATHS = [
      // Express
      getNodeModulesPaths('express/lib/response.js'),
      // Fastify
      getNodeModulesPaths('fastify/lib/reply.js'),
      getNodeModulesPaths('fastify/lib/hooks.js'),
      getNodeModulesPaths('@fastify/cookie/plugin.js'),
    ]
    var CookieAnalyzer = class extends Analyzer {
      constructor(type, propertyToBeSafe) {
        super(type)
        this.propertyToBeSafe = propertyToBeSafe.toLowerCase()
      }
      onConfigure() {
        this.addSub({ channelName: 'datadog:iast:set-cookie', moduleName: 'http' }, (cookieInfo) =>
          this.analyze(cookieInfo)
        )
      }
      _isVulnerable({ cookieProperties, cookieValue }) {
        return (
          cookieValue &&
          !(cookieProperties && cookieProperties.map((x) => x.toLowerCase().trim()).includes(this.propertyToBeSafe))
        )
      }
      _getEvidence({ cookieName }) {
        return { value: cookieName }
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS
      }
      _checkOCE(context, value) {
        if (value && value.location) {
          return true
        }
        return super._checkOCE(context, value)
      }
      _getLocation(value, callSiteFrames) {
        if (!value) {
          return super._getLocation(value, callSiteFrames)
        }
        if (value.location) {
          return value.location
        }
        const location = super._getLocation(value, callSiteFrames)
        value.location = location
        return location
      }
    }
    module2.exports = CookieAnalyzer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/insecure-cookie-analyzer.js
var require_insecure_cookie_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/insecure-cookie-analyzer.js'(exports2, module2) {
    'use strict'
    var { INSECURE_COOKIE } = require_vulnerabilities()
    var CookieAnalyzer = require_cookie_analyzer()
    var InsecureCookieAnalyzer = class extends CookieAnalyzer {
      constructor() {
        super(INSECURE_COOKIE, 'secure')
      }
    }
    module2.exports = new InsecureCookieAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/ldap-injection-analyzer.js
var require_ldap_injection_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/ldap-injection-analyzer.js'(exports2, module2) {
    'use strict'
    var InjectionAnalyzer = require_injection_analyzer()
    var { LDAP_INJECTION } = require_vulnerabilities()
    var { getNodeModulesPaths } = require_path_line()
    var EXCLUDED_PATHS = getNodeModulesPaths('ldapjs-promise')
    var LdapInjectionAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(LDAP_INJECTION)
      }
      onConfigure() {
        this.addSub('datadog:ldapjs:client:search', ({ base, filter }) => this.analyzeAll(base, filter))
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS
      }
    }
    module2.exports = new LdapInjectionAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/no-httponly-cookie-analyzer.js
var require_no_httponly_cookie_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/no-httponly-cookie-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var { NO_HTTPONLY_COOKIE } = require_vulnerabilities()
    var CookieAnalyzer = require_cookie_analyzer()
    var NoHttponlyCookieAnalyzer = class extends CookieAnalyzer {
      constructor() {
        super(NO_HTTPONLY_COOKIE, 'HttpOnly')
      }
    }
    module2.exports = new NoHttponlyCookieAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/no-samesite-cookie-analyzer.js
var require_no_samesite_cookie_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/no-samesite-cookie-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var { NO_SAMESITE_COOKIE } = require_vulnerabilities()
    var CookieAnalyzer = require_cookie_analyzer()
    var NoSamesiteCookieAnalyzer = class extends CookieAnalyzer {
      constructor() {
        super(NO_SAMESITE_COOKIE, 'SameSite=strict')
      }
    }
    module2.exports = new NoSamesiteCookieAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/utils.js
var require_utils11 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/utils.js'(exports2, module2) {
    'use strict'
    function iterateObjectStrings(target, fn, levelKeys = [], depth = 20, visited = /* @__PURE__ */ new Set()) {
      if (target !== null && typeof target === 'object') {
        if (visited.has(target)) return
        visited.add(target)
        Object.keys(target).forEach((key) => {
          const nextLevelKeys = [...levelKeys, key]
          const val = target[key]
          if (typeof val === 'string') {
            fn(val, nextLevelKeys, target, key)
          } else if (depth > 0) {
            iterateObjectStrings(val, fn, nextLevelKeys, depth - 1, visited)
          }
        })
      }
    }
    module2.exports = {
      iterateObjectStrings,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/nosql-injection-mongodb-analyzer.js
var require_nosql_injection_mongodb_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/nosql-injection-mongodb-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var InjectionAnalyzer = require_injection_analyzer()
    var { NOSQL_MONGODB_INJECTION } = require_vulnerabilities()
    var { getRanges, addSecureMark } = require_operations()
    var { getNodeModulesPaths } = require_path_line()
    var { storage } = require_datadog_core()
    var { getIastContext } = require_iast_context()
    var { HTTP_REQUEST_PARAMETER, HTTP_REQUEST_BODY } = require_source_types()
    var EXCLUDED_PATHS_FROM_STACK = getNodeModulesPaths('mongodb', 'mongoose', 'mquery')
    var { NOSQL_MONGODB_INJECTION_MARK } = require_secure_marks()
    var { iterateObjectStrings } = require_utils11()
    var SAFE_OPERATORS = /* @__PURE__ */ new Set([
      '$eq',
      '$gt',
      '$gte',
      '$in',
      '$lt',
      '$lte',
      '$ne',
      '$nin',
      '$exists',
      '$type',
      '$mod',
      '$bitsAllClear',
      '$bitsAllSet',
      '$bitsAnyClear',
      '$bitsAnySet',
    ])
    var NosqlInjectionMongodbAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(NOSQL_MONGODB_INJECTION)
        this.sanitizedObjects = /* @__PURE__ */ new WeakSet()
      }
      onConfigure() {
        this.configureSanitizers()
        const onStart = ({ filters }) => {
          const store = storage('legacy').getStore()
          if (store && !store.nosqlAnalyzed && filters?.length) {
            filters.forEach((filter) => {
              this.analyze({ filter }, store)
            })
          }
          return store
        }
        const onStartAndEnterWithStore = (message) => {
          const store = onStart(message || {})
          if (store) {
            storage('legacy').enterWith({ ...store, nosqlAnalyzed: true, nosqlParentStore: store })
          }
        }
        const onFinish = () => {
          const store = storage('legacy').getStore()
          if (store?.nosqlParentStore) {
            storage('legacy').enterWith(store.nosqlParentStore)
          }
        }
        this.addSub('datadog:mongodb:collection:filter:start', onStart)
        this.addSub('datadog:mongoose:model:filter:start', onStartAndEnterWithStore)
        this.addSub('datadog:mongoose:model:filter:finish', onFinish)
        this.addSub('datadog:mquery:filter:prepare', onStart)
        this.addSub('tracing:datadog:mquery:filter:start', onStartAndEnterWithStore)
        this.addSub('tracing:datadog:mquery:filter:asyncEnd', onFinish)
      }
      configureSanitizers() {
        this.addNotSinkSub('datadog:express-mongo-sanitize:filter:finish', ({ sanitizedProperties, req }) => {
          const store = storage('legacy').getStore()
          const iastContext = getIastContext(store)
          if (iastContext) {
            sanitizedProperties.forEach((key) => {
              iterateObjectStrings(req[key], function (value, levelKeys) {
                if (typeof value === 'string') {
                  let parentObj = req[key]
                  const levelsLength = levelKeys.length
                  for (let i = 0; i < levelsLength; i++) {
                    const currentLevelKey = levelKeys[i]
                    if (i === levelsLength - 1) {
                      parentObj[currentLevelKey] = addSecureMark(iastContext, value, NOSQL_MONGODB_INJECTION_MARK)
                    } else {
                      parentObj = parentObj[currentLevelKey]
                    }
                  }
                }
              })
            })
          }
        })
        this.addNotSinkSub('datadog:express-mongo-sanitize:sanitize:finish', ({ sanitizedObject }) => {
          const store = storage('legacy').getStore()
          const iastContext = getIastContext(store)
          if (iastContext) {
            iterateObjectStrings(sanitizedObject, function (value, levelKeys, parent, lastKey) {
              try {
                parent[lastKey] = addSecureMark(iastContext, value, NOSQL_MONGODB_INJECTION_MARK)
              } catch {}
            })
          }
        })
        this.addNotSinkSub('datadog:mongoose:sanitize-filter:finish', ({ sanitizedObject }) => {
          this.sanitizedObjects.add(sanitizedObject)
        })
      }
      _isVulnerableRange(range, value) {
        const rangeIsWholeValue = range.start === 0 && range.end === value?.length
        if (!rangeIsWholeValue) return false
        const rangeType = range?.iinfo?.type
        return rangeType === HTTP_REQUEST_PARAMETER || rangeType === HTTP_REQUEST_BODY
      }
      _isVulnerable(value, iastContext) {
        if (value?.filter && iastContext) {
          let isVulnerable = false
          if (this.sanitizedObjects.has(value.filter)) {
            return false
          }
          const rangesByKey = {}
          const allRanges = []
          iterateMongodbQueryStrings(value.filter, (val, nextLevelKeys) => {
            let ranges = getRanges(iastContext, val)
            if (ranges?.length === 1) {
              ranges = this._filterSecureRanges(ranges)
              if (!ranges.length) {
                this._incrementSuppressedMetric(iastContext)
                return
              }
              const range = ranges[0]
              if (!this._isVulnerableRange(range, val)) {
                return
              }
              isVulnerable = true
              rangesByKey[nextLevelKeys.join('.')] = ranges
              allRanges.push(range)
            }
          })
          if (isVulnerable) {
            value.rangesToApply = rangesByKey
            value.ranges = allRanges
          }
          return isVulnerable
        }
        return false
      }
      _getEvidence(value, iastContext) {
        return { value: value.filter, rangesToApply: value.rangesToApply, ranges: value.ranges }
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS_FROM_STACK
      }
    }
    function iterateMongodbQueryStrings(target, fn, levelKeys = [], depth = 10, visited = /* @__PURE__ */ new Set()) {
      if (target !== null && typeof target === 'object') {
        if (visited.has(target)) return
        visited.add(target)
        Object.keys(target).forEach((key) => {
          if (SAFE_OPERATORS.has(key)) return
          const nextLevelKeys = [...levelKeys, key]
          const val = target[key]
          if (typeof val === 'string') {
            fn(val, nextLevelKeys, target, key)
          } else if (depth > 0) {
            iterateMongodbQueryStrings(val, fn, nextLevelKeys, depth - 1, visited)
          }
        })
      }
    }
    module2.exports = new NosqlInjectionMongodbAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/path-traversal-analyzer.js
var require_path_traversal_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/path-traversal-analyzer.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var InjectionAnalyzer = require_injection_analyzer()
    var { getIastContext } = require_iast_context()
    var { storage } = require_datadog_core()
    var { PATH_TRAVERSAL } = require_vulnerabilities()
    var ignoredOperations = /* @__PURE__ */ new Set(['dir.close', 'close'])
    var PathTraversalAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(PATH_TRAVERSAL)
        this.exclusionList = [path.join('node_modules', 'send') + path.sep]
        this.internalExclusionList = [
          'node:fs',
          'node:internal/fs',
          String.raw`node:internal\fs`,
          'fs.js',
          'internal/fs',
          String.raw`internal\fs`,
        ]
      }
      onConfigure() {
        this.addSub('apm:fs:operation:start', (obj) => {
          const store = storage('legacy').getStore()
          const outOfReqOrChild = !store?.fs?.root
          if (ignoredOperations.has(obj.operation) || outOfReqOrChild) return
          const pathArguments = []
          if (obj.dest) {
            pathArguments.push(obj.dest)
          }
          if (obj.existingPath) {
            pathArguments.push(obj.existingPath)
          }
          if (obj.file) {
            pathArguments.push(obj.file)
          }
          if (obj.newPath) {
            pathArguments.push(obj.newPath)
          }
          if (obj.oldPath) {
            pathArguments.push(obj.oldPath)
          }
          if (obj.path) {
            pathArguments.push(obj.path)
          }
          if (obj.prefix) {
            pathArguments.push(obj.prefix)
          }
          if (obj.src) {
            pathArguments.push(obj.src)
          }
          if (obj.target) {
            pathArguments.push(obj.target)
          }
          this.analyze(pathArguments)
        })
        this.addSub('tracing:datadog:express:response:render:start', (ctx) => {
          const store = storage('legacy').getStore()
          if (!store) return
          this.analyze([ctx.view])
        })
      }
      _isExcluded(location) {
        if (location?.path) {
          return location.isInternal
            ? this.internalExclusionList.some((elem) => location.path.includes(elem))
            : this.exclusionList.some((elem) => location.path.includes(elem))
        }
        return true
      }
      analyze(value) {
        const iastContext = getIastContext(storage('legacy').getStore())
        if (!iastContext) {
          return
        }
        if (value && value.constructor === Array) {
          for (const val of value) {
            if (this._isVulnerable(val, iastContext) && this._checkOCE(iastContext)) {
              this._report(val, iastContext)
              break
            }
          }
        }
      }
    }
    module2.exports = new PathTraversalAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/sql-injection-analyzer.js
var require_sql_injection_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/sql-injection-analyzer.js'(exports2, module2) {
    'use strict'
    var { SQL_INJECTION } = require_vulnerabilities()
    var { getRanges } = require_operations()
    var { storage } = require_datadog_core()
    var { getNodeModulesPaths } = require_path_line()
    var StoredInjectionAnalyzer = require_stored_injection_analyzer()
    var EXCLUDED_PATHS = getNodeModulesPaths('mysql', 'mysql2', 'sequelize', 'pg-pool', 'knex')
    var SqlInjectionAnalyzer = class extends StoredInjectionAnalyzer {
      constructor() {
        super(SQL_INJECTION)
      }
      onConfigure() {
        this.addSub('apm:mysql:query:start', ({ sql }) => this.analyze(sql, void 0, 'MYSQL'))
        this.addSub('datadog:mysql2:outerquery:start', ({ sql }) => this.analyze(sql, void 0, 'MYSQL'))
        this.addSub('apm:pg:query:start', ({ originalText, query }) =>
          this.analyze(originalText || query.text, void 0, 'POSTGRES')
        )
        this.addBind('datadog:sequelize:query:start', ({ sql, dialect }) =>
          this.getStoreAndAnalyze(sql, dialect.toUpperCase())
        )
        this.addSub('datadog:sequelize:query:finish', () => this.returnToParentStore())
        this.addBind('datadog:pg:pool:query:start', ({ query }) => this.getStoreAndAnalyze(query.text, 'POSTGRES'))
        this.addSub('datadog:pg:pool:query:finish', () => this.returnToParentStore())
        this.addSub('datadog:mysql:pool:query:start', ({ sql }) => this.setStoreAndAnalyze(sql, 'MYSQL'))
        this.addSub('datadog:mysql:pool:query:finish', () => this.returnToParentStore())
        this.addBind('datadog:knex:raw:start', (context) => {
          const { sql, dialect: knexDialect } = context
          const dialect = this.normalizeKnexDialect(knexDialect)
          const currentStore = this.getStoreAndAnalyze(sql, dialect)
          context.currentStore = currentStore
          return currentStore
        })
        this.addBind('datadog:knex:raw:subscribes', ({ currentStore }) => currentStore)
        this.addBind('datadog:knex:raw:finish', ({ currentStore }) => currentStore?.sqlParentStore)
      }
      setStoreAndAnalyze(query, dialect) {
        const store = this.getStoreAndAnalyze(query, dialect)
        if (store) {
          storage('legacy').enterWith(store)
        }
      }
      getStoreAndAnalyze(query, dialect) {
        const parentStore = storage('legacy').getStore()
        if (parentStore) {
          this.analyze(query, parentStore, dialect)
          return { ...parentStore, sqlAnalyzed: true, sqlParentStore: parentStore }
        }
      }
      returnToParentStore(store = storage('legacy').getStore()) {
        if (store && store.sqlParentStore) {
          storage('legacy').enterWith(store.sqlParentStore)
        }
      }
      _getEvidence(value, iastContext, dialect) {
        const ranges = getRanges(iastContext, value)
        return { value, ranges, dialect }
      }
      analyze(value, store, dialect) {
        store = store || storage('legacy').getStore()
        if (!(store && store.sqlAnalyzed)) {
          super.analyze(value, store, dialect)
        }
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS
      }
      normalizeKnexDialect(knexDialect) {
        if (knexDialect === 'postgresql') {
          return 'POSTGRES'
        }
        if (knexDialect === 'sqlite3') {
          return 'SQLITE'
        }
        if (typeof knexDialect === 'string') {
          return knexDialect.toUpperCase()
        }
      }
    }
    module2.exports = new SqlInjectionAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/ssrf-analyzer.js
var require_ssrf_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/ssrf-analyzer.js'(exports2, module2) {
    'use strict'
    var InjectionAnalyzer = require_injection_analyzer()
    var { SSRF } = require_vulnerabilities()
    var SSRFAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(SSRF)
      }
      onConfigure() {
        this.addSub('apm:http:client:request:start', ({ args }) => {
          if (typeof args.originalUrl === 'string') {
            this.analyze(args.originalUrl)
          } else if (args.options && args.options.host) {
            this.analyze(args.options.host)
          }
        })
        this.addSub('apm:http2:client:connect:start', ({ authority }) => {
          if (authority && typeof authority === 'string') {
            this.analyze(authority)
          }
        })
      }
      _isRangeSecure(range, value) {
        const fragmentIndex = value.indexOf('#')
        if (fragmentIndex !== -1 && range.start >= fragmentIndex) {
          return true
        }
        return super._isRangeSecure(range, value)
      }
    }
    module2.exports = new SSRFAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/template-injection-analyzer.js
var require_template_injection_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/template-injection-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var { TEMPLATE_INJECTION } = require_vulnerabilities()
    var StoredInjectionAnalyzer = require_stored_injection_analyzer()
    var TemplateInjectionAnalyzer = class extends StoredInjectionAnalyzer {
      constructor() {
        super(TEMPLATE_INJECTION)
      }
      onConfigure() {
        this.addSub('datadog:handlebars:compile:start', ({ source }) => this.analyze(source))
        this.addSub('datadog:handlebars:register-partial:start', ({ partial }) => this.analyze(partial))
        this.addSub('datadog:pug:compile:start', ({ source }) => this.analyze(source))
      }
    }
    module2.exports = new TemplateInjectionAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/unvalidated-redirect-analyzer.js
var require_unvalidated_redirect_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/unvalidated-redirect-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var InjectionAnalyzer = require_injection_analyzer()
    var { UNVALIDATED_REDIRECT } = require_vulnerabilities()
    var { getNodeModulesPaths } = require_path_line()
    var { getRanges } = require_operations()
    var { HTTP_REQUEST_BODY, HTTP_REQUEST_PARAMETER } = require_source_types()
    var EXCLUDED_PATHS = [getNodeModulesPaths('express/lib/response.js'), getNodeModulesPaths('fastify/lib/reply.js')]
    var VULNERABLE_SOURCE_TYPES = /* @__PURE__ */ new Set([HTTP_REQUEST_BODY, HTTP_REQUEST_PARAMETER])
    var UnvalidatedRedirectAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(UNVALIDATED_REDIRECT)
      }
      onConfigure() {
        this.addSub('datadog:http:server:response:set-header:finish', ({ name, value }) => this.analyze(name, value))
        this.addSub('datadog:fastify:set-header:finish', ({ name, value }) => this.analyze(name, value))
      }
      analyze(name, value) {
        if (!this.isLocationHeader(name) || typeof value !== 'string') return
        super.analyze(value)
      }
      isLocationHeader(name) {
        return name && name.trim().toLowerCase() === 'location'
      }
      _isVulnerable(value, iastContext) {
        if (!value) return false
        const ranges = getRanges(iastContext, value)
        return ranges?.length > 0 && this._hasUnsafeRange(ranges)
      }
      _hasUnsafeRange(ranges) {
        return ranges.some((range) => this._isVulnerableRange(range))
      }
      _isVulnerableRange(range) {
        return VULNERABLE_SOURCE_TYPES.has(range.iinfo.type)
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS
      }
    }
    module2.exports = new UnvalidatedRedirectAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/untrusted-deserialization-analyzer.js
var require_untrusted_deserialization_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/untrusted-deserialization-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var InjectionAnalyzer = require_injection_analyzer()
    var { UNTRUSTED_DESERIALIZATION } = require_vulnerabilities()
    var UntrustedDeserializationAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(UNTRUSTED_DESERIALIZATION)
      }
      onConfigure() {
        this.addSub('datadog:node-serialize:unserialize:start', ({ obj }) => this.analyze(obj))
      }
    }
    module2.exports = new UntrustedDeserializationAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-cipher-analyzer.js
var require_weak_cipher_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-cipher-analyzer.js'(exports2, module2) {
    'use strict'
    var Analyzer = require_vulnerability_analyzer()
    var { WEAK_CIPHER } = require_vulnerabilities()
    var INSECURE_CIPHERS = new Set(
      [
        'des',
        'des-cbc',
        'des-cfb',
        'des-cfb1',
        'des-cfb8',
        'des-ecb',
        'des-ede',
        'des-ede-cbc',
        'des-ede-cfb',
        'des-ede-ecb',
        'des-ede-ofb',
        'des-ede3',
        'des-ede3-cbc',
        'des-ede3-cfb',
        'des-ede3-cfb1',
        'des-ede3-cfb8',
        'des-ede3-ecb',
        'des-ede3-ofb',
        'des-ofb',
        'des3',
        'des3-wrap',
        'rc2',
        'rc2-128',
        'rc2-40',
        'rc2-40-cbc',
        'rc2-64',
        'rc2-64-cbc',
        'rc2-cbc',
        'rc2-cfb',
        'rc2-ecb',
        'rc2-ofb',
        'blowfish',
        'rc4',
        'rc4-40',
        'rc4-hmac-md5',
      ].map((algorithm) => algorithm.toLowerCase())
    )
    var WeakCipherAnalyzer = class extends Analyzer {
      constructor() {
        super(WEAK_CIPHER)
      }
      onConfigure() {
        this.addSub('datadog:crypto:cipher:start', ({ algorithm }) => this.analyze(algorithm))
      }
      _isVulnerable(algorithm) {
        if (algorithm && typeof algorithm === 'string') {
          return INSECURE_CIPHERS.has(algorithm.toLowerCase())
        }
        return false
      }
    }
    module2.exports = new WeakCipherAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-hash-analyzer.js
var require_weak_hash_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-hash-analyzer.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var { getNodeModulesPaths } = require_path_line()
    var Analyzer = require_vulnerability_analyzer()
    var { WEAK_HASH } = require_vulnerabilities()
    var INSECURE_HASH_ALGORITHMS = new Set(
      [
        'md4',
        'md4WithRSAEncryption',
        'RSA-MD4',
        'RSA-MD5',
        'md5',
        'md5-sha1',
        'ssl3-md5',
        'md5WithRSAEncryption',
        'RSA-SHA1',
        'RSA-SHA1-2',
        'sha1',
        'md5-sha1',
        'sha1WithRSAEncryption',
        'ssl3-sha1',
      ].map((algorithm) => algorithm.toLowerCase())
    )
    var EXCLUDED_LOCATIONS = getNodeModulesPaths(
      'etag/index.js',
      '@mikro-orm/core/utils/Utils.js',
      'mongodb/lib/core/connection/connection.js',
      'mysql2/lib/auth_41.js',
      'pusher/lib/utils.js',
      'redlock/dist/cjs',
      'sqreen/lib/package-reader/index.js',
      'ws/lib/websocket-server.js',
      'google-gax/build/src/grpc.js',
      'cookie-signature/index.js',
      'express-session/index.js'
    )
    var EXCLUDED_PATHS_FROM_STACK = [
      path.join('node_modules', 'object-hash', path.sep),
      path.join('node_modules', 'aws-sdk', 'lib', 'util.js'),
      path.join('node_modules', 'keygrip', path.sep),
    ]
    var WeakHashAnalyzer = class extends Analyzer {
      constructor() {
        super(WEAK_HASH)
      }
      onConfigure() {
        this.addSub('datadog:crypto:hashing:start', ({ algorithm }) => this.analyze(algorithm))
      }
      _isVulnerable(algorithm) {
        if (typeof algorithm === 'string') {
          return INSECURE_HASH_ALGORITHMS.has(algorithm.toLowerCase())
        }
        return false
      }
      _isExcluded(location) {
        if (!location) return false
        return EXCLUDED_LOCATIONS.some((excludedLocation) => {
          return location.path.includes(excludedLocation)
        })
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS_FROM_STACK
      }
    }
    module2.exports = new WeakHashAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-randomness-analyzer.js
var require_weak_randomness_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-randomness-analyzer.js'(exports2, module2) {
    'use strict'
    var Analyzer = require_vulnerability_analyzer()
    var { WEAK_RANDOMNESS } = require_vulnerabilities()
    var WeakRandomnessAnalyzer = class extends Analyzer {
      constructor() {
        super(WEAK_RANDOMNESS)
      }
      onConfigure() {
        this.addSub('datadog:random:call', ({ fn }) => this.analyze(fn))
      }
      _isVulnerable(fn) {
        return fn === Math.random
      }
    }
    module2.exports = new WeakRandomnessAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/xcontenttype-header-missing-analyzer.js
var require_xcontenttype_header_missing_analyzer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/xcontenttype-header-missing-analyzer.js'(
    exports2,
    module2
  ) {
    'use strict'
    var { XCONTENTTYPE_HEADER_MISSING } = require_vulnerabilities()
    var { MissingHeaderAnalyzer } = require_missing_header_analyzer()
    var XCONTENTTYPEOPTIONS_HEADER_NAME = 'X-Content-Type-Options'
    var XcontenttypeHeaderMissingAnalyzer = class extends MissingHeaderAnalyzer {
      constructor() {
        super(XCONTENTTYPE_HEADER_MISSING, XCONTENTTYPEOPTIONS_HEADER_NAME)
      }
      _isVulnerableFromRequestAndResponse(req, res, storedHeaders) {
        const headerValues = this._getHeaderValues(res, storedHeaders, XCONTENTTYPEOPTIONS_HEADER_NAME)
        return (
          headerValues.length === 0 ||
          headerValues.some((headerValue) => headerValue.trim().toLowerCase() !== 'nosniff')
        )
      }
    }
    module2.exports = new XcontenttypeHeaderMissingAnalyzer()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/analyzers.js
var require_analyzers = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/analyzers.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      CODE_INJECTION_ANALYZER: require_code_injection_analyzer(),
      COMMAND_INJECTION_ANALYZER: require_command_injection_analyzer(),
      HARCODED_PASSWORD_ANALYZER: require_hardcoded_password_analyzer2(),
      HARCODED_SECRET_ANALYZER: require_hardcoded_secret_analyzer(),
      HSTS_HEADER_MISSING_ANALYZER: require_hsts_header_missing_analyzer(),
      INSECURE_COOKIE_ANALYZER: require_insecure_cookie_analyzer(),
      LDAP_ANALYZER: require_ldap_injection_analyzer(),
      NO_HTTPONLY_COOKIE_ANALYZER: require_no_httponly_cookie_analyzer(),
      NO_SAMESITE_COOKIE_ANALYZER: require_no_samesite_cookie_analyzer(),
      NOSQL_MONGODB_INJECTION: require_nosql_injection_mongodb_analyzer(),
      PATH_TRAVERSAL_ANALYZER: require_path_traversal_analyzer(),
      SQL_INJECTION_ANALYZER: require_sql_injection_analyzer(),
      SSRF: require_ssrf_analyzer(),
      TEMPLATE_INJECTION_ANALYZER: require_template_injection_analyzer(),
      UNVALIDATED_REDIRECT_ANALYZER: require_unvalidated_redirect_analyzer(),
      UNTRUSTED_DESERIALIZATION_ANALYZER: require_untrusted_deserialization_analyzer(),
      WEAK_CIPHER_ANALYZER: require_weak_cipher_analyzer(),
      WEAK_HASH_ANALYZER: require_weak_hash_analyzer(),
      WEAK_RANDOMNESS_ANALYZER: require_weak_randomness_analyzer(),
      XCONTENTTYPE_HEADER_MISSING_ANALYZER: require_xcontenttype_header_missing_analyzer(),
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/set-cookies-header-interceptor.js
var require_set_cookies_header_interceptor = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/set-cookies-header-interceptor.js'(
    exports2,
    module2
  ) {
    'use strict'
    var Plugin = require_plugin()
    var { setCookieChannel } = require_channels2()
    var SetCookiesHeaderInterceptor = class extends Plugin {
      constructor() {
        super()
        this.cookiesInRequest = /* @__PURE__ */ new WeakMap()
        this.addSub('datadog:http:server:response:set-header:finish', ({ name, value, res }) =>
          this._handleCookies(name, value, res)
        )
        this.addSub('datadog:fastify:set-header:finish', ({ name, value, res }) =>
          this._handleCookies(name, value, res)
        )
      }
      _handleCookies(name, value, res) {
        if (name.toLowerCase() === 'set-cookie') {
          let allCookies = value
          if (typeof value === 'string') {
            allCookies = [value]
          }
          const alreadyCheckedCookies = this._getAlreadyCheckedCookiesInResponse(res)
          let location
          allCookies.forEach((cookieString) => {
            if (!alreadyCheckedCookies.includes(cookieString)) {
              alreadyCheckedCookies.push(cookieString)
              const parsedCookie = this._parseCookie(cookieString, location)
              setCookieChannel.publish(parsedCookie)
              location = parsedCookie.location
            }
          })
        }
      }
      _parseCookie(cookieString, location) {
        const cookieParts = cookieString.split(';')
        const nameValueParts = cookieParts[0].split('=')
        const cookieName = nameValueParts[0]
        const cookieValue = nameValueParts.slice(1).join('=')
        const cookieProperties = cookieParts.slice(1).map((part) => part.trim())
        return { cookieName, cookieValue, cookieProperties, cookieString, location }
      }
      _getAlreadyCheckedCookiesInResponse(res) {
        let alreadyCheckedCookies = this.cookiesInRequest.get(res)
        if (!alreadyCheckedCookies) {
          alreadyCheckedCookies = []
          this.cookiesInRequest.set(res, alreadyCheckedCookies)
        }
        return alreadyCheckedCookies
      }
    }
    module2.exports = new SetCookiesHeaderInterceptor()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/index.js
var require_analyzers2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/index.js'(exports2, module2) {
    'use strict'
    var analyzers = require_analyzers()
    var setCookiesHeaderInterceptor = require_set_cookies_header_interceptor()
    function enableAllAnalyzers(tracerConfig) {
      setCookiesHeaderInterceptor.configure({ enabled: true, tracerConfig })
      for (const analyzer in analyzers) {
        analyzers[analyzer].configure({ enabled: true, tracerConfig })
      }
    }
    function disableAllAnalyzers() {
      setCookiesHeaderInterceptor.configure(false)
      for (const analyzer in analyzers) {
        analyzers[analyzer].configure(false)
      }
    }
    module2.exports = {
      enableAllAnalyzers,
      disableAllAnalyzers,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/plugin.js
var require_plugin2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/plugin.js'(exports2, module2) {
    'use strict'
    var { SourceIastPlugin } = require_iast_plugin()
    var { getIastContext } = require_iast_context()
    var { storage } = require_datadog_core()
    var { taintObject, newTaintedString, getRanges, taintQueryWithCache } = require_operations()
    var {
      HTTP_REQUEST_BODY,
      HTTP_REQUEST_COOKIE_VALUE,
      HTTP_REQUEST_COOKIE_NAME,
      HTTP_REQUEST_HEADER_VALUE,
      HTTP_REQUEST_HEADER_NAME,
      HTTP_REQUEST_PARAMETER,
      HTTP_REQUEST_PATH_PARAM,
      HTTP_REQUEST_URI,
      SQL_ROW_VALUE,
    } = require_source_types()
    var { EXECUTED_SOURCE } = require_iast_metric()
    var REQ_HEADER_TAGS = EXECUTED_SOURCE.formatTags(HTTP_REQUEST_HEADER_VALUE, HTTP_REQUEST_HEADER_NAME)
    var REQ_URI_TAGS = EXECUTED_SOURCE.formatTags(HTTP_REQUEST_URI)
    var TaintTrackingPlugin = class extends SourceIastPlugin {
      constructor() {
        super()
        this._type = 'taint-tracking'
        this._taintedURLs = /* @__PURE__ */ new WeakMap()
      }
      configure(config) {
        super.configure(config)
        let rowsToTaint = this.iastConfig?.dbRowsToTaint
        if (typeof rowsToTaint !== 'number') {
          rowsToTaint = 1
        }
        this._rowsToTaint = rowsToTaint
      }
      onConfigure() {
        this.addBodyParsingSubscriptions()
        this.addQueryParameterSubscriptions()
        this.addCookieSubscriptions()
        this.addDatabaseSubscriptions()
        this.addPathParameterSubscriptions()
        this.addGraphQLSubscriptions()
        this.addURLParsingSubscriptions()
        this.addInstrumentedSource('http', [HTTP_REQUEST_HEADER_VALUE, HTTP_REQUEST_HEADER_NAME])
      }
      addBodyParsingSubscriptions() {
        const onRequestBody = ({ req }) => {
          const iastContext = getIastContext(storage('legacy').getStore())
          if (iastContext && iastContext.body !== req.body) {
            this._taintTrackingHandler(HTTP_REQUEST_BODY, req, 'body', iastContext)
            iastContext.body = req.body
          }
        }
        this.addSub({ channelName: 'datadog:body-parser:read:finish', tag: HTTP_REQUEST_BODY }, onRequestBody)
        this.addSub({ channelName: 'datadog:multer:read:finish', tag: HTTP_REQUEST_BODY }, onRequestBody)
        this.addSub({ channelName: 'datadog:fastify:body-parser:finish', tag: HTTP_REQUEST_BODY }, ({ body }) => {
          const iastContext = getIastContext(storage('legacy').getStore())
          if (iastContext && iastContext.body !== body) {
            this._taintTrackingHandler(HTTP_REQUEST_BODY, body)
            iastContext.body = body
          }
        })
        this.addSub({ channelName: 'apm:express:middleware:next', tag: HTTP_REQUEST_BODY }, ({ req }) => {
          if (req && req.body !== null && typeof req.body === 'object') {
            const iastContext = getIastContext(storage('legacy').getStore())
            if (iastContext && iastContext.body !== req.body) {
              this._taintTrackingHandler(HTTP_REQUEST_BODY, req, 'body', iastContext)
              iastContext.body = req.body
            }
          }
        })
      }
      addQueryParameterSubscriptions() {
        this.addSub({ channelName: 'datadog:query:read:finish', tag: HTTP_REQUEST_PARAMETER }, ({ query }) =>
          this._taintTrackingHandler(HTTP_REQUEST_PARAMETER, query)
        )
        this.addSub(
          { channelName: 'datadog:fastify:query-params:finish', tag: HTTP_REQUEST_PARAMETER },
          ({ query }) => {
            this._taintTrackingHandler(HTTP_REQUEST_PARAMETER, query)
          }
        )
        this.addSub({ channelName: 'datadog:express:query:finish', tag: HTTP_REQUEST_PARAMETER }, ({ query }) => {
          const iastContext = getIastContext(storage('legacy').getStore())
          if (!iastContext || !query) return
          taintQueryWithCache(iastContext, query)
        })
      }
      addCookieSubscriptions() {
        this.addSub(
          { channelName: 'datadog:cookie:parse:finish', tag: [HTTP_REQUEST_COOKIE_VALUE, HTTP_REQUEST_COOKIE_NAME] },
          ({ cookies }) => this._cookiesTaintTrackingHandler(cookies)
        )
        this.addSub(
          {
            channelName: 'datadog:fastify-cookie:read:finish',
            tag: [HTTP_REQUEST_COOKIE_VALUE, HTTP_REQUEST_COOKIE_NAME],
          },
          ({ cookies }) => this._cookiesTaintTrackingHandler(cookies)
        )
      }
      addDatabaseSubscriptions() {
        this.addSub({ channelName: 'datadog:sequelize:query:finish', tag: SQL_ROW_VALUE }, ({ result }) =>
          this._taintDatabaseResult(result, 'sequelize', getIastContext(storage('legacy').getStore()))
        )
        this.addSub({ channelName: 'apm:pg:query:finish', tag: SQL_ROW_VALUE }, ({ result, currentStore }) =>
          this._taintDatabaseResult(result, 'pg', getIastContext(currentStore))
        )
      }
      addPathParameterSubscriptions() {
        const pathParamHandler = ({ req }) => {
          if (req && req.params !== null && typeof req.params === 'object') {
            this._taintTrackingHandler(HTTP_REQUEST_PATH_PARAM, req, 'params')
          }
        }
        this.addSub(
          { channelName: 'datadog:express:process_params:start', tag: HTTP_REQUEST_PATH_PARAM },
          pathParamHandler
        )
        this.addSub({ channelName: 'datadog:router:param:start', tag: HTTP_REQUEST_PATH_PARAM }, pathParamHandler)
        this.addSub(
          { channelName: 'datadog:fastify:path-params:finish', tag: HTTP_REQUEST_PATH_PARAM },
          ({ req, params }) => {
            if (req) {
              this._taintTrackingHandler(HTTP_REQUEST_PATH_PARAM, params)
            }
          }
        )
      }
      addGraphQLSubscriptions() {
        this.addSub({ channelName: 'apm:graphql:resolve:start', tag: HTTP_REQUEST_BODY }, (data) => {
          const iastContext = getIastContext(storage('legacy').getStore())
          const source = data.rootCtx?.source
          const ranges = source && getRanges(iastContext, source)
          if (ranges?.length) {
            this._taintTrackingHandler(ranges[0].iinfo.type, data.args, null, iastContext)
          }
        })
      }
      addURLParsingSubscriptions() {
        const urlResultTaintedProperties = ['host', 'origin', 'hostname']
        this.addSub({ channelName: 'datadog:url:parse:finish' }, ({ input, base, parsed, isURL }) => {
          const iastContext = getIastContext(storage('legacy').getStore())
          const ranges = getRanges(iastContext, base || input)
          if (ranges?.length) {
            if (isURL) {
              this._taintedURLs.set(parsed, ranges[0])
            } else {
              urlResultTaintedProperties.forEach((param) => {
                this._taintTrackingHandler(ranges[0].iinfo.type, parsed, param, iastContext)
              })
            }
          }
        })
        this.addSub({ channelName: 'datadog:url:getter:finish' }, (context) => {
          if (!urlResultTaintedProperties.includes(context.property)) return
          const origRange = this._taintedURLs.get(context.urlObject)
          if (!origRange) return
          const iastContext = getIastContext(storage('legacy').getStore())
          if (!iastContext) return
          context.result = newTaintedString(
            iastContext,
            context.result,
            origRange.iinfo.parameterName,
            origRange.iinfo.type
          )
        })
      }
      _taintTrackingHandler(type, target, property, iastContext = getIastContext(storage('legacy').getStore())) {
        if (!property) {
          taintObject(iastContext, target, type)
        } else if (target[property]) {
          target[property] = taintObject(iastContext, target[property], type)
        }
      }
      _cookiesTaintTrackingHandler(target) {
        const iastContext = getIastContext(storage('legacy').getStore())
        taintObject(iastContext, target, HTTP_REQUEST_COOKIE_VALUE)
      }
      taintHeaders(headers, iastContext) {
        this.execSource({
          handler: () => taintObject(iastContext, headers, HTTP_REQUEST_HEADER_VALUE),
          tags: REQ_HEADER_TAGS,
          iastContext,
        })
      }
      taintUrl(req, iastContext) {
        this.execSource({
          handler: function () {
            req.url = newTaintedString(iastContext, req.url, HTTP_REQUEST_URI, HTTP_REQUEST_URI)
          },
          tags: REQ_URI_TAGS,
          iastContext,
        })
      }
      taintRequest(req, iastContext) {
        this.taintHeaders(req.headers, iastContext)
        this.taintUrl(req, iastContext)
      }
      _taintDatabaseResult(result, dbOrigin, iastContext, name) {
        if (!iastContext) return result
        if (this._rowsToTaint === 0) return result
        if (Array.isArray(result)) {
          for (let i = 0; i < result.length && i < this._rowsToTaint; i++) {
            const nextName = name ? `${name}.${i}` : String(i)
            result[i] = this._taintDatabaseResult(result[i], dbOrigin, iastContext, nextName)
          }
        } else if (result && typeof result === 'object') {
          if (dbOrigin === 'sequelize' && result.dataValues) {
            result.dataValues = this._taintDatabaseResult(result.dataValues, dbOrigin, iastContext, name)
          } else {
            for (const key in result) {
              const nextName = name ? `${name}.${key}` : key
              result[key] = this._taintDatabaseResult(result[key], dbOrigin, iastContext, nextName)
            }
          }
        } else if (typeof result === 'string') {
          result = newTaintedString(iastContext, result, name, SQL_ROW_VALUE)
        }
        return result
      }
    }
    module2.exports = new TaintTrackingPlugin()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/plugins/kafka.js
var require_kafka = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/plugins/kafka.js'(exports2, module2) {
    'use strict'
    var shimmer = require_datadog_shimmer()
    var { getIastContext } = require_iast_context()
    var { KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE } = require_source_types()
    var { newTaintedObject, newTaintedString } = require_operations()
    var { SourceIastPlugin } = require_iast_plugin()
    var KafkaConsumerIastPlugin = class extends SourceIastPlugin {
      onConfigure() {
        this.addSub(
          { channelName: 'dd-trace:kafkajs:consumer:afterStart', tag: [KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE] },
          ({ message, currentStore }) => this.taintKafkaMessage(message, currentStore)
        )
      }
      getToStringWrap(toString, iastContext, type) {
        return function () {
          const res = toString.apply(this, arguments)
          return newTaintedString(iastContext, res, void 0, type)
        }
      }
      taintKafkaMessage(message, currentStore) {
        const iastContext = getIastContext(currentStore)
        if (iastContext && message) {
          const { key, value } = message
          if (key !== null && typeof key === 'object') {
            shimmer.wrap(key, 'toString', (toString) => this.getToStringWrap(toString, iastContext, KAFKA_MESSAGE_KEY))
            newTaintedObject(iastContext, key, void 0, KAFKA_MESSAGE_KEY)
          }
          if (value !== null && typeof value === 'object') {
            shimmer.wrap(value, 'toString', (toString) =>
              this.getToStringWrap(toString, iastContext, KAFKA_MESSAGE_VALUE)
            )
            newTaintedObject(iastContext, value, void 0, KAFKA_MESSAGE_VALUE)
          }
        }
      }
    }
    module2.exports = new KafkaConsumerIastPlugin()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/context/context-plugin.js
var require_context_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/context/context-plugin.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var iastContextFunctions = require_iast_context()
    var overheadController = require_overhead_controller()
    var { IastPlugin } = require_iast_plugin()
    var { IAST_ENABLED_TAG_KEY } = require_tags4()
    var { createTransaction, removeTransaction } = require_operations()
    var vulnerabilityReporter = require_vulnerability_reporter()
    var { TagKey } = require_iast_metric()
    var IastContextPlugin = class extends IastPlugin {
      startCtxOn(channelName, tag) {
        super.addSub(channelName, (message) => this.startContext(message?.currentStore))
        this._getAndRegisterSubscription({
          channelName,
          tag,
          tagKey: TagKey.SOURCE_TYPE,
        })
      }
      finishCtxOn(channelName) {
        super.addSub(channelName, (message) => this.finishContext())
      }
      getRootSpan(store) {
        return store?.span
      }
      getTopContext() {
        return {}
      }
      newIastContext(rootSpan) {
        return { rootSpan }
      }
      addIastEnabledTag(isRequestAcquired, rootSpan) {
        if (rootSpan?.addTags) {
          rootSpan.addTags({
            [IAST_ENABLED_TAG_KEY]: isRequestAcquired ? 1 : 0,
          })
        }
      }
      startContext(store = storage('legacy').getStore()) {
        let isRequestAcquired = false
        let iastContext
        if (store) {
          const topContext = this.getTopContext()
          const rootSpan = this.getRootSpan(store)
          isRequestAcquired = overheadController.acquireRequest(rootSpan)
          if (isRequestAcquired) {
            iastContext = iastContextFunctions.saveIastContext(store, topContext, this.newIastContext(rootSpan))
            createTransaction(rootSpan.context().toSpanId(), iastContext)
            overheadController.initializeRequestContext(iastContext)
          }
          this.addIastEnabledTag(isRequestAcquired, rootSpan)
        }
        return {
          isRequestAcquired,
          iastContext,
          store,
        }
      }
      finishContext() {
        const store = storage('legacy').getStore()
        if (store) {
          const topContext = this.getTopContext()
          const iastContext = iastContextFunctions.getIastContext(store, topContext)
          const rootSpan = iastContext?.rootSpan
          if (iastContext && rootSpan) {
            vulnerabilityReporter.sendVulnerabilities(iastContext.vulnerabilities, rootSpan)
            removeTransaction(iastContext)
          }
          if (iastContextFunctions.cleanIastContext(store, topContext, iastContext)) {
            overheadController.releaseRequest()
          }
        }
      }
    }
    module2.exports = IastContextPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/context/kafka-ctx-plugin.js
var require_kafka_ctx_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/context/kafka-ctx-plugin.js'(exports2, module2) {
    'use strict'
    var { KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE } = require_source_types()
    var IastContextPlugin = require_context_plugin()
    var KafkaContextPlugin = class extends IastContextPlugin {
      onConfigure() {
        this.startCtxOn('dd-trace:kafkajs:consumer:afterStart', [KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE])
        this.finishCtxOn('dd-trace:kafkajs:consumer:beforeFinish')
      }
    }
    module2.exports = new KafkaContextPlugin()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/index.js
var require_taint_tracking = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/index.js'(exports2, module2) {
    'use strict'
    var { createTransaction, removeTransaction, setMaxTransactions, enableTaintOperations, disableTaintOperations } =
      require_operations()
    var taintTrackingPlugin = require_plugin2()
    var kafkaConsumerPlugin = require_kafka()
    var kafkaContextPlugin = require_kafka_ctx_plugin()
    module2.exports = {
      enableTaintTracking(config, telemetryVerbosity) {
        enableTaintOperations(telemetryVerbosity)
        taintTrackingPlugin.enable(config)
        kafkaContextPlugin.enable(config)
        kafkaConsumerPlugin.enable(config)
        setMaxTransactions(config.maxConcurrentRequests)
      },
      disableTaintTracking() {
        disableTaintOperations()
        taintTrackingPlugin.disable()
        kafkaContextPlugin.disable()
        kafkaConsumerPlugin.disable()
      },
      setMaxTransactions,
      createTransaction,
      removeTransaction,
      taintTrackingPlugin,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/security-controls/parser.js
var require_parser = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/security-controls/parser.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var { getMarkFromVulnerabilityType, CUSTOM_SECURE_MARK } = require_secure_marks()
    var SECURITY_CONTROL_DELIMITER = ';'
    var SECURITY_CONTROL_FIELD_DELIMITER = ':'
    var SECURITY_CONTROL_ELEMENT_DELIMITER = ','
    var INPUT_VALIDATOR_TYPE = 'INPUT_VALIDATOR'
    var SANITIZER_TYPE = 'SANITIZER'
    var validTypes = /* @__PURE__ */ new Set([INPUT_VALIDATOR_TYPE, SANITIZER_TYPE])
    function parse(securityControlsConfiguration) {
      const controls = /* @__PURE__ */ new Map()
      securityControlsConfiguration
        ?.replaceAll(/[\r\n\t\v\f]*/g, '')
        .split(SECURITY_CONTROL_DELIMITER)
        .map(parseControl)
        .filter((control) => !!control)
        .forEach((control) => {
          if (!controls.has(control.file)) {
            controls.set(control.file, [])
          }
          controls.get(control.file).push(control)
        })
      return controls
    }
    function parseControl(control) {
      if (!control) return
      const fields = control.split(SECURITY_CONTROL_FIELD_DELIMITER)
      if (fields.length < 3 || fields.length > 5) {
        log.warn('[ASM] Security control configuration is invalid: %s', control)
        return
      }
      let [type, marks, file, method, parameters] = fields
      type = type.trim().toUpperCase()
      if (!validTypes.has(type)) {
        log.warn('[ASM] Invalid security control type: %s', type)
        return
      }
      let secureMarks = CUSTOM_SECURE_MARK
      getSecureMarks(marks).forEach((mark) => {
        secureMarks |= mark
      })
      if (secureMarks === CUSTOM_SECURE_MARK) {
        log.warn('[ASM] Invalid security control mark: %s', marks)
        return
      }
      file = file?.trim()
      method = method?.trim()
      try {
        parameters = getParameters(parameters)
      } catch {
        log.warn('[ASM] Invalid non-numeric security control parameter %s', parameters)
        return
      }
      return { type, secureMarks, file, method, parameters }
    }
    function getSecureMarks(marks) {
      return marks
        ?.split(SECURITY_CONTROL_ELEMENT_DELIMITER)
        .map(getMarkFromVulnerabilityType)
        .filter((mark) => !!mark)
    }
    function getParameters(parameters) {
      return parameters?.split(SECURITY_CONTROL_ELEMENT_DELIMITER).map((param) => {
        const parsedParam = Number.parseInt(param, 10)
        if (Number.isNaN(parsedParam)) {
          throw new TypeError('Invalid non-numeric security control parameter')
        }
        return parsedParam
      })
    }
    module2.exports = {
      parse,
      INPUT_VALIDATOR_TYPE,
      SANITIZER_TYPE,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/security-controls/index.js
var require_security_controls = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/security-controls/index.js'(exports2, module2) {
    'use strict'
    var path = require('path')
    var dc = require_dc_polyfill()
    var { storage } = require_datadog_core()
    var shimmer = require_datadog_shimmer()
    var log = require_log2()
    var { parse, SANITIZER_TYPE } = require_parser()
    var TaintTrackingOperations = require_operations()
    var { getIastContext } = require_iast_context()
    var { iterateObjectStrings } = require_utils11()
    var moduleLoadStartChannel = dc.channel('dd-trace:moduleLoadStart')
    var moduleLoadEndChannel = dc.channel('dd-trace:moduleLoadEnd')
    var controls
    var controlsKeys
    var hooks
    function configure(iastConfig) {
      if (!iastConfig?.securityControlsConfiguration) return
      try {
        controls = parse(iastConfig.securityControlsConfiguration)
        if (controls?.size > 0) {
          hooks = /* @__PURE__ */ new WeakSet()
          controlsKeys = [...controls.keys()]
          moduleLoadStartChannel.subscribe(onModuleLoaded)
          moduleLoadEndChannel.subscribe(onModuleLoaded)
        }
      } catch (e) {
        log.error('[ASM] Error configuring IAST Security Controls', e)
      }
    }
    function onModuleLoaded(payload) {
      if (!payload?.module || hooks?.has(payload.module)) return
      const { filename, module: module3 } = payload
      const controlsByFile = getControls(filename)
      if (controlsByFile) {
        const hook = hookModule(filename, module3, controlsByFile)
        payload.module = hook
        hooks.add(hook)
      }
    }
    function getControls(filename) {
      if (filename.startsWith('file://')) {
        filename = filename.slice(7)
      }
      let key = path.isAbsolute(filename) ? path.relative(process.cwd(), filename) : filename
      key = key.replaceAll(path.sep, path.posix.sep)
      if (key.includes('node_modules')) {
        key = controlsKeys.find((file) => key.endsWith(file))
      }
      return controls.get(key)
    }
    function hookModule(filename, module3, controlsByFile) {
      try {
        controlsByFile.forEach(({ type, method, parameters, secureMarks }) => {
          const { target, parent, methodName } = resolve(method, module3)
          if (!target) {
            log.error('[ASM] Unable to resolve IAST security control %s:%s', filename, method)
            return
          }
          const wrapper =
            type === SANITIZER_TYPE
              ? wrapSanitizer(target, secureMarks)
              : wrapInputValidator(target, parameters, secureMarks)
          if (methodName) {
            parent[methodName] = wrapper
          } else {
            module3 = wrapper
          }
        })
      } catch (e) {
        log.error('[ASM] Error initializing IAST security control for %s', filename, e)
      }
      return module3
    }
    function resolve(path2, obj, separator = '.') {
      if (!path2) {
        return obj?.default ? { target: obj.default, parent: obj, methodName: 'default' } : { target: obj, parent: obj }
      }
      const properties = path2.split(separator)
      let parent
      let methodName
      const target = properties.reduce((prev, curr) => {
        parent = prev
        methodName = curr
        return prev?.[curr]
      }, obj)
      return { target, parent, methodName }
    }
    function wrapSanitizer(target, secureMarks) {
      return shimmer.wrapFunction(
        target,
        (orig) =>
          function () {
            const result = orig.apply(this, arguments)
            try {
              return addSecureMarks(result, secureMarks)
            } catch (e) {
              log.error('[ASM] Error adding Secure mark for sanitizer', e)
            }
            return result
          }
      )
    }
    function wrapInputValidator(target, parameters, secureMarks) {
      const allParameters = !parameters?.length
      return shimmer.wrapFunction(
        target,
        (orig) =>
          function () {
            try {
              ;[...arguments].forEach((arg, index) => {
                if (allParameters || parameters.includes(index)) {
                  addSecureMarks(arg, secureMarks, false)
                }
              })
            } catch (e) {
              log.error('[ASM] Error adding Secure mark for input validator', e)
            }
            return orig.apply(this, arguments)
          }
      )
    }
    function addSecureMarks(value, secureMarks, createNewTainted = true) {
      if (!value) return
      const store = storage('legacy').getStore()
      const iastContext = getIastContext(store)
      if (typeof value === 'string') {
        return TaintTrackingOperations.addSecureMark(iastContext, value, secureMarks, createNewTainted)
      }
      iterateObjectStrings(value, (value2, levelKeys, parent, lastKey) => {
        try {
          const securedTainted = TaintTrackingOperations.addSecureMark(
            iastContext,
            value2,
            secureMarks,
            createNewTainted
          )
          if (createNewTainted) {
            parent[lastKey] = securedTainted
          }
        } catch {}
      })
      return value
    }
    function disable() {
      if (moduleLoadStartChannel.hasSubscribers) moduleLoadStartChannel.unsubscribe(onModuleLoaded)
      if (moduleLoadEndChannel.hasSubscribers) moduleLoadEndChannel.unsubscribe(onModuleLoaded)
      controls = void 0
      controlsKeys = void 0
      hooks = void 0
    }
    module2.exports = {
      configure,
      disable,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/index.js
var require_iast = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/iast/index.js'(exports2, module2) {
    'use strict'
    var vulnerabilityReporter = require_vulnerability_reporter()
    var { enableAllAnalyzers, disableAllAnalyzers } = require_analyzers2()
    var web = require_web3()
    var { storage } = require_datadog_core()
    var overheadController = require_overhead_controller()
    var dc = require_dc_polyfill()
    var iastContextFunctions = require_iast_context()
    var { enableTaintTracking, disableTaintTracking, createTransaction, removeTransaction, taintTrackingPlugin } =
      require_taint_tracking()
    var { IAST_ENABLED_TAG_KEY } = require_tags4()
    var iastTelemetry = require_telemetry7()
    var { enable: enableFsPlugin, disable: disableFsPlugin, IAST_MODULE } = require_fs_plugin()
    var securityControls = require_security_controls()
    var { incomingHttpRequestStart, incomingHttpRequestEnd, responseWriteHead } = require_channels2()
    var collectedResponseHeaders = /* @__PURE__ */ new WeakMap()
    var iastResponseEnd = dc.channel('datadog:iast:response-end')
    var isEnabled = false
    function enable(config, _tracer) {
      if (isEnabled) return
      iastTelemetry.configure(config, config.iast?.telemetryVerbosity)
      enableFsPlugin(IAST_MODULE)
      enableAllAnalyzers(config)
      enableTaintTracking(config.iast, iastTelemetry.verbosity)
      incomingHttpRequestStart.subscribe(onIncomingHttpRequestStart)
      incomingHttpRequestEnd.subscribe(onIncomingHttpRequestEnd)
      responseWriteHead.subscribe(onResponseWriteHeadCollect)
      overheadController.configure(config.iast)
      overheadController.startGlobalContext()
      securityControls.configure(config.iast)
      vulnerabilityReporter.start(config, _tracer)
      isEnabled = true
    }
    function disable() {
      if (!isEnabled) return
      isEnabled = false
      iastTelemetry.stop()
      disableFsPlugin(IAST_MODULE)
      disableAllAnalyzers()
      disableTaintTracking()
      overheadController.finishGlobalContext()
      if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(onIncomingHttpRequestStart)
      if (incomingHttpRequestEnd.hasSubscribers) incomingHttpRequestEnd.unsubscribe(onIncomingHttpRequestEnd)
      if (responseWriteHead.hasSubscribers) responseWriteHead.unsubscribe(onResponseWriteHeadCollect)
      vulnerabilityReporter.stop()
    }
    function onIncomingHttpRequestStart(data) {
      if (data?.req) {
        const store = storage('legacy').getStore()
        if (store) {
          const topContext = web.getContext(data.req)
          if (topContext) {
            const rootSpan = topContext.span
            const isRequestAcquired = overheadController.acquireRequest(rootSpan)
            if (isRequestAcquired) {
              const iastContext = iastContextFunctions.saveIastContext(store, topContext, { rootSpan, req: data.req })
              createTransaction(rootSpan.context().toSpanId(), iastContext)
              overheadController.initializeRequestContext(iastContext)
              iastTelemetry.onRequestStart(iastContext)
              taintTrackingPlugin.taintRequest(data.req, iastContext)
            }
            if (rootSpan.addTags) {
              rootSpan.addTags({
                [IAST_ENABLED_TAG_KEY]: isRequestAcquired ? 1 : 0,
              })
            }
          }
        }
      }
    }
    function onIncomingHttpRequestEnd(data) {
      if (data?.req) {
        const store = storage('legacy').getStore()
        const topContext = web.getContext(data.req)
        const iastContext = iastContextFunctions.getIastContext(store, topContext)
        if (iastContext?.rootSpan) {
          const storedHeaders = collectedResponseHeaders.get(data.res) || {}
          iastResponseEnd.publish({ ...data, storedHeaders })
          if (Object.keys(storedHeaders).length) {
            collectedResponseHeaders.delete(data.res)
          }
          const vulnerabilities = iastContext.vulnerabilities
          const rootSpan = iastContext.rootSpan
          vulnerabilityReporter.sendVulnerabilities(vulnerabilities, rootSpan)
          overheadController.consolidateVulnerabilities(iastContext)
          removeTransaction(iastContext)
          iastTelemetry.onRequestEnd(iastContext, iastContext.rootSpan)
        }
        if (iastContextFunctions.cleanIastContext(store, topContext, iastContext)) {
          overheadController.releaseRequest()
        }
      }
    }
    function onResponseWriteHeadCollect({ res, responseHeaders = {} }) {
      if (!res) return
      if (Object.keys(responseHeaders).length) {
        collectedResponseHeaders.set(res, responseHeaders)
      }
    }
    module2.exports = { enable, disable, onIncomingHttpRequestEnd, onIncomingHttpRequestStart }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/constants/text.js
var require_text = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/constants/text.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      DROPPED_VALUE_TEXT: "[This value has been dropped because this span's size exceeds the 1MB size limit.]",
      UNSERIALIZABLE_VALUE_TEXT: 'Unserializable value',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/span_processor.js
var require_span_processor3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/span_processor.js'(exports2, module2) {
    'use strict'
    var {
      SPAN_KIND,
      MODEL_NAME,
      MODEL_PROVIDER,
      METADATA,
      INPUT_MESSAGES,
      INPUT_VALUE,
      INTEGRATION,
      OUTPUT_MESSAGES,
      INPUT_DOCUMENTS,
      OUTPUT_DOCUMENTS,
      OUTPUT_VALUE,
      METRICS,
      ML_APP,
      TAGS,
      PARENT_ID_KEY,
      SESSION_ID,
      NAME,
    } = require_tags3()
    var { UNSERIALIZABLE_VALUE_TEXT } = require_text()
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants2()
    var telemetry = require_telemetry4()
    var LLMObsTagger = require_tagger2()
    var tracerVersion = require_package().version
    var logger = require_log2()
    var util = require('node:util')
    var LLMObservabilitySpan = class {
      constructor() {
        this.input = []
        this.output = []
        this._tags = {}
      }
      getTag(key) {
        return this._tags[key]
      }
    }
    var LLMObsSpanProcessor = class {
      /** @type {import('../config')} */
      #config
      /** @type {((span: LLMObservabilitySpan) => LLMObservabilitySpan | null) | null} */
      #userSpanProcessor
      /** @type {import('./writers/spans')} */
      #writer
      constructor(config) {
        this.#config = config
      }
      setUserSpanProcessor(userSpanProcessor) {
        this.#userSpanProcessor = userSpanProcessor
      }
      setWriter(writer) {
        this.#writer = writer
      }
      // TODO: instead of relying on the tagger's weakmap registry, can we use some namespaced storage correlation?
      process(span) {
        if (!this.#config.llmobs.enabled) return
        if (!LLMObsTagger.tagMap.has(span)) return
        try {
          const formattedEvent = this.format(span)
          telemetry.incrementLLMObsSpanFinishedCount(span)
          if (formattedEvent == null) return
          this.#writer.append(formattedEvent)
        } catch (e) {
          logger.warn(`
        Failed to append span to LLM Observability writer, likely due to an unserializable property.
        Span won't be sent to LLM Observability: ${e.message}
      `)
        }
      }
      format(span) {
        const llmObsSpan = new LLMObservabilitySpan()
        let inputType, outputType
        const spanTags = span.context()._tags
        const mlObsTags = LLMObsTagger.tagMap.get(span)
        const spanKind = mlObsTags[SPAN_KIND]
        const meta = { 'span.kind': spanKind, input: {}, output: {} }
        const input = {}
        const output = {}
        if (['llm', 'embedding'].includes(spanKind)) {
          meta.model_name = mlObsTags[MODEL_NAME] || 'custom'
          meta.model_provider = (mlObsTags[MODEL_PROVIDER] || 'custom').toLowerCase()
        }
        if (mlObsTags[METADATA]) {
          this.#addObject(mlObsTags[METADATA], (meta.metadata = {}))
        }
        if (spanKind === 'llm' && mlObsTags[INPUT_MESSAGES]) {
          llmObsSpan.input = mlObsTags[INPUT_MESSAGES]
          inputType = 'messages'
        } else if (spanKind === 'embedding' && mlObsTags[INPUT_DOCUMENTS]) {
          input.documents = mlObsTags[INPUT_DOCUMENTS]
        } else if (mlObsTags[INPUT_VALUE]) {
          llmObsSpan.input = [{ role: '', content: mlObsTags[INPUT_VALUE] }]
          inputType = 'value'
        }
        if (mlObsTags['_ml_obs.meta.input.prompt']) {
          input.prompt = mlObsTags['_ml_obs.meta.input.prompt']
        }
        if (spanKind === 'llm' && mlObsTags[OUTPUT_MESSAGES]) {
          llmObsSpan.output = mlObsTags[OUTPUT_MESSAGES]
          outputType = 'messages'
        } else if (spanKind === 'retrieval' && mlObsTags[OUTPUT_DOCUMENTS]) {
          output.documents = mlObsTags[OUTPUT_DOCUMENTS]
        } else if (mlObsTags[OUTPUT_VALUE]) {
          llmObsSpan.output = [{ role: '', content: mlObsTags[OUTPUT_VALUE] }]
          outputType = 'value'
        }
        const error = spanTags.error || spanTags[ERROR_TYPE]
        if (error) {
          meta[ERROR_MESSAGE] = spanTags[ERROR_MESSAGE] || error.message || error.code
          meta[ERROR_TYPE] = spanTags[ERROR_TYPE] || error.name
          meta[ERROR_STACK] = spanTags[ERROR_STACK] || error.stack
        }
        const metrics = mlObsTags[METRICS] || {}
        const mlApp = mlObsTags[ML_APP]
        const sessionId = mlObsTags[SESSION_ID]
        const parentId = mlObsTags[PARENT_ID_KEY]
        const name = mlObsTags[NAME] || span._name
        const tags = this.#getTags(span, mlApp, sessionId, error)
        llmObsSpan._tags = tags
        const processedSpan = this.#runProcessor(llmObsSpan)
        if (processedSpan === void 0) return null
        if (processedSpan.input) {
          if (inputType === 'messages') {
            input.messages = processedSpan.input
          } else if (inputType === 'value') {
            input.value = processedSpan.input[0].content
          }
        }
        if (processedSpan.output) {
          if (outputType === 'messages') {
            output.messages = processedSpan.output
          } else if (outputType === 'value') {
            output.value = processedSpan.output[0].content
          }
        }
        if (input) meta.input = input
        if (output) meta.output = output
        const llmObsSpanEvent = {
          trace_id: span.context().toTraceId(true),
          span_id: span.context().toSpanId(),
          parent_id: parentId,
          name,
          tags: this.#objectTagsToStringArrayTags(tags),
          start_ns: Math.round(span._startTime * 1e6),
          duration: Math.round(span._duration * 1e6),
          status: error ? 'error' : 'ok',
          meta,
          metrics,
          _dd: {
            span_id: span.context().toSpanId(),
            trace_id: span.context().toTraceId(true),
          },
        }
        if (sessionId) llmObsSpanEvent.session_id = sessionId
        return llmObsSpanEvent
      }
      // For now, this only applies to metadata, as we let users annotate this field with any object
      // However, we want to protect against circular references or BigInts (unserializable)
      // This function can be reused for other fields if needed
      // Messages, Documents, and Metrics are safeguarded in `llmobs/tagger.js`
      #addObject(obj, carrier) {
        const seenObjects = new WeakSet([obj])
        const isCircular = (value) => {
          if (value == null || typeof value !== 'object') return false
          if (seenObjects.has(value)) return true
          seenObjects.add(value)
          return false
        }
        const add = (obj2, carrier2) => {
          for (const key in obj2) {
            const value = obj2[key]
            if (!Object.hasOwn(obj2, key)) continue
            if (typeof value === 'bigint' || isCircular(value)) {
              logger.warn(`Unserializable property found in metadata: ${key}`)
              carrier2[key] = UNSERIALIZABLE_VALUE_TEXT
              continue
            }
            if (value !== null && typeof value === 'object') {
              carrier2[key] = Array.isArray(value) ? [] : {}
              add(value, carrier2[key])
            } else {
              carrier2[key] = value
            }
          }
        }
        add(obj, carrier)
      }
      #getTags(span, mlApp, sessionId, error) {
        let tags = {
          ...this.#config.parsedDdTags,
          version: this.#config.version,
          env: this.#config.env,
          service: this.#config.service,
          source: 'integration',
          ml_app: mlApp,
          'ddtrace.version': tracerVersion,
          error: Number(!!error) || 0,
          language: 'javascript',
        }
        const errType = span.context()._tags[ERROR_TYPE] || error?.name
        if (errType) tags.error_type = errType
        if (sessionId) tags.session_id = sessionId
        const integration = LLMObsTagger.tagMap.get(span)?.[INTEGRATION]
        if (integration) tags.integration = integration
        const existingTags = LLMObsTagger.tagMap.get(span)?.[TAGS] || {}
        if (existingTags) tags = { ...tags, ...existingTags }
        return tags
      }
      #objectTagsToStringArrayTags(tags) {
        return Object.entries(tags).map(([key, value]) => `${key}:${value ?? ''}`)
      }
      /**
       * Runs the user span processor, emitting telemetry and adding some guardrails against invalid return types
       * @param {LLMObservabilitySpan} span
       * @returns {LLMObservabilitySpan | undefined}
       */
      #runProcessor(span) {
        const processor = this.#userSpanProcessor
        if (!processor) return span
        let error = false
        try {
          const processedLLMObsSpan = processor(span)
          if (processedLLMObsSpan === null) return
          if (!(processedLLMObsSpan instanceof LLMObservabilitySpan)) {
            error = true
            logger.warn(
              'User span processor must return an instance of an LLMObservabilitySpan or null, dropping span.'
            )
            return
          }
          return processedLLMObsSpan
        } catch (e) {
          logger.error(`[LLMObs] Error in LLMObs span processor (${util.inspect(processor)}): ${util.inspect(e)}`)
          error = true
        } finally {
          telemetry.recordLLMObsUserProcessorCalled(error)
        }
      }
    }
    module2.exports = LLMObsSpanProcessor
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/constants/writers.js
var require_writers = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/constants/writers.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      EVP_PROXY_AGENT_BASE_PATH: '/evp_proxy/v2/',
      EVP_SUBDOMAIN_HEADER_NAME: 'X-Datadog-EVP-Subdomain',
      SPANS_EVENT_TYPE: 'span',
      SPANS_INTAKE: 'llmobs-intake',
      SPANS_ENDPOINT: '/api/v2/llmobs',
      EVALUATIONS_INTAKE: 'api',
      EVALUATIONS_EVENT_TYPE: 'evaluation_metric',
      EVALUATIONS_ENDPOINT: '/api/intake/llm-obs/v1/eval-metric',
      EVP_PAYLOAD_SIZE_LIMIT: 5 << 20,
      // 5MB (actual limit is 5.1MB)
      EVP_EVENT_SIZE_LIMIT: (1 << 20) - 1024,
      // 999KB (actual limit is 1MB)
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/util.js
var require_util14 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/util.js'(exports2, module2) {
    'use strict'
    var logger = require_log2()
    var { EVP_PROXY_AGENT_BASE_PATH } = require_writers()
    var telemetry = require_telemetry4()
    var AgentInfoExporter = require_agent_info_exporter()
    var agentInfoExporter
    function setAgentStrategy(config, setWritersAgentlessValue) {
      const agentlessEnabled = config.llmobs.agentlessEnabled
      if (agentlessEnabled != null) {
        setWritersAgentlessValue(agentlessEnabled)
        return
      }
      if (!agentInfoExporter) {
        agentInfoExporter = new AgentInfoExporter(config)
      }
      agentInfoExporter.getAgentInfo((err, agentInfo) => {
        if (err) {
          setWritersAgentlessValue(true)
          return
        }
        const endpoints = agentInfo.endpoints
        const hasEndpoint = Array.isArray(endpoints) && endpoints.includes(EVP_PROXY_AGENT_BASE_PATH)
        setWritersAgentlessValue(!hasEndpoint)
      })
    }
    function parseResponseAndLog(err, code, eventsLength, url, eventType) {
      if (code === 403 && err.message.includes('API key is invalid')) {
        logger.error(
          '[LLMObs] The provided Datadog API key is invalid (likely due to an API key and DD_SITE mismatch). Please verify your API key and DD_SITE are correct.'
        )
        telemetry.recordDroppedPayload(eventsLength, eventType, 'request_error')
      } else if (err) {
        logger.error('Error sending %d LLMObs %s events to %s: %s', eventsLength, eventType, url, err.message, err)
        telemetry.recordDroppedPayload(eventsLength, eventType, 'request_error')
      } else if (code >= 300) {
        logger.error('Error sending %d LLMObs %s events to %s: %s', eventsLength, eventType, url, code)
        telemetry.recordDroppedPayload(eventsLength, eventType, 'http_error')
      } else {
        logger.debug(`Sent ${eventsLength} LLMObs ${eventType} events to ${url}`)
      }
    }
    module2.exports = {
      setAgentStrategy,
      parseResponseAndLog,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/base.js
var require_base3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/base.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var { getEnvironmentVariable } = require_config_helper()
    var { URL: URL2, format } = require('node:url')
    var path = require('node:path')
    var logger = require_log2()
    var { encodeUnicode } = require_util8()
    var telemetry = require_telemetry4()
    var log = require_log2()
    var { EVP_SUBDOMAIN_HEADER_NAME, EVP_PROXY_AGENT_BASE_PATH } = require_writers()
    var { parseResponseAndLog } = require_util14()
    var BaseLLMObsWriter = class {
      constructor({ interval, timeout, eventType, config, endpoint, intake }) {
        this._interval = interval ?? getEnvironmentVariable('_DD_LLMOBS_FLUSH_INTERVAL') ?? 1e3
        this._timeout = timeout ?? getEnvironmentVariable('_DD_LLMOBS_TIMEOUT') ?? 5e3
        this._eventType = eventType
        this._buffer = []
        this._bufferLimit = 1e3
        this._bufferSize = 0
        this._config = config
        this._endpoint = endpoint
        this._intake = intake
        this._periodic = setInterval(() => {
          this.flush()
        }, this._interval).unref()
        this._beforeExitHandler = () => {
          this.destroy()
        }
        process.once('beforeExit', this._beforeExitHandler)
        this._destroyed = false
      }
      get url() {
        if (this._agentless == null) return null
        const baseUrl = this._baseUrl.href
        const endpoint = this._endpoint
        const [protocol, rest] = baseUrl.split('://')
        return protocol + '://' + path.join(rest, endpoint)
      }
      append(event, byteLength) {
        if (this._buffer.length >= this._bufferLimit) {
          logger.warn(`${this.constructor.name} event buffer full (limit is ${this._bufferLimit}), dropping event`)
          telemetry.recordDroppedPayload(1, this._eventType, 'buffer_full')
          return
        }
        this._bufferSize += byteLength || Buffer.byteLength(JSON.stringify(event))
        this._buffer.push(event)
      }
      flush() {
        const noAgentStrategy = this._agentless == null
        if (this._buffer.length === 0 || noAgentStrategy) {
          return
        }
        const events = this._buffer
        this._buffer = []
        this._bufferSize = 0
        const payload = this._encode(this.makePayload(events))
        log.debug('Encoded LLMObs payload: %s', payload)
        const options = this._getOptions()
        request(payload, options, (err, resp, code) => {
          parseResponseAndLog(err, code, events.length, this.url, this._eventType)
        })
      }
      makePayload(events) {}
      destroy() {
        if (!this._destroyed) {
          logger.debug(`Stopping ${this.constructor.name}`)
          clearInterval(this._periodic)
          process.removeListener('beforeExit', this._beforeExitHandler)
          this.flush()
          this._destroyed = true
        }
      }
      setAgentless(agentless) {
        this._agentless = agentless
        const { url, endpoint } = this._getUrlAndPath()
        this._baseUrl = url
        this._endpoint = endpoint
        logger.debug(`Configuring ${this.constructor.name} to ${this.url}`)
      }
      _getUrlAndPath() {
        if (this._agentless) {
          return {
            url: new URL2(
              format({
                protocol: 'https:',
                hostname: `${this._intake}.${this._config.site}`,
              })
            ),
            endpoint: this._endpoint,
          }
        }
        const { hostname, port } = this._config
        const overrideOriginEnv = getEnvironmentVariable('_DD_LLMOBS_OVERRIDE_ORIGIN')
        const overrideOriginUrl = overrideOriginEnv && new URL2(overrideOriginEnv)
        const base =
          overrideOriginUrl ??
          this._config.url ??
          new URL2(
            format({
              protocol: 'http:',
              hostname,
              port,
            })
          )
        return {
          url: base,
          endpoint: path.join(EVP_PROXY_AGENT_BASE_PATH, this._endpoint),
        }
      }
      _getOptions() {
        const options = {
          headers: {
            'Content-Type': 'application/json',
          },
          method: 'POST',
          timeout: this._timeout,
          url: this._baseUrl,
          path: this._endpoint,
        }
        if (this._agentless) {
          options.headers['DD-API-KEY'] = this._config.apiKey || ''
        } else {
          options.headers[EVP_SUBDOMAIN_HEADER_NAME] = this._intake
        }
        return options
      }
      _encode(payload) {
        return JSON.stringify(payload, (key, value) => {
          if (typeof value === 'string') {
            return encodeUnicode(value)
          }
          return value
        }).replaceAll(String.raw`\\u`, String.raw`\u`)
      }
    }
    module2.exports = BaseLLMObsWriter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/evaluations.js
var require_evaluations = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/evaluations.js'(exports2, module2) {
    'use strict'
    var { EVALUATIONS_ENDPOINT, EVALUATIONS_EVENT_TYPE, EVALUATIONS_INTAKE } = require_writers()
    var BaseWriter = require_base3()
    var LLMObsEvalMetricsWriter = class extends BaseWriter {
      constructor(config) {
        super({
          config,
          intake: EVALUATIONS_INTAKE,
          eventType: EVALUATIONS_EVENT_TYPE,
          endpoint: EVALUATIONS_ENDPOINT,
        })
      }
      makePayload(events) {
        return {
          data: {
            type: this._eventType,
            attributes: {
              metrics: events,
            },
          },
        }
      }
    }
    module2.exports = LLMObsEvalMetricsWriter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/spans.js
var require_spans = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/writers/spans.js'(exports2, module2) {
    'use strict'
    var { EVP_EVENT_SIZE_LIMIT, EVP_PAYLOAD_SIZE_LIMIT, SPANS_ENDPOINT, SPANS_EVENT_TYPE, SPANS_INTAKE } =
      require_writers()
    var { DROPPED_VALUE_TEXT } = require_text()
    var { DROPPED_IO_COLLECTION_ERROR } = require_tags3()
    var BaseWriter = require_base3()
    var telemetry = require_telemetry4()
    var logger = require_log2()
    var tracerVersion = require_package().version
    var LLMObsSpanWriter = class extends BaseWriter {
      constructor(config) {
        super({
          config,
          eventType: SPANS_EVENT_TYPE,
          intake: SPANS_INTAKE,
          endpoint: SPANS_ENDPOINT,
        })
      }
      append(event) {
        const eventSizeBytes = Buffer.byteLength(JSON.stringify(event))
        telemetry.recordLLMObsRawSpanSize(event, eventSizeBytes)
        const shouldTruncate = eventSizeBytes > EVP_EVENT_SIZE_LIMIT
        let processedEventSizeBytes = eventSizeBytes
        if (shouldTruncate) {
          logger.warn(
            `Dropping event input/output because its size (${eventSizeBytes}) exceeds the 1MB event size limit`
          )
          event = this._truncateSpanEvent(event)
          processedEventSizeBytes = Buffer.byteLength(JSON.stringify(event))
        }
        telemetry.recordLLMObsSpanSize(event, processedEventSizeBytes, shouldTruncate)
        if (this._bufferSize + eventSizeBytes > EVP_PAYLOAD_SIZE_LIMIT) {
          logger.debug('Flushing queue because queuing next event will exceed EvP payload limit')
          this.flush()
        }
        super.append(event, processedEventSizeBytes)
      }
      makePayload(events) {
        return events.map((event) => ({
          '_dd.stage': 'raw',
          '_dd.tracer_version': tracerVersion,
          event_type: this._eventType,
          spans: [event],
        }))
      }
      _truncateSpanEvent(event) {
        event.meta.input = { value: DROPPED_VALUE_TEXT }
        event.meta.output = { value: DROPPED_VALUE_TEXT }
        event.collection_errors = [DROPPED_IO_COLLECTION_ERROR]
        return event
      }
    }
    module2.exports = LLMObsSpanWriter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/index.js
var require_llmobs = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/index.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var { ML_APP, PROPAGATED_ML_APP_KEY, PROPAGATED_PARENT_ID_KEY } = require_tags3()
    var { storage } = require_storage4()
    var telemetry = require_telemetry4()
    var LLMObsSpanProcessor = require_span_processor3()
    var { channel } = require_dc_polyfill()
    var spanFinishCh = channel('dd-trace:span:finish')
    var evalMetricAppendCh = channel('llmobs:eval-metric:append')
    var flushCh = channel('llmobs:writers:flush')
    var injectCh = channel('dd-trace:span:inject')
    var registerUserSpanProcessorCh = channel('llmobs:register-processor')
    var LLMObsEvalMetricsWriter = require_evaluations()
    var LLMObsTagger = require_tagger2()
    var LLMObsSpanWriter = require_spans()
    var { setAgentStrategy } = require_util14()
    var util = require('node:util')
    var spanProcessor
    var spanWriter
    var evalWriter
    var globalTracerConfig
    function enable(config) {
      globalTracerConfig = config
      const startTime = performance.now()
      evalWriter = new LLMObsEvalMetricsWriter(config)
      spanWriter = new LLMObsSpanWriter(config)
      evalMetricAppendCh.subscribe(handleEvalMetricAppend)
      flushCh.subscribe(handleFlush)
      registerUserSpanProcessorCh.subscribe(handleRegisterProcessor)
      spanProcessor = new LLMObsSpanProcessor(config)
      spanProcessor.setWriter(spanWriter)
      spanFinishCh.subscribe(handleSpanProcess)
      injectCh.subscribe(handleLLMObsParentIdInjection)
      setAgentStrategy(config, (useAgentless) => {
        if (useAgentless && !(config.apiKey && config.site)) {
          throw new Error(
            'Cannot send LLM Observability data without a running agent or without both a Datadog API key and site.\nEnsure these configurations are set before running your application.'
          )
        }
        evalWriter?.setAgentless(useAgentless)
        spanWriter?.setAgentless(useAgentless)
        telemetry.recordLLMObsEnabled(startTime, config)
        log.debug(`[LLMObs] Enabled LLM Observability with configuration: ${util.inspect(config.llmobs)}`)
      })
    }
    function disable() {
      if (evalMetricAppendCh.hasSubscribers) evalMetricAppendCh.unsubscribe(handleEvalMetricAppend)
      if (flushCh.hasSubscribers) flushCh.unsubscribe(handleFlush)
      if (spanFinishCh.hasSubscribers) spanFinishCh.unsubscribe(handleSpanProcess)
      if (injectCh.hasSubscribers) injectCh.unsubscribe(handleLLMObsParentIdInjection)
      if (registerUserSpanProcessorCh.hasSubscribers) registerUserSpanProcessorCh.unsubscribe(handleRegisterProcessor)
      spanWriter?.destroy()
      evalWriter?.destroy()
      spanProcessor?.setWriter(null)
      spanWriter = null
      evalWriter = null
      log.debug('[LLMObs] Disabled LLM Observability')
    }
    function handleLLMObsParentIdInjection({ carrier }) {
      const parent = storage.getStore()?.span
      const mlObsSpanTags = LLMObsTagger.tagMap.get(parent)
      const parentContext = parent?.context()
      const parentId = parentContext?.toSpanId()
      const mlApp =
        mlObsSpanTags?.[ML_APP] ||
        parentContext?._trace?.tags?.[PROPAGATED_ML_APP_KEY] ||
        globalTracerConfig.llmobs.mlApp
      if (parentId) carrier['x-datadog-tags'] += `,${PROPAGATED_PARENT_ID_KEY}=${parentId}`
      if (mlApp) carrier['x-datadog-tags'] += `,${PROPAGATED_ML_APP_KEY}=${mlApp}`
    }
    function handleFlush() {
      let err = ''
      try {
        spanWriter.flush()
        evalWriter.flush()
      } catch (e) {
        err = 'writer_flush_error'
        log.warn('Failed to flush LLMObs spans and evaluation metrics:', e.message)
      }
      telemetry.recordUserFlush(err)
    }
    function handleRegisterProcessor(userSpanProcessor) {
      spanProcessor.setUserSpanProcessor(userSpanProcessor)
    }
    function handleSpanProcess(span) {
      spanProcessor.process(span)
    }
    function handleEvalMetricAppend(payload) {
      try {
        evalWriter.append(payload)
      } catch (e) {
        log.warn(
          // eslint-disable-next-line @stylistic/max-len
          "Failed to append evaluation metric to LLM Observability writer, likely due to an unserializable property. Evaluation metrics won't be sent to LLM Observability:",
          e.message
        )
      }
    }
    module2.exports = { enable, disable }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/openfeature/writers/base.js
var require_base4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/openfeature/writers/base.js'(exports2, module2) {
    'use strict'
    var request = require_request()
    var { safeJSONStringify } = require_util2()
    var { URL: URL2, format } = require('node:url')
    var log = require_log2()
    var BaseFFEWriter = class {
      /**
       * @param {BaseFFEWriterOptions} options - Writer configuration options
       */
      constructor({ interval, timeout, config, endpoint, agentUrl, payloadSizeLimit, eventSizeLimit, headers }) {
        this._interval = interval ?? 1e3
        this._timeout = timeout ?? 5e3
        this._buffer = []
        this._bufferLimit = 1e3
        this._bufferSize = 0
        this._config = config
        this._endpoint = endpoint
        this._baseUrl = agentUrl ?? this._getAgentUrl()
        this._payloadSizeLimit = payloadSizeLimit
        this._eventSizeLimit = eventSizeLimit
        this._headers = headers || {}
        this._requestOptions = {
          headers: {
            ...this._headers,
            'Content-Type': 'application/json',
          },
          method: 'POST',
          timeout: this._timeout,
          url: this._baseUrl,
          path: this._endpoint,
        }
        this._periodic = setInterval(() => {
          this.flush()
        }, this._interval).unref()
        this._beforeExitHandler = () => {
          this.destroy()
        }
        process.once('beforeExit', this._beforeExitHandler)
        this._destroyed = false
        this._droppedEvents = 0
      }
      /**
       * Appends an event array to the buffer
       * @param {Array|Object} events - Event object(s) to append to buffer
       */
      append(events) {
        const eventArray = Array.isArray(events) ? events : [events]
        for (const event of eventArray) {
          if (this._buffer.length >= this._bufferLimit) {
            log.warn(`${this.constructor.name} event buffer full (limit is ${this._bufferLimit}), dropping event`)
            this._droppedEvents++
            continue
          }
          const eventSizeBytes = Buffer.byteLength(JSON.stringify(event))
          if (this._eventSizeLimit && eventSizeBytes > this._eventSizeLimit) {
            log.warn(`${this.constructor.name} event size
          ${eventSizeBytes} bytes exceeds limit ${this._eventSizeLimit}, dropping event`)
            this._droppedEvents++
            continue
          }
          if (this._payloadSizeLimit && this._bufferSize + eventSizeBytes > this._payloadSizeLimit) {
            log.debug(
              () => `${this.constructor.name}
        buffer size would exceed ${this._payloadSizeLimit} bytes, flushing first`
            )
            this.flush()
          }
          this._bufferSize += eventSizeBytes
          this._buffer.push(event)
        }
      }
      /**
       * Flushes all buffered events to the agent
       */
      flush() {
        if (this._buffer.length === 0) {
          return
        }
        const events = this._buffer
        this._buffer = []
        this._bufferSize = 0
        const payload = this._encode(this.makePayload(events))
        log.debug(() => `${this.constructor.name} flushing payload: ${safeJSONStringify(payload)}`)
        request(payload, this._requestOptions, (err, resp, code) => {
          if (err) {
            log.error(`Failed to send events to ${this._baseUrl.href}${this._endpoint}: ${err.message}`)
          } else if (code >= 200 && code < 300) {
            log.debug(() => `Successfully sent ${events.length} events`)
          } else {
            log.warn(`Events request returned status ${code}`)
          }
        })
      }
      /**
       * Override in subclass to customize payload structure
       * @param {Array} events - Array of events to be sent
       * @returns {object} Formatted payload
       */
      makePayload(events) {
        return events
      }
      /**
       * Cleans up resources and flushes remaining events
       */
      destroy() {
        if (!this._destroyed) {
          log.debug(() => `Stopping ${this.constructor.name}`)
          clearInterval(this._periodic)
          process.removeListener('beforeExit', this._beforeExitHandler)
          this.flush()
          this._destroyed = true
          if (this._droppedEvents > 0) {
            log.warn(`${this.constructor.name} dropped ${this._droppedEvents} events due to buffer overflow`)
          }
        }
      }
      /**
       * @private
       * @returns {URL} Constructs agent URL from config
       */
      _getAgentUrl() {
        const { hostname, port } = this._config
        return (
          this._config.url ??
          new URL2(
            format({
              protocol: 'http:',
              hostname: hostname || 'localhost',
              port: port || 8126,
            })
          )
        )
      }
      /**
       * @private
       * @param {Array<object>} payload - Payload to encode
       * @returns {string} JSON-stringified payload
       */
      _encode(payload) {
        return JSON.stringify(payload)
      }
    }
    module2.exports = BaseFFEWriter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/openfeature/writers/exposures.js
var require_exposures = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/openfeature/writers/exposures.js'(exports2, module2) {
    'use strict'
    var BaseFFEWriter = require_base4()
    var {
      EXPOSURES_ENDPOINT,
      EVP_PROXY_AGENT_BASE_PATH,
      EVP_SUBDOMAIN_HEADER_NAME,
      EVP_SUBDOMAIN_VALUE,
      EVP_PAYLOAD_SIZE_LIMIT,
      EVP_EVENT_SIZE_LIMIT,
    } = require_constants()
    var ExposuresWriter = class extends BaseFFEWriter {
      /**
       * @param {import('../../config')} config - Tracer configuration object
       */
      constructor(config) {
        const basePath = EVP_PROXY_AGENT_BASE_PATH.replace(/\/+$/, '')
        const endpoint = EXPOSURES_ENDPOINT.replace(/^\/+/, '')
        const fullEndpoint = `${basePath}/${endpoint}`
        super({
          config,
          endpoint: fullEndpoint,
          payloadSizeLimit: EVP_PAYLOAD_SIZE_LIMIT,
          eventSizeLimit: EVP_EVENT_SIZE_LIMIT,
          headers: {
            [EVP_SUBDOMAIN_HEADER_NAME]: EVP_SUBDOMAIN_VALUE,
          },
        })
        this._enabled = false
        this._pendingEvents = []
        this._context = this._buildContext()
      }
      /**
       * @param {boolean} enabled - Whether to enable the writer
       */
      setEnabled(enabled) {
        this._enabled = enabled
        if (enabled && this._pendingEvents.length > 0) {
          super.append(this._pendingEvents)
          this._pendingEvents = []
        }
      }
      /**
       * Appends exposure event(s) to the buffer
       * @param {ExposureEvent|ExposureEvent[]} events - Exposure event(s) to append
       */
      append(events) {
        if (!this._enabled) {
          if (Array.isArray(events)) {
            this._pendingEvents.push(...events)
          } else {
            this._pendingEvents.push(events)
          }
          return
        }
        super.append(events)
      }
      /**
       * Flushes buffered exposure events to the agent
       */
      flush() {
        if (!this._enabled) {
          return
        }
        super.flush()
      }
      /**
       * Formats exposure events with service context metadata
       * @param {Array<ExposureEvent>} events - Array of exposure events
       * @returns {ExposureEventPayload} Formatted payload with service context
       */
      makePayload(events) {
        const formattedEvents = events.map((event) => this._formatExposureEvent(event))
        return {
          context: this._context,
          exposures: formattedEvents,
        }
      }
      /**
       * Builds service context metadata
       * @private
       * @returns {ExposureContext} Service context
       */
      _buildContext() {
        const context = {
          service: this._config.service || 'unknown',
        }
        if (this._config.version !== void 0) {
          context.version = this._config.version
        }
        if (this._config.env !== void 0) {
          context.env = this._config.env
        }
        return context
      }
      /**
       * @private
       * @param {ExposureEvent} event - Raw exposure event
       * @returns {ExposureEvent} Formatted exposure event
       */
      _formatExposureEvent(event) {
        const formattedEvent = {
          timestamp: event.timestamp || Date.now(),
          allocation: {
            key: event.allocation?.key || event['allocation.key'],
          },
          flag: {
            key: event.flag?.key || event['flag.key'],
          },
          variant: {
            key: event.variant?.key || event['variant.key'],
          },
          subject: {
            id: event.subject?.id || event['subject.id'],
            type: event.subject?.type,
            attributes: event.subject?.attributes,
          },
        }
        return formattedEvent
      }
    }
    module2.exports = ExposuresWriter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/openfeature/writers/util.js
var require_util15 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/openfeature/writers/util.js'(exports2, module2) {
    'use strict'
    var logger = require_log2()
    var { EVP_PROXY_AGENT_BASE_PATH } = require_constants()
    var AgentInfoExporter = require_agent_info_exporter()
    var agentInfoExporter
    function setAgentStrategy(config, setWriterEnabledValue) {
      if (!agentInfoExporter) {
        agentInfoExporter = new AgentInfoExporter(config)
      }
      agentInfoExporter.getAgentInfo((err, agentInfo) => {
        if (err) {
          logger.debug('FFE Writer disabled - error getting agent info:', err.message)
          setWriterEnabledValue(false)
          return
        }
        const endpoints = agentInfo.endpoints
        const normalizedPath = EVP_PROXY_AGENT_BASE_PATH.replace(/\/+$/, '')
        const hasEndpoint =
          (Array.isArray(endpoints) && endpoints.includes(normalizedPath)) || endpoints.includes(normalizedPath + '/')
        if (hasEndpoint) {
          logger.debug('FFE Writer enabled - agent has EVP proxy support')
          setWriterEnabledValue(true)
        } else {
          logger.debug('FFE Writer disabled - agent does not have EVP proxy support')
          setWriterEnabledValue(false)
        }
      })
    }
    module2.exports = {
      setAgentStrategy,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/openfeature/index.js
var require_openfeature = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/openfeature/index.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var ExposuresWriter = require_exposures()
    var { setAgentStrategy } = require_util15()
    var { channel } = require_dc_polyfill()
    var exposureSubmitCh = channel('ffe:exposure:submit')
    var flushCh = channel('ffe:writers:flush')
    var exposuresWriter = null
    function _handleExposureSubmit(exposureEvents) {
      if (!exposuresWriter) return
      exposuresWriter.append(exposureEvents)
    }
    function _handleFlush() {
      exposuresWriter?.flush()
    }
    function enable(config) {
      if (exposuresWriter) {
        log.warn(exposuresWriter.constructor.name + ' already enabled')
        return
      }
      exposuresWriter = new ExposuresWriter(config)
      exposureSubmitCh.subscribe(_handleExposureSubmit)
      flushCh.subscribe(_handleFlush)
      setAgentStrategy(config, (hasAgent) => {
        exposuresWriter?.setEnabled(hasAgent)
      })
      log.debug('OpenFeature module enabled')
    }
    function disable() {
      if (!exposuresWriter) return
      if (exposureSubmitCh.hasSubscribers) {
        exposureSubmitCh.unsubscribe(_handleExposureSubmit)
      }
      if (flushCh.hasSubscribers) {
        flushCh.unsubscribe(_handleFlush)
      }
      exposuresWriter.destroy?.()
      exposuresWriter = null
      log.debug('OpenFeature module disabled')
    }
    module2.exports = {
      enable,
      disable,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/crashtracking/crashtracker.js
var require_crashtracker = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/crashtracking/crashtracker.js'(exports2, module2) {
    'use strict'
    var libdatadog = require('@datadog/libdatadog')
    var binding = libdatadog.load('crashtracker')
    var log = require_log2()
    var defaults = require_config_defaults()
    var { URL: URL2 } = require('url')
    var pkg = require_package()
    var Crashtracker = class {
      #started = false
      configure(config) {
        if (!this.#started) return
        try {
          binding.updateConfig(this.#getConfig(config))
          binding.updateMetadata(this.#getMetadata(config))
        } catch (e) {
          log.error('Error configuring crashtracker', e)
        }
      }
      start(config) {
        if (this.#started) return this.configure(config)
        this.#started = true
        try {
          binding.init(this.#getConfig(config), this.#getReceiverConfig(), this.#getMetadata(config))
        } catch (e) {
          log.error('Error initialising crashtracker', e)
        }
      }
      withProfilerSerializing(f) {
        binding.beginProfilerSerializing()
        try {
          return f()
        } finally {
          binding.endProfilerSerializing()
        }
      }
      // TODO: Send only configured values when defaults are fixed.
      #getConfig(config) {
        const { hostname = defaults.hostname, port = defaults.port } = config
        const url = config.url || new URL2(`http://${hostname}:${port}`)
        return {
          additional_files: [],
          create_alt_stack: true,
          use_alt_stack: true,
          endpoint: {
            // TODO: Use the string directly when deserialization is fixed.
            url: {
              scheme: url.protocol.slice(0, -1),
              authority: url.protocol === 'unix:' ? Buffer.from(url.pathname).toString('hex') : url.host,
              path_and_query: '',
            },
            timeout_ms: 3e3,
          },
          timeout_ms: 5e3,
          // TODO: Use `EnabledWithSymbolsInReceiver` instead for Linux when fixed.
          resolve_frames: 'EnabledWithInprocessSymbols',
        }
      }
      #getMetadata(config) {
        const tags = Object.keys(config.tags).map((key) => `${key}:${config.tags[key]}`)
        return {
          library_name: pkg.name,
          library_version: pkg.version,
          family: 'nodejs',
          tags: [
            ...tags,
            'is_crash:true',
            'language:javascript',
            `library_version:${pkg.version}`,
            'runtime:nodejs',
            `runtime_version:${process.versions.node}`,
            'severity:crash',
          ],
        }
      }
      #getReceiverConfig() {
        return {
          args: [],
          env: [],
          path_to_receiver_binary: libdatadog.find('crashtracker-receiver', true),
          stderr_filename: null,
          stdout_filename: null,
        }
      }
    }
    module2.exports = new Crashtracker()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/crashtracking/noop.js
var require_noop5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/crashtracking/noop.js'(exports2, module2) {
    'use strict'
    var NoopCrashtracker = class {
      configure() {}
      start() {}
      withProfilerSerializing(f) {
        return f()
      }
    }
    module2.exports = new NoopCrashtracker()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/crashtracking/index.js
var require_crashtracking = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/crashtracking/index.js'(exports2, module2) {
    'use strict'
    var { isMainThread } = require('worker_threads')
    var log = require_log2()
    if (isMainThread) {
      try {
        module2.exports = require_crashtracker()
      } catch (e) {
        log.warn(e.message)
        module2.exports = require_noop5()
      }
    } else {
      module2.exports = require_noop5()
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/heap_snapshots.js
var require_heap_snapshots = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/heap_snapshots.js'(exports2, module2) {
    'use strict'
    var { join } = require('path')
    var { setImmediate: setImmediate2, setTimeout: setTimeout2 } = require('timers/promises')
    var { format } = require('util')
    var { writeHeapSnapshot } = require('v8')
    var { threadId } = require('worker_threads')
    var log = require_log2()
    async function scheduleSnapshot(config, total) {
      if (total > config.heapSnapshot.count) return
      await setTimeout2(config.heapSnapshot.interval * 1e3, null, { ref: false })
      await clearMemory()
      writeHeapSnapshot(getName(config.heapSnapshot.destination))
      await scheduleSnapshot(config, total + 1)
    }
    async function clearMemory() {
      if (!globalThis.gc) return
      globalThis.gc()
      await setImmediate2()
      globalThis.gc()
    }
    function pad(value) {
      return String(value).padStart(2, 0)
    }
    function getName(destination) {
      const date = /* @__PURE__ */ new Date()
      const filename = format(
        'Heap-%s%s%s-%s%s%s-%s-%s.heapsnapshot',
        date.getFullYear(),
        pad(date.getMonth()),
        pad(date.getDate()),
        pad(date.getHours()),
        pad(date.getMinutes()),
        pad(date.getSeconds()),
        process.pid,
        threadId
      )
      return join(destination, filename)
    }
    module2.exports = {
      async start(config) {
        const destination = config.heapSnapshot.destination
        try {
          await scheduleSnapshot(config, 1)
          log.debug('Wrote heap snapshots to %s.', destination)
        } catch (e) {
          log.error('Failed to write heap snapshots to %s.', destination, e)
        }
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/ssi-heuristics.js
var require_ssi_heuristics = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/ssi-heuristics.js'(exports2, module2) {
    'use strict'
    var dc = require_dc_polyfill()
    var log = require_log2()
    var DEFAULT_LONG_LIVED_THRESHOLD = 3e4
    var SSIHeuristics = class {
      constructor(config) {
        const longLivedThreshold = config.profiling.longLivedThreshold || DEFAULT_LONG_LIVED_THRESHOLD
        if (typeof longLivedThreshold !== 'number' || longLivedThreshold <= 0) {
          this.longLivedThreshold = DEFAULT_LONG_LIVED_THRESHOLD
          log.warn(
            'Invalid SSIHeuristics.longLivedThreshold value: %s. Using default value:',
            config.profiling.longLivedThreshold,
            DEFAULT_LONG_LIVED_THRESHOLD
          )
        } else {
          this.longLivedThreshold = longLivedThreshold
        }
        this.hasSentProfiles = false
        this.noSpan = true
        this.shortLived = true
      }
      start() {
        setTimeout(() => {
          this.shortLived = false
          this._maybeTriggered()
        }, this.longLivedThreshold).unref()
        this._onSpanCreated = this._onSpanCreated.bind(this)
        dc.subscribe('dd-trace:span:start', this._onSpanCreated)
        this._onAppClosing = this._onAppClosing.bind(this)
        dc.subscribe('datadog:telemetry:app-closing', this._onAppClosing)
      }
      onTriggered(callback) {
        switch (typeof callback) {
          case 'undefined':
          case 'function':
            this.triggeredCallback = callback
            process.nextTick(() => {
              this._maybeTriggered()
            })
            break
          default:
            throw new TypeError('callback must be a function or undefined')
        }
      }
      _maybeTriggered() {
        if (!this.shortLived && !this.noSpan && typeof this.triggeredCallback === 'function') {
          this.triggeredCallback.call(null)
        }
      }
      _onSpanCreated() {
        this.noSpan = false
        this._maybeTriggered()
        dc.unsubscribe('dd-trace:span:start', this._onSpanCreated)
      }
      _onAppClosing() {
        dc.unsubscribe('datadog:telemetry:app-closing', this._onAppClosing)
        if (this.noSpan) {
          dc.unsubscribe('dd-trace:span:start', this._onSpanCreated)
        }
      }
    }
    module2.exports = { SSIHeuristics }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/test-api-manual/test-api-manual-plugin.js
var require_test_api_manual_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/test-api-manual/test-api-manual-plugin.js'(
    exports2,
    module2
  ) {
    'use strict'
    var CiPlugin = require_ci_plugin()
    var { TEST_STATUS, finishAllTraceSpans, getTestSuitePath } = require_test()
    var { storage } = require_datadog_core()
    var TestApiManualPlugin = class extends CiPlugin {
      static id = 'test-api-manual'
      constructor(...args) {
        super(...args)
        this._isEnvDataCalcualted = false
        this.sourceRoot = process.cwd()
        this.unconfiguredAddSub('dd-trace:ci:manual:test:start', ({ testName, testSuite }) => {
          const store = storage('legacy').getStore()
          const testSuiteRelative = getTestSuitePath(testSuite, this.sourceRoot)
          const testSpan = this.startTestSpan(testName, testSuiteRelative)
          this.enter(testSpan, store)
        })
        this.unconfiguredAddSub('dd-trace:ci:manual:test:finish', ({ status, error }) => {
          const store = storage('legacy').getStore()
          const testSpan = store && store.span
          if (testSpan) {
            testSpan.setTag(TEST_STATUS, status)
            if (error) {
              testSpan.setTag('error', error)
            }
            testSpan.finish()
            finishAllTraceSpans(testSpan)
          }
        })
        this.unconfiguredAddSub('dd-trace:ci:manual:test:addTags', (tags) => {
          const store = storage('legacy').getStore()
          const testSpan = store && store.span
          if (testSpan) {
            testSpan.addTags(tags)
          }
        })
      }
      // To lazily calculate env data.
      unconfiguredAddSub(channelName, handler) {
        this.addSub(channelName, (...args) => {
          if (!this._isEnvDataCalcualted) {
            this._isEnvDataCalcualted = true
            this.configure(this._config, true)
          }
          return handler(...args)
        })
      }
      configure(config, shouldGetEnvironmentData) {
        this._config = config
        super.configure(config, shouldGetEnvironmentData)
      }
    }
    module2.exports = TestApiManualPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/log-submission/log-submission-plugin.js
var require_log_submission_plugin = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/ci-visibility/log-submission/log-submission-plugin.js'(
    exports2,
    module2
  ) {
    'use strict'
    var Plugin = require_plugin()
    var log = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    function getWinstonLogSubmissionParameters(config) {
      const { site, service } = config
      const defaultParameters = {
        host: `http-intake.logs.${site}`,
        path: `/api/v2/logs?ddsource=winston&service=${service}`,
        ssl: true,
        headers: {
          'DD-API-KEY': getEnvironmentVariable('DD_API_KEY'),
        },
      }
      if (!getEnvironmentVariable('DD_AGENTLESS_LOG_SUBMISSION_URL')) {
        return defaultParameters
      }
      try {
        const url = new URL(getEnvironmentVariable('DD_AGENTLESS_LOG_SUBMISSION_URL'))
        return {
          host: url.hostname,
          port: url.port,
          ssl: url.protocol === 'https:',
          path: defaultParameters.path,
          headers: defaultParameters.headers,
        }
      } catch {
        log.error('Could not parse DD_AGENTLESS_LOG_SUBMISSION_URL')
        return defaultParameters
      }
    }
    var LogSubmissionPlugin = class extends Plugin {
      static id = 'log-submission'
      constructor(...args) {
        super(...args)
        this.addSub('ci:log-submission:winston:configure', (httpClass) => {
          this.HttpClass = httpClass
        })
        this.addSub('ci:log-submission:winston:add-transport', (logger) => {
          logger.add(new this.HttpClass(getWinstonLogSubmissionParameters(this.config)))
        })
      }
    }
    module2.exports = LogSubmissionPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/logger.js
var require_logger = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/logger.js'(exports2, module2) {
    'use strict'
    var { sanitizeAttributes } = require_core()
    var { context } = require('@opentelemetry/api')
    var { VERSION: packageVersion } = require_version()
    var Logger = class {
      #instrumentationScope
      /**
       * Creates a new Logger instance.
       *
       * @param {LoggerProvider} loggerProvider - Parent logger provider
       * @param {InstrumentationScope} [instrumentationScope] - Instrumentation scope information (newer API).
       *  `name` defaults to 'dd-trace-js';
       *  `version` defaults to tracer version;
       *  `schemaUrl` defaults to '';
       * @param {InstrumentationLibrary} [instrumentationLibrary]
       *  - Instrumentation library information (legacy API) [DEPRECATED in v1.3.0].
       *  `name` defaults to 'dd-trace-js';
       *  `version` defaults to tracer version;
       *  `schemaUrl` defaults to '';
       */
      constructor(loggerProvider, instrumentationScope, instrumentationLibrary) {
        this.loggerProvider = loggerProvider
        const scope = instrumentationScope || instrumentationLibrary
        this.#instrumentationScope = {
          name: scope?.name || 'dd-trace-js',
          version: scope?.version || packageVersion,
          schemaUrl: scope?.schemaUrl || '',
        }
      }
      /**
       * Emits a log record.
       *
       * @param {LogRecord} logRecord - The log record to emit
       * @returns {void}
       */
      emit(logRecord) {
        if (this.loggerProvider.isShutdown || !this.loggerProvider.processor) {
          return
        }
        if (logRecord.attributes) {
          logRecord.attributes = sanitizeAttributes(logRecord.attributes)
        }
        if (!logRecord.timestamp) {
          logRecord.timestamp = Number(process.hrtime.bigint())
        }
        if (!logRecord.context) {
          logRecord.context = context.active()
        }
        this.loggerProvider.processor.onEmit(logRecord, this.#instrumentationScope)
      }
    }
    module2.exports = Logger
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/logger_provider.js
var require_logger_provider = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/logger_provider.js'(exports2, module2) {
    'use strict'
    var { logs } = require('@opentelemetry/api-logs')
    var { context } = require('@opentelemetry/api')
    var Logger = require_logger()
    var log = require_log2()
    var ContextManager = require_context_manager()
    var LoggerProvider = class {
      #loggers
      #contextManager
      /**
       * Creates a new LoggerProvider instance with a single processor for Datadog Agent export.
       *
       * @param {Object} [options] - LoggerProvider options
       * @param {BatchLogRecordProcessor} [options.processor] - Single LogRecordProcessor instance for
       *   exporting logs to Datadog Agent
       */
      constructor(options = {}) {
        this.processor = options.processor
        this.#loggers = /* @__PURE__ */ new Map()
        this.#contextManager = new ContextManager()
        this.isShutdown = false
      }
      /**
       * Gets or creates a logger instance.
       *
       * @param {string|Object} nameOrOptions - Logger name or options object
       * @param {string} [version] - Logger version (when nameOrOptions is a string)
       * @param {Object} [options] - Additional options (when nameOrOptions is a string)
       * @returns {Logger} Logger instance
       */
      getLogger(nameOrOptions, version, options = {}) {
        if (this.isShutdown) {
          return this.#createNoOpLogger()
        }
        let name, loggerOptions
        if (typeof nameOrOptions === 'string') {
          name = nameOrOptions
          loggerOptions = { version, ...options }
        } else {
          name = nameOrOptions.name
          loggerOptions = nameOrOptions
        }
        const loggerVersion = loggerOptions.version || ''
        const loggerSchemaUrl = loggerOptions?.schemaUrl || ''
        const key = `${name}@${loggerVersion}`
        if (!this.#loggers.has(key)) {
          this.#loggers.set(key, new Logger(this, { name, version: loggerVersion, schemaUrl: loggerSchemaUrl }))
        }
        return this.#loggers.get(key)
      }
      /**
       * Registers this logger provider as the global provider.
       */
      register() {
        if (this.isShutdown) {
          log.warn('Cannot register after shutdown')
          return
        }
        context.setGlobalContextManager(this.#contextManager)
        logs.setGlobalLoggerProvider(this)
      }
      /**
       * Forces a flush of all pending log records.
       * @returns {undefined} Promise that resolves when flush is n ssue cncomplete
       */
      forceFlush() {
        if (!this.isShutdown) {
          return this.processor?.forceFlush()
        }
      }
      /**
       * Shuts down the logger provider and all associated processors.
       * @returns {undefined} Promise that resolves when shutdown is complete
       */
      shutdown() {
        if (!this.isShutdown) {
          this.isShutdown = true
        }
      }
      /**
       * Creates a no-op logger for use when the provider is shutdown.
       * @returns {Logger} A no-op logger instance
       * @private
       */
      #createNoOpLogger() {
        return {
          instrumentationScope: {
            name: 'dd-trace-js',
            version: '',
          },
          emit: () => {},
          debug: () => {},
          info: () => {},
          warn: () => {},
          error: () => {},
          fatal: () => {},
        }
      }
    }
    module2.exports = LoggerProvider
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/batch_log_processor.js
var require_batch_log_processor = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/batch_log_processor.js'(exports2, module2) {
    'use strict'
    var BatchLogRecordProcessor = class {
      #logRecords
      #timer
      #batchTimeout
      #maxExportBatchSize
      /**
       * Creates a new BatchLogRecordProcessor instance.
       *
       * @param {OtlpHttpLogExporter} exporter - Log processor for exporting batches to Datadog Agent
       * @param {number} batchTimeout - Timeout in milliseconds for batch processing
       * @param {number} maxExportBatchSize - Maximum number of log records per batch
       */
      constructor(exporter, batchTimeout, maxExportBatchSize) {
        this.exporter = exporter
        this.#batchTimeout = batchTimeout
        this.#maxExportBatchSize = maxExportBatchSize
        this.#logRecords = []
        this.#timer = null
      }
      /**
       * Processes a single log record.
       *
       * @param {LogRecord} logRecord - The enriched log record with trace correlation and metadata
       * @param {InstrumentationScope} instrumentationScope - The instrumentation library
       */
      onEmit(logRecord, instrumentationScope) {
        this.#logRecords.push({ ...logRecord, instrumentationScope })
        if (this.#logRecords.length >= this.#maxExportBatchSize) {
          this.#export()
        } else if (this.#logRecords.length === 1) {
          this.#startTimer()
        }
      }
      /**
       * Forces an immediate flush of all pending log records.
       * @returns {undefined} Promise that resolves when flush is complete
       */
      forceFlush() {
        this.#export()
      }
      /**
       * Starts the batch timeout timer.
       * @private
       */
      #startTimer() {
        if (this.#timer) {
          return
        }
        this.#timer = setTimeout(() => {
          this.#export()
        }, this.#batchTimeout)
      }
      /**
       * Exports the current batch of log records.
       * @private
       */
      #export() {
        const logRecords = this.#logRecords.slice(0, this.#maxExportBatchSize)
        this.#logRecords = this.#logRecords.slice(this.#maxExportBatchSize)
        this.#clearTimer()
        this.exporter.export(logRecords, () => {})
      }
      /**
       * Clears the batch timeout timer.
       * @private
       */
      #clearTimer() {
        if (this.#timer) {
          clearTimeout(this.#timer)
          this.#timer = null
        }
      }
    }
    module2.exports = BatchLogRecordProcessor
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/otlp/otlp_http_exporter_base.js
var require_otlp_http_exporter_base = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/otlp/otlp_http_exporter_base.js'(exports2, module2) {
    'use strict'
    var http = require('http')
    var { URL: URL2 } = require('url')
    var log = require_log2()
    var telemetryMetrics = require_metrics()
    var tracerMetrics = telemetryMetrics.manager.namespace('tracers')
    var OtlpHttpExporterBase = class {
      /**
       * Creates a new OtlpHttpExporterBase instance.
       *
       * @param {string} url - OTLP endpoint URL
       * @param {string} headers - Additional HTTP headers as comma-separated key=value string
       * @param {number} timeout - Request timeout in milliseconds
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       * @param {string} defaultPath - Default path to use if URL has no path
       * @param {string} signalType - Signal type for error messages (e.g., 'logs', 'metrics')
       */
      constructor(url, headers, timeout, protocol, defaultPath, signalType) {
        const parsedUrl = new URL2(url)
        this.protocol = protocol
        this.signalType = signalType
        const path = parsedUrl.pathname === '/' ? defaultPath : parsedUrl.pathname
        const isJson = protocol === 'http/json'
        this.options = {
          hostname: parsedUrl.hostname,
          port: parsedUrl.port,
          path: path + parsedUrl.search,
          method: 'POST',
          timeout,
          headers: {
            'Content-Type': isJson ? 'application/json' : 'application/x-protobuf',
            ...this.#parseAdditionalHeaders(headers),
          },
        }
        this.telemetryTags = ['protocol:http', `encoding:${isJson ? 'json' : 'protobuf'}`]
      }
      /**
       * Records telemetry metrics for exported data.
       * @param {string} metricName - Name of the metric to record
       * @param {number} count - Count to increment
       * @param {Array<string>} [additionalTags] - Optional custom tags (defaults to this exporter's tags)
       * @protected
       */
      recordTelemetry(metricName, count, additionalTags) {
        if (additionalTags?.length > 0) {
          tracerMetrics.count(metricName, [...this.telemetryTags, ...(additionalTags || [])]).inc(count)
        } else {
          tracerMetrics.count(metricName, this.telemetryTags).inc(count)
        }
      }
      /**
       * Sends the payload via HTTP request.
       * @param {Buffer|string} payload - The payload to send
       * @param {Function} resultCallback - Callback for the result
       * @protected
       */
      sendPayload(payload, resultCallback) {
        const options = {
          ...this.options,
          headers: {
            ...this.options.headers,
            'Content-Length': payload.length,
          },
        }
        const req = http.request(options, (res) => {
          let data = ''
          res.on('data', (chunk) => {
            data += chunk
          })
          res.on('end', () => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
              resultCallback({ code: 0 })
            } else {
              const error = new Error(`HTTP ${res.statusCode}: ${data}`)
              resultCallback({ code: 1, error })
            }
          })
        })
        req.on('error', (error) => {
          log.error(`Error sending OTLP ${this.signalType}:`, error)
          resultCallback({ code: 1, error })
        })
        req.on('timeout', () => {
          req.destroy()
          const error = new Error('Request timeout')
          resultCallback({ code: 1, error })
        })
        req.write(payload)
        req.end()
      }
      /**
       * Parses additional HTTP headers from a comma-separated string.
       * @param {string} headersString - Comma-separated key=value pairs
       * @returns {Record<string, string>} Parsed headers object
       * @private
       */
      #parseAdditionalHeaders(headersString) {
        const headers = {}
        let key = ''
        let value = ''
        let readingKey = true
        for (const char of headersString) {
          if (readingKey) {
            if (char === '=') {
              readingKey = false
              key = key.trim()
            } else {
              key += char
            }
          } else if (char === ',') {
            value = value.trim()
            if (key && value) {
              headers[key] = value
            }
            key = ''
            value = ''
            readingKey = true
          } else {
            value += char
          }
        }
        if (!readingKey) {
          value = value.trim()
          if (value) {
            headers[key] = value
          }
        }
        return headers
      }
      /**
       * Shuts down the exporter.
       * Subclasses can override to add cleanup logic.
       */
      shutdown() {}
    }
    module2.exports = OtlpHttpExporterBase
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/otlp/otlp_transformer_base.js
var require_otlp_transformer_base = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/otlp/otlp_transformer_base.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var OtlpTransformerBase = class {
      #resourceAttributes
      /**
       * Creates a new OtlpTransformerBase instance.
       *
       * @param {Attributes} resourceAttributes - Resource attributes
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       * @param {string} signalType - Signal type for warning messages (e.g., 'logs', 'metrics')
       */
      constructor(resourceAttributes, protocol, signalType) {
        this.#resourceAttributes = this.transformAttributes(resourceAttributes)
        if (protocol === 'grpc') {
          log.warn(
            `OTLP gRPC protocol is not supported for ${signalType}. Defaulting to http/protobuf. gRPC protobuf support may be added in a future release.`
          )
          protocol = 'http/protobuf'
        }
        this.protocol = protocol
      }
      /**
       * Groups items by instrumentation scope (name, version, schemaUrl, and attributes).
       * @param {Array} items - Array of items to group
       * @returns {Map<string, Array>} Map of instrumentation scope key to items
       * @protected
       */
      groupByInstrumentationScope(items) {
        const grouped = /* @__PURE__ */ new Map()
        for (const item of items) {
          const instrumentationScope = item.instrumentationScope || {
            name: '',
            version: '',
            schemaUrl: '',
            attributes: {},
          }
          const attrsKey = stableStringify(instrumentationScope.attributes || {})
          const key = `${instrumentationScope.name}@${instrumentationScope.version}@${instrumentationScope.schemaUrl}@${attrsKey}`
          const group = grouped.get(key)
          if (group === void 0) {
            grouped.set(key, [item])
          } else {
            group.push(item)
          }
        }
        return grouped
      }
      /**
       * Transforms resource attributes to OTLP resource format.
       * @returns {Object} OTLP resource object
       * @protected
       */
      transformResource() {
        return {
          attributes: this.#resourceAttributes,
          droppedAttributesCount: 0,
        }
      }
      /**
       * Transforms attributes to OTLP KeyValue format.
       * @param {Object} attributes - Attributes to transform
       * @returns {Object[]} Array of OTLP KeyValue objects
       * @protected
       */
      transformAttributes(attributes) {
        return Object.entries(attributes).map(([key, value]) => ({
          key,
          value: this.transformAnyValue(value),
        }))
      }
      /**
       * Transforms attributes to JSON format (simplified).
       * @param {Object} attributes - Attributes to transform
       * @returns {Object[]} Array of OTLP KeyValue objects with string values
       * @protected
       */
      attributesToJson(attributes) {
        if (!attributes) return []
        return Object.entries(attributes).map(([key, value]) => ({
          key,
          value: { stringValue: String(value) },
        }))
      }
      /**
       * Transforms any value to OTLP AnyValue format.
       * Supports: strings, numbers (int/double), booleans, arrays.
       * Objects are filtered out by sanitizeAttributes before reaching this method.
       * @param {any} value - Value to transform
       * @returns {Object} OTLP AnyValue object
       * @protected
       */
      transformAnyValue(value) {
        if (typeof value === 'string') {
          return { stringValue: value }
        } else if (typeof value === 'number') {
          if (Number.isInteger(value)) {
            return { intValue: value }
          }
          return { doubleValue: value }
        } else if (typeof value === 'boolean') {
          return { boolValue: value }
        } else if (Array.isArray(value)) {
          return {
            arrayValue: {
              values: value.map((v) => this.transformAnyValue(v)),
            },
          }
        }
        return { stringValue: String(value) }
      }
      /**
       * Serializes data to protobuf format.
       * @param {Object} protoType - Protobuf type from protobuf_loader
       * @param {Object} data - Data to serialize
       * @returns {Buffer} Protobuf-encoded data
       * @protected
       */
      serializeToProtobuf(protoType, data) {
        const message = protoType.create(data)
        const buffer = protoType.encode(message).finish()
        return buffer
      }
      /**
       * Serializes data to JSON format.
       * @param {Object} data - Data to serialize
       * @returns {Buffer} JSON-encoded data
       * @protected
       */
      serializeToJson(data) {
        return Buffer.from(JSON.stringify(data))
      }
    }
    function stableStringify(attributes) {
      if (attributes == null) {
        return JSON.stringify(attributes)
      }
      return Object.keys(attributes)
        .sort()
        .map((key) => `${key}:${JSON.stringify(attributes[key])}`)
        .join(',')
    }
    module2.exports = OtlpTransformerBase
    module2.exports.stableStringify = stableStringify
  },
})

// node_modules/dd-trace/vendor/dist/protobufjs/index.js
var require_protobufjs2 = __commonJS({
  'node_modules/dd-trace/vendor/dist/protobufjs/index.js'(exports, module) {
    ;(() => {
      'use strict'
      var __webpack_modules__ = {
          './@protobufjs/aspromise/index.js': function (e) {
            e.exports = t
            function t(e2, t2) {
              for (var r = Array(arguments.length - 1), o = 0, s = 2, i = true; s < arguments.length; )
                r[o++] = arguments[s++]
              return new Promise(function (s2, n) {
                r[o] = function (e3) {
                  if (i)
                    if (((i = false), e3)) n(e3)
                    else {
                      for (var t3 = Array(arguments.length - 1), r2 = 0; r2 < t3.length; ) t3[r2++] = arguments[r2]
                      s2.apply(null, t3)
                    }
                }
                try {
                  e2.apply(t2 || null, r)
                } catch (e3) {
                  i && ((i = false), n(e3))
                }
              })
            }
          },
          './@protobufjs/base64/index.js': function (e, t) {
            var r = t
            r.length = function (e2) {
              var t2 = e2.length
              if (!t2) return 0
              for (var r2 = 0; --t2 % 4 > 1 && '=' === e2.charAt(t2); ) ++r2
              return Math.ceil(3 * e2.length) / 4 - r2
            }
            for (var o = Array(64), s = Array(123), i = 0; i < 64; )
              s[(o[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : (i - 59) | 43)] = i++
            r.encode = function (e2, t2, r2) {
              for (var s2, i2 = null, n2 = [], u = 0, f = 0; t2 < r2; ) {
                var a = e2[t2++]
                switch (f) {
                  case 0:
                    ;((n2[u++] = o[a >> 2]), (s2 = (3 & a) << 4), (f = 1))
                    break
                  case 1:
                    ;((n2[u++] = o[s2 | (a >> 4)]), (s2 = (15 & a) << 2), (f = 2))
                    break
                  case 2:
                    ;((n2[u++] = o[s2 | (a >> 6)]), (n2[u++] = o[63 & a]), (f = 0))
                }
                u > 8191 && ((i2 || (i2 = [])).push(String.fromCharCode.apply(String, n2)), (u = 0))
              }
              return (f && ((n2[u++] = o[s2]), (n2[u++] = 61), 1 === f && (n2[u++] = 61)), i2)
                ? (u && i2.push(String.fromCharCode.apply(String, n2.slice(0, u))), i2.join(''))
                : String.fromCharCode.apply(String, n2.slice(0, u))
            }
            var n = 'invalid encoding'
            ;((r.decode = function (e2, t2, r2) {
              for (var o2, i2 = r2, u = 0, f = 0; f < e2.length; ) {
                var a = e2.charCodeAt(f++)
                if (61 === a && u > 1) break
                if (void 0 === (a = s[a])) throw Error(n)
                switch (u) {
                  case 0:
                    ;((o2 = a), (u = 1))
                    break
                  case 1:
                    ;((t2[r2++] = (o2 << 2) | ((48 & a) >> 4)), (o2 = a), (u = 2))
                    break
                  case 2:
                    ;((t2[r2++] = ((15 & o2) << 4) | ((60 & a) >> 2)), (o2 = a), (u = 3))
                    break
                  case 3:
                    ;((t2[r2++] = ((3 & o2) << 6) | a), (u = 0))
                }
              }
              if (1 === u) throw Error(n)
              return r2 - i2
            }),
              (r.test = function (e2) {
                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e2)
              }))
          },
          './@protobufjs/codegen/index.js': function (e) {
            function t(e2, r) {
              'string' == typeof e2 && ((r = e2), (e2 = void 0))
              var o = []
              function s(e3) {
                if ('string' != typeof e3) {
                  var r2 = i()
                  if ((t.verbose && console.log('codegen: ' + r2), (r2 = 'return ' + r2), e3)) {
                    for (var n = Object.keys(e3), u = Array(n.length + 1), f = Array(n.length), a = 0; a < n.length; )
                      ((u[a] = n[a]), (f[a] = e3[n[a++]]))
                    return ((u[a] = r2), Function.apply(null, u).apply(null, f))
                  }
                  return Function(r2)()
                }
                for (var l = Array(arguments.length - 1), p = 0; p < l.length; ) l[p] = arguments[++p]
                if (
                  ((p = 0),
                  (e3 = e3.replace(/%([%dfijs])/g, function (e4, t2) {
                    var r3 = l[p++]
                    switch (t2) {
                      case 'd':
                      case 'f':
                        return String(Number(r3))
                      case 'i':
                        return String(Math.floor(r3))
                      case 'j':
                        return JSON.stringify(r3)
                      case 's':
                        return String(r3)
                    }
                    return '%'
                  })),
                  p !== l.length)
                )
                  throw Error('parameter count mismatch')
                return (o.push(e3), s)
              }
              function i(t2) {
                return (
                  'function ' + (t2 || r || '') + '(' + ((e2 && e2.join(',')) || '') + '){\n  ' + o.join('\n  ') + '\n}'
                )
              }
              return ((s.toString = i), s)
            }
            ;((e.exports = t), (t.verbose = false))
          },
          './@protobufjs/eventemitter/index.js': function (e) {
            function t() {
              this._listeners = {}
            }
            ;((e.exports = t),
              (t.prototype.on = function (e2, t2, r) {
                return ((this._listeners[e2] || (this._listeners[e2] = [])).push({ fn: t2, ctx: r || this }), this)
              }),
              (t.prototype.off = function (e2, t2) {
                if (void 0 === e2) this._listeners = {}
                else if (void 0 === t2) this._listeners[e2] = []
                else for (var r = this._listeners[e2], o = 0; o < r.length; ) r[o].fn === t2 ? r.splice(o, 1) : ++o
                return this
              }),
              (t.prototype.emit = function (e2) {
                var t2 = this._listeners[e2]
                if (t2) {
                  for (var r = [], o = 1; o < arguments.length; ) r.push(arguments[o++])
                  for (o = 0; o < t2.length; ) t2[o].fn.apply(t2[o++].ctx, r)
                }
                return this
              }))
          },
          './@protobufjs/fetch/index.js': function (e, t, r) {
            e.exports = i
            var o = r('./@protobufjs/aspromise/index.js'),
              s = r('./@protobufjs/inquire/index.js')('fs')
            function i(e2, t2, r2) {
              return ('function' == typeof t2 ? ((r2 = t2), (t2 = {})) : t2 || (t2 = {}), r2)
                ? !t2.xhr && s && s.readFile
                  ? s.readFile(e2, function (o2, s2) {
                      return o2 && 'undefined' != typeof XMLHttpRequest
                        ? i.xhr(e2, t2, r2)
                        : o2
                          ? r2(o2)
                          : r2(null, t2.binary ? s2 : s2.toString('utf8'))
                    })
                  : i.xhr(e2, t2, r2)
                : o(i, this, e2, t2)
            }
            i.xhr = function (e2, t2, r2) {
              var o2 = new XMLHttpRequest()
              ;((o2.onreadystatechange = function () {
                if (4 === o2.readyState) {
                  if (0 !== o2.status && 200 !== o2.status) return r2(Error('status ' + o2.status))
                  if (t2.binary) {
                    var e3 = o2.response
                    if (!e3) {
                      e3 = []
                      for (var s2 = 0; s2 < o2.responseText.length; ++s2) e3.push(255 & o2.responseText.charCodeAt(s2))
                    }
                    return r2(null, 'undefined' != typeof Uint8Array ? new Uint8Array(e3) : e3)
                  }
                  return r2(null, o2.responseText)
                }
              }),
                t2.binary &&
                  ('overrideMimeType' in o2 && o2.overrideMimeType('text/plain; charset=x-user-defined'),
                  (o2.responseType = 'arraybuffer')),
                o2.open('GET', e2),
                o2.send())
            }
          },
          './@protobufjs/float/index.js': function (e) {
            function t(e2) {
              return (
                'undefined' != typeof Float32Array
                  ? !(function () {
                      var t2 = new Float32Array([-0]),
                        r2 = new Uint8Array(t2.buffer),
                        o2 = 128 === r2[3]
                      function s2(e3, o3, s3) {
                        ;((t2[0] = e3),
                          (o3[s3] = r2[0]),
                          (o3[s3 + 1] = r2[1]),
                          (o3[s3 + 2] = r2[2]),
                          (o3[s3 + 3] = r2[3]))
                      }
                      function i2(e3, o3, s3) {
                        ;((t2[0] = e3),
                          (o3[s3] = r2[3]),
                          (o3[s3 + 1] = r2[2]),
                          (o3[s3 + 2] = r2[1]),
                          (o3[s3 + 3] = r2[0]))
                      }
                      function n(e3, o3) {
                        return (
                          (r2[0] = e3[o3]),
                          (r2[1] = e3[o3 + 1]),
                          (r2[2] = e3[o3 + 2]),
                          (r2[3] = e3[o3 + 3]),
                          t2[0]
                        )
                      }
                      function u(e3, o3) {
                        return (
                          (r2[3] = e3[o3]),
                          (r2[2] = e3[o3 + 1]),
                          (r2[1] = e3[o3 + 2]),
                          (r2[0] = e3[o3 + 3]),
                          t2[0]
                        )
                      }
                      ;((e2.writeFloatLE = o2 ? s2 : i2),
                        (e2.writeFloatBE = o2 ? i2 : s2),
                        (e2.readFloatLE = o2 ? n : u),
                        (e2.readFloatBE = o2 ? u : n))
                    })()
                  : !(function () {
                      function t2(e3, t3, r2, o2) {
                        var s2 = +(t3 < 0)
                        if ((s2 && (t3 = -t3), 0 === t3)) e3(1 / t3 > 0 ? 0 : 2147483648, r2, o2)
                        else if (isNaN(t3)) e3(2143289344, r2, o2)
                        else if (t3 > 34028234663852886e22) e3(((s2 << 31) | 2139095040) >>> 0, r2, o2)
                        else if (t3 < 11754943508222875e-54)
                          e3(((s2 << 31) | Math.round(t3 / 1401298464324817e-60)) >>> 0, r2, o2)
                        else {
                          var i2 = Math.floor(Math.log(t3) / Math.LN2),
                            n2 = 8388607 & Math.round(t3 * Math.pow(2, -i2) * 8388608)
                          e3(((s2 << 31) | ((i2 + 127) << 23) | n2) >>> 0, r2, o2)
                        }
                      }
                      function n(e3, t3, r2) {
                        var o2 = e3(t3, r2),
                          s2 = (o2 >> 31) * 2 + 1,
                          i2 = (o2 >>> 23) & 255,
                          n2 = 8388607 & o2
                        return 255 === i2
                          ? n2
                            ? NaN
                            : (1 / 0) * s2
                          : 0 === i2
                            ? 1401298464324817e-60 * s2 * n2
                            : s2 * Math.pow(2, i2 - 150) * (n2 + 8388608)
                      }
                      ;((e2.writeFloatLE = t2.bind(null, r)),
                        (e2.writeFloatBE = t2.bind(null, o)),
                        (e2.readFloatLE = n.bind(null, s)),
                        (e2.readFloatBE = n.bind(null, i)))
                    })(),
                'undefined' != typeof Float64Array
                  ? !(function () {
                      var t2 = new Float64Array([-0]),
                        r2 = new Uint8Array(t2.buffer),
                        o2 = 128 === r2[7]
                      function s2(e3, o3, s3) {
                        ;((t2[0] = e3),
                          (o3[s3] = r2[0]),
                          (o3[s3 + 1] = r2[1]),
                          (o3[s3 + 2] = r2[2]),
                          (o3[s3 + 3] = r2[3]),
                          (o3[s3 + 4] = r2[4]),
                          (o3[s3 + 5] = r2[5]),
                          (o3[s3 + 6] = r2[6]),
                          (o3[s3 + 7] = r2[7]))
                      }
                      function i2(e3, o3, s3) {
                        ;((t2[0] = e3),
                          (o3[s3] = r2[7]),
                          (o3[s3 + 1] = r2[6]),
                          (o3[s3 + 2] = r2[5]),
                          (o3[s3 + 3] = r2[4]),
                          (o3[s3 + 4] = r2[3]),
                          (o3[s3 + 5] = r2[2]),
                          (o3[s3 + 6] = r2[1]),
                          (o3[s3 + 7] = r2[0]))
                      }
                      function n(e3, o3) {
                        return (
                          (r2[0] = e3[o3]),
                          (r2[1] = e3[o3 + 1]),
                          (r2[2] = e3[o3 + 2]),
                          (r2[3] = e3[o3 + 3]),
                          (r2[4] = e3[o3 + 4]),
                          (r2[5] = e3[o3 + 5]),
                          (r2[6] = e3[o3 + 6]),
                          (r2[7] = e3[o3 + 7]),
                          t2[0]
                        )
                      }
                      function u(e3, o3) {
                        return (
                          (r2[7] = e3[o3]),
                          (r2[6] = e3[o3 + 1]),
                          (r2[5] = e3[o3 + 2]),
                          (r2[4] = e3[o3 + 3]),
                          (r2[3] = e3[o3 + 4]),
                          (r2[2] = e3[o3 + 5]),
                          (r2[1] = e3[o3 + 6]),
                          (r2[0] = e3[o3 + 7]),
                          t2[0]
                        )
                      }
                      ;((e2.writeDoubleLE = o2 ? s2 : i2),
                        (e2.writeDoubleBE = o2 ? i2 : s2),
                        (e2.readDoubleLE = o2 ? n : u),
                        (e2.readDoubleBE = o2 ? u : n))
                    })()
                  : !(function () {
                      function t2(e3, t3, r2, o2, s2, i2) {
                        var n2,
                          u = +(o2 < 0)
                        if ((u && (o2 = -o2), 0 === o2))
                          (e3(0, s2, i2 + t3), e3(1 / o2 > 0 ? 0 : 2147483648, s2, i2 + r2))
                        else if (isNaN(o2)) (e3(0, s2, i2 + t3), e3(2146959360, s2, i2 + r2))
                        else if (o2 > 17976931348623157e292)
                          (e3(0, s2, i2 + t3), e3(((u << 31) | 2146435072) >>> 0, s2, i2 + r2))
                        else if (o2 < 22250738585072014e-324)
                          (e3((n2 = o2 / 5e-324) >>> 0, s2, i2 + t3),
                            e3(((u << 31) | (n2 / 4294967296)) >>> 0, s2, i2 + r2))
                        else {
                          var f = Math.floor(Math.log(o2) / Math.LN2)
                          ;(1024 === f && (f = 1023),
                            e3((4503599627370496 * (n2 = o2 * Math.pow(2, -f))) >>> 0, s2, i2 + t3),
                            e3(((u << 31) | ((f + 1023) << 20) | ((1048576 * n2) & 1048575)) >>> 0, s2, i2 + r2))
                        }
                      }
                      function n(e3, t3, r2, o2, s2) {
                        var i2 = e3(o2, s2 + t3),
                          n2 = e3(o2, s2 + r2),
                          u = (n2 >> 31) * 2 + 1,
                          f = (n2 >>> 20) & 2047,
                          a = 4294967296 * (1048575 & n2) + i2
                        return 2047 === f
                          ? a
                            ? NaN
                            : (1 / 0) * u
                          : 0 === f
                            ? 5e-324 * u * a
                            : u * Math.pow(2, f - 1075) * (a + 4503599627370496)
                      }
                      ;((e2.writeDoubleLE = t2.bind(null, r, 0, 4)),
                        (e2.writeDoubleBE = t2.bind(null, o, 4, 0)),
                        (e2.readDoubleLE = n.bind(null, s, 0, 4)),
                        (e2.readDoubleBE = n.bind(null, i, 4, 0)))
                    })(),
                e2
              )
            }
            function r(e2, t2, r2) {
              ;((t2[r2] = 255 & e2),
                (t2[r2 + 1] = (e2 >>> 8) & 255),
                (t2[r2 + 2] = (e2 >>> 16) & 255),
                (t2[r2 + 3] = e2 >>> 24))
            }
            function o(e2, t2, r2) {
              ;((t2[r2] = e2 >>> 24),
                (t2[r2 + 1] = (e2 >>> 16) & 255),
                (t2[r2 + 2] = (e2 >>> 8) & 255),
                (t2[r2 + 3] = 255 & e2))
            }
            function s(e2, t2) {
              return (e2[t2] | (e2[t2 + 1] << 8) | (e2[t2 + 2] << 16) | (e2[t2 + 3] << 24)) >>> 0
            }
            function i(e2, t2) {
              return ((e2[t2] << 24) | (e2[t2 + 1] << 16) | (e2[t2 + 2] << 8) | e2[t2 + 3]) >>> 0
            }
            e.exports = t(t)
          },
          './@protobufjs/inquire/index.js': function (module) {
            module.exports = inquire
            function inquire(moduleName) {
              try {
                var mod = eval('quire'.replace(/^/, 're'))(moduleName)
                if (mod && (mod.length || Object.keys(mod).length)) return mod
              } catch (e) {}
              return null
            }
          },
          './@protobufjs/path/index.js': function (e, t) {
            var r = t,
              o = (r.isAbsolute = function (e2) {
                return /^(?:\/|\w+:)/.test(e2)
              }),
              s = (r.normalize = function (e2) {
                var t2 = (e2 = e2.replace(/\\/g, '/').replace(/\/{2,}/g, '/')).split('/'),
                  r2 = o(e2),
                  s2 = ''
                r2 && (s2 = t2.shift() + '/')
                for (var i = 0; i < t2.length; )
                  '..' === t2[i]
                    ? i > 0 && '..' !== t2[i - 1]
                      ? t2.splice(--i, 2)
                      : r2
                        ? t2.splice(i, 1)
                        : ++i
                    : '.' === t2[i]
                      ? t2.splice(i, 1)
                      : ++i
                return s2 + t2.join('/')
              })
            r.resolve = function (e2, t2, r2) {
              return (r2 || (t2 = s(t2)), o(t2))
                ? t2
                : (r2 || (e2 = s(e2)), (e2 = e2.replace(/(?:\/|^)[^/]+$/, '')).length ? s(e2 + '/' + t2) : t2)
            }
          },
          './@protobufjs/pool/index.js': function (e) {
            e.exports = t
            function t(e2, t2, r) {
              var o = r || 8192,
                s = o >>> 1,
                i = null,
                n = o
              return function (r2) {
                if (r2 < 1 || r2 > s) return e2(r2)
                n + r2 > o && ((i = e2(o)), (n = 0))
                var u = t2.call(i, n, (n += r2))
                return (7 & n && (n = (7 | n) + 1), u)
              }
            }
          },
          './@protobufjs/utf8/index.js': function (e, t) {
            var r = t
            ;((r.length = function (e2) {
              for (var t2 = 0, r2 = 0, o = 0; o < e2.length; ++o)
                (r2 = e2.charCodeAt(o)) < 128
                  ? (t2 += 1)
                  : r2 < 2048
                    ? (t2 += 2)
                    : (64512 & r2) == 55296 && (64512 & e2.charCodeAt(o + 1)) == 56320
                      ? (++o, (t2 += 4))
                      : (t2 += 3)
              return t2
            }),
              (r.read = function (e2, t2, r2) {
                if (r2 - t2 < 1) return ''
                for (var o, s = null, i = [], n = 0; t2 < r2; )
                  ((o = e2[t2++]) < 128
                    ? (i[n++] = o)
                    : o > 191 && o < 224
                      ? (i[n++] = ((31 & o) << 6) | (63 & e2[t2++]))
                      : o > 239 && o < 365
                        ? ((o =
                            (((7 & o) << 18) | ((63 & e2[t2++]) << 12) | ((63 & e2[t2++]) << 6) | (63 & e2[t2++])) -
                            65536),
                          (i[n++] = 55296 + (o >> 10)),
                          (i[n++] = 56320 + (1023 & o)))
                        : (i[n++] = ((15 & o) << 12) | ((63 & e2[t2++]) << 6) | (63 & e2[t2++])),
                    n > 8191 && ((s || (s = [])).push(String.fromCharCode.apply(String, i)), (n = 0)))
                return s
                  ? (n && s.push(String.fromCharCode.apply(String, i.slice(0, n))), s.join(''))
                  : String.fromCharCode.apply(String, i.slice(0, n))
              }),
              (r.write = function (e2, t2, r2) {
                for (var o, s, i = r2, n = 0; n < e2.length; ++n)
                  (o = e2.charCodeAt(n)) < 128
                    ? (t2[r2++] = o)
                    : (o < 2048
                        ? (t2[r2++] = (o >> 6) | 192)
                        : ((64512 & o) == 55296 && (64512 & (s = e2.charCodeAt(n + 1))) == 56320
                            ? ((o = 65536 + ((1023 & o) << 10) + (1023 & s)),
                              ++n,
                              (t2[r2++] = (o >> 18) | 240),
                              (t2[r2++] = ((o >> 12) & 63) | 128))
                            : (t2[r2++] = (o >> 12) | 224),
                          (t2[r2++] = ((o >> 6) & 63) | 128)),
                      (t2[r2++] = (63 & o) | 128))
                return r2 - i
              }))
          },
          './protobufjs/index.js': function (e, t, r) {
            e.exports = r('./protobufjs/src/index.js')
          },
          './protobufjs/src/common.js': function (e) {
            e.exports = o
            var t,
              r = /\/|\./
            function o(e2, t2) {
              ;(r.test(e2) ||
                ((e2 = 'google/protobuf/' + e2 + '.proto'),
                (t2 = { nested: { google: { nested: { protobuf: { nested: t2 } } } } })),
                (o[e2] = t2))
            }
            ;(o('any', { Any: { fields: { type_url: { type: 'string', id: 1 }, value: { type: 'bytes', id: 2 } } } }),
              o('duration', {
                Duration: (t = { fields: { seconds: { type: 'int64', id: 1 }, nanos: { type: 'int32', id: 2 } } }),
              }),
              o('timestamp', { Timestamp: t }),
              o('empty', { Empty: { fields: {} } }),
              o('struct', {
                Struct: { fields: { fields: { keyType: 'string', type: 'Value', id: 1 } } },
                Value: {
                  oneofs: {
                    kind: {
                      oneof: ['nullValue', 'numberValue', 'stringValue', 'boolValue', 'structValue', 'listValue'],
                    },
                  },
                  fields: {
                    nullValue: { type: 'NullValue', id: 1 },
                    numberValue: { type: 'double', id: 2 },
                    stringValue: { type: 'string', id: 3 },
                    boolValue: { type: 'bool', id: 4 },
                    structValue: { type: 'Struct', id: 5 },
                    listValue: { type: 'ListValue', id: 6 },
                  },
                },
                NullValue: { values: { NULL_VALUE: 0 } },
                ListValue: { fields: { values: { rule: 'repeated', type: 'Value', id: 1 } } },
              }),
              o('wrappers', {
                DoubleValue: { fields: { value: { type: 'double', id: 1 } } },
                FloatValue: { fields: { value: { type: 'float', id: 1 } } },
                Int64Value: { fields: { value: { type: 'int64', id: 1 } } },
                UInt64Value: { fields: { value: { type: 'uint64', id: 1 } } },
                Int32Value: { fields: { value: { type: 'int32', id: 1 } } },
                UInt32Value: { fields: { value: { type: 'uint32', id: 1 } } },
                BoolValue: { fields: { value: { type: 'bool', id: 1 } } },
                StringValue: { fields: { value: { type: 'string', id: 1 } } },
                BytesValue: { fields: { value: { type: 'bytes', id: 1 } } },
              }),
              o('field_mask', { FieldMask: { fields: { paths: { rule: 'repeated', type: 'string', id: 1 } } } }),
              (o.get = function (e2) {
                return o[e2] || null
              }))
          },
          './protobufjs/src/converter.js': function (e, t, r) {
            var o = t,
              s = r('./protobufjs/src/enum.js'),
              i = r('./protobufjs/src/util.js')
            function n(e2, t2, r2, o2) {
              var i2 = false
              if (t2.resolvedType)
                if (t2.resolvedType instanceof s) {
                  e2('switch(d%s){', o2)
                  for (var n2 = t2.resolvedType.values, u2 = Object.keys(n2), f = 0; f < u2.length; ++f)
                    (n2[u2[f]] !== t2.typeDefault ||
                      i2 ||
                      (e2('default:')('if(typeof(d%s)==="number"){m%s=d%s;break}', o2, o2, o2),
                      t2.repeated || e2('break'),
                      (i2 = true)),
                      e2('case%j:', u2[f])('case %i:', n2[u2[f]])('m%s=%j', o2, n2[u2[f]])('break'))
                  e2('}')
                } else
                  e2('if(typeof d%s!=="object")', o2)('throw TypeError(%j)', t2.fullName + ': object expected')(
                    'm%s=types[%i].fromObject(d%s)',
                    o2,
                    r2,
                    o2
                  )
              else {
                var a = false
                switch (t2.type) {
                  case 'double':
                  case 'float':
                    e2('m%s=Number(d%s)', o2, o2)
                    break
                  case 'uint32':
                  case 'fixed32':
                    e2('m%s=d%s>>>0', o2, o2)
                    break
                  case 'int32':
                  case 'sint32':
                  case 'sfixed32':
                    e2('m%s=d%s|0', o2, o2)
                    break
                  case 'uint64':
                    a = true
                  case 'int64':
                  case 'sint64':
                  case 'fixed64':
                  case 'sfixed64':
                    e2('if(util.Long)')('(m%s=util.Long.fromValue(d%s)).unsigned=%j', o2, o2, a)(
                      'else if(typeof d%s==="string")',
                      o2
                    )(
                      'm%s=parseInt(d%s,10)',
                      o2,
                      o2
                    )('else if(typeof d%s==="number")', o2)(
                      'm%s=d%s',
                      o2,
                      o2
                    )('else if(typeof d%s==="object")', o2)(
                      'm%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)',
                      o2,
                      o2,
                      o2,
                      a ? 'true' : ''
                    )
                    break
                  case 'bytes':
                    e2('if(typeof d%s==="string")', o2)(
                      'util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)',
                      o2,
                      o2,
                      o2
                    )('else if(d%s.length >= 0)', o2)('m%s=d%s', o2, o2)
                    break
                  case 'string':
                    e2('m%s=String(d%s)', o2, o2)
                    break
                  case 'bool':
                    e2('m%s=Boolean(d%s)', o2, o2)
                }
              }
              return e2
            }
            function u(e2, t2, r2, o2) {
              if (t2.resolvedType)
                t2.resolvedType instanceof s
                  ? e2(
                      'd%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s',
                      o2,
                      r2,
                      o2,
                      o2,
                      r2,
                      o2,
                      o2
                    )
                  : e2('d%s=types[%i].toObject(m%s,o)', o2, r2, o2)
              else {
                var i2 = false
                switch (t2.type) {
                  case 'double':
                  case 'float':
                    e2('d%s=o.json&&!isFinite(m%s)?String(m%s):m%s', o2, o2, o2, o2)
                    break
                  case 'uint64':
                    i2 = true
                  case 'int64':
                  case 'sint64':
                  case 'fixed64':
                  case 'sfixed64':
                    e2('if(typeof m%s==="number")', o2)('d%s=o.longs===String?String(m%s):m%s', o2, o2, o2)('else')(
                      'd%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s',
                      o2,
                      o2,
                      o2,
                      o2,
                      i2 ? 'true' : '',
                      o2
                    )
                    break
                  case 'bytes':
                    e2(
                      'd%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s',
                      o2,
                      o2,
                      o2,
                      o2,
                      o2
                    )
                    break
                  default:
                    e2('d%s=m%s', o2, o2)
                }
              }
              return e2
            }
            ;((o.fromObject = function (e2) {
              var t2 = e2.fieldsArray,
                r2 = i.codegen(['d'], e2.name + '$fromObject')('if(d instanceof this.ctor)')('return d')
              if (!t2.length) return r2('return new this.ctor')
              r2('var m=new this.ctor')
              for (var o2 = 0; o2 < t2.length; ++o2) {
                var u2 = t2[o2].resolve(),
                  f = i.safeProp(u2.name)
                u2.map
                  ? (r2('if(d%s){', f)('if(typeof d%s!=="object")', f)(
                      'throw TypeError(%j)',
                      u2.fullName + ': object expected'
                    )('m%s={}', f)('for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){', f),
                    n(r2, u2, o2, f + '[ks[i]]')('}')('}'))
                  : u2.repeated
                    ? (r2('if(d%s){', f)('if(!Array.isArray(d%s))', f)(
                        'throw TypeError(%j)',
                        u2.fullName + ': array expected'
                      )('m%s=[]', f)('for(var i=0;i<d%s.length;++i){', f),
                      n(r2, u2, o2, f + '[i]')('}')('}'))
                    : (u2.resolvedType instanceof s || r2('if(d%s!=null){', f),
                      n(r2, u2, o2, f),
                      u2.resolvedType instanceof s || r2('}'))
              }
              return r2('return m')
            }),
              (o.toObject = function (e2) {
                var t2 = e2.fieldsArray.slice().sort(i.compareFieldsById)
                if (!t2.length) return i.codegen()('return {}')
                for (
                  var r2 = i.codegen(['m', 'o'], e2.name + '$toObject')('if(!o)')('o={}')('var d={}'),
                    o2 = [],
                    n2 = [],
                    f = [],
                    a = 0;
                  a < t2.length;
                  ++a
                )
                  t2[a].partOf || (t2[a].resolve().repeated ? o2 : t2[a].map ? n2 : f).push(t2[a])
                if (o2.length) {
                  for (r2('if(o.arrays||o.defaults){'), a = 0; a < o2.length; ++a) r2('d%s=[]', i.safeProp(o2[a].name))
                  r2('}')
                }
                if (n2.length) {
                  for (r2('if(o.objects||o.defaults){'), a = 0; a < n2.length; ++a) r2('d%s={}', i.safeProp(n2[a].name))
                  r2('}')
                }
                if (f.length) {
                  for (r2('if(o.defaults){'), a = 0; a < f.length; ++a) {
                    var l = f[a],
                      p = i.safeProp(l.name)
                    if (l.resolvedType instanceof s)
                      r2('d%s=o.enums===String?%j:%j', p, l.resolvedType.valuesById[l.typeDefault], l.typeDefault)
                    else if (l.long)
                      r2('if(util.Long){')(
                        'var n=new util.Long(%i,%i,%j)',
                        l.typeDefault.low,
                        l.typeDefault.high,
                        l.typeDefault.unsigned
                      )(
                        'd%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n',
                        p
                      )('}else')('d%s=o.longs===String?%j:%i', p, l.typeDefault.toString(), l.typeDefault.toNumber())
                    else if (l.bytes) {
                      var c = '[' + Array.prototype.slice.call(l.typeDefault).join(',') + ']'
                      r2('if(o.bytes===String)d%s=%j', p, String.fromCharCode.apply(String, l.typeDefault))('else{')(
                        'd%s=%s',
                        p,
                        c
                      )(
                        'if(o.bytes!==Array)d%s=util.newBuffer(d%s)',
                        p,
                        p
                      )('}')
                    } else r2('d%s=%j', p, l.typeDefault)
                  }
                  r2('}')
                }
                var h = false
                for (a = 0; a < t2.length; ++a) {
                  var l = t2[a],
                    d = e2._fieldsArray.indexOf(l),
                    p = i.safeProp(l.name)
                  ;(l.map
                    ? (h || ((h = true), r2('var ks2')),
                      r2('if(m%s&&(ks2=Object.keys(m%s)).length){', p, p)('d%s={}', p)(
                        'for(var j=0;j<ks2.length;++j){'
                      ),
                      u(r2, l, d, p + '[ks2[j]]')('}'))
                    : l.repeated
                      ? (r2('if(m%s&&m%s.length){', p, p)('d%s=[]', p)('for(var j=0;j<m%s.length;++j){', p),
                        u(r2, l, d, p + '[j]')('}'))
                      : (r2('if(m%s!=null&&m.hasOwnProperty(%j)){', p, l.name),
                        u(r2, l, d, p),
                        l.partOf && r2('if(o.oneofs)')('d%s=%j', i.safeProp(l.partOf.name), l.name)),
                    r2('}'))
                }
                return r2('return d')
              }))
          },
          './protobufjs/src/decoder.js': function (e, t, r) {
            e.exports = u
            var o = r('./protobufjs/src/enum.js'),
              s = r('./protobufjs/src/types.js'),
              i = r('./protobufjs/src/util.js')
            function n(e2) {
              return "missing required '" + e2.name + "'"
            }
            function u(e2) {
              for (
                var t2 = i.codegen(['r', 'l', 'e'], e2.name + '$decode')('if(!(r instanceof Reader))')(
                    'r=Reader.create(r)'
                  )(
                    'var c=l===undefined?r.len:r.pos+l,m=new this.ctor' +
                      (e2.fieldsArray.filter(function (e3) {
                        return e3.map
                      }).length
                        ? ',k,value'
                        : '')
                  )('while(r.pos<c){')('var t=r.uint32()')('if(t===e)')('break')('switch(t>>>3){'),
                  r2 = 0;
                r2 < e2.fieldsArray.length;
                ++r2
              ) {
                var u2 = e2._fieldsArray[r2].resolve(),
                  f = u2.resolvedType instanceof o ? 'int32' : u2.type,
                  a = 'm' + i.safeProp(u2.name)
                ;(t2('case %i: {', u2.id),
                  u2.map
                    ? (t2('if(%s===util.emptyObject)', a)('%s={}', a)('var c2 = r.uint32()+r.pos'),
                      void 0 !== s.defaults[u2.keyType] ? t2('k=%j', s.defaults[u2.keyType]) : t2('k=null'),
                      void 0 !== s.defaults[f] ? t2('value=%j', s.defaults[f]) : t2('value=null'),
                      t2('while(r.pos<c2){')('var tag2=r.uint32()')('switch(tag2>>>3){')(
                        'case 1: k=r.%s(); break',
                        u2.keyType
                      )('case 2:'),
                      void 0 === s.basic[f] ? t2('value=types[%i].decode(r,r.uint32())', r2) : t2('value=r.%s()', f),
                      t2('break')('default:')('r.skipType(tag2&7)')('break')('}')('}'),
                      void 0 !== s.long[u2.keyType]
                        ? t2('%s[typeof k==="object"?util.longToHash(k):k]=value', a)
                        : t2('%s[k]=value', a))
                    : u2.repeated
                      ? (t2('if(!(%s&&%s.length))', a, a)('%s=[]', a),
                        void 0 !== s.packed[f] &&
                          t2('if((t&7)===2){')('var c2=r.uint32()+r.pos')('while(r.pos<c2)')('%s.push(r.%s())', a, f)(
                            '}else'
                          ),
                        void 0 === s.basic[f]
                          ? t2(
                              u2.delimited
                                ? '%s.push(types[%i].decode(r,undefined,((t&~7)|4)))'
                                : '%s.push(types[%i].decode(r,r.uint32()))',
                              a,
                              r2
                            )
                          : t2('%s.push(r.%s())', a, f))
                      : void 0 === s.basic[f]
                        ? t2(
                            u2.delimited
                              ? '%s=types[%i].decode(r,undefined,((t&~7)|4))'
                              : '%s=types[%i].decode(r,r.uint32())',
                            a,
                            r2
                          )
                        : t2('%s=r.%s()', a, f),
                  t2('break')('}'))
              }
              for (t2('default:')('r.skipType(t&7)')('break')('}')('}'), r2 = 0; r2 < e2._fieldsArray.length; ++r2) {
                var l = e2._fieldsArray[r2]
                l.required && t2('if(!m.hasOwnProperty(%j))', l.name)('throw util.ProtocolError(%j,{instance:m})', n(l))
              }
              return t2('return m')
            }
          },
          './protobufjs/src/encoder.js': function (e, t, r) {
            e.exports = u
            var o = r('./protobufjs/src/enum.js'),
              s = r('./protobufjs/src/types.js'),
              i = r('./protobufjs/src/util.js')
            function n(e2, t2, r2, o2) {
              return t2.delimited
                ? e2(
                    'types[%i].encode(%s,w.uint32(%i)).uint32(%i)',
                    r2,
                    o2,
                    ((t2.id << 3) | 3) >>> 0,
                    ((t2.id << 3) | 4) >>> 0
                  )
                : e2('types[%i].encode(%s,w.uint32(%i).fork()).ldelim()', r2, o2, ((t2.id << 3) | 2) >>> 0)
            }
            function u(e2) {
              for (
                var t2,
                  r2,
                  u2 = i.codegen(['m', 'w'], e2.name + '$encode')('if(!w)')('w=Writer.create()'),
                  f = e2.fieldsArray.slice().sort(i.compareFieldsById),
                  t2 = 0;
                t2 < f.length;
                ++t2
              ) {
                var a = f[t2].resolve(),
                  l = e2._fieldsArray.indexOf(a),
                  p = a.resolvedType instanceof o ? 'int32' : a.type,
                  c = s.basic[p]
                ;((r2 = 'm' + i.safeProp(a.name)),
                  a.map
                    ? (u2(
                        'if(%s!=null&&Object.hasOwnProperty.call(m,%j)){',
                        r2,
                        a.name
                      )('for(var ks=Object.keys(%s),i=0;i<ks.length;++i){', r2)(
                        'w.uint32(%i).fork().uint32(%i).%s(ks[i])',
                        ((a.id << 3) | 2) >>> 0,
                        8 | s.mapKey[a.keyType],
                        a.keyType
                      ),
                      void 0 === c
                        ? u2('types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()', l, r2)
                        : u2('.uint32(%i).%s(%s[ks[i]]).ldelim()', 16 | c, p, r2),
                      u2('}')('}'))
                    : a.repeated
                      ? (u2('if(%s!=null&&%s.length){', r2, r2),
                        a.packed && void 0 !== s.packed[p]
                          ? u2('w.uint32(%i).fork()', ((a.id << 3) | 2) >>> 0)('for(var i=0;i<%s.length;++i)', r2)(
                              'w.%s(%s[i])',
                              p,
                              r2
                            )('w.ldelim()')
                          : (u2('for(var i=0;i<%s.length;++i)', r2),
                            void 0 === c
                              ? n(u2, a, l, r2 + '[i]')
                              : u2('w.uint32(%i).%s(%s[i])', ((a.id << 3) | c) >>> 0, p, r2)),
                        u2('}'))
                      : (a.optional && u2('if(%s!=null&&Object.hasOwnProperty.call(m,%j))', r2, a.name),
                        void 0 === c ? n(u2, a, l, r2) : u2('w.uint32(%i).%s(%s)', ((a.id << 3) | c) >>> 0, p, r2)))
              }
              return u2('return w')
            }
          },
          './protobufjs/src/enum.js': function (e, t, r) {
            e.exports = n
            var o = r('./protobufjs/src/object.js')
            ;((n.prototype = Object.create(o.prototype)).constructor = n).className = 'Enum'
            var s = r('./protobufjs/src/namespace.js'),
              i = r('./protobufjs/src/util.js')
            function n(e2, t2, r2, s2, i2, n2) {
              if ((o.call(this, e2, r2), t2 && 'object' != typeof t2)) throw TypeError('values must be an object')
              if (
                ((this.valuesById = {}),
                (this.values = Object.create(this.valuesById)),
                (this.comment = s2),
                (this.comments = i2 || {}),
                (this.valuesOptions = n2),
                (this._valuesFeatures = {}),
                (this.reserved = void 0),
                t2)
              )
                for (var u = Object.keys(t2), f = 0; f < u.length; ++f)
                  'number' == typeof t2[u[f]] && (this.valuesById[(this.values[u[f]] = t2[u[f]])] = u[f])
            }
            ;((n.prototype._resolveFeatures = function (e2) {
              return (
                (e2 = this._edition || e2),
                o.prototype._resolveFeatures.call(this, e2),
                Object.keys(this.values).forEach((e3) => {
                  var t2 = Object.assign({}, this._features)
                  this._valuesFeatures[e3] = Object.assign(
                    t2,
                    this.valuesOptions && this.valuesOptions[e3] && this.valuesOptions[e3].features
                  )
                }),
                this
              )
            }),
              (n.fromJSON = function (e2, t2) {
                var r2 = new n(e2, t2.values, t2.options, t2.comment, t2.comments)
                return (
                  (r2.reserved = t2.reserved),
                  t2.edition && (r2._edition = t2.edition),
                  (r2._defaultEdition = 'proto3'),
                  r2
                )
              }),
              (n.prototype.toJSON = function (e2) {
                var t2 = !!e2 && !!e2.keepComments
                return i.toObject([
                  'edition',
                  this._editionToJSON(),
                  'options',
                  this.options,
                  'valuesOptions',
                  this.valuesOptions,
                  'values',
                  this.values,
                  'reserved',
                  this.reserved && this.reserved.length ? this.reserved : void 0,
                  'comment',
                  t2 ? this.comment : void 0,
                  'comments',
                  t2 ? this.comments : void 0,
                ])
              }),
              (n.prototype.add = function (e2, t2, r2, o2) {
                if (!i.isString(e2)) throw TypeError('name must be a string')
                if (!i.isInteger(t2)) throw TypeError('id must be an integer')
                if (void 0 !== this.values[e2]) throw Error("duplicate name '" + e2 + "' in " + this)
                if (this.isReservedId(t2)) throw Error('id ' + t2 + ' is reserved in ' + this)
                if (this.isReservedName(e2)) throw Error("name '" + e2 + "' is reserved in " + this)
                if (void 0 !== this.valuesById[t2]) {
                  if (!(this.options && this.options.allow_alias)) throw Error('duplicate id ' + t2 + ' in ' + this)
                  this.values[e2] = t2
                } else this.valuesById[(this.values[e2] = t2)] = e2
                return (
                  o2 &&
                    (void 0 === this.valuesOptions && (this.valuesOptions = {}), (this.valuesOptions[e2] = o2 || null)),
                  (this.comments[e2] = r2 || null),
                  this
                )
              }),
              (n.prototype.remove = function (e2) {
                if (!i.isString(e2)) throw TypeError('name must be a string')
                var t2 = this.values[e2]
                if (null == t2) throw Error("name '" + e2 + "' does not exist in " + this)
                return (
                  delete this.valuesById[t2],
                  delete this.values[e2],
                  delete this.comments[e2],
                  this.valuesOptions && delete this.valuesOptions[e2],
                  this
                )
              }),
              (n.prototype.isReservedId = function (e2) {
                return s.isReservedId(this.reserved, e2)
              }),
              (n.prototype.isReservedName = function (e2) {
                return s.isReservedName(this.reserved, e2)
              }))
          },
          './protobufjs/src/field.js': function (e, t, r) {
            e.exports = a
            var o,
              s = r('./protobufjs/src/object.js')
            ;((a.prototype = Object.create(s.prototype)).constructor = a).className = 'Field'
            var i = r('./protobufjs/src/enum.js'),
              n = r('./protobufjs/src/types.js'),
              u = r('./protobufjs/src/util.js'),
              f = /^required|optional|repeated$/
            function a(e2, t2, r2, o2, i2, a2, l) {
              if (
                (u.isObject(o2)
                  ? ((l = i2), (a2 = o2), (o2 = i2 = void 0))
                  : u.isObject(i2) && ((l = a2), (a2 = i2), (i2 = void 0)),
                s.call(this, e2, a2),
                !u.isInteger(t2) || t2 < 0)
              )
                throw TypeError('id must be a non-negative integer')
              if (!u.isString(r2)) throw TypeError('type must be a string')
              if (void 0 !== o2 && !f.test((o2 = o2.toString().toLowerCase())))
                throw TypeError('rule must be a string rule')
              if (void 0 !== i2 && !u.isString(i2)) throw TypeError('extend must be a string')
              ;('proto3_optional' === o2 && (o2 = 'optional'),
                (this.rule = o2 && 'optional' !== o2 ? o2 : void 0),
                (this.type = r2),
                (this.id = t2),
                (this.extend = i2 || void 0),
                (this.repeated = 'repeated' === o2),
                (this.map = false),
                (this.message = null),
                (this.partOf = null),
                (this.typeDefault = null),
                (this.defaultValue = null),
                (this.long = !!u.Long && void 0 !== n.long[r2]),
                (this.bytes = 'bytes' === r2),
                (this.resolvedType = null),
                (this.extensionField = null),
                (this.declaringField = null),
                (this.comment = l))
            }
            ;((a.fromJSON = function (e2, t2) {
              var r2 = new a(e2, t2.id, t2.type, t2.rule, t2.extend, t2.options, t2.comment)
              return (t2.edition && (r2._edition = t2.edition), (r2._defaultEdition = 'proto3'), r2)
            }),
              Object.defineProperty(a.prototype, 'required', {
                get: function () {
                  return 'LEGACY_REQUIRED' === this._features.field_presence
                },
              }),
              Object.defineProperty(a.prototype, 'optional', {
                get: function () {
                  return !this.required
                },
              }),
              Object.defineProperty(a.prototype, 'delimited', {
                get: function () {
                  return this.resolvedType instanceof o && 'DELIMITED' === this._features.message_encoding
                },
              }),
              Object.defineProperty(a.prototype, 'packed', {
                get: function () {
                  return 'PACKED' === this._features.repeated_field_encoding
                },
              }),
              Object.defineProperty(a.prototype, 'hasPresence', {
                get: function () {
                  return (
                    !this.repeated &&
                    !this.map &&
                    (this.partOf ||
                      this.declaringField ||
                      this.extensionField ||
                      'IMPLICIT' !== this._features.field_presence)
                  )
                },
              }),
              (a.prototype.setOption = function (e2, t2, r2) {
                return s.prototype.setOption.call(this, e2, t2, r2)
              }),
              (a.prototype.toJSON = function (e2) {
                var t2 = !!e2 && !!e2.keepComments
                return u.toObject([
                  'edition',
                  this._editionToJSON(),
                  'rule',
                  ('optional' !== this.rule && this.rule) || void 0,
                  'type',
                  this.type,
                  'id',
                  this.id,
                  'extend',
                  this.extend,
                  'options',
                  this.options,
                  'comment',
                  t2 ? this.comment : void 0,
                ])
              }),
              (a.prototype.resolve = function () {
                if (this.resolved) return this
                if (
                  (void 0 === (this.typeDefault = n.defaults[this.type])
                    ? ((this.resolvedType = (
                        this.declaringField ? this.declaringField.parent : this.parent
                      ).lookupTypeOrEnum(this.type)),
                      this.resolvedType instanceof o
                        ? (this.typeDefault = null)
                        : (this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]))
                    : this.options && this.options.proto3_optional && (this.typeDefault = null),
                  this.options &&
                    null != this.options.default &&
                    ((this.typeDefault = this.options.default),
                    this.resolvedType instanceof i &&
                      'string' == typeof this.typeDefault &&
                      (this.typeDefault = this.resolvedType.values[this.typeDefault])),
                  this.options &&
                    (void 0 === this.options.packed ||
                      !this.resolvedType ||
                      this.resolvedType instanceof i ||
                      delete this.options.packed,
                    Object.keys(this.options).length || (this.options = void 0)),
                  this.long)
                )
                  ((this.typeDefault = u.Long.fromNumber(this.typeDefault, 'u' === this.type.charAt(0))),
                    Object.freeze && Object.freeze(this.typeDefault))
                else if (this.bytes && 'string' == typeof this.typeDefault) {
                  var e2
                  ;(u.base64.test(this.typeDefault)
                    ? u.base64.decode(this.typeDefault, (e2 = u.newBuffer(u.base64.length(this.typeDefault))), 0)
                    : u.utf8.write(this.typeDefault, (e2 = u.newBuffer(u.utf8.length(this.typeDefault))), 0),
                    (this.typeDefault = e2))
                }
                return (
                  this.map
                    ? (this.defaultValue = u.emptyObject)
                    : this.repeated
                      ? (this.defaultValue = u.emptyArray)
                      : (this.defaultValue = this.typeDefault),
                  this.parent instanceof o && (this.parent.ctor.prototype[this.name] = this.defaultValue),
                  s.prototype.resolve.call(this)
                )
              }),
              (a.prototype._inferLegacyProtoFeatures = function (e2) {
                if ('proto2' !== e2 && 'proto3' !== e2) return {}
                var t2 = {}
                if (
                  ('required' === this.rule && (t2.field_presence = 'LEGACY_REQUIRED'),
                  this.parent && void 0 === n.defaults[this.type])
                ) {
                  var r2 = this.parent.get(this.type.split('.').pop())
                  r2 && r2 instanceof o && r2.group && (t2.message_encoding = 'DELIMITED')
                }
                return (
                  true === this.getOption('packed')
                    ? (t2.repeated_field_encoding = 'PACKED')
                    : false === this.getOption('packed') && (t2.repeated_field_encoding = 'EXPANDED'),
                  t2
                )
              }),
              (a.prototype._resolveFeatures = function (e2) {
                return s.prototype._resolveFeatures.call(this, this._edition || e2)
              }),
              (a.d = function (e2, t2, r2, o2) {
                return (
                  'function' == typeof t2
                    ? (t2 = u.decorateType(t2).name)
                    : t2 && 'object' == typeof t2 && (t2 = u.decorateEnum(t2).name),
                  function (s2, i2) {
                    u.decorateType(s2.constructor).add(new a(i2, e2, t2, r2, { default: o2 }))
                  }
                )
              }),
              (a._configure = function (e2) {
                o = e2
              }))
          },
          './protobufjs/src/index-light.js': function (e, t, r) {
            var o = (e.exports = r('./protobufjs/src/index-minimal.js'))
            function s(e2, t2, r2) {
              return (
                'function' == typeof t2 ? ((r2 = t2), (t2 = new o.Root())) : t2 || (t2 = new o.Root()),
                t2.load(e2, r2)
              )
            }
            function i(e2, t2) {
              return (t2 || (t2 = new o.Root()), t2.loadSync(e2))
            }
            ;((o.build = 'light'),
              (o.load = s),
              (o.loadSync = i),
              (o.encoder = r('./protobufjs/src/encoder.js')),
              (o.decoder = r('./protobufjs/src/decoder.js')),
              (o.verifier = r('./protobufjs/src/verifier.js')),
              (o.converter = r('./protobufjs/src/converter.js')),
              (o.ReflectionObject = r('./protobufjs/src/object.js')),
              (o.Namespace = r('./protobufjs/src/namespace.js')),
              (o.Root = r('./protobufjs/src/root.js')),
              (o.Enum = r('./protobufjs/src/enum.js')),
              (o.Type = r('./protobufjs/src/type.js')),
              (o.Field = r('./protobufjs/src/field.js')),
              (o.OneOf = r('./protobufjs/src/oneof.js')),
              (o.MapField = r('./protobufjs/src/mapfield.js')),
              (o.Service = r('./protobufjs/src/service.js')),
              (o.Method = r('./protobufjs/src/method.js')),
              (o.Message = r('./protobufjs/src/message.js')),
              (o.wrappers = r('./protobufjs/src/wrappers.js')),
              (o.types = r('./protobufjs/src/types.js')),
              (o.util = r('./protobufjs/src/util.js')),
              o.ReflectionObject._configure(o.Root),
              o.Namespace._configure(o.Type, o.Service, o.Enum),
              o.Root._configure(o.Type),
              o.Field._configure(o.Type))
          },
          './protobufjs/src/index-minimal.js': function (e, t, r) {
            var o = t
            function s() {
              ;(o.util._configure(), o.Writer._configure(o.BufferWriter), o.Reader._configure(o.BufferReader))
            }
            ;((o.build = 'minimal'),
              (o.Writer = r('./protobufjs/src/writer.js')),
              (o.BufferWriter = r('./protobufjs/src/writer_buffer.js')),
              (o.Reader = r('./protobufjs/src/reader.js')),
              (o.BufferReader = r('./protobufjs/src/reader_buffer.js')),
              (o.util = r('./protobufjs/src/util/minimal.js')),
              (o.rpc = r('./protobufjs/src/rpc.js')),
              (o.roots = r('./protobufjs/src/roots.js')),
              (o.configure = s),
              s())
          },
          './protobufjs/src/index.js': function (e, t, r) {
            var o = (e.exports = r('./protobufjs/src/index-light.js'))
            ;((o.build = 'full'),
              (o.tokenize = r('./protobufjs/src/tokenize.js')),
              (o.parse = r('./protobufjs/src/parse.js')),
              (o.common = r('./protobufjs/src/common.js')),
              o.Root._configure(o.Type, o.parse, o.common))
          },
          './protobufjs/src/mapfield.js': function (e, t, r) {
            e.exports = n
            var o = r('./protobufjs/src/field.js')
            ;((n.prototype = Object.create(o.prototype)).constructor = n).className = 'MapField'
            var s = r('./protobufjs/src/types.js'),
              i = r('./protobufjs/src/util.js')
            function n(e2, t2, r2, s2, n2, u) {
              if ((o.call(this, e2, t2, s2, void 0, void 0, n2, u), !i.isString(r2)))
                throw TypeError('keyType must be a string')
              ;((this.keyType = r2), (this.resolvedKeyType = null), (this.map = true))
            }
            ;((n.fromJSON = function (e2, t2) {
              return new n(e2, t2.id, t2.keyType, t2.type, t2.options, t2.comment)
            }),
              (n.prototype.toJSON = function (e2) {
                var t2 = !!e2 && !!e2.keepComments
                return i.toObject([
                  'keyType',
                  this.keyType,
                  'type',
                  this.type,
                  'id',
                  this.id,
                  'extend',
                  this.extend,
                  'options',
                  this.options,
                  'comment',
                  t2 ? this.comment : void 0,
                ])
              }),
              (n.prototype.resolve = function () {
                if (this.resolved) return this
                if (void 0 === s.mapKey[this.keyType]) throw Error('invalid key type: ' + this.keyType)
                return o.prototype.resolve.call(this)
              }),
              (n.d = function (e2, t2, r2) {
                return (
                  'function' == typeof r2
                    ? (r2 = i.decorateType(r2).name)
                    : r2 && 'object' == typeof r2 && (r2 = i.decorateEnum(r2).name),
                  function (o2, s2) {
                    i.decorateType(o2.constructor).add(new n(s2, e2, t2, r2))
                  }
                )
              }))
          },
          './protobufjs/src/message.js': function (e, t, r) {
            e.exports = s
            var o = r('./protobufjs/src/util/minimal.js')
            function s(e2) {
              if (e2) for (var t2 = Object.keys(e2), r2 = 0; r2 < t2.length; ++r2) this[t2[r2]] = e2[t2[r2]]
            }
            ;((s.create = function (e2) {
              return this.$type.create(e2)
            }),
              (s.encode = function (e2, t2) {
                return this.$type.encode(e2, t2)
              }),
              (s.encodeDelimited = function (e2, t2) {
                return this.$type.encodeDelimited(e2, t2)
              }),
              (s.decode = function (e2) {
                return this.$type.decode(e2)
              }),
              (s.decodeDelimited = function (e2) {
                return this.$type.decodeDelimited(e2)
              }),
              (s.verify = function (e2) {
                return this.$type.verify(e2)
              }),
              (s.fromObject = function (e2) {
                return this.$type.fromObject(e2)
              }),
              (s.toObject = function (e2, t2) {
                return this.$type.toObject(e2, t2)
              }),
              (s.prototype.toJSON = function () {
                return this.$type.toObject(this, o.toJSONOptions)
              }))
          },
          './protobufjs/src/method.js': function (e, t, r) {
            e.exports = i
            var o = r('./protobufjs/src/object.js')
            ;((i.prototype = Object.create(o.prototype)).constructor = i).className = 'Method'
            var s = r('./protobufjs/src/util.js')
            function i(e2, t2, r2, i2, n, u, f, a, l) {
              if (
                (s.isObject(n) ? ((f = n), (n = u = void 0)) : s.isObject(u) && ((f = u), (u = void 0)),
                !(void 0 === t2 || s.isString(t2)))
              )
                throw TypeError('type must be a string')
              if (!s.isString(r2)) throw TypeError('requestType must be a string')
              if (!s.isString(i2)) throw TypeError('responseType must be a string')
              ;(o.call(this, e2, f),
                (this.type = t2 || 'rpc'),
                (this.requestType = r2),
                (this.requestStream = !!n || void 0),
                (this.responseType = i2),
                (this.responseStream = !!u || void 0),
                (this.resolvedRequestType = null),
                (this.resolvedResponseType = null),
                (this.comment = a),
                (this.parsedOptions = l))
            }
            ;((i.fromJSON = function (e2, t2) {
              return new i(
                e2,
                t2.type,
                t2.requestType,
                t2.responseType,
                t2.requestStream,
                t2.responseStream,
                t2.options,
                t2.comment,
                t2.parsedOptions
              )
            }),
              (i.prototype.toJSON = function (e2) {
                var t2 = !!e2 && !!e2.keepComments
                return s.toObject([
                  'type',
                  ('rpc' !== this.type && this.type) || void 0,
                  'requestType',
                  this.requestType,
                  'requestStream',
                  this.requestStream,
                  'responseType',
                  this.responseType,
                  'responseStream',
                  this.responseStream,
                  'options',
                  this.options,
                  'comment',
                  t2 ? this.comment : void 0,
                  'parsedOptions',
                  this.parsedOptions,
                ])
              }),
              (i.prototype.resolve = function () {
                return this.resolved
                  ? this
                  : ((this.resolvedRequestType = this.parent.lookupType(this.requestType)),
                    (this.resolvedResponseType = this.parent.lookupType(this.responseType)),
                    o.prototype.resolve.call(this))
              }))
          },
          './protobufjs/src/namespace.js': function (e, t, r) {
            e.exports = p
            var o,
              s,
              i,
              n = r('./protobufjs/src/object.js')
            ;((p.prototype = Object.create(n.prototype)).constructor = p).className = 'Namespace'
            var u = r('./protobufjs/src/field.js'),
              f = r('./protobufjs/src/util.js'),
              a = r('./protobufjs/src/oneof.js')
            function l(e2, t2) {
              if (e2 && e2.length) {
                for (var r2 = {}, o2 = 0; o2 < e2.length; ++o2) r2[e2[o2].name] = e2[o2].toJSON(t2)
                return r2
              }
            }
            function p(e2, t2) {
              ;(n.call(this, e2, t2),
                (this.nested = void 0),
                (this._nestedArray = null),
                (this._lookupCache = {}),
                (this._needsRecursiveFeatureResolution = true),
                (this._needsRecursiveResolve = true))
            }
            function c(e2) {
              ;((e2._nestedArray = null), (e2._lookupCache = {}))
              for (var t2 = e2; (t2 = t2.parent); ) t2._lookupCache = {}
              return e2
            }
            ;((p.fromJSON = function (e2, t2) {
              return new p(e2, t2.options).addJSON(t2.nested)
            }),
              (p.arrayToJSON = l),
              (p.isReservedId = function (e2, t2) {
                if (e2) {
                  for (var r2 = 0; r2 < e2.length; ++r2)
                    if ('string' != typeof e2[r2] && e2[r2][0] <= t2 && e2[r2][1] > t2) return true
                }
                return false
              }),
              (p.isReservedName = function (e2, t2) {
                if (e2) {
                  for (var r2 = 0; r2 < e2.length; ++r2) if (e2[r2] === t2) return true
                }
                return false
              }),
              Object.defineProperty(p.prototype, 'nestedArray', {
                get: function () {
                  return this._nestedArray || (this._nestedArray = f.toArray(this.nested))
                },
              }),
              (p.prototype.toJSON = function (e2) {
                return f.toObject(['options', this.options, 'nested', l(this.nestedArray, e2)])
              }),
              (p.prototype.addJSON = function (e2) {
                var t2 = this
                if (e2)
                  for (var r2, n2 = Object.keys(e2), f2 = 0; f2 < n2.length; ++f2)
                    ((r2 = e2[n2[f2]]),
                      t2.add(
                        (void 0 !== r2.fields
                          ? o.fromJSON
                          : void 0 !== r2.values
                            ? i.fromJSON
                            : void 0 !== r2.methods
                              ? s.fromJSON
                              : void 0 !== r2.id
                                ? u.fromJSON
                                : p.fromJSON)(n2[f2], r2)
                      ))
                return this
              }),
              (p.prototype.get = function (e2) {
                return (this.nested && this.nested[e2]) || null
              }),
              (p.prototype.getEnum = function (e2) {
                if (this.nested && this.nested[e2] instanceof i) return this.nested[e2].values
                throw Error('no such enum: ' + e2)
              }),
              (p.prototype.add = function (e2) {
                if (
                  !(
                    (e2 instanceof u && void 0 !== e2.extend) ||
                    e2 instanceof o ||
                    e2 instanceof a ||
                    e2 instanceof i ||
                    e2 instanceof s ||
                    e2 instanceof p
                  )
                )
                  throw TypeError('object must be a valid nested object')
                if (this.nested) {
                  var t2 = this.get(e2.name)
                  if (t2)
                    if (t2 instanceof p && e2 instanceof p && !(t2 instanceof o || t2 instanceof s)) {
                      for (var r2 = t2.nestedArray, n2 = 0; n2 < r2.length; ++n2) e2.add(r2[n2])
                      ;(this.remove(t2), this.nested || (this.nested = {}), e2.setOptions(t2.options, true))
                    } else throw Error("duplicate name '" + e2.name + "' in " + this)
                } else this.nested = {}
                ;((this.nested[e2.name] = e2),
                  this instanceof o ||
                    this instanceof s ||
                    this instanceof i ||
                    this instanceof u ||
                    e2._edition ||
                    (e2._edition = e2._defaultEdition),
                  (this._needsRecursiveFeatureResolution = true),
                  (this._needsRecursiveResolve = true))
                for (var f2 = this; (f2 = f2.parent); )
                  ((f2._needsRecursiveFeatureResolution = true), (f2._needsRecursiveResolve = true))
                return (e2.onAdd(this), c(this))
              }),
              (p.prototype.remove = function (e2) {
                if (!(e2 instanceof n)) throw TypeError('object must be a ReflectionObject')
                if (e2.parent !== this) throw Error(e2 + ' is not a member of ' + this)
                return (
                  delete this.nested[e2.name],
                  Object.keys(this.nested).length || (this.nested = void 0),
                  e2.onRemove(this),
                  c(this)
                )
              }),
              (p.prototype.define = function (e2, t2) {
                if (f.isString(e2)) e2 = e2.split('.')
                else if (!Array.isArray(e2)) throw TypeError('illegal path')
                if (e2 && e2.length && '' === e2[0]) throw Error('path must be relative')
                for (var r2 = this; e2.length > 0; ) {
                  var o2 = e2.shift()
                  if (r2.nested && r2.nested[o2]) {
                    if (!((r2 = r2.nested[o2]) instanceof p)) throw Error('path conflicts with non-namespace objects')
                  } else r2.add((r2 = new p(o2)))
                }
                return (t2 && r2.addJSON(t2), r2)
              }),
              (p.prototype.resolveAll = function () {
                if (!this._needsRecursiveResolve) return this
                this._resolveFeaturesRecursive(this._edition)
                var e2 = this.nestedArray,
                  t2 = 0
                for (this.resolve(); t2 < e2.length; ) e2[t2] instanceof p ? e2[t2++].resolveAll() : e2[t2++].resolve()
                return ((this._needsRecursiveResolve = false), this)
              }),
              (p.prototype._resolveFeaturesRecursive = function (e2) {
                return (
                  this._needsRecursiveFeatureResolution &&
                    ((this._needsRecursiveFeatureResolution = false),
                    (e2 = this._edition || e2),
                    n.prototype._resolveFeaturesRecursive.call(this, e2),
                    this.nestedArray.forEach((t2) => {
                      t2._resolveFeaturesRecursive(e2)
                    })),
                  this
                )
              }),
              (p.prototype.lookup = function (e2, t2, r2) {
                if (
                  ('boolean' == typeof t2 ? ((r2 = t2), (t2 = void 0)) : t2 && !Array.isArray(t2) && (t2 = [t2]),
                  f.isString(e2) && e2.length)
                ) {
                  if ('.' === e2) return this.root
                  e2 = e2.split('.')
                } else if (!e2.length) return this
                var o2 = e2.join('.')
                if ('' === e2[0]) return this.root.lookup(e2.slice(1), t2)
                var s2 = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects['.' + o2]
                if (
                  (s2 && (!t2 || t2.indexOf(s2.constructor) > -1)) ||
                  ((s2 = this._lookupImpl(e2, o2)) && (!t2 || t2.indexOf(s2.constructor) > -1))
                )
                  return s2
                if (r2) return null
                for (var i2 = this; i2.parent; ) {
                  if ((s2 = i2.parent._lookupImpl(e2, o2)) && (!t2 || t2.indexOf(s2.constructor) > -1)) return s2
                  i2 = i2.parent
                }
                return null
              }),
              (p.prototype._lookupImpl = function (e2, t2) {
                if (Object.prototype.hasOwnProperty.call(this._lookupCache, t2)) return this._lookupCache[t2]
                var r2 = this.get(e2[0]),
                  o2 = null
                if (r2)
                  1 === e2.length
                    ? (o2 = r2)
                    : r2 instanceof p && ((e2 = e2.slice(1)), (o2 = r2._lookupImpl(e2, e2.join('.'))))
                else
                  for (var s2 = 0; s2 < this.nestedArray.length; ++s2)
                    this._nestedArray[s2] instanceof p && (r2 = this._nestedArray[s2]._lookupImpl(e2, t2)) && (o2 = r2)
                return ((this._lookupCache[t2] = o2), o2)
              }),
              (p.prototype.lookupType = function (e2) {
                var t2 = this.lookup(e2, [o])
                if (!t2) throw Error('no such type: ' + e2)
                return t2
              }),
              (p.prototype.lookupEnum = function (e2) {
                var t2 = this.lookup(e2, [i])
                if (!t2) throw Error("no such Enum '" + e2 + "' in " + this)
                return t2
              }),
              (p.prototype.lookupTypeOrEnum = function (e2) {
                var t2 = this.lookup(e2, [o, i])
                if (!t2) throw Error("no such Type or Enum '" + e2 + "' in " + this)
                return t2
              }),
              (p.prototype.lookupService = function (e2) {
                var t2 = this.lookup(e2, [s])
                if (!t2) throw Error("no such Service '" + e2 + "' in " + this)
                return t2
              }),
              (p._configure = function (e2, t2, r2) {
                ;((o = e2), (s = t2), (i = r2))
              }))
          },
          './protobufjs/src/object.js': function (e, t, r) {
            ;((e.exports = a), (a.className = 'ReflectionObject'))
            let o = r('./protobufjs/src/oneof.js')
            var s,
              i = r('./protobufjs/src/util.js'),
              n = {
                enum_type: 'OPEN',
                field_presence: 'EXPLICIT',
                json_format: 'ALLOW',
                message_encoding: 'LENGTH_PREFIXED',
                repeated_field_encoding: 'PACKED',
                utf8_validation: 'VERIFY',
              },
              u = {
                enum_type: 'CLOSED',
                field_presence: 'EXPLICIT',
                json_format: 'LEGACY_BEST_EFFORT',
                message_encoding: 'LENGTH_PREFIXED',
                repeated_field_encoding: 'EXPANDED',
                utf8_validation: 'NONE',
              },
              f = {
                enum_type: 'OPEN',
                field_presence: 'IMPLICIT',
                json_format: 'ALLOW',
                message_encoding: 'LENGTH_PREFIXED',
                repeated_field_encoding: 'PACKED',
                utf8_validation: 'VERIFY',
              }
            function a(e2, t2) {
              if (!i.isString(e2)) throw TypeError('name must be a string')
              if (t2 && !i.isObject(t2)) throw TypeError('options must be an object')
              ;((this.options = t2),
                (this.parsedOptions = null),
                (this.name = e2),
                (this._edition = null),
                (this._defaultEdition = 'proto2'),
                (this._features = {}),
                (this._featuresResolved = false),
                (this.parent = null),
                (this.resolved = false),
                (this.comment = null),
                (this.filename = null))
            }
            ;(Object.defineProperties(a.prototype, {
              root: {
                get: function () {
                  for (var e2 = this; null !== e2.parent; ) e2 = e2.parent
                  return e2
                },
              },
              fullName: {
                get: function () {
                  for (var e2 = [this.name], t2 = this.parent; t2; ) (e2.unshift(t2.name), (t2 = t2.parent))
                  return e2.join('.')
                },
              },
            }),
              (a.prototype.toJSON = function () {
                throw Error()
              }),
              (a.prototype.onAdd = function (e2) {
                ;(this.parent && this.parent !== e2 && this.parent.remove(this),
                  (this.parent = e2),
                  (this.resolved = false))
                var t2 = e2.root
                t2 instanceof s && t2._handleAdd(this)
              }),
              (a.prototype.onRemove = function (e2) {
                var t2 = e2.root
                ;(t2 instanceof s && t2._handleRemove(this), (this.parent = null), (this.resolved = false))
              }),
              (a.prototype.resolve = function () {
                return (this.resolved || (this.root instanceof s && (this.resolved = true)), this)
              }),
              (a.prototype._resolveFeaturesRecursive = function (e2) {
                return this._resolveFeatures(this._edition || e2)
              }),
              (a.prototype._resolveFeatures = function (e2) {
                if (!this._featuresResolved) {
                  var t2 = {}
                  if (!e2) throw Error('Unknown edition for ' + this.fullName)
                  var r2 = Object.assign(
                    this.options ? Object.assign({}, this.options.features) : {},
                    this._inferLegacyProtoFeatures(e2)
                  )
                  if (this._edition) {
                    if ('proto2' === e2) t2 = Object.assign({}, u)
                    else if ('proto3' === e2) t2 = Object.assign({}, f)
                    else if ('2023' === e2) t2 = Object.assign({}, n)
                    else throw Error('Unknown edition: ' + e2)
                    ;((this._features = Object.assign(t2, r2 || {})), (this._featuresResolved = true))
                    return
                  }
                  if (this.partOf instanceof o) {
                    var s2 = Object.assign({}, this.partOf._features)
                    this._features = Object.assign(s2, r2 || {})
                  } else if (this.declaringField);
                  else if (this.parent) {
                    var i2 = Object.assign({}, this.parent._features)
                    this._features = Object.assign(i2, r2 || {})
                  } else throw Error('Unable to find a parent for ' + this.fullName)
                  ;(this.extensionField && (this.extensionField._features = this._features),
                    (this._featuresResolved = true))
                }
              }),
              (a.prototype._inferLegacyProtoFeatures = function () {
                return {}
              }),
              (a.prototype.getOption = function (e2) {
                if (this.options) return this.options[e2]
              }),
              (a.prototype.setOption = function (e2, t2, r2) {
                return (
                  this.options || (this.options = {}),
                  /^features\./.test(e2)
                    ? i.setProperty(this.options, e2, t2, r2)
                    : (r2 && void 0 !== this.options[e2]) ||
                      (this.getOption(e2) !== t2 && (this.resolved = false), (this.options[e2] = t2)),
                  this
                )
              }),
              (a.prototype.setParsedOption = function (e2, t2, r2) {
                this.parsedOptions || (this.parsedOptions = [])
                var o2 = this.parsedOptions
                if (r2) {
                  var s2 = o2.find(function (t3) {
                    return Object.prototype.hasOwnProperty.call(t3, e2)
                  })
                  if (s2) {
                    var n2 = s2[e2]
                    i.setProperty(n2, r2, t2)
                  } else (((s2 = {})[e2] = i.setProperty({}, r2, t2)), o2.push(s2))
                } else {
                  var u2 = {}
                  ;((u2[e2] = t2), o2.push(u2))
                }
                return this
              }),
              (a.prototype.setOptions = function (e2, t2) {
                if (e2)
                  for (var r2 = Object.keys(e2), o2 = 0; o2 < r2.length; ++o2) this.setOption(r2[o2], e2[r2[o2]], t2)
                return this
              }),
              (a.prototype.toString = function () {
                var e2 = this.constructor.className,
                  t2 = this.fullName
                return t2.length ? e2 + ' ' + t2 : e2
              }),
              (a.prototype._editionToJSON = function () {
                if (this._edition && 'proto3' !== this._edition) return this._edition
              }),
              (a._configure = function (e2) {
                s = e2
              }))
          },
          './protobufjs/src/oneof.js': function (e, t, r) {
            e.exports = n
            var o = r('./protobufjs/src/object.js')
            ;((n.prototype = Object.create(o.prototype)).constructor = n).className = 'OneOf'
            var s = r('./protobufjs/src/field.js'),
              i = r('./protobufjs/src/util.js')
            function n(e2, t2, r2, s2) {
              if (
                (Array.isArray(t2) || ((r2 = t2), (t2 = void 0)),
                o.call(this, e2, r2),
                !(void 0 === t2 || Array.isArray(t2)))
              )
                throw TypeError('fieldNames must be an Array')
              ;((this.oneof = t2 || []), (this.fieldsArray = []), (this.comment = s2))
            }
            function u(e2) {
              if (e2.parent)
                for (var t2 = 0; t2 < e2.fieldsArray.length; ++t2)
                  e2.fieldsArray[t2].parent || e2.parent.add(e2.fieldsArray[t2])
            }
            ;((n.fromJSON = function (e2, t2) {
              return new n(e2, t2.oneof, t2.options, t2.comment)
            }),
              (n.prototype.toJSON = function (e2) {
                var t2 = !!e2 && !!e2.keepComments
                return i.toObject(['options', this.options, 'oneof', this.oneof, 'comment', t2 ? this.comment : void 0])
              }),
              (n.prototype.add = function (e2) {
                if (!(e2 instanceof s)) throw TypeError('field must be a Field')
                return (
                  e2.parent && e2.parent !== this.parent && e2.parent.remove(e2),
                  this.oneof.push(e2.name),
                  this.fieldsArray.push(e2),
                  (e2.partOf = this),
                  u(this),
                  this
                )
              }),
              (n.prototype.remove = function (e2) {
                if (!(e2 instanceof s)) throw TypeError('field must be a Field')
                var t2 = this.fieldsArray.indexOf(e2)
                if (t2 < 0) throw Error(e2 + ' is not a member of ' + this)
                return (
                  this.fieldsArray.splice(t2, 1),
                  (t2 = this.oneof.indexOf(e2.name)) > -1 && this.oneof.splice(t2, 1),
                  (e2.partOf = null),
                  this
                )
              }),
              (n.prototype.onAdd = function (e2) {
                o.prototype.onAdd.call(this, e2)
                for (var t2 = this, r2 = 0; r2 < this.oneof.length; ++r2) {
                  var s2 = e2.get(this.oneof[r2])
                  s2 && !s2.partOf && ((s2.partOf = t2), t2.fieldsArray.push(s2))
                }
                u(this)
              }),
              (n.prototype.onRemove = function (e2) {
                for (var t2, r2 = 0; r2 < this.fieldsArray.length; ++r2)
                  (t2 = this.fieldsArray[r2]).parent && t2.parent.remove(t2)
                o.prototype.onRemove.call(this, e2)
              }),
              Object.defineProperty(n.prototype, 'isProto3Optional', {
                get: function () {
                  if (null == this.fieldsArray || 1 !== this.fieldsArray.length) return false
                  var e2 = this.fieldsArray[0]
                  return null != e2.options && true === e2.options.proto3_optional
                },
              }),
              (n.d = function () {
                for (var e2 = Array(arguments.length), t2 = 0; t2 < arguments.length; ) e2[t2] = arguments[t2++]
                return function (t3, r2) {
                  ;(i.decorateType(t3.constructor).add(new n(r2, e2)),
                    Object.defineProperty(t3, r2, { get: i.oneOfGetter(e2), set: i.oneOfSetter(e2) }))
                }
              }))
          },
          './protobufjs/src/parse.js': function (e, t, r) {
            ;((e.exports = k), (k.filename = null), (k.defaults = { keepCase: false }))
            var o = r('./protobufjs/src/tokenize.js'),
              s = r('./protobufjs/src/root.js'),
              i = r('./protobufjs/src/type.js'),
              n = r('./protobufjs/src/field.js'),
              u = r('./protobufjs/src/mapfield.js'),
              f = r('./protobufjs/src/oneof.js'),
              a = r('./protobufjs/src/enum.js'),
              l = r('./protobufjs/src/service.js'),
              p = r('./protobufjs/src/method.js'),
              c = r('./protobufjs/src/object.js'),
              h = r('./protobufjs/src/types.js'),
              d = r('./protobufjs/src/util.js'),
              y = /^[1-9][0-9]*$/,
              v = /^-?[1-9][0-9]*$/,
              m = /^0[x][0-9a-fA-F]+$/,
              b = /^-?0[x][0-9a-fA-F]+$/,
              j = /^0[0-7]+$/,
              g = /^-?0[0-7]+$/,
              w = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
              O = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
              _ = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/
            function k(e2, t2, r2) {
              ;(t2 instanceof s || ((r2 = t2), (t2 = new s())), r2 || (r2 = k.defaults))
              var x,
                A,
                E,
                S,
                T = r2.preferTrailingComment || false,
                N = o(e2, r2.alternateCommentMode || false),
                R = N.next,
                F = N.push,
                I = N.peek,
                B = N.skip,
                P = N.cmnt,
                D = true,
                L = 'proto2',
                C = t2,
                J = [],
                $ = {},
                q = r2.keepCase
                  ? function (e3) {
                      return e3
                    }
                  : d.camelCase
              function V() {
                J.forEach((e3) => {
                  ;((e3._edition = L),
                    Object.keys($).forEach((t3) => {
                      void 0 === e3.getOption(t3) && e3.setOption(t3, $[t3], true)
                    }))
                })
              }
              function z(e3, t3, r3) {
                var o2 = k.filename
                return (
                  r3 || (k.filename = null),
                  Error(
                    'illegal ' + (t3 || 'token') + " '" + e3 + "' (" + (o2 ? o2 + ', ' : '') + 'line ' + N.line + ')'
                  )
                )
              }
              function M() {
                var e3,
                  t3 = []
                do {
                  if ('"' !== (e3 = R()) && "'" !== e3) throw z(e3)
                  ;(t3.push(R()), B(e3), (e3 = I()))
                } while ('"' === e3 || "'" === e3)
                return t3.join('')
              }
              function U(e3) {
                var t3 = R()
                switch (t3) {
                  case "'":
                  case '"':
                    return (F(t3), M())
                  case 'true':
                  case 'TRUE':
                    return true
                  case 'false':
                  case 'FALSE':
                    return false
                }
                try {
                  return W(t3, true)
                } catch (r3) {
                  if (e3 && _.test(t3)) return t3
                  throw z(t3, 'value')
                }
              }
              function H(e3, t3) {
                do
                  if (t3 && ('"' === (r3 = I()) || "'" === r3)) {
                    var r3,
                      o2,
                      s2 = M()
                    if ((e3.push(s2), L >= 2023)) throw z(s2, 'id')
                  } else
                    try {
                      e3.push([(o2 = G(R())), B('to', true) ? G(R()) : o2])
                    } catch (o3) {
                      if (t3 && _.test(r3) && L >= 2023) e3.push(r3)
                      else throw o3
                    }
                while (B(',', true))
                var i2 = { options: void 0 }
                ;((i2.setOption = function (e4, t4) {
                  ;(void 0 === this.options && (this.options = {}), (this.options[e4] = t4))
                }),
                  ee(
                    i2,
                    function (e4) {
                      if ('option' === e4) (ef(i2, e4), B(';'))
                      else throw z(e4)
                    },
                    function () {
                      ec(i2)
                    }
                  ))
              }
              function W(e3, t3) {
                var r3 = 1
                switch (('-' === e3.charAt(0) && ((r3 = -1), (e3 = e3.substring(1))), e3)) {
                  case 'inf':
                  case 'INF':
                  case 'Inf':
                    return (1 / 0) * r3
                  case 'nan':
                  case 'NAN':
                  case 'Nan':
                  case 'NaN':
                    return NaN
                  case '0':
                    return 0
                }
                if (y.test(e3)) return r3 * parseInt(e3, 10)
                if (m.test(e3)) return r3 * parseInt(e3, 16)
                if (j.test(e3)) return r3 * parseInt(e3, 8)
                if (w.test(e3)) return r3 * parseFloat(e3)
                throw z(e3, 'number', t3)
              }
              function G(e3, t3) {
                switch (e3) {
                  case 'max':
                  case 'MAX':
                  case 'Max':
                    return 536870911
                  case '0':
                    return 0
                }
                if (!t3 && '-' === e3.charAt(0)) throw z(e3, 'id')
                if (v.test(e3)) return parseInt(e3, 10)
                if (b.test(e3)) return parseInt(e3, 16)
                if (g.test(e3)) return parseInt(e3, 8)
                throw z(e3, 'id')
              }
              function X() {
                if (void 0 !== A) throw z('package')
                if (((A = R()), !_.test(A))) throw z(A, 'name')
                ;((C = C.define(A)), B(';'))
              }
              function Z() {
                var e3,
                  t3 = I()
                switch (t3) {
                  case 'weak':
                    ;((e3 = S || (S = [])), R())
                    break
                  case 'public':
                    R()
                  default:
                    e3 = E || (E = [])
                }
                ;((t3 = M()), B(';'), e3.push(t3))
              }
              function K() {
                if ((B('='), (L = M()) < 2023)) throw z(L, 'syntax')
                B(';')
              }
              function Q() {
                if ((B('='), !['2023'].includes((L = M())))) throw z(L, 'edition')
                B(';')
              }
              function Y(e3, t3) {
                switch (t3) {
                  case 'option':
                    return (ef(e3, t3), B(';'), true)
                  case 'message':
                    return (et(e3, t3), true)
                  case 'enum':
                    return (en(e3, t3), true)
                  case 'service':
                    return (eh(e3, t3), true)
                  case 'extend':
                    return (ey(e3, t3), true)
                }
                return false
              }
              function ee(e3, t3, r3) {
                var o2,
                  s2 = N.line
                if (
                  (e3 && ('string' != typeof e3.comment && (e3.comment = P()), (e3.filename = k.filename)),
                  B('{', true))
                ) {
                  for (; '}' !== (o2 = R()); ) t3(o2)
                  B(';', true)
                } else
                  (r3 && r3(), B(';'), e3 && ('string' != typeof e3.comment || T) && (e3.comment = P(s2) || e3.comment))
              }
              function et(e3, t3) {
                if (!O.test((t3 = R()))) throw z(t3, 'type name')
                var r3 = new i(t3)
                ;(ee(r3, function (e4) {
                  if (!Y(r3, e4))
                    switch (e4) {
                      case 'map':
                        es(r3, e4)
                        break
                      case 'required':
                        if ('proto2' !== L) throw z(e4)
                      case 'repeated':
                        er(r3, e4)
                        break
                      case 'optional':
                        if ('proto3' === L) er(r3, 'proto3_optional')
                        else if ('proto2' !== L) throw z(e4)
                        else er(r3, 'optional')
                        break
                      case 'oneof':
                        ei(r3, e4)
                        break
                      case 'extensions':
                        H(r3.extensions || (r3.extensions = []))
                        break
                      case 'reserved':
                        H(r3.reserved || (r3.reserved = []), true)
                        break
                      default:
                        if ('proto2' === L || !_.test(e4)) throw z(e4)
                        ;(F(e4), er(r3, 'optional'))
                    }
                }),
                  e3.add(r3),
                  e3 === C && J.push(r3))
              }
              function er(e3, t3, r3) {
                var o2 = R()
                if ('group' === o2) return void eo(e3, t3)
                for (; o2.endsWith('.') || I().startsWith('.'); ) o2 += R()
                if (!_.test(o2)) throw z(o2, 'type')
                var s2 = R()
                if (!O.test(s2)) throw z(s2, 'name')
                ;((s2 = q(s2)), B('='))
                var i2 = new n(s2, G(R()), o2, t3, r3)
                if (
                  (ee(
                    i2,
                    function (e4) {
                      if ('option' === e4) (ef(i2, e4), B(';'))
                      else throw z(e4)
                    },
                    function () {
                      ec(i2)
                    }
                  ),
                  'proto3_optional' === t3)
                ) {
                  var u2 = new f('_' + s2)
                  ;(i2.setOption('proto3_optional', true), u2.add(i2), e3.add(u2))
                } else e3.add(i2)
                e3 === C && J.push(i2)
              }
              function eo(e3, t3) {
                if (L >= 2023) throw z('group')
                var r3 = R()
                if (!O.test(r3)) throw z(r3, 'name')
                var o2 = d.lcFirst(r3)
                ;(r3 === o2 && (r3 = d.ucFirst(r3)), B('='))
                var s2 = G(R()),
                  u2 = new i(r3)
                u2.group = true
                var f2 = new n(o2, s2, r3, t3)
                ;((f2.filename = k.filename),
                  ee(u2, function (e4) {
                    switch (e4) {
                      case 'option':
                        ;(ef(u2, e4), B(';'))
                        break
                      case 'required':
                      case 'repeated':
                        er(u2, e4)
                        break
                      case 'optional':
                        'proto3' === L ? er(u2, 'proto3_optional') : er(u2, 'optional')
                        break
                      case 'message':
                        et(u2, e4)
                        break
                      case 'enum':
                        en(u2, e4)
                        break
                      case 'reserved':
                        H(u2.reserved || (u2.reserved = []), true)
                        break
                      default:
                        throw z(e4)
                    }
                  }),
                  e3.add(u2).add(f2))
              }
              function es(e3) {
                B('<')
                var t3 = R()
                if (void 0 === h.mapKey[t3]) throw z(t3, 'type')
                B(',')
                var r3 = R()
                if (!_.test(r3)) throw z(r3, 'type')
                B('>')
                var o2 = R()
                if (!O.test(o2)) throw z(o2, 'name')
                B('=')
                var s2 = new u(q(o2), G(R()), t3, r3)
                ;(ee(
                  s2,
                  function (e4) {
                    if ('option' === e4) (ef(s2, e4), B(';'))
                    else throw z(e4)
                  },
                  function () {
                    ec(s2)
                  }
                ),
                  e3.add(s2))
              }
              function ei(e3, t3) {
                if (!O.test((t3 = R()))) throw z(t3, 'name')
                var r3 = new f(q(t3))
                ;(ee(r3, function (e4) {
                  'option' === e4 ? (ef(r3, e4), B(';')) : (F(e4), er(r3, 'optional'))
                }),
                  e3.add(r3))
              }
              function en(e3, t3) {
                if (!O.test((t3 = R()))) throw z(t3, 'name')
                var r3 = new a(t3)
                ;(ee(r3, function (e4) {
                  switch (e4) {
                    case 'option':
                      ;(ef(r3, e4), B(';'))
                      break
                    case 'reserved':
                      ;(H(r3.reserved || (r3.reserved = []), true), void 0 === r3.reserved && (r3.reserved = []))
                      break
                    default:
                      eu(r3, e4)
                  }
                }),
                  e3.add(r3),
                  e3 === C && J.push(r3))
              }
              function eu(e3, t3) {
                if (!O.test(t3)) throw z(t3, 'name')
                B('=')
                var r3 = G(R(), true),
                  o2 = { options: void 0 }
                ;((o2.getOption = function (e4) {
                  return this.options[e4]
                }),
                  (o2.setOption = function (e4, t4) {
                    c.prototype.setOption.call(o2, e4, t4)
                  }),
                  (o2.setParsedOption = function () {}),
                  ee(
                    o2,
                    function (e4) {
                      if ('option' === e4) (ef(o2, e4), B(';'))
                      else throw z(e4)
                    },
                    function () {
                      ec(o2)
                    }
                  ),
                  e3.add(t3, r3, o2.comment, o2.parsedOptions || o2.options))
              }
              function ef(e3, t3) {
                var r3,
                  o2,
                  s2 = true
                for ('option' === t3 && (t3 = R()); '=' !== t3; ) {
                  if ('(' === t3) {
                    var i2 = R()
                    ;(B(')'), (t3 = '(' + i2 + ')'))
                  }
                  if (s2) {
                    if (((s2 = false), t3.includes('.') && !t3.includes('('))) {
                      var n2 = t3.split('.')
                      ;((r3 = n2[0] + '.'), (t3 = n2[1]))
                      continue
                    }
                    r3 = t3
                  } else o2 = o2 ? (o2 += t3) : t3
                  t3 = R()
                }
                var u2 = ea(e3, o2 ? r3.concat(o2) : r3)
                ;((o2 = o2 && '.' === o2[0] ? o2.slice(1) : o2),
                  ep(e3, (r3 = r3 && '.' === r3[r3.length - 1] ? r3.slice(0, -1) : r3), u2, o2))
              }
              function ea(e3, t3) {
                if (B('{', true)) {
                  for (var r3 = {}; !B('}', true); ) {
                    if (!O.test((x = R()))) throw z(x, 'name')
                    if (null === x) throw z(x, 'end of input')
                    var o2,
                      s2,
                      i2 = x
                    if ((B(':', true), '{' === I())) o2 = ea(e3, t3 + '.' + x)
                    else if ('[' === I()) {
                      if (((o2 = []), B('[', true))) {
                        do ((s2 = U(true)), o2.push(s2))
                        while (B(',', true))
                        ;(B(']'), void 0 !== s2 && el(e3, t3 + '.' + x, s2))
                      }
                    } else ((o2 = U(true)), el(e3, t3 + '.' + x, o2))
                    var n2 = r3[i2]
                    ;(n2 && (o2 = [].concat(n2).concat(o2)), (r3[i2] = o2), B(',', true), B(';', true))
                  }
                  return r3
                }
                var u2 = U(true)
                return (el(e3, t3, u2), u2)
              }
              function el(e3, t3, r3) {
                if (C === e3 && /^features\./.test(t3)) {
                  $[t3] = r3
                  return
                }
                e3.setOption && e3.setOption(t3, r3)
              }
              function ep(e3, t3, r3, o2) {
                e3.setParsedOption && e3.setParsedOption(t3, r3, o2)
              }
              function ec(e3) {
                if (B('[', true)) {
                  do ef(e3, 'option')
                  while (B(',', true))
                  B(']')
                }
                return e3
              }
              function eh(e3, t3) {
                if (!O.test((t3 = R()))) throw z(t3, 'service name')
                var r3 = new l(t3)
                ;(ee(r3, function (e4) {
                  if (!Y(r3, e4))
                    if ('rpc' === e4) ed(r3, e4)
                    else throw z(e4)
                }),
                  e3.add(r3),
                  e3 === C && J.push(r3))
              }
              function ed(e3, t3) {
                var r3 = P(),
                  o2 = t3
                if (!O.test((t3 = R()))) throw z(t3, 'name')
                var s2,
                  i2,
                  n2,
                  u2,
                  f2 = t3
                if (
                  (B('('),
                  B('stream', true) && (i2 = true),
                  !_.test((t3 = R())) ||
                    ((s2 = t3), B(')'), B('returns'), B('('), B('stream', true) && (u2 = true), !_.test((t3 = R()))))
                )
                  throw z(t3)
                ;((n2 = t3), B(')'))
                var a2 = new p(f2, o2, s2, n2, i2, u2)
                ;((a2.comment = r3),
                  ee(a2, function (e4) {
                    if ('option' === e4) (ef(a2, e4), B(';'))
                    else throw z(e4)
                  }),
                  e3.add(a2))
              }
              function ey(e3, t3) {
                if (!_.test((t3 = R()))) throw z(t3, 'reference')
                var r3 = t3
                ee(null, function (t4) {
                  switch (t4) {
                    case 'required':
                    case 'repeated':
                      er(e3, t4, r3)
                      break
                    case 'optional':
                      'proto3' === L ? er(e3, 'proto3_optional', r3) : er(e3, 'optional', r3)
                      break
                    default:
                      if ('proto2' === L || !_.test(t4)) throw z(t4)
                      ;(F(t4), er(e3, 'optional', r3))
                  }
                })
              }
              for (; null !== (x = R()); )
                switch (x) {
                  case 'package':
                    if (!D) throw z(x)
                    X()
                    break
                  case 'import':
                    if (!D) throw z(x)
                    Z()
                    break
                  case 'syntax':
                    if (!D) throw z(x)
                    K()
                    break
                  case 'edition':
                    if (!D) throw z(x)
                    Q()
                    break
                  case 'option':
                    ;(ef(C, x), B(';', true))
                    break
                  default:
                    if (Y(C, x)) {
                      D = false
                      continue
                    }
                    throw z(x)
                }
              return (V(), (k.filename = null), { package: A, imports: E, weakImports: S, root: t2 })
            }
          },
          './protobufjs/src/reader.js': function (e, t, r) {
            e.exports = f
            var o,
              s = r('./protobufjs/src/util/minimal.js'),
              i = s.LongBits,
              n = s.utf8
            function u(e2, t2) {
              return RangeError('index out of range: ' + e2.pos + ' + ' + (t2 || 1) + ' > ' + e2.len)
            }
            function f(e2) {
              ;((this.buf = e2), (this.pos = 0), (this.len = e2.length))
            }
            var a =
                'undefined' != typeof Uint8Array
                  ? function (e2) {
                      if (e2 instanceof Uint8Array || Array.isArray(e2)) return new f(e2)
                      throw Error('illegal buffer')
                    }
                  : function (e2) {
                      if (Array.isArray(e2)) return new f(e2)
                      throw Error('illegal buffer')
                    },
              l = function () {
                return s.Buffer
                  ? function (e2) {
                      return (f.create = function (e3) {
                        return s.Buffer.isBuffer(e3) ? new o(e3) : a(e3)
                      })(e2)
                    }
                  : a
              }
            function p() {
              var e2 = new i(0, 0),
                t2 = 0
              if (this.len - this.pos > 4) {
                for (; t2 < 4; ++t2)
                  if (((e2.lo = (e2.lo | ((127 & this.buf[this.pos]) << (7 * t2))) >>> 0), this.buf[this.pos++] < 128))
                    return e2
                if (
                  ((e2.lo = (e2.lo | ((127 & this.buf[this.pos]) << 28)) >>> 0),
                  (e2.hi = (e2.hi | ((127 & this.buf[this.pos]) >> 4)) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return e2
                t2 = 0
              } else {
                for (; t2 < 3; ++t2) {
                  if (this.pos >= this.len) throw u(this)
                  if (((e2.lo = (e2.lo | ((127 & this.buf[this.pos]) << (7 * t2))) >>> 0), this.buf[this.pos++] < 128))
                    return e2
                }
                return ((e2.lo = (e2.lo | ((127 & this.buf[this.pos++]) << (7 * t2))) >>> 0), e2)
              }
              if (this.len - this.pos > 4) {
                for (; t2 < 5; ++t2)
                  if (
                    ((e2.hi = (e2.hi | ((127 & this.buf[this.pos]) << (7 * t2 + 3))) >>> 0), this.buf[this.pos++] < 128)
                  )
                    return e2
              } else
                for (; t2 < 5; ++t2) {
                  if (this.pos >= this.len) throw u(this)
                  if (
                    ((e2.hi = (e2.hi | ((127 & this.buf[this.pos]) << (7 * t2 + 3))) >>> 0), this.buf[this.pos++] < 128)
                  )
                    return e2
                }
              throw Error('invalid varint encoding')
            }
            function c(e2, t2) {
              return (e2[t2 - 4] | (e2[t2 - 3] << 8) | (e2[t2 - 2] << 16) | (e2[t2 - 1] << 24)) >>> 0
            }
            function h() {
              if (this.pos + 8 > this.len) throw u(this, 8)
              return new i(c(this.buf, (this.pos += 4)), c(this.buf, (this.pos += 4)))
            }
            ;((f.create = l()),
              (f.prototype._slice = s.Array.prototype.subarray || s.Array.prototype.slice),
              (f.prototype.uint32 = /* @__PURE__ */ (function () {
                var e2 = 4294967295
                return function () {
                  if (
                    ((e2 = (127 & this.buf[this.pos]) >>> 0),
                    this.buf[this.pos++] < 128 ||
                      ((e2 = (e2 | ((127 & this.buf[this.pos]) << 7)) >>> 0), this.buf[this.pos++] < 128) ||
                      ((e2 = (e2 | ((127 & this.buf[this.pos]) << 14)) >>> 0), this.buf[this.pos++] < 128) ||
                      ((e2 = (e2 | ((127 & this.buf[this.pos]) << 21)) >>> 0), this.buf[this.pos++] < 128) ||
                      ((e2 = (e2 | ((15 & this.buf[this.pos]) << 28)) >>> 0), this.buf[this.pos++] < 128))
                  )
                    return e2
                  if ((this.pos += 5) > this.len) throw ((this.pos = this.len), u(this, 10))
                  return e2
                }
              })()),
              (f.prototype.int32 = function () {
                return 0 | this.uint32()
              }),
              (f.prototype.sint32 = function () {
                var e2 = this.uint32()
                return (e2 >>> 1) ^ -(1 & e2)
              }),
              (f.prototype.bool = function () {
                return 0 !== this.uint32()
              }),
              (f.prototype.fixed32 = function () {
                if (this.pos + 4 > this.len) throw u(this, 4)
                return c(this.buf, (this.pos += 4))
              }),
              (f.prototype.sfixed32 = function () {
                if (this.pos + 4 > this.len) throw u(this, 4)
                return 0 | c(this.buf, (this.pos += 4))
              }),
              (f.prototype.float = function () {
                if (this.pos + 4 > this.len) throw u(this, 4)
                var e2 = s.float.readFloatLE(this.buf, this.pos)
                return ((this.pos += 4), e2)
              }),
              (f.prototype.double = function () {
                if (this.pos + 8 > this.len) throw u(this, 4)
                var e2 = s.float.readDoubleLE(this.buf, this.pos)
                return ((this.pos += 8), e2)
              }),
              (f.prototype.bytes = function () {
                var e2 = this.uint32(),
                  t2 = this.pos,
                  r2 = this.pos + e2
                if (r2 > this.len) throw u(this, e2)
                if (((this.pos += e2), Array.isArray(this.buf))) return this.buf.slice(t2, r2)
                if (t2 === r2) {
                  var o2 = s.Buffer
                  return o2 ? o2.alloc(0) : new this.buf.constructor(0)
                }
                return this._slice.call(this.buf, t2, r2)
              }),
              (f.prototype.string = function () {
                var e2 = this.bytes()
                return n.read(e2, 0, e2.length)
              }),
              (f.prototype.skip = function (e2) {
                if ('number' == typeof e2) {
                  if (this.pos + e2 > this.len) throw u(this, e2)
                  this.pos += e2
                } else
                  do if (this.pos >= this.len) throw u(this)
                  while (128 & this.buf[this.pos++])
                return this
              }),
              (f.prototype.skipType = function (e2) {
                switch (e2) {
                  case 0:
                    this.skip()
                    break
                  case 1:
                    this.skip(8)
                    break
                  case 2:
                    this.skip(this.uint32())
                    break
                  case 3:
                    for (; 4 != (e2 = 7 & this.uint32()); ) this.skipType(e2)
                    break
                  case 5:
                    this.skip(4)
                    break
                  default:
                    throw Error('invalid wire type ' + e2 + ' at offset ' + this.pos)
                }
                return this
              }),
              (f._configure = function (e2) {
                ;((o = e2), (f.create = l()), o._configure())
                var t2 = s.Long ? 'toLong' : 'toNumber'
                s.merge(f.prototype, {
                  int64: function () {
                    return p.call(this)[t2](false)
                  },
                  uint64: function () {
                    return p.call(this)[t2](true)
                  },
                  sint64: function () {
                    return p.call(this).zzDecode()[t2](false)
                  },
                  fixed64: function () {
                    return h.call(this)[t2](true)
                  },
                  sfixed64: function () {
                    return h.call(this)[t2](false)
                  },
                })
              }))
          },
          './protobufjs/src/reader_buffer.js': function (e, t, r) {
            e.exports = i
            var o = r('./protobufjs/src/reader.js')
            ;(i.prototype = Object.create(o.prototype)).constructor = i
            var s = r('./protobufjs/src/util/minimal.js')
            function i(e2) {
              o.call(this, e2)
            }
            ;((i._configure = function () {
              s.Buffer && (i.prototype._slice = s.Buffer.prototype.slice)
            }),
              (i.prototype.string = function () {
                var e2 = this.uint32()
                return this.buf.utf8Slice
                  ? this.buf.utf8Slice(this.pos, (this.pos = Math.min(this.pos + e2, this.len)))
                  : this.buf.toString('utf-8', this.pos, (this.pos = Math.min(this.pos + e2, this.len)))
              }),
              i._configure())
          },
          './protobufjs/src/root.js': function (e, t, r) {
            e.exports = p
            var o,
              s,
              i,
              n = r('./protobufjs/src/namespace.js')
            ;((p.prototype = Object.create(n.prototype)).constructor = p).className = 'Root'
            var u = r('./protobufjs/src/field.js'),
              f = r('./protobufjs/src/enum.js'),
              a = r('./protobufjs/src/oneof.js'),
              l = r('./protobufjs/src/util.js')
            function p(e2) {
              ;(n.call(this, '', e2),
                (this.deferred = []),
                (this.files = []),
                (this._edition = 'proto2'),
                (this._fullyQualifiedObjects = {}))
            }
            function c() {}
            ;((p.fromJSON = function (e2, t2) {
              return (t2 || (t2 = new p()), e2.options && t2.setOptions(e2.options), t2.addJSON(e2.nested).resolveAll())
            }),
              (p.prototype.resolvePath = l.path.resolve),
              (p.prototype.fetch = l.fetch),
              (p.prototype.load = function e2(t2, r2, o2) {
                'function' == typeof r2 && ((o2 = r2), (r2 = void 0))
                var n2 = this
                if (!o2) return l.asPromise(e2, n2, t2, r2)
                var u2 = o2 === c
                function f2(e3, t3) {
                  if (o2) {
                    if (u2) throw e3
                    t3 && t3.resolveAll()
                    var r3 = o2
                    ;((o2 = null), r3(e3, t3))
                  }
                }
                function a2(e3) {
                  var t3 = e3.lastIndexOf('google/protobuf/')
                  if (t3 > -1) {
                    var r3 = e3.substring(t3)
                    if (r3 in i) return r3
                  }
                  return null
                }
                function p2(e3, t3) {
                  try {
                    if ((l.isString(t3) && '{' === t3.charAt(0) && (t3 = JSON.parse(t3)), l.isString(t3))) {
                      s.filename = e3
                      var o3,
                        i2 = s(t3, n2, r2),
                        p3 = 0
                      if (i2.imports)
                        for (; p3 < i2.imports.length; ++p3)
                          (o3 = a2(i2.imports[p3]) || n2.resolvePath(e3, i2.imports[p3])) && h2(o3)
                      if (i2.weakImports)
                        for (p3 = 0; p3 < i2.weakImports.length; ++p3)
                          (o3 = a2(i2.weakImports[p3]) || n2.resolvePath(e3, i2.weakImports[p3])) && h2(o3, true)
                    } else n2.setOptions(t3.options).addJSON(t3.nested)
                  } catch (e4) {
                    f2(e4)
                  }
                  u2 || d2 || f2(null, n2)
                }
                function h2(e3, t3) {
                  if (((e3 = a2(e3) || e3), !(n2.files.indexOf(e3) > -1))) {
                    if ((n2.files.push(e3), e3 in i))
                      return void (u2
                        ? p2(e3, i[e3])
                        : (++d2,
                          setTimeout(function () {
                            ;(--d2, p2(e3, i[e3]))
                          })))
                    if (u2) {
                      var r3
                      try {
                        r3 = l.fs.readFileSync(e3).toString('utf8')
                      } catch (e4) {
                        t3 || f2(e4)
                        return
                      }
                      p2(e3, r3)
                    } else
                      (++d2,
                        n2.fetch(e3, function (r4, s2) {
                          if ((--d2, o2)) {
                            if (r4) return void (t3 ? d2 || f2(null, n2) : f2(r4))
                            p2(e3, s2)
                          }
                        }))
                  }
                }
                var d2 = 0
                l.isString(t2) && (t2 = [t2])
                for (var y, v = 0; v < t2.length; ++v) (y = n2.resolvePath('', t2[v])) && h2(y)
                return (u2 ? n2.resolveAll() : d2 || f2(null, n2), n2)
              }),
              (p.prototype.loadSync = function (e2, t2) {
                if (!l.isNode) throw Error('not supported')
                return this.load(e2, t2, c)
              }),
              (p.prototype.resolveAll = function () {
                if (!this._needsRecursiveResolve) return this
                if (this.deferred.length)
                  throw Error(
                    'unresolvable extensions: ' +
                      this.deferred
                        .map(function (e2) {
                          return "'extend " + e2.extend + "' in " + e2.parent.fullName
                        })
                        .join(', ')
                  )
                return n.prototype.resolveAll.call(this)
              }))
            var h = /^[A-Z]/
            function d(e2, t2) {
              var r2 = t2.parent.lookup(t2.extend)
              if (r2) {
                var o2 = new u(t2.fullName, t2.id, t2.type, t2.rule, void 0, t2.options)
                return !!r2.get(o2.name) || ((o2.declaringField = t2), (t2.extensionField = o2), r2.add(o2), true)
              }
              return false
            }
            ;((p.prototype._handleAdd = function (e2) {
              if (e2 instanceof u) void 0 === e2.extend || e2.extensionField || d(this, e2) || this.deferred.push(e2)
              else if (e2 instanceof f) h.test(e2.name) && (e2.parent[e2.name] = e2.values)
              else if (!(e2 instanceof a)) {
                if (e2 instanceof o)
                  for (var t2 = 0; t2 < this.deferred.length; )
                    d(this, this.deferred[t2]) ? this.deferred.splice(t2, 1) : ++t2
                for (var r2 = 0; r2 < e2.nestedArray.length; ++r2) this._handleAdd(e2._nestedArray[r2])
                h.test(e2.name) && (e2.parent[e2.name] = e2)
              }
              ;(e2 instanceof o || e2 instanceof f || e2 instanceof u) &&
                (this._fullyQualifiedObjects[e2.fullName] = e2)
            }),
              (p.prototype._handleRemove = function (e2) {
                if (e2 instanceof u) {
                  if (void 0 !== e2.extend)
                    if (e2.extensionField)
                      (e2.extensionField.parent.remove(e2.extensionField), (e2.extensionField = null))
                    else {
                      var t2 = this.deferred.indexOf(e2)
                      t2 > -1 && this.deferred.splice(t2, 1)
                    }
                } else if (e2 instanceof f) h.test(e2.name) && delete e2.parent[e2.name]
                else if (e2 instanceof n) {
                  for (var r2 = 0; r2 < e2.nestedArray.length; ++r2) this._handleRemove(e2._nestedArray[r2])
                  h.test(e2.name) && delete e2.parent[e2.name]
                }
                delete this._fullyQualifiedObjects[e2.fullName]
              }),
              (p._configure = function (e2, t2, r2) {
                ;((o = e2), (s = t2), (i = r2))
              }))
          },
          './protobufjs/src/roots.js': function (e) {
            e.exports = {}
          },
          './protobufjs/src/rpc.js': function (e, t, r) {
            t.Service = r('./protobufjs/src/rpc/service.js')
          },
          './protobufjs/src/rpc/service.js': function (e, t, r) {
            e.exports = s
            var o = r('./protobufjs/src/util/minimal.js')
            function s(e2, t2, r2) {
              if ('function' != typeof e2) throw TypeError('rpcImpl must be a function')
              ;(o.EventEmitter.call(this),
                (this.rpcImpl = e2),
                (this.requestDelimited = !!t2),
                (this.responseDelimited = !!r2))
            }
            ;(((s.prototype = Object.create(o.EventEmitter.prototype)).constructor = s),
              (s.prototype.rpcCall = function e2(t2, r2, s2, i, n) {
                if (!i) throw TypeError('request must be specified')
                var u = this
                if (!n) return o.asPromise(e2, u, t2, r2, s2, i)
                if (!u.rpcImpl)
                  return void setTimeout(function () {
                    n(Error('already ended'))
                  }, 0)
                try {
                  return u.rpcImpl(
                    t2,
                    r2[u.requestDelimited ? 'encodeDelimited' : 'encode'](i).finish(),
                    function (e3, r3) {
                      if (e3) return (u.emit('error', e3, t2), n(e3))
                      if (null === r3) return void u.end(true)
                      if (!(r3 instanceof s2))
                        try {
                          r3 = s2[u.responseDelimited ? 'decodeDelimited' : 'decode'](r3)
                        } catch (e4) {
                          return (u.emit('error', e4, t2), n(e4))
                        }
                      return (u.emit('data', r3, t2), n(null, r3))
                    }
                  )
                } catch (e3) {
                  ;(u.emit('error', e3, t2),
                    setTimeout(function () {
                      n(e3)
                    }, 0))
                  return
                }
              }),
              (s.prototype.end = function (e2) {
                return (
                  this.rpcImpl && (e2 || this.rpcImpl(null, null, null), (this.rpcImpl = null), this.emit('end').off()),
                  this
                )
              }))
          },
          './protobufjs/src/service.js': function (e, t, r) {
            e.exports = u
            var o = r('./protobufjs/src/namespace.js')
            ;((u.prototype = Object.create(o.prototype)).constructor = u).className = 'Service'
            var s = r('./protobufjs/src/method.js'),
              i = r('./protobufjs/src/util.js'),
              n = r('./protobufjs/src/rpc.js')
            function u(e2, t2) {
              ;(o.call(this, e2, t2), (this.methods = {}), (this._methodsArray = null))
            }
            function f(e2) {
              return ((e2._methodsArray = null), e2)
            }
            ;((u.fromJSON = function (e2, t2) {
              var r2 = new u(e2, t2.options)
              if (t2.methods)
                for (var o2 = Object.keys(t2.methods), i2 = 0; i2 < o2.length; ++i2)
                  r2.add(s.fromJSON(o2[i2], t2.methods[o2[i2]]))
              return (
                t2.nested && r2.addJSON(t2.nested),
                t2.edition && (r2._edition = t2.edition),
                (r2.comment = t2.comment),
                (r2._defaultEdition = 'proto3'),
                r2
              )
            }),
              (u.prototype.toJSON = function (e2) {
                var t2 = o.prototype.toJSON.call(this, e2),
                  r2 = !!e2 && !!e2.keepComments
                return i.toObject([
                  'edition',
                  this._editionToJSON(),
                  'options',
                  (t2 && t2.options) || void 0,
                  'methods',
                  o.arrayToJSON(this.methodsArray, e2) || {},
                  'nested',
                  (t2 && t2.nested) || void 0,
                  'comment',
                  r2 ? this.comment : void 0,
                ])
              }),
              Object.defineProperty(u.prototype, 'methodsArray', {
                get: function () {
                  return this._methodsArray || (this._methodsArray = i.toArray(this.methods))
                },
              }),
              (u.prototype.get = function (e2) {
                return this.methods[e2] || o.prototype.get.call(this, e2)
              }),
              (u.prototype.resolveAll = function () {
                if (!this._needsRecursiveResolve) return this
                o.prototype.resolve.call(this)
                for (var e2 = this.methodsArray, t2 = 0; t2 < e2.length; ++t2) e2[t2].resolve()
                return this
              }),
              (u.prototype._resolveFeaturesRecursive = function (e2) {
                return (
                  this._needsRecursiveFeatureResolution &&
                    ((e2 = this._edition || e2),
                    o.prototype._resolveFeaturesRecursive.call(this, e2),
                    this.methodsArray.forEach((t2) => {
                      t2._resolveFeaturesRecursive(e2)
                    })),
                  this
                )
              }),
              (u.prototype.add = function (e2) {
                if (this.get(e2.name)) throw Error("duplicate name '" + e2.name + "' in " + this)
                return e2 instanceof s
                  ? ((this.methods[e2.name] = e2), (e2.parent = this), f(this))
                  : o.prototype.add.call(this, e2)
              }),
              (u.prototype.remove = function (e2) {
                if (e2 instanceof s) {
                  if (this.methods[e2.name] !== e2) throw Error(e2 + ' is not a member of ' + this)
                  return (delete this.methods[e2.name], (e2.parent = null), f(this))
                }
                return o.prototype.remove.call(this, e2)
              }),
              (u.prototype.create = function (e2, t2, r2) {
                for (var o2, s2 = new n.Service(e2, t2, r2), u2 = 0; u2 < this.methodsArray.length; ++u2) {
                  var f2 = i.lcFirst((o2 = this._methodsArray[u2]).resolve().name).replace(/[^$\w_]/g, '')
                  s2[f2] = i.codegen(['r', 'c'], i.isReserved(f2) ? f2 + '_' : f2)('return this.rpcCall(m,q,s,r,c)')({
                    m: o2,
                    q: o2.resolvedRequestType.ctor,
                    s: o2.resolvedResponseType.ctor,
                  })
                }
                return s2
              }))
          },
          './protobufjs/src/tokenize.js': function (e) {
            e.exports = p
            var t = /[\s{}=;:[\],'"()<>]/g,
              r = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
              o = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
              s = /^ *[*/]+ */,
              i = /^\s*\*?\/*/,
              n = /\n/g,
              u = /\s/,
              f = /\\(.?)/g,
              a = { 0: '\0', r: '\r', n: '\n', t: '	' }
            function l(e2) {
              return e2.replace(f, function (e3, t2) {
                switch (t2) {
                  case '\\':
                  case '':
                    return t2
                  default:
                    return a[t2] || ''
                }
              })
            }
            function p(e2, f2) {
              e2 = e2.toString()
              var a2 = 0,
                p2 = e2.length,
                c = 1,
                h = 0,
                d = {},
                y = [],
                v = null
              function m(e3) {
                return Error('illegal ' + e3 + ' (line ' + c + ')')
              }
              function b() {
                var t2 = "'" === v ? o : r
                t2.lastIndex = a2 - 1
                var s2 = t2.exec(e2)
                if (!s2) throw m('string')
                return ((a2 = t2.lastIndex), k(v), (v = null), l(s2[1]))
              }
              function j(t2) {
                return e2.charAt(t2)
              }
              function g(t2, r2, o2) {
                var u2,
                  a3 = { type: e2.charAt(t2++), lineEmpty: false, leading: o2 },
                  l2 = t2 - (f2 ? 2 : 3)
                do
                  if (--l2 < 0 || '\n' === (u2 = e2.charAt(l2))) {
                    a3.lineEmpty = true
                    break
                  }
                while (' ' === u2 || '	' === u2)
                for (var p3 = e2.substring(t2, r2).split(n), y2 = 0; y2 < p3.length; ++y2)
                  p3[y2] = p3[y2].replace(f2 ? i : s, '').trim()
                ;((a3.text = p3.join('\n').trim()), (d[c] = a3), (h = c))
              }
              function w(t2) {
                var r2 = O(t2),
                  o2 = e2.substring(t2, r2)
                return /^\s*\/\//.test(o2)
              }
              function O(e3) {
                for (var t2 = e3; t2 < p2 && '\n' !== j(t2); ) t2++
                return t2
              }
              function _() {
                if (y.length > 0) return y.shift()
                if (v) return b()
                var r2,
                  o2,
                  s2,
                  i2,
                  n2,
                  l2 = 0 === a2
                do {
                  if (a2 === p2) return null
                  for (r2 = false; u.test((s2 = j(a2))); )
                    if (('\n' === s2 && ((l2 = true), ++c), ++a2 === p2)) return null
                  if ('/' === j(a2)) {
                    if (++a2 === p2) throw m('comment')
                    if ('/' === j(a2))
                      if (f2) {
                        if (((i2 = a2), (n2 = false), w(a2 - 1))) {
                          n2 = true
                          do if ((a2 = O(a2)) === p2 || (a2++, !l2)) break
                          while (w(a2))
                        } else a2 = Math.min(p2, O(a2) + 1)
                        ;(n2 && (g(i2, a2, l2), (l2 = true)), c++, (r2 = true))
                      } else {
                        for (n2 = '/' === j((i2 = a2 + 1)); '\n' !== j(++a2); ) if (a2 === p2) return null
                        ;(++a2, n2 && (g(i2, a2 - 1, l2), (l2 = true)), ++c, (r2 = true))
                      }
                    else {
                      if ('*' !== (s2 = j(a2))) return '/'
                      ;((i2 = a2 + 1), (n2 = f2 || '*' === j(i2)))
                      do {
                        if (('\n' === s2 && ++c, ++a2 === p2)) throw m('comment')
                        ;((o2 = s2), (s2 = j(a2)))
                      } while ('*' !== o2 || '/' !== s2)
                      ;(++a2, n2 && (g(i2, a2 - 2, l2), (l2 = true)), (r2 = true))
                    }
                  }
                } while (r2)
                var h2 = a2
                if (((t.lastIndex = 0), !t.test(j(h2++)))) for (; h2 < p2 && !t.test(j(h2)); ) ++h2
                var d2 = e2.substring(a2, (a2 = h2))
                return (('"' === d2 || "'" === d2) && (v = d2), d2)
              }
              function k(e3) {
                y.push(e3)
              }
              function x() {
                if (!y.length) {
                  var e3 = _()
                  if (null === e3) return null
                  k(e3)
                }
                return y[0]
              }
              function A(e3, t2) {
                var r2 = x()
                if (r2 === e3) return (_(), true)
                if (!t2) throw m("token '" + r2 + "', '" + e3 + "' expected")
                return false
              }
              function E(e3) {
                var t2,
                  r2 = null
                return (
                  void 0 === e3
                    ? ((t2 = d[c - 1]),
                      delete d[c - 1],
                      t2 && (f2 || '*' === t2.type || t2.lineEmpty) && (r2 = t2.leading ? t2.text : null))
                    : (h < e3 && x(),
                      (t2 = d[e3]),
                      delete d[e3],
                      t2 && !t2.lineEmpty && (f2 || '/' === t2.type) && (r2 = t2.leading ? null : t2.text)),
                  r2
                )
              }
              return Object.defineProperty({ next: _, peek: x, push: k, skip: A, cmnt: E }, 'line', {
                get: function () {
                  return c
                },
              })
            }
            p.unescape = l
          },
          './protobufjs/src/type.js': function (e, t, r) {
            e.exports = b
            var o = r('./protobufjs/src/namespace.js')
            ;((b.prototype = Object.create(o.prototype)).constructor = b).className = 'Type'
            var s = r('./protobufjs/src/enum.js'),
              i = r('./protobufjs/src/oneof.js'),
              n = r('./protobufjs/src/field.js'),
              u = r('./protobufjs/src/mapfield.js'),
              f = r('./protobufjs/src/service.js'),
              a = r('./protobufjs/src/message.js'),
              l = r('./protobufjs/src/reader.js'),
              p = r('./protobufjs/src/writer.js'),
              c = r('./protobufjs/src/util.js'),
              h = r('./protobufjs/src/encoder.js'),
              d = r('./protobufjs/src/decoder.js'),
              y = r('./protobufjs/src/verifier.js'),
              v = r('./protobufjs/src/converter.js'),
              m = r('./protobufjs/src/wrappers.js')
            function b(e2, t2) {
              ;(o.call(this, e2, t2),
                (this.fields = {}),
                (this.oneofs = void 0),
                (this.extensions = void 0),
                (this.reserved = void 0),
                (this.group = void 0),
                (this._fieldsById = null),
                (this._fieldsArray = null),
                (this._oneofsArray = null),
                (this._ctor = null))
            }
            function j(e2) {
              return (
                (e2._fieldsById = e2._fieldsArray = e2._oneofsArray = null),
                delete e2.encode,
                delete e2.decode,
                delete e2.verify,
                e2
              )
            }
            ;(Object.defineProperties(b.prototype, {
              fieldsById: {
                get: function () {
                  if (this._fieldsById) return this._fieldsById
                  this._fieldsById = {}
                  for (var e2 = Object.keys(this.fields), t2 = 0; t2 < e2.length; ++t2) {
                    var r2 = this.fields[e2[t2]],
                      o2 = r2.id
                    if (this._fieldsById[o2]) throw Error('duplicate id ' + o2 + ' in ' + this)
                    this._fieldsById[o2] = r2
                  }
                  return this._fieldsById
                },
              },
              fieldsArray: {
                get: function () {
                  return this._fieldsArray || (this._fieldsArray = c.toArray(this.fields))
                },
              },
              oneofsArray: {
                get: function () {
                  return this._oneofsArray || (this._oneofsArray = c.toArray(this.oneofs))
                },
              },
              ctor: {
                get: function () {
                  return this._ctor || (this.ctor = b.generateConstructor(this)())
                },
                set: function (e2) {
                  var t2 = e2.prototype
                  ;(t2 instanceof a || (((e2.prototype = new a()).constructor = e2), c.merge(e2.prototype, t2)),
                    (e2.$type = e2.prototype.$type = this),
                    c.merge(e2, a, true),
                    (this._ctor = e2))
                  for (var r2 = 0; r2 < this.fieldsArray.length; ++r2) this._fieldsArray[r2].resolve()
                  var o2 = {}
                  for (r2 = 0; r2 < this.oneofsArray.length; ++r2)
                    o2[this._oneofsArray[r2].resolve().name] = {
                      get: c.oneOfGetter(this._oneofsArray[r2].oneof),
                      set: c.oneOfSetter(this._oneofsArray[r2].oneof),
                    }
                  r2 && Object.defineProperties(e2.prototype, o2)
                },
              },
            }),
              (b.generateConstructor = function (e2) {
                for (var t2, r2 = c.codegen(['p'], e2.name), o2 = 0; o2 < e2.fieldsArray.length; ++o2)
                  (t2 = e2._fieldsArray[o2]).map
                    ? r2('this%s={}', c.safeProp(t2.name))
                    : t2.repeated && r2('this%s=[]', c.safeProp(t2.name))
                return r2('if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)')(
                  'this[ks[i]]=p[ks[i]]'
                )
              }),
              (b.fromJSON = function (e2, t2) {
                var r2 = new b(e2, t2.options)
                ;((r2.extensions = t2.extensions), (r2.reserved = t2.reserved))
                for (var a2 = Object.keys(t2.fields), l2 = 0; l2 < a2.length; ++l2)
                  r2.add((void 0 !== t2.fields[a2[l2]].keyType ? u.fromJSON : n.fromJSON)(a2[l2], t2.fields[a2[l2]]))
                if (t2.oneofs)
                  for (a2 = Object.keys(t2.oneofs), l2 = 0; l2 < a2.length; ++l2)
                    r2.add(i.fromJSON(a2[l2], t2.oneofs[a2[l2]]))
                if (t2.nested)
                  for (a2 = Object.keys(t2.nested), l2 = 0; l2 < a2.length; ++l2) {
                    var p2 = t2.nested[a2[l2]]
                    r2.add(
                      (void 0 !== p2.id
                        ? n.fromJSON
                        : void 0 !== p2.fields
                          ? b.fromJSON
                          : void 0 !== p2.values
                            ? s.fromJSON
                            : void 0 !== p2.methods
                              ? f.fromJSON
                              : o.fromJSON)(a2[l2], p2)
                    )
                  }
                return (
                  t2.extensions && t2.extensions.length && (r2.extensions = t2.extensions),
                  t2.reserved && t2.reserved.length && (r2.reserved = t2.reserved),
                  t2.group && (r2.group = true),
                  t2.comment && (r2.comment = t2.comment),
                  t2.edition && (r2._edition = t2.edition),
                  (r2._defaultEdition = 'proto3'),
                  r2
                )
              }),
              (b.prototype.toJSON = function (e2) {
                var t2 = o.prototype.toJSON.call(this, e2),
                  r2 = !!e2 && !!e2.keepComments
                return c.toObject([
                  'edition',
                  this._editionToJSON(),
                  'options',
                  (t2 && t2.options) || void 0,
                  'oneofs',
                  o.arrayToJSON(this.oneofsArray, e2),
                  'fields',
                  o.arrayToJSON(
                    this.fieldsArray.filter(function (e3) {
                      return !e3.declaringField
                    }),
                    e2
                  ) || {},
                  'extensions',
                  this.extensions && this.extensions.length ? this.extensions : void 0,
                  'reserved',
                  this.reserved && this.reserved.length ? this.reserved : void 0,
                  'group',
                  this.group || void 0,
                  'nested',
                  (t2 && t2.nested) || void 0,
                  'comment',
                  r2 ? this.comment : void 0,
                ])
              }),
              (b.prototype.resolveAll = function () {
                if (!this._needsRecursiveResolve) return this
                o.prototype.resolveAll.call(this)
                var e2 = this.oneofsArray
                for (r2 = 0; r2 < e2.length; ) e2[r2++].resolve()
                for (var t2 = this.fieldsArray, r2 = 0; r2 < t2.length; ) t2[r2++].resolve()
                return this
              }),
              (b.prototype._resolveFeaturesRecursive = function (e2) {
                return (
                  this._needsRecursiveFeatureResolution &&
                    ((e2 = this._edition || e2),
                    o.prototype._resolveFeaturesRecursive.call(this, e2),
                    this.oneofsArray.forEach((t2) => {
                      t2._resolveFeatures(e2)
                    }),
                    this.fieldsArray.forEach((t2) => {
                      t2._resolveFeatures(e2)
                    })),
                  this
                )
              }),
              (b.prototype.get = function (e2) {
                return this.fields[e2] || (this.oneofs && this.oneofs[e2]) || (this.nested && this.nested[e2]) || null
              }),
              (b.prototype.add = function (e2) {
                if (this.get(e2.name)) throw Error("duplicate name '" + e2.name + "' in " + this)
                if (e2 instanceof n && void 0 === e2.extend) {
                  if (this._fieldsById ? this._fieldsById[e2.id] : this.fieldsById[e2.id])
                    throw Error('duplicate id ' + e2.id + ' in ' + this)
                  if (this.isReservedId(e2.id)) throw Error('id ' + e2.id + ' is reserved in ' + this)
                  if (this.isReservedName(e2.name)) throw Error("name '" + e2.name + "' is reserved in " + this)
                  return (
                    e2.parent && e2.parent.remove(e2),
                    (this.fields[e2.name] = e2),
                    (e2.message = this),
                    e2.onAdd(this),
                    j(this)
                  )
                }
                return e2 instanceof i
                  ? (this.oneofs || (this.oneofs = {}), (this.oneofs[e2.name] = e2), e2.onAdd(this), j(this))
                  : o.prototype.add.call(this, e2)
              }),
              (b.prototype.remove = function (e2) {
                if (e2 instanceof n && void 0 === e2.extend) {
                  if (!this.fields || this.fields[e2.name] !== e2) throw Error(e2 + ' is not a member of ' + this)
                  return (delete this.fields[e2.name], (e2.parent = null), e2.onRemove(this), j(this))
                }
                if (e2 instanceof i) {
                  if (!this.oneofs || this.oneofs[e2.name] !== e2) throw Error(e2 + ' is not a member of ' + this)
                  return (delete this.oneofs[e2.name], (e2.parent = null), e2.onRemove(this), j(this))
                }
                return o.prototype.remove.call(this, e2)
              }),
              (b.prototype.isReservedId = function (e2) {
                return o.isReservedId(this.reserved, e2)
              }),
              (b.prototype.isReservedName = function (e2) {
                return o.isReservedName(this.reserved, e2)
              }),
              (b.prototype.create = function (e2) {
                return new this.ctor(e2)
              }),
              (b.prototype.setup = function () {
                for (var e2 = this.fullName, t2 = [], r2 = 0; r2 < this.fieldsArray.length; ++r2)
                  t2.push(this._fieldsArray[r2].resolve().resolvedType)
                ;((this.encode = h(this)({ Writer: p, types: t2, util: c })),
                  (this.decode = d(this)({ Reader: l, types: t2, util: c })),
                  (this.verify = y(this)({ types: t2, util: c })),
                  (this.fromObject = v.fromObject(this)({ types: t2, util: c })),
                  (this.toObject = v.toObject(this)({ types: t2, util: c })))
                var o2 = m[e2]
                if (o2) {
                  var s2 = Object.create(this)
                  ;((s2.fromObject = this.fromObject),
                    (this.fromObject = o2.fromObject.bind(s2)),
                    (s2.toObject = this.toObject),
                    (this.toObject = o2.toObject.bind(s2)))
                }
                return this
              }),
              (b.prototype.encode = function (e2, t2) {
                return this.setup().encode(e2, t2)
              }),
              (b.prototype.encodeDelimited = function (e2, t2) {
                return this.encode(e2, t2 && t2.len ? t2.fork() : t2).ldelim()
              }),
              (b.prototype.decode = function (e2, t2) {
                return this.setup().decode(e2, t2)
              }),
              (b.prototype.decodeDelimited = function (e2) {
                return (e2 instanceof l || (e2 = l.create(e2)), this.decode(e2, e2.uint32()))
              }),
              (b.prototype.verify = function (e2) {
                return this.setup().verify(e2)
              }),
              (b.prototype.fromObject = function (e2) {
                return this.setup().fromObject(e2)
              }),
              (b.prototype.toObject = function (e2, t2) {
                return this.setup().toObject(e2, t2)
              }),
              (b.d = function (e2) {
                return function (t2) {
                  c.decorateType(t2, e2)
                }
              }))
          },
          './protobufjs/src/types.js': function (e, t, r) {
            var o = t,
              s = r('./protobufjs/src/util.js'),
              i = [
                'double',
                'float',
                'int32',
                'uint32',
                'sint32',
                'fixed32',
                'sfixed32',
                'int64',
                'uint64',
                'sint64',
                'fixed64',
                'sfixed64',
                'bool',
                'string',
                'bytes',
              ]
            function n(e2, t2) {
              var r2 = 0,
                o2 = {}
              for (t2 |= 0; r2 < e2.length; ) o2[i[r2 + t2]] = e2[r2++]
              return o2
            }
            ;((o.basic = n([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2])),
              (o.defaults = n([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, '', s.emptyArray, null])),
              (o.long = n([0, 0, 0, 1, 1], 7)),
              (o.mapKey = n([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2)),
              (o.packed = n([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0])))
          },
          './protobufjs/src/util.js': function (e, t, r) {
            var o,
              s,
              i = (e.exports = r('./protobufjs/src/util/minimal.js')),
              n = r('./protobufjs/src/roots.js')
            ;((i.codegen = r('./@protobufjs/codegen/index.js')),
              (i.fetch = r('./@protobufjs/fetch/index.js')),
              (i.path = r('./@protobufjs/path/index.js')),
              (i.fs = i.inquire('fs')),
              (i.toArray = function (e2) {
                if (e2) {
                  for (var t2 = Object.keys(e2), r2 = Array(t2.length), o2 = 0; o2 < t2.length; ) r2[o2] = e2[t2[o2++]]
                  return r2
                }
                return []
              }),
              (i.toObject = function (e2) {
                for (var t2 = {}, r2 = 0; r2 < e2.length; ) {
                  var o2 = e2[r2++],
                    s2 = e2[r2++]
                  void 0 !== s2 && (t2[o2] = s2)
                }
                return t2
              }))
            var u = /\\/g,
              f = /"/g
            ;((i.isReserved = function (e2) {
              return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(
                e2
              )
            }),
              (i.safeProp = function (e2) {
                return !/^[$\w_]+$/.test(e2) || i.isReserved(e2)
                  ? '["' + e2.replace(u, '\\\\').replace(f, '\\"') + '"]'
                  : '.' + e2
              }),
              (i.ucFirst = function (e2) {
                return e2.charAt(0).toUpperCase() + e2.substring(1)
              }))
            var a = /_([a-z])/g
            ;((i.camelCase = function (e2) {
              return (
                e2.substring(0, 1) +
                e2.substring(1).replace(a, function (e3, t2) {
                  return t2.toUpperCase()
                })
              )
            }),
              (i.compareFieldsById = function (e2, t2) {
                return e2.id - t2.id
              }),
              (i.decorateType = function (e2, t2) {
                if (e2.$type)
                  return (
                    t2 &&
                      e2.$type.name !== t2 &&
                      (i.decorateRoot.remove(e2.$type), (e2.$type.name = t2), i.decorateRoot.add(e2.$type)),
                    e2.$type
                  )
                o || (o = r('./protobufjs/src/type.js'))
                var s2 = new o(t2 || e2.name)
                return (
                  i.decorateRoot.add(s2),
                  (s2.ctor = e2),
                  Object.defineProperty(e2, '$type', { value: s2, enumerable: false }),
                  Object.defineProperty(e2.prototype, '$type', { value: s2, enumerable: false }),
                  s2
                )
              }))
            var l = 0
            ;((i.decorateEnum = function (e2) {
              if (e2.$type) return e2.$type
              s || (s = r('./protobufjs/src/enum.js'))
              var t2 = new s('Enum' + l++, e2)
              return (i.decorateRoot.add(t2), Object.defineProperty(e2, '$type', { value: t2, enumerable: false }), t2)
            }),
              (i.setProperty = function (e2, t2, r2, o2) {
                function s2(e3, t3, r3) {
                  var i2 = t3.shift()
                  if ('__proto__' === i2 || 'prototype' === i2) return e3
                  if (t3.length > 0) e3[i2] = s2(e3[i2] || {}, t3, r3)
                  else {
                    var n2 = e3[i2]
                    if (n2 && o2) return e3
                    ;(n2 && (r3 = [].concat(n2).concat(r3)), (e3[i2] = r3))
                  }
                  return e3
                }
                if ('object' != typeof e2) throw TypeError('dst must be an object')
                if (!t2) throw TypeError('path must be specified')
                return s2(e2, (t2 = t2.split('.')), r2)
              }),
              Object.defineProperty(i, 'decorateRoot', {
                get: function () {
                  return n.decorated || (n.decorated = new (r('./protobufjs/src/root.js'))())
                },
              }))
          },
          './protobufjs/src/util/longbits.js': function (e, t, r) {
            e.exports = s
            var o = r('./protobufjs/src/util/minimal.js')
            function s(e2, t2) {
              ;((this.lo = e2 >>> 0), (this.hi = t2 >>> 0))
            }
            var i = (s.zero = new s(0, 0))
            ;((i.toNumber = function () {
              return 0
            }),
              (i.zzEncode = i.zzDecode =
                function () {
                  return this
                }),
              (i.length = function () {
                return 1
              }))
            var n = (s.zeroHash = '\0\0\0\0\0\0\0\0')
            ;((s.fromNumber = function (e2) {
              if (0 === e2) return i
              var t2 = e2 < 0
              t2 && (e2 = -e2)
              var r2 = e2 >>> 0,
                o2 = ((e2 - r2) / 4294967296) >>> 0
              return (
                t2 &&
                  ((o2 = ~o2 >>> 0), (r2 = ~r2 >>> 0), ++r2 > 4294967295 && ((r2 = 0), ++o2 > 4294967295 && (o2 = 0))),
                new s(r2, o2)
              )
            }),
              (s.from = function (e2) {
                if ('number' == typeof e2) return s.fromNumber(e2)
                if (o.isString(e2))
                  if (!o.Long) return s.fromNumber(parseInt(e2, 10))
                  else e2 = o.Long.fromString(e2)
                return e2.low || e2.high ? new s(e2.low >>> 0, e2.high >>> 0) : i
              }),
              (s.prototype.toNumber = function (e2) {
                if (!e2 && this.hi >>> 31) {
                  var t2 = (~this.lo + 1) >>> 0,
                    r2 = ~this.hi >>> 0
                  return (t2 || (r2 = (r2 + 1) >>> 0), -(t2 + 4294967296 * r2))
                }
                return this.lo + 4294967296 * this.hi
              }),
              (s.prototype.toLong = function (e2) {
                return o.Long
                  ? new o.Long(0 | this.lo, 0 | this.hi, !!e2)
                  : { low: 0 | this.lo, high: 0 | this.hi, unsigned: !!e2 }
              }))
            var u = String.prototype.charCodeAt
            ;((s.fromHash = function (e2) {
              return e2 === n
                ? i
                : new s(
                    (u.call(e2, 0) | (u.call(e2, 1) << 8) | (u.call(e2, 2) << 16) | (u.call(e2, 3) << 24)) >>> 0,
                    (u.call(e2, 4) | (u.call(e2, 5) << 8) | (u.call(e2, 6) << 16) | (u.call(e2, 7) << 24)) >>> 0
                  )
            }),
              (s.prototype.toHash = function () {
                return String.fromCharCode(
                  255 & this.lo,
                  (this.lo >>> 8) & 255,
                  (this.lo >>> 16) & 255,
                  this.lo >>> 24,
                  255 & this.hi,
                  (this.hi >>> 8) & 255,
                  (this.hi >>> 16) & 255,
                  this.hi >>> 24
                )
              }),
              (s.prototype.zzEncode = function () {
                var e2 = this.hi >> 31
                return (
                  (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ e2) >>> 0),
                  (this.lo = ((this.lo << 1) ^ e2) >>> 0),
                  this
                )
              }),
              (s.prototype.zzDecode = function () {
                var e2 = -(1 & this.lo)
                return (
                  (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ e2) >>> 0),
                  (this.hi = ((this.hi >>> 1) ^ e2) >>> 0),
                  this
                )
              }),
              (s.prototype.length = function () {
                var e2 = this.lo,
                  t2 = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
                  r2 = this.hi >>> 24
                return 0 === r2
                  ? 0 === t2
                    ? e2 < 16384
                      ? e2 < 128
                        ? 1
                        : 2
                      : e2 < 2097152
                        ? 3
                        : 4
                    : t2 < 16384
                      ? t2 < 128
                        ? 5
                        : 6
                      : t2 < 2097152
                        ? 7
                        : 8
                  : r2 < 128
                    ? 9
                    : 10
              }))
          },
          './protobufjs/src/util/minimal.js': function (e, t, r) {
            var o = t
            function s(e2, t2, r2) {
              for (var o2 = Object.keys(t2), s2 = 0; s2 < o2.length; ++s2)
                (void 0 !== e2[o2[s2]] && r2) || (e2[o2[s2]] = t2[o2[s2]])
              return e2
            }
            function i(e2) {
              function t2(e3, r2) {
                if (!(this instanceof t2)) return new t2(e3, r2)
                ;(Object.defineProperty(this, 'message', {
                  get: function () {
                    return e3
                  },
                }),
                  Error.captureStackTrace
                    ? Error.captureStackTrace(this, t2)
                    : Object.defineProperty(this, 'stack', { value: Error().stack || '' }),
                  r2 && s(this, r2))
              }
              return (
                (t2.prototype = Object.create(Error.prototype, {
                  constructor: { value: t2, writable: true, enumerable: false, configurable: true },
                  name: {
                    get: function () {
                      return e2
                    },
                    set: void 0,
                    enumerable: false,
                    configurable: true,
                  },
                  toString: {
                    value: function () {
                      return this.name + ': ' + this.message
                    },
                    writable: true,
                    enumerable: false,
                    configurable: true,
                  },
                })),
                t2
              )
            }
            ;((o.asPromise = r('./@protobufjs/aspromise/index.js')),
              (o.base64 = r('./@protobufjs/base64/index.js')),
              (o.EventEmitter = r('./@protobufjs/eventemitter/index.js')),
              (o.float = r('./@protobufjs/float/index.js')),
              (o.inquire = r('./@protobufjs/inquire/index.js')),
              (o.utf8 = r('./@protobufjs/utf8/index.js')),
              (o.pool = r('./@protobufjs/pool/index.js')),
              (o.LongBits = r('./protobufjs/src/util/longbits.js')),
              (o.isNode = !!(
                'undefined' != typeof global &&
                global &&
                global.process &&
                global.process.versions &&
                global.process.versions.node
              )),
              (o.global =
                (o.isNode && global) ||
                ('undefined' != typeof window && window) ||
                ('undefined' != typeof self && self) ||
                this),
              (o.emptyArray = Object.freeze ? Object.freeze([]) : []),
              (o.emptyObject = Object.freeze ? Object.freeze({}) : {}),
              (o.isInteger =
                Number.isInteger ||
                function (e2) {
                  return 'number' == typeof e2 && isFinite(e2) && Math.floor(e2) === e2
                }),
              (o.isString = function (e2) {
                return 'string' == typeof e2 || e2 instanceof String
              }),
              (o.isObject = function (e2) {
                return e2 && 'object' == typeof e2
              }),
              (o.isset = o.isSet =
                function (e2, t2) {
                  var r2 = e2[t2]
                  return (
                    !!(null != r2 && e2.hasOwnProperty(t2)) &&
                    ('object' != typeof r2 || (Array.isArray(r2) ? r2.length : Object.keys(r2).length) > 0)
                  )
                }),
              (o.Buffer = (function () {
                try {
                  var e2 = o.inquire('buffer').Buffer
                  return e2.prototype.utf8Write ? e2 : null
                } catch (e3) {
                  return null
                }
              })()),
              (o._Buffer_from = null),
              (o._Buffer_allocUnsafe = null),
              (o.newBuffer = function (e2) {
                return 'number' == typeof e2
                  ? o.Buffer
                    ? o._Buffer_allocUnsafe(e2)
                    : new o.Array(e2)
                  : o.Buffer
                    ? o._Buffer_from(e2)
                    : 'undefined' == typeof Uint8Array
                      ? e2
                      : new Uint8Array(e2)
              }),
              (o.Array = 'undefined' != typeof Uint8Array ? Uint8Array : Array),
              (o.Long = (o.global.dcodeIO && o.global.dcodeIO.Long) || o.global.Long || o.inquire('long')),
              (o.key2Re = /^true|false|0|1$/),
              (o.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
              (o.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
              (o.longToHash = function (e2) {
                return e2 ? o.LongBits.from(e2).toHash() : o.LongBits.zeroHash
              }),
              (o.longFromHash = function (e2, t2) {
                var r2 = o.LongBits.fromHash(e2)
                return o.Long ? o.Long.fromBits(r2.lo, r2.hi, t2) : r2.toNumber(!!t2)
              }),
              (o.merge = s),
              (o.lcFirst = function (e2) {
                return e2.charAt(0).toLowerCase() + e2.substring(1)
              }),
              (o.newError = i),
              (o.ProtocolError = i('ProtocolError')),
              (o.oneOfGetter = function (e2) {
                for (var t2 = {}, r2 = 0; r2 < e2.length; ++r2) t2[e2[r2]] = 1
                return function () {
                  for (var e3 = Object.keys(this), r3 = e3.length - 1; r3 > -1; --r3)
                    if (1 === t2[e3[r3]] && void 0 !== this[e3[r3]] && null !== this[e3[r3]]) return e3[r3]
                }
              }),
              (o.oneOfSetter = function (e2) {
                return function (t2) {
                  for (var r2 = 0; r2 < e2.length; ++r2) e2[r2] !== t2 && delete this[e2[r2]]
                }
              }),
              (o.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }),
              (o._configure = function () {
                var e2 = o.Buffer
                if (!e2) {
                  o._Buffer_from = o._Buffer_allocUnsafe = null
                  return
                }
                ;((o._Buffer_from =
                  (e2.from !== Uint8Array.from && e2.from) ||
                  function (t2, r2) {
                    return new e2(t2, r2)
                  }),
                  (o._Buffer_allocUnsafe =
                    e2.allocUnsafe ||
                    function (t2) {
                      return new e2(t2)
                    }))
              }))
          },
          './protobufjs/src/verifier.js': function (e, t, r) {
            e.exports = f
            var o = r('./protobufjs/src/enum.js'),
              s = r('./protobufjs/src/util.js')
            function i(e2, t2) {
              return (
                e2.name +
                ': ' +
                t2 +
                (e2.repeated && 'array' !== t2 ? '[]' : e2.map && 'object' !== t2 ? '{k:' + e2.keyType + '}' : '') +
                ' expected'
              )
            }
            function n(e2, t2, r2, s2) {
              if (t2.resolvedType)
                if (t2.resolvedType instanceof o) {
                  e2('switch(%s){', s2)('default:')('return%j', i(t2, 'enum value'))
                  for (var n2 = Object.keys(t2.resolvedType.values), u2 = 0; u2 < n2.length; ++u2)
                    e2('case %i:', t2.resolvedType.values[n2[u2]])
                  e2('break')('}')
                } else e2('{')('var e=types[%i].verify(%s);', r2, s2)('if(e)')('return%j+e', t2.name + '.')('}')
              else
                switch (t2.type) {
                  case 'int32':
                  case 'uint32':
                  case 'sint32':
                  case 'fixed32':
                  case 'sfixed32':
                    e2('if(!util.isInteger(%s))', s2)('return%j', i(t2, 'integer'))
                    break
                  case 'int64':
                  case 'uint64':
                  case 'sint64':
                  case 'fixed64':
                  case 'sfixed64':
                    e2(
                      'if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))',
                      s2,
                      s2,
                      s2,
                      s2
                    )('return%j', i(t2, 'integer|Long'))
                    break
                  case 'float':
                  case 'double':
                    e2('if(typeof %s!=="number")', s2)('return%j', i(t2, 'number'))
                    break
                  case 'bool':
                    e2('if(typeof %s!=="boolean")', s2)('return%j', i(t2, 'boolean'))
                    break
                  case 'string':
                    e2('if(!util.isString(%s))', s2)('return%j', i(t2, 'string'))
                    break
                  case 'bytes':
                    e2(
                      'if(!(%s&&typeof %s.length==="number"||util.isString(%s)))',
                      s2,
                      s2,
                      s2
                    )('return%j', i(t2, 'buffer'))
                }
              return e2
            }
            function u(e2, t2, r2) {
              switch (t2.keyType) {
                case 'int32':
                case 'uint32':
                case 'sint32':
                case 'fixed32':
                case 'sfixed32':
                  e2('if(!util.key32Re.test(%s))', r2)('return%j', i(t2, 'integer key'))
                  break
                case 'int64':
                case 'uint64':
                case 'sint64':
                case 'fixed64':
                case 'sfixed64':
                  e2('if(!util.key64Re.test(%s))', r2)('return%j', i(t2, 'integer|Long key'))
                  break
                case 'bool':
                  e2('if(!util.key2Re.test(%s))', r2)('return%j', i(t2, 'boolean key'))
              }
              return e2
            }
            function f(e2) {
              var t2 = s.codegen(['m'], e2.name + '$verify')('if(typeof m!=="object"||m===null)')(
                  'return%j',
                  'object expected'
                ),
                r2 = e2.oneofsArray,
                o2 = {}
              r2.length && t2('var p={}')
              for (var f2 = 0; f2 < e2.fieldsArray.length; ++f2) {
                var a = e2._fieldsArray[f2].resolve(),
                  l = 'm' + s.safeProp(a.name)
                if ((a.optional && t2('if(%s!=null&&m.hasOwnProperty(%j)){', l, a.name), a.map))
                  (t2('if(!util.isObject(%s))', l)('return%j', i(a, 'object'))('var k=Object.keys(%s)', l)(
                    'for(var i=0;i<k.length;++i){'
                  ),
                    u(t2, a, 'k[i]'),
                    n(t2, a, f2, l + '[k[i]]')('}'))
                else if (a.repeated)
                  (t2('if(!Array.isArray(%s))', l)('return%j', i(a, 'array'))('for(var i=0;i<%s.length;++i){', l),
                    n(t2, a, f2, l + '[i]')('}'))
                else {
                  if (a.partOf) {
                    var p = s.safeProp(a.partOf.name)
                    ;(1 === o2[a.partOf.name] && t2('if(p%s===1)', p)('return%j', a.partOf.name + ': multiple values'),
                      (o2[a.partOf.name] = 1),
                      t2('p%s=1', p))
                  }
                  n(t2, a, f2, l)
                }
                a.optional && t2('}')
              }
              return t2('return null')
            }
          },
          './protobufjs/src/wrappers.js': function (e, t, r) {
            var o = t,
              s = r('./protobufjs/src/message.js')
            o['.google.protobuf.Any'] = {
              fromObject: function (e2) {
                if (e2 && e2['@type']) {
                  var t2 = e2['@type'].substring(e2['@type'].lastIndexOf('/') + 1),
                    r2 = this.lookup(t2)
                  if (r2) {
                    var o2 = '.' === e2['@type'].charAt(0) ? e2['@type'].slice(1) : e2['@type']
                    return (
                      -1 === o2.indexOf('/') && (o2 = '/' + o2),
                      this.create({ type_url: o2, value: r2.encode(r2.fromObject(e2)).finish() })
                    )
                  }
                }
                return this.fromObject(e2)
              },
              toObject: function (e2, t2) {
                var r2 = 'type.googleapis.com/',
                  o2 = '',
                  i = ''
                if (t2 && t2.json && e2.type_url && e2.value) {
                  ;((i = e2.type_url.substring(e2.type_url.lastIndexOf('/') + 1)),
                    (o2 = e2.type_url.substring(0, e2.type_url.lastIndexOf('/') + 1)))
                  var n = this.lookup(i)
                  n && (e2 = n.decode(e2.value))
                }
                if (!(e2 instanceof this.ctor) && e2 instanceof s) {
                  var u = e2.$type.toObject(e2, t2),
                    f = '.' === e2.$type.fullName[0] ? e2.$type.fullName.slice(1) : e2.$type.fullName
                  return ('' === o2 && (o2 = r2), (i = o2 + f), (u['@type'] = i), u)
                }
                return this.toObject(e2, t2)
              },
            }
          },
          './protobufjs/src/writer.js': function (e, t, r) {
            e.exports = p
            var o,
              s = r('./protobufjs/src/util/minimal.js'),
              i = s.LongBits,
              n = s.base64,
              u = s.utf8
            function f(e2, t2, r2) {
              ;((this.fn = e2), (this.len = t2), (this.next = void 0), (this.val = r2))
            }
            function a() {}
            function l(e2) {
              ;((this.head = e2.head), (this.tail = e2.tail), (this.len = e2.len), (this.next = e2.states))
            }
            function p() {
              ;((this.len = 0), (this.head = new f(a, 0, 0)), (this.tail = this.head), (this.states = null))
            }
            var c = function () {
              return s.Buffer
                ? function () {
                    return (p.create = function () {
                      return new o()
                    })()
                  }
                : function () {
                    return new p()
                  }
            }
            function h(e2, t2, r2) {
              t2[r2] = 255 & e2
            }
            function d(e2, t2, r2) {
              for (; e2 > 127; ) ((t2[r2++] = (127 & e2) | 128), (e2 >>>= 7))
              t2[r2] = e2
            }
            function y(e2, t2) {
              ;((this.len = e2), (this.next = void 0), (this.val = t2))
            }
            function v(e2, t2, r2) {
              for (; e2.hi; )
                ((t2[r2++] = (127 & e2.lo) | 128), (e2.lo = ((e2.lo >>> 7) | (e2.hi << 25)) >>> 0), (e2.hi >>>= 7))
              for (; e2.lo > 127; ) ((t2[r2++] = (127 & e2.lo) | 128), (e2.lo = e2.lo >>> 7))
              t2[r2++] = e2.lo
            }
            function m(e2, t2, r2) {
              ;((t2[r2] = 255 & e2),
                (t2[r2 + 1] = (e2 >>> 8) & 255),
                (t2[r2 + 2] = (e2 >>> 16) & 255),
                (t2[r2 + 3] = e2 >>> 24))
            }
            ;((p.create = c()),
              (p.alloc = function (e2) {
                return new s.Array(e2)
              }),
              s.Array !== Array && (p.alloc = s.pool(p.alloc, s.Array.prototype.subarray)),
              (p.prototype._push = function (e2, t2, r2) {
                return ((this.tail = this.tail.next = new f(e2, t2, r2)), (this.len += t2), this)
              }),
              (y.prototype = Object.create(f.prototype)),
              (y.prototype.fn = d),
              (p.prototype.uint32 = function (e2) {
                return (
                  (this.len += (this.tail = this.tail.next =
                    new y((e2 >>>= 0) < 128 ? 1 : e2 < 16384 ? 2 : e2 < 2097152 ? 3 : e2 < 268435456 ? 4 : 5, e2)).len),
                  this
                )
              }),
              (p.prototype.int32 = function (e2) {
                return e2 < 0 ? this._push(v, 10, i.fromNumber(e2)) : this.uint32(e2)
              }),
              (p.prototype.sint32 = function (e2) {
                return this.uint32(((e2 << 1) ^ (e2 >> 31)) >>> 0)
              }),
              (p.prototype.uint64 = function (e2) {
                var t2 = i.from(e2)
                return this._push(v, t2.length(), t2)
              }),
              (p.prototype.int64 = p.prototype.uint64),
              (p.prototype.sint64 = function (e2) {
                var t2 = i.from(e2).zzEncode()
                return this._push(v, t2.length(), t2)
              }),
              (p.prototype.bool = function (e2) {
                return this._push(h, 1, +!!e2)
              }),
              (p.prototype.fixed32 = function (e2) {
                return this._push(m, 4, e2 >>> 0)
              }),
              (p.prototype.sfixed32 = p.prototype.fixed32),
              (p.prototype.fixed64 = function (e2) {
                var t2 = i.from(e2)
                return this._push(m, 4, t2.lo)._push(m, 4, t2.hi)
              }),
              (p.prototype.sfixed64 = p.prototype.fixed64),
              (p.prototype.float = function (e2) {
                return this._push(s.float.writeFloatLE, 4, e2)
              }),
              (p.prototype.double = function (e2) {
                return this._push(s.float.writeDoubleLE, 8, e2)
              }))
            var b = s.Array.prototype.set
              ? function (e2, t2, r2) {
                  t2.set(e2, r2)
                }
              : function (e2, t2, r2) {
                  for (var o2 = 0; o2 < e2.length; ++o2) t2[r2 + o2] = e2[o2]
                }
            ;((p.prototype.bytes = function (e2) {
              var t2 = e2.length >>> 0
              if (!t2) return this._push(h, 1, 0)
              if (s.isString(e2)) {
                var r2 = p.alloc((t2 = n.length(e2)))
                ;(n.decode(e2, r2, 0), (e2 = r2))
              }
              return this.uint32(t2)._push(b, t2, e2)
            }),
              (p.prototype.string = function (e2) {
                var t2 = u.length(e2)
                return t2 ? this.uint32(t2)._push(u.write, t2, e2) : this._push(h, 1, 0)
              }),
              (p.prototype.fork = function () {
                return ((this.states = new l(this)), (this.head = this.tail = new f(a, 0, 0)), (this.len = 0), this)
              }),
              (p.prototype.reset = function () {
                return (
                  this.states
                    ? ((this.head = this.states.head),
                      (this.tail = this.states.tail),
                      (this.len = this.states.len),
                      (this.states = this.states.next))
                    : ((this.head = this.tail = new f(a, 0, 0)), (this.len = 0)),
                  this
                )
              }),
              (p.prototype.ldelim = function () {
                var e2 = this.head,
                  t2 = this.tail,
                  r2 = this.len
                return (
                  this.reset().uint32(r2),
                  r2 && ((this.tail.next = e2.next), (this.tail = t2), (this.len += r2)),
                  this
                )
              }),
              (p.prototype.finish = function () {
                for (var e2 = this.head.next, t2 = this.constructor.alloc(this.len), r2 = 0; e2; )
                  (e2.fn(e2.val, t2, r2), (r2 += e2.len), (e2 = e2.next))
                return t2
              }),
              (p._configure = function (e2) {
                ;((o = e2), (p.create = c()), o._configure())
              }))
          },
          './protobufjs/src/writer_buffer.js': function (e, t, r) {
            e.exports = i
            var o = r('./protobufjs/src/writer.js')
            ;(i.prototype = Object.create(o.prototype)).constructor = i
            var s = r('./protobufjs/src/util/minimal.js')
            function i() {
              o.call(this)
            }
            function n(e2, t2, r2) {
              e2.length < 40 ? s.utf8.write(e2, t2, r2) : t2.utf8Write ? t2.utf8Write(e2, r2) : t2.write(e2, r2)
            }
            ;((i._configure = function () {
              ;((i.alloc = s._Buffer_allocUnsafe),
                (i.writeBytesBuffer =
                  s.Buffer && s.Buffer.prototype instanceof Uint8Array && 'set' === s.Buffer.prototype.set.name
                    ? function (e2, t2, r2) {
                        t2.set(e2, r2)
                      }
                    : function (e2, t2, r2) {
                        if (e2.copy) e2.copy(t2, r2, 0, e2.length)
                        else for (var o2 = 0; o2 < e2.length; ) t2[r2++] = e2[o2++]
                      }))
            }),
              (i.prototype.bytes = function (e2) {
                s.isString(e2) && (e2 = s._Buffer_from(e2, 'base64'))
                var t2 = e2.length >>> 0
                return (this.uint32(t2), t2 && this._push(i.writeBytesBuffer, t2, e2), this)
              }),
              (i.prototype.string = function (e2) {
                var t2 = s.Buffer.byteLength(e2)
                return (this.uint32(t2), t2 && this._push(n, t2, e2), this)
              }),
              i._configure())
          },
        },
        __webpack_module_cache__ = {}
      function __webpack_require__(e) {
        var t = __webpack_module_cache__[e]
        if (void 0 !== t) return t.exports
        var r = (__webpack_module_cache__[e] = { exports: {} })
        return (__webpack_modules__[e].call(r.exports, r, r.exports, __webpack_require__), r.exports)
      }
      var __webpack_exports__ = __webpack_require__('./protobufjs/index.js')
      module.exports = __webpack_exports__
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/otlp/protobuf_loader.js
var require_protobuf_loader = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/otlp/protobuf_loader.js'(exports2, module2) {
    'use strict'
    var protobuf = require_protobufjs2()
    var path = require('path')
    var _root = null
    var protoLogsService = null
    var protoSeverityNumber = null
    var protoMetricsService = null
    var protoAggregationTemporality = null
    function getProtobufTypes() {
      if (_root) {
        return {
          protoLogsService,
          protoSeverityNumber,
          protoMetricsService,
          protoAggregationTemporality,
        }
      }
      const protoDir = __dirname
      const protoFiles = [
        'common.proto',
        'resource.proto',
        'logs.proto',
        'logs_service.proto',
        'metrics.proto',
        'metrics_service.proto',
      ].map((file) => path.join(protoDir, file))
      _root = protobuf.loadSync(protoFiles)
      protoLogsService = _root.lookupType('opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest')
      protoSeverityNumber = _root.lookupEnum('opentelemetry.proto.logs.v1.SeverityNumber')
      protoMetricsService = _root.lookupType('opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest')
      protoAggregationTemporality = _root.lookupEnum('opentelemetry.proto.metrics.v1.AggregationTemporality')
      return {
        protoLogsService,
        protoSeverityNumber,
        protoMetricsService,
        protoAggregationTemporality,
      }
    }
    module2.exports = {
      getProtobufTypes,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/otlp_transformer.js
var require_otlp_transformer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/otlp_transformer.js'(exports2, module2) {
    'use strict'
    var OtlpTransformerBase = require_otlp_transformer_base()
    var { SeverityNumber } = require('@opentelemetry/api-logs')
    var { getProtobufTypes } = require_protobuf_loader()
    var { trace } = require('@opentelemetry/api')
    var SEVERITY_MAP = {
      [SeverityNumber.TRACE]: 'SEVERITY_NUMBER_TRACE',
      [SeverityNumber.TRACE2]: 'SEVERITY_NUMBER_TRACE2',
      [SeverityNumber.TRACE3]: 'SEVERITY_NUMBER_TRACE3',
      [SeverityNumber.TRACE4]: 'SEVERITY_NUMBER_TRACE4',
      [SeverityNumber.DEBUG]: 'SEVERITY_NUMBER_DEBUG',
      [SeverityNumber.DEBUG2]: 'SEVERITY_NUMBER_DEBUG2',
      [SeverityNumber.DEBUG3]: 'SEVERITY_NUMBER_DEBUG3',
      [SeverityNumber.DEBUG4]: 'SEVERITY_NUMBER_DEBUG4',
      [SeverityNumber.INFO]: 'SEVERITY_NUMBER_INFO',
      [SeverityNumber.INFO2]: 'SEVERITY_NUMBER_INFO2',
      [SeverityNumber.INFO3]: 'SEVERITY_NUMBER_INFO3',
      [SeverityNumber.INFO4]: 'SEVERITY_NUMBER_INFO4',
      [SeverityNumber.WARN]: 'SEVERITY_NUMBER_WARN',
      [SeverityNumber.WARN2]: 'SEVERITY_NUMBER_WARN2',
      [SeverityNumber.WARN3]: 'SEVERITY_NUMBER_WARN3',
      [SeverityNumber.WARN4]: 'SEVERITY_NUMBER_WARN4',
      [SeverityNumber.ERROR]: 'SEVERITY_NUMBER_ERROR',
      [SeverityNumber.ERROR2]: 'SEVERITY_NUMBER_ERROR2',
      [SeverityNumber.ERROR3]: 'SEVERITY_NUMBER_ERROR3',
      [SeverityNumber.ERROR4]: 'SEVERITY_NUMBER_ERROR4',
      [SeverityNumber.FATAL]: 'SEVERITY_NUMBER_FATAL',
      [SeverityNumber.FATAL2]: 'SEVERITY_NUMBER_FATAL2',
      [SeverityNumber.FATAL3]: 'SEVERITY_NUMBER_FATAL3',
      [SeverityNumber.FATAL4]: 'SEVERITY_NUMBER_FATAL4',
    }
    var OtlpTransformer = class extends OtlpTransformerBase {
      /**
       * Creates a new OtlpTransformer instance.
       *
       * @param {import('@opentelemetry/api').Attributes} resourceAttributes - Resource attributes
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       */
      constructor(resourceAttributes, protocol) {
        super(resourceAttributes, protocol, 'logs')
      }
      /**
       * Transforms log records to OTLP format based on the configured protocol.
       * @param {LogRecord[]} logRecords - Array of enriched log records to transform
       * @returns {Buffer} Transformed log records in the appropriate format
       */
      transformLogRecords(logRecords) {
        if (this.protocol === 'http/json') {
          return this.#transformToJson(logRecords)
        }
        return this.#transformToProtobuf(logRecords)
      }
      /**
       * Transforms log records to protobuf format.
       * @param {LogRecord[]} logRecords - Array of enriched log records to transform
       * @returns {Buffer} Protobuf-encoded log records
       */
      #transformToProtobuf(logRecords) {
        const { protoLogsService } = getProtobufTypes()
        const logsData = {
          resourceLogs: [
            {
              resource: this.transformResource(),
              scopeLogs: this.#transformScope(logRecords),
            },
          ],
        }
        return this.serializeToProtobuf(protoLogsService, logsData)
      }
      /**
       * Transforms log records to JSON format.
       * @param {LogRecord[]} logRecords - Array of enriched log records to transform
       * @returns {Buffer} JSON-encoded log records
       */
      #transformToJson(logRecords) {
        const logsData = {
          resourceLogs: [
            {
              resource: this.transformResource(),
              scopeLogs: this.#transformScope(logRecords),
            },
          ],
        }
        return this.serializeToJson(logsData)
      }
      /**
       * Creates scope logs grouped by instrumentation library.
       * @param {LogRecord[]} logRecords - Array of log records to transform
       * @returns {Object[]} Array of scope log objects
       */
      #transformScope(logRecords) {
        const groupedRecords = this.groupByInstrumentationScope(logRecords)
        const scopeLogs = []
        for (const records of groupedRecords.values()) {
          const schemaUrl = records[0]?.instrumentationScope?.schemaUrl || ''
          scopeLogs.push({
            scope: {
              name: records[0]?.instrumentationScope?.name || 'dd-trace-js',
              version: records[0]?.instrumentationScope?.version || '',
              attributes: [],
              droppedAttributesCount: 0,
            },
            schemaUrl,
            logRecords: records.map((record) => this.#transformLogRecord(record)),
          })
        }
        return scopeLogs
      }
      /**
       * Transforms a single log record to OTLP format.
       * @param {LogRecord} logRecord - Log record to transform
       * @returns {Object} OTLP log record object
       */
      #transformLogRecord(logRecord) {
        const spanContext = this.#extractSpanContext(logRecord.context)
        const result = {
          timeUnixNano: logRecord.timestamp,
          body: this.#transformBody(logRecord.body),
        }
        if (logRecord.observedTimestamp) {
          result.observedTimeUnixNano = logRecord.observedTimestamp
        }
        if (logRecord.severityNumber !== void 0) {
          result.severityNumber = this.#mapSeverityNumber(logRecord.severityNumber)
        }
        if (logRecord.severityText) {
          result.severityText = logRecord.severityText
        }
        if (logRecord.attributes) {
          result.attributes = this.transformAttributes(logRecord.attributes)
        }
        if (spanContext?.traceFlags !== void 0) {
          result.flags = spanContext.traceFlags
        }
        if (spanContext?.traceId && spanContext.traceId !== '00000000000000000000000000000000') {
          result.traceId = this.#hexToBytes(spanContext.traceId)
        }
        if (spanContext?.spanId && spanContext.spanId !== '0000000000000000') {
          result.spanId = this.#hexToBytes(spanContext.spanId)
        }
        return result
      }
      /**
       * Extracts span context from the log record's context.
       * @param {Object} logContext - The log record's context
       * @returns {Object|null} Span context or null if not available
       */
      #extractSpanContext(logContext) {
        if (!logContext) return null
        const activeSpan = trace.getSpan(logContext)
        if (activeSpan) {
          return activeSpan.spanContext()
        }
        return null
      }
      /**
       * Maps OpenTelemetry severity number to protobuf severity number.
       * @param {number} severityNumber - OpenTelemetry severity number
       * @returns {number} Protobuf severity number
       */
      #mapSeverityNumber(severityNumber) {
        const { protoSeverityNumber } = getProtobufTypes()
        const severityName = SEVERITY_MAP[severityNumber] || 'SEVERITY_NUMBER_INFO'
        return protoSeverityNumber.values[severityName]
      }
      /**
       * Converts a hex string to a Buffer.
       * @param {string} hexString - Hex string to convert
       * @returns {Buffer} Buffer containing the hex data
       */
      #hexToBytes(hexString) {
        const cleanHex = hexString ? (hexString.startsWith('0x') ? hexString.slice(2) : hexString) : ''
        const paddedHex = cleanHex.length % 2 === 0 ? cleanHex : '0' + cleanHex
        return Buffer.from(paddedHex, 'hex')
      }
      /**
       * Transforms log body to OTLP AnyValue format.
       * @param {any} body - Log body to transform
       * @returns {Object} OTLP AnyValue object
       */
      #transformBody(body) {
        if (typeof body === 'string') {
          return { stringValue: body }
        } else if (typeof body === 'number') {
          if (Number.isInteger(body)) {
            return { intValue: body }
          }
          return { doubleValue: body }
        } else if (typeof body === 'boolean') {
          return { boolValue: body }
        } else if (body && typeof body === 'object') {
          return {
            kvlistValue: {
              values: Object.entries(body).map(([key, value]) => ({
                key,
                value: this.transformAnyValue(value),
              })),
            },
          }
        }
        return { stringValue: String(body) }
      }
    }
    module2.exports = OtlpTransformer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/otlp_http_log_exporter.js
var require_otlp_http_log_exporter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/otlp_http_log_exporter.js'(exports2, module2) {
    'use strict'
    var OtlpHttpExporterBase = require_otlp_http_exporter_base()
    var OtlpTransformer = require_otlp_transformer()
    var OtlpHttpLogExporter = class extends OtlpHttpExporterBase {
      /**
       * Creates a new OtlpHttpLogExporter instance.
       *
       * @param {string} url - OTLP endpoint URL
       * @param {string} headers - Additional HTTP headers as comma-separated key=value string
       * @param {number} timeout - Request timeout in milliseconds
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       * @param {Resource} resource - Resource attributes
       */
      constructor(url, headers, timeout, protocol, resource) {
        super(url, headers, timeout, protocol, '/v1/logs', 'logs')
        this.transformer = new OtlpTransformer(resource, protocol)
      }
      /**
       * Exports log records via OTLP over HTTP.
       *
       * @param {LogRecord[]} logRecords - Array of enriched log records to export
       * @param {Function} resultCallback - Callback function for export result
       *
       * @returns {void}
       */
      export(logRecords, resultCallback) {
        if (logRecords.length === 0) {
          resultCallback({ code: 0 })
          return
        }
        const payload = this.transformer.transformLogRecords(logRecords)
        this.sendPayload(payload, resultCallback)
        this.recordTelemetry('otel.log_records', logRecords.length)
      }
    }
    module2.exports = OtlpHttpLogExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/index.js
var require_logs2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/logs/index.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var LoggerProvider = require_logger_provider()
    var BatchLogRecordProcessor = require_batch_log_processor()
    var OtlpHttpLogExporter = require_otlp_http_log_exporter()
    function initializeOpenTelemetryLogs(config) {
      const resourceAttributes = {
        'service.name': config.service,
        'service.version': config.version,
        'deployment.environment': config.env,
      }
      if (config.tags) {
        const filteredTags = { ...config.tags }
        delete filteredTags.service
        delete filteredTags.version
        delete filteredTags.env
        Object.assign(resourceAttributes, filteredTags)
      }
      if (config.reportHostname) {
        resourceAttributes['host.name'] = os.hostname()
      }
      const exporter = new OtlpHttpLogExporter(
        config.otelLogsUrl,
        config.otelLogsHeaders,
        config.otelLogsTimeout,
        config.otelLogsProtocol,
        resourceAttributes
      )
      const processor = new BatchLogRecordProcessor(exporter, config.otelBatchTimeout, config.otelMaxExportBatchSize)
      const loggerProvider = new LoggerProvider({ processor })
      loggerProvider.register()
    }
    module2.exports = {
      LoggerProvider,
      initializeOpenTelemetryLogs,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/constants.js
var require_constants4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/constants.js'(exports2, module2) {
    'use strict'
    var METRIC_TYPES = {
      HISTOGRAM: 'histogram',
      COUNTER: 'counter',
      UPDOWNCOUNTER: 'updowncounter',
      OBSERVABLECOUNTER: 'observable-counter',
      OBSERVABLEUPDOWNCOUNTER: 'observable-updowncounter',
      GAUGE: 'gauge',
    }
    var TEMPORALITY = {
      DELTA: 'DELTA',
      CUMULATIVE: 'CUMULATIVE',
      GAUGE: 'GAUGE',
      LOWMEMORY: 'LOWMEMORY',
    }
    var DEFAULT_HISTOGRAM_BUCKETS = [0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1e3, 2500, 5e3, 7500, 1e4]
    var DEFAULT_MAX_MEASUREMENT_QUEUE_SIZE = 65536
    module2.exports = {
      METRIC_TYPES,
      TEMPORALITY,
      DEFAULT_HISTOGRAM_BUCKETS,
      DEFAULT_MAX_MEASUREMENT_QUEUE_SIZE,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/instruments.js
var require_instruments = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/instruments.js'(exports2, module2) {
    'use strict'
    var { sanitizeAttributes } = require_core()
    var { METRIC_TYPES } = require_constants4()
    var Instrument = class {
      /**
       * Creates a new instrument instance.
       *
       * @param {string} name - Instrument name (e.g., 'http.request.duration')
       * @param {Object} options - Instrument configuration options
       * @param {string} [options.description] - Human-readable description of the instrument
       * @param {string} [options.unit] - Unit of measurement (e.g., 'ms', 'bytes', '1')
       * @param {InstrumentationScope} instrumentationScope - Instrumentation scope for this instrument
       * @param {Object} reader - Metric reader for recording measurements
       */
      constructor(name, options, instrumentationScope, reader) {
        this.name = name
        this.description = options.description ?? ''
        this.unit = options.unit ?? ''
        this.valueType = options.valueType
        this.advice = options.advice
        this.instrumentationScope = instrumentationScope
        this.reader = reader
      }
      /**
       * Creates a measurement object for recording metric values.
       * @param {string} type - Metric type from METRIC_TYPES
       * @param {number} value - Numeric value to record
       * @param {Attributes} attributes - Key-value pairs for metric dimensions
       * @returns {Measurement} Measurement object with metadata and timestamp
       */
      createMeasurement(type, value, attributes) {
        return {
          name: this.name,
          description: this.description,
          unit: this.unit,
          instrumentationScope: this.instrumentationScope,
          type,
          value,
          attributes: sanitizeAttributes(attributes),
          timestamp: Number(process.hrtime.bigint()),
        }
      }
    }
    var Counter = class extends Instrument {
      add(value, attributes = {}) {
        if (value < 0) return
        this.reader?.record(this.createMeasurement(METRIC_TYPES.COUNTER, value, attributes))
      }
    }
    var UpDownCounter = class extends Instrument {
      add(value, attributes = {}) {
        this.reader?.record(this.createMeasurement(METRIC_TYPES.UPDOWNCOUNTER, value, attributes))
      }
    }
    var Histogram = class extends Instrument {
      record(value, attributes = {}) {
        if (value < 0) return
        this.reader?.record(this.createMeasurement(METRIC_TYPES.HISTOGRAM, value, attributes))
      }
    }
    var Gauge = class extends Instrument {
      record(value, attributes = {}) {
        this.reader?.record(this.createMeasurement(METRIC_TYPES.GAUGE, value, attributes))
      }
    }
    var ObservableInstrument = class extends Instrument {
      #callbacks = []
      #type
      constructor(name, options, instrumentationScope, reader, type) {
        super(name, options, instrumentationScope, reader)
        this.#type = type
      }
      /**
       * Adds a callback to invoke during metric collection.
       *
       * @param {Function} callback - Receives an ObservableResult to record observations
       */
      addCallback(callback) {
        if (typeof callback !== 'function') return
        this.#callbacks.push(callback)
        this.reader?.observableInstruments.add(this)
      }
      /**
       * Removes a callback.
       *
       * @param {Function} callback - The callback to remove
       */
      removeCallback(callback) {
        const index = this.#callbacks.indexOf(callback)
        if (index !== -1) {
          this.#callbacks.splice(index, 1)
          if (this.#callbacks.length === 0) {
            this.reader?.observableInstruments.delete(this)
          }
        }
      }
      /**
       * Collects observations from all callbacks. Errors are silently ignored.
       *
       * @returns {Array<Measurement>} Array of measurements
       */
      collect() {
        const observations = []
        const observableResult = {
          observe: (value, attributes = {}) => {
            observations.push(this.createMeasurement(this.#type, value, attributes))
          },
        }
        for (const callback of this.#callbacks) {
          try {
            callback(observableResult)
          } catch {}
        }
        return observations
      }
    }
    var ObservableGauge = class extends ObservableInstrument {
      constructor(name, options, instrumentationScope, reader) {
        super(name, options, instrumentationScope, reader, METRIC_TYPES.GAUGE)
      }
    }
    var ObservableCounter = class extends ObservableInstrument {
      constructor(name, options, instrumentationScope, reader) {
        super(name, options, instrumentationScope, reader, METRIC_TYPES.OBSERVABLECOUNTER)
      }
    }
    var ObservableUpDownCounter = class extends ObservableInstrument {
      constructor(name, options, instrumentationScope, reader) {
        super(name, options, instrumentationScope, reader, METRIC_TYPES.OBSERVABLEUPDOWNCOUNTER)
      }
    }
    module2.exports = {
      Counter,
      UpDownCounter,
      Histogram,
      Gauge,
      ObservableGauge,
      ObservableCounter,
      ObservableUpDownCounter,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/meter.js
var require_meter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/meter.js'(exports2, module2) {
    'use strict'
    var { VERSION: packageVersion } = require_version()
    var { Counter, UpDownCounter, Histogram, Gauge, ObservableGauge, ObservableCounter, ObservableUpDownCounter } =
      require_instruments()
    var log = require_log2()
    var { METRIC_TYPES } = require_constants4()
    var Meter = class {
      #instrumentationScope
      #instruments = /* @__PURE__ */ new Map()
      /**
       * Creates a new Meter instance.
       *
       * @param {MeterProvider} meterProvider - Parent meter provider
       * @param {InstrumentationScope} instrumentationScope - Instrumentation scope information
       * @param {string} [instrumentationScope.name] - Meter name (defaults to 'dd-trace-js')
       * @param {string} [instrumentationScope.version] - Meter version (defaults to tracer version)
       * @param {string} [instrumentationScope.schemaUrl] - Schema URL
       * @param {Object} [instrumentationScope.attributes] - Attributes for the instrumentation scope
       */
      constructor(
        meterProvider,
        { name = 'dd-trace-js', version = packageVersion, schemaUrl = '', attributes = {} } = {}
      ) {
        this.meterProvider = meterProvider
        this.#instrumentationScope = {
          name,
          version,
          schemaUrl,
          attributes,
        }
      }
      /**
       * Gets an existing instrument or creates a new one if it doesn't exist.
       * Instruments are cached by type and normalized (lowercase) name.
       *
       *
       * @param {string} name - Instrument name (will be normalized to lowercase)
       * @param {string} type - Instrument type (e.g., 'counter', 'histogram', 'gauge')
       * @param {Function} InstrumentClass - Constructor for the instrument type
       * @param {MetricOptions} [options] - Instrument options (description, unit, etc.)
       * @returns {Instrument} The instrument instance (new or cached)
       */
      #getOrCreateInstrument(name, type, InstrumentClass, options) {
        const normalizedName = name.toLowerCase()
        const key = `${type}:${normalizedName}`
        let instrument = this.#instruments.get(key)
        if (!instrument) {
          instrument = new InstrumentClass(
            normalizedName,
            options,
            this.#instrumentationScope,
            this.meterProvider.reader
          )
          this.#instruments.set(key, instrument)
        }
        return instrument
      }
      /**
       * Creates a Counter instrument.
       *
       * @param {string} name - Instrument name (case-insensitive)
       * @param {MetricOptions} [options] - Instrument options
       * @returns {Counter} Counter instrument
       */
      createCounter(name, options = {}) {
        return this.#getOrCreateInstrument(name, METRIC_TYPES.COUNTER, Counter, options)
      }
      /**
       * Creates an UpDownCounter instrument.
       *
       * @param {string} name - Instrument name
       * @param {MetricOptions} [options] - Instrument options
       * @returns {UpDownCounter} UpDownCounter instrument
       */
      createUpDownCounter(name, options = {}) {
        return this.#getOrCreateInstrument(name, METRIC_TYPES.UPDOWNCOUNTER, UpDownCounter, options)
      }
      /**
       * Creates a Histogram instrument.
       *
       * @param {string} name - Instrument name (case-insensitive)
       * @param {MetricOptions} [options] - Instrument options
       * @returns {Histogram} Histogram instrument
       */
      createHistogram(name, options = {}) {
        return this.#getOrCreateInstrument(name, METRIC_TYPES.HISTOGRAM, Histogram, options)
      }
      /**
       * Creates a Gauge instrument.
       *
       * @param {string} name - Instrument name (case-insensitive)
       * @param {MetricOptions} [options] - Instrument options
       * @returns {Gauge} Gauge instrument
       */
      createGauge(name, options = {}) {
        return this.#getOrCreateInstrument(name, METRIC_TYPES.GAUGE, Gauge, options)
      }
      /**
       * Creates an ObservableGauge instrument.
       *
       * @param {string} name - Instrument name (case-insensitive)
       * @param {MetricOptions} [options] - Instrument options
       * @returns {ObservableGauge} ObservableGauge instrument
       */
      createObservableGauge(name, options = {}) {
        return this.#getOrCreateInstrument(name, METRIC_TYPES.OBSERVABLEGAUGE, ObservableGauge, options)
      }
      /**
       * Creates an ObservableCounter instrument.
       *
       * @param {string} name - Instrument name (case-insensitive)
       * @param {MetricOptions} [options] - Instrument options
       * @returns {ObservableCounter} ObservableCounter instrument
       */
      createObservableCounter(name, options = {}) {
        return this.#getOrCreateInstrument(name, METRIC_TYPES.OBSERVABLECOUNTER, ObservableCounter, options)
      }
      /**
       * Creates an ObservableUpDownCounter instrument.
       *
       * @param {string} name - Instrument name (case-insensitive)
       * @param {MetricOptions} [options] - Instrument options
       * @returns {ObservableUpDownCounter} ObservableUpDownCounter instrument
       */
      createObservableUpDownCounter(name, options = {}) {
        return this.#getOrCreateInstrument(name, METRIC_TYPES.OBSERVABLEUPDOWNCOUNTER, ObservableUpDownCounter, options)
      }
      /**
       * Adds a batch observable callback (not implemented).
       *
       * @param {Function} callback - Batch observable callback
       * @param {Array} observables - Array of observable instruments
       */
      addBatchObservableCallback(callback, observables) {
        log.warn('addBatchObservableCallback is not implemented')
      }
      /**
       * Removes a batch observable callback (not implemented).
       *
       * @param {Function} callback - Batch observable callback
       * @param {Array} observables - Array of observable instruments
       */
      removeBatchObservableCallback(callback, observables) {
        log.warn('removeBatchObservableCallback is not implemented')
      }
    }
    module2.exports = Meter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/meter_provider.js
var require_meter_provider = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/meter_provider.js'(exports2, module2) {
    'use strict'
    var Meter = require_meter()
    var MeterProvider = class {
      #meters = /* @__PURE__ */ new Map()
      /**
       * Creates a new MeterProvider instance with a single reader for Datadog Agent export.
       *
       * @param {MeterOptions} [options] - MeterProvider options
       * @param {PeriodicMetricReader} [options.reader] - Single MetricReader instance for
       *   exporting metrics to Datadog Agent
       */
      constructor(options = {}) {
        this.reader = options.reader
      }
      /**
       * Gets or creates a meter instance.
       *
       * @param {string} name - Meter name (case-insensitive)
       * @param {string} [version] - Meter version
       * @param {MeterOptions} [options] - Additional options
       * @returns {Meter} Meter instance
       */
      getMeter(name, version = '', { schemaUrl = '', attributes = {} } = {}) {
        const normalizedName = name.toLowerCase()
        const key = `${normalizedName}@${version}@${schemaUrl}`
        let meter = this.#meters.get(key)
        if (!meter) {
          meter = new Meter(this, { name: normalizedName, version, schemaUrl, attributes })
          this.#meters.set(key, meter)
        }
        return meter
      }
    }
    module2.exports = MeterProvider
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/periodic_metric_reader.js
var require_periodic_metric_reader = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/periodic_metric_reader.js'(exports2, module2) {
    'use strict'
    var { METRIC_TYPES, TEMPORALITY, DEFAULT_HISTOGRAM_BUCKETS, DEFAULT_MAX_MEASUREMENT_QUEUE_SIZE } =
      require_constants4()
    var log = require_log2()
    var { stableStringify } = require_otlp_transformer_base()
    var PeriodicMetricReader = class {
      #measurements = []
      #cumulativeState = /* @__PURE__ */ new Map()
      #lastExportedState = /* @__PURE__ */ new Map()
      #droppedCount = 0
      #timer = null
      #isShutdown = false
      #exportInterval
      #aggregator
      /**
       * Creates a new PeriodicMetricReader instance.
       *
       * @param {OtlpHttpMetricExporter} exporter - Metric exporter for sending to Datadog Agent
       * @param {number} exportInterval - Export interval in milliseconds
       * @param {string} temporalityPreference - Temporality preference: DELTA, CUMULATIVE, or LOWMEMORY
       * @param {number} maxBatchedQueueSize - Maximum number of measurements to queue before dropping
       */
      constructor(exporter, exportInterval, temporalityPreference, maxBatchedQueueSize) {
        this.exporter = exporter
        this.observableInstruments = /* @__PURE__ */ new Set()
        this.#exportInterval = exportInterval
        this.#aggregator = new MetricAggregator(temporalityPreference, maxBatchedQueueSize)
        this.#startTimer()
      }
      /**
       * Records a measurement from a synchronous instrument.
       *
       * @param {Measurement} measurement - The measurement data
       */
      record(measurement) {
        if (this.#measurements.length >= DEFAULT_MAX_MEASUREMENT_QUEUE_SIZE || this.#isShutdown) {
          this.#droppedCount++
          return
        }
        this.#measurements.push(measurement)
      }
      /**
       * Forces an immediate collection and export of all metrics.
       * @returns {void}
       */
      forceFlush() {
        if (this.#isShutdown) {
          log.warn(`PeriodicMetricReader is shutdown. ${this.#droppedCount} measurement(s) were dropped`)
          return
        }
        this.#collectAndExport()
      }
      /**
       * Shuts down the reader and stops periodic collection.
       * @returns {void}
       */
      shutdown() {
        if (this.#isShutdown) {
          log.warn('PeriodicMetricReader is already shutdown')
          return
        }
        this.#isShutdown = true
        this.#clearTimer()
        this.forceFlush()
      }
      /**
       * Starts the periodic export timer.
       *
       */
      #startTimer() {
        if (this.#timer) return
        this.#timer = setInterval(() => {
          this.#collectAndExport()
        }, this.#exportInterval).unref()
      }
      /**
       * Clears the periodic export timer.
       *
       */
      #clearTimer() {
        if (this.#timer) {
          clearInterval(this.#timer)
          this.#timer = null
        }
      }
      /**
       * Collects measurements and exports metrics.
       *
       * @param {Function} [callback] - Called after export completes
       */
      #collectAndExport(callback = () => {}) {
        const allMeasurements = this.#measurements.splice(0)
        for (const instrument of this.observableInstruments) {
          const observableMeasurements = instrument.collect()
          if (allMeasurements.length >= DEFAULT_MAX_MEASUREMENT_QUEUE_SIZE) {
            this.#droppedCount += observableMeasurements.length
            continue
          }
          const remainingCapacity = DEFAULT_MAX_MEASUREMENT_QUEUE_SIZE - allMeasurements.length
          if (observableMeasurements.length <= remainingCapacity) {
            allMeasurements.push(...observableMeasurements)
          } else {
            allMeasurements.push(...observableMeasurements.slice(0, remainingCapacity))
            this.#droppedCount += observableMeasurements.length - remainingCapacity
          }
        }
        if (this.#droppedCount > 0) {
          log.warn(
            `Metric queue exceeded limit (max: ${DEFAULT_MAX_MEASUREMENT_QUEUE_SIZE}). Dropping ${this.#droppedCount} measurements. `
          )
          this.#droppedCount = 0
        }
        if (allMeasurements.length === 0) {
          callback()
          return
        }
        const metrics = this.#aggregator.aggregate(allMeasurements, this.#cumulativeState, this.#lastExportedState)
        this.exporter.export(metrics, callback)
      }
    }
    var MetricAggregator = class {
      #startTime = Number(process.hrtime.bigint())
      #temporalityPreference
      #maxBatchedQueueSize
      constructor(temporalityPreference, maxBatchedQueueSize) {
        this.#temporalityPreference = temporalityPreference
        this.#maxBatchedQueueSize = maxBatchedQueueSize
      }
      /**
       * Gets the temporality for a given metric type.
       *
       * @param {string} type - Metric type from METRIC_TYPES
       * @returns {string} Temporality from TEMPORALITY
       */
      #getTemporality(type) {
        if (type === METRIC_TYPES.UPDOWNCOUNTER || type === METRIC_TYPES.OBSERVABLEUPDOWNCOUNTER) {
          return TEMPORALITY.CUMULATIVE
        }
        if (type === METRIC_TYPES.GAUGE) {
          return TEMPORALITY.GAUGE
        }
        switch (this.#temporalityPreference) {
          case TEMPORALITY.CUMULATIVE:
            return TEMPORALITY.CUMULATIVE
          case TEMPORALITY.LOWMEMORY:
            return type === METRIC_TYPES.COUNTER || type === METRIC_TYPES.HISTOGRAM
              ? TEMPORALITY.DELTA
              : TEMPORALITY.CUMULATIVE
          default:
            return TEMPORALITY.DELTA
        }
      }
      /**
       * Aggregates measurements into metrics.
       *
       * @param {Measurement[]} measurements - The measurements to aggregate
       * @param {Map<string, any>} cumulativeState - The cumulative state of the metrics
       * @param {Map<string, any>} lastExportedState - The last exported state of the metrics
       * @returns {Iterable<AggregatedMetric>} The aggregated metrics
       */
      aggregate(measurements, cumulativeState, lastExportedState) {
        const metricsMap = /* @__PURE__ */ new Map()
        for (const measurement of measurements) {
          const { name, description, unit, type, instrumentationScope, value, attributes, timestamp } = measurement
          const scopeKey = this.#getScopeKey(instrumentationScope)
          const metricKey = `${scopeKey}:${name}:${type}`
          const attrKey = stableStringify(attributes)
          const stateKey = this.#getStateKey(scopeKey, name, type, attrKey)
          let metric = metricsMap.get(metricKey)
          if (!metric) {
            if (metricsMap.size >= this.#maxBatchedQueueSize) {
              log.warn(
                `Metric queue exceeded limit (max: ${this.#maxBatchedQueueSize}). Dropping metric: ${metricKey}, value: ${value}. Consider increasing OTEL_BSP_MAX_QUEUE_SIZE or decreasing OTEL_METRIC_EXPORT_INTERVAL.`
              )
              continue
            }
            metric = {
              name,
              description,
              unit,
              type,
              instrumentationScope,
              temporality: this.#getTemporality(type),
              dataPointMap: /* @__PURE__ */ new Map(),
            }
            metricsMap.set(metricKey, metric)
          }
          if (type === METRIC_TYPES.COUNTER || type === METRIC_TYPES.UPDOWNCOUNTER) {
            this.#aggregateSum(metric, value, attributes, attrKey, timestamp, stateKey, cumulativeState)
          } else if (type === METRIC_TYPES.HISTOGRAM) {
            this.#aggregateHistogram(metric, value, attributes, attrKey, timestamp, stateKey, cumulativeState)
          } else {
            this.#aggregateLastValue(metric, value, attributes, attrKey, timestamp)
          }
        }
        this.#applyDeltaTemporality(metricsMap, lastExportedState)
        return metricsMap
      }
      /**
       * Gets unique identifier for a given instrumentation scope.
       *
       * @param {InstrumentationScope} instrumentationScope - The instrumentation scope
       * @returns {string} - The scope identifier
       */
      #getScopeKey(instrumentationScope) {
        return `${instrumentationScope.name}@${instrumentationScope.version}@${instrumentationScope.schemaUrl}`
      }
      /**
       * Gets unique identifier for a given metric.
       *
       * @param {string} scopeKey - The scope identifier
       * @param {string} name - The metric name
       * @param {string} type - The metric type from METRIC_TYPES
       * @param {string} attrKey - The attribute key
       * @returns {string} - The metric identifier
       */
      #getStateKey(scopeKey, name, type, attrKey) {
        return `${scopeKey}:${name}:${type}:${attrKey}`
      }
      /**
       * Checks if a given metric type is a delta type.
       *
       * @param {string} type - The metric type from METRIC_TYPES
       * @returns {boolean} - True if the metric type is a delta type
       */
      #isDeltaType(type) {
        return (
          type === METRIC_TYPES.COUNTER || type === METRIC_TYPES.OBSERVABLECOUNTER || type === METRIC_TYPES.HISTOGRAM
        )
      }
      /**
       * Applies delta temporality to the metrics.
       *
       * @param {Iterable<AggregatedMetric>} metrics - The metrics to apply delta temporality to
       * @param {Map<string, any>} lastExportedState - The last exported state of the metrics
       * @returns {void}
       */
      #applyDeltaTemporality(metrics, lastExportedState) {
        for (const metric of metrics) {
          if (metric.temporality === TEMPORALITY.DELTA && this.#isDeltaType(metric.type)) {
            const scopeKey = this.#getScopeKey(metric.instrumentationScope)
            for (const dataPoint of metric.dataPointMap.values()) {
              const stateKey = this.#getStateKey(scopeKey, metric.name, metric.type, dataPoint.attrKey)
              if (metric.type === METRIC_TYPES.COUNTER || metric.type === METRIC_TYPES.OBSERVABLECOUNTER) {
                const lastValue = lastExportedState.get(stateKey) || 0
                const currentValue = dataPoint.value
                dataPoint.value = currentValue - lastValue
                lastExportedState.set(stateKey, currentValue)
              } else if (metric.type === METRIC_TYPES.HISTOGRAM) {
                const lastState = lastExportedState.get(stateKey) || {
                  count: 0,
                  sum: 0,
                  bucketCounts: new Array(dataPoint.bucketCounts.length).fill(0),
                }
                const currentState = {
                  count: dataPoint.count,
                  sum: dataPoint.sum,
                  min: dataPoint.min,
                  max: dataPoint.max,
                  bucketCounts: [...dataPoint.bucketCounts],
                }
                dataPoint.count = currentState.count - lastState.count
                dataPoint.sum = currentState.sum - lastState.sum
                dataPoint.bucketCounts = currentState.bucketCounts.map(
                  (count, idx) => count - (lastState.bucketCounts[idx] || 0)
                )
                lastExportedState.set(stateKey, currentState)
              }
            }
          }
        }
      }
      /**
       * Finds or creates a data point for a given metric.
       *
       * @param {AggregatedMetric} metric - The metric to find or create a data point for
       * @param {Attributes} attributes - The attributes of the metric
       * @param {string} attrKey - The attribute key
       * @param {Function} createInitialDataPoint - Function to create an initial data point
       * @returns {NumberDataPoint|HistogramDataPoint} - The data point
       */
      #findOrCreateDataPoint(metric, attributes, attrKey, createInitialDataPoint) {
        let dataPoint = metric.dataPointMap.get(attrKey)
        if (!dataPoint) {
          dataPoint = { attributes, attrKey, ...createInitialDataPoint() }
          metric.dataPointMap.set(attrKey, dataPoint)
        }
        return dataPoint
      }
      /**
       * Records the sum of all values for a given metric.
       * Creates a new data point if it doesn't exist.
       *
       * @param {AggregatedMetric} metric - The metric to aggregate a sum for
       * @param {number} value - The value to aggregate
       * @param {Attributes} attributes - The attributes of the metric
       * @param {string} attrKey - The attribute key
       * @param {number} timestamp - The timestamp of the measurement
       * @param {string} stateKey - The state key
       * @param {Map<string, any>} cumulativeState - The cumulative state of the metrics
       */
      #aggregateSum(metric, value, attributes, attrKey, timestamp, stateKey, cumulativeState) {
        if (!cumulativeState.has(stateKey)) {
          cumulativeState.set(stateKey, {
            value: 0,
            startTime: metric.temporality === TEMPORALITY.CUMULATIVE ? this.#startTime : timestamp,
          })
        }
        const state = cumulativeState.get(stateKey)
        state.value += value
        const dataPoint = this.#findOrCreateDataPoint(metric, attributes, attrKey, () => ({
          startTimeUnixNano: state.startTime,
          timeUnixNano: timestamp,
          value: 0,
        }))
        dataPoint.value = state.value
        dataPoint.timeUnixNano = timestamp
      }
      /**
       * Overwrites the last recorded value for a given metric or
       * creates a new data point if it doesn't exist.
       *
       * @param {AggregatedMetric} metric - The metric to aggregate a last value for
       * @param {number} value - The value to aggregate
       * @param {Attributes} attributes - The attributes of the metric
       * @param {string} attrKey - The attribute key
       * @param {number} timestamp - The timestamp of the measurement
       */
      #aggregateLastValue(metric, value, attributes, attrKey, timestamp) {
        const dataPoint = this.#findOrCreateDataPoint(metric, attributes, attrKey, () => ({
          timeUnixNano: timestamp,
          value: 0,
        }))
        dataPoint.value = value
        dataPoint.timeUnixNano = timestamp
      }
      /**
       * Aggregates histogram values by distributing them into buckets.
       * Tracks count, sum, min, max, and per-bucket counts and creates
       * a new data point if it doesn't exist.
       *
       * @param {AggregatedMetric} metric - The metric to aggregate a histogram for
       * @param {number} value - The value to aggregate
       * @param {Attributes} attributes - The attributes of the metric
       * @param {string} attrKey - The attribute key
       * @param {number} timestamp - The timestamp of the measurement
       * @param {string} stateKey - The state key
       * @param {Map<string, any>} cumulativeState - The cumulative state of the metrics
       * @returns {void}
       */
      #aggregateHistogram(metric, value, attributes, attrKey, timestamp, stateKey, cumulativeState) {
        if (!cumulativeState.has(stateKey)) {
          cumulativeState.set(stateKey, {
            count: 0,
            sum: 0,
            min: Infinity,
            max: -Infinity,
            bucketCounts: new Array(DEFAULT_HISTOGRAM_BUCKETS.length + 1).fill(0),
            startTime: metric.temporality === TEMPORALITY.CUMULATIVE ? this.#startTime : timestamp,
          })
        }
        const state = cumulativeState.get(stateKey)
        let bucketIndex = DEFAULT_HISTOGRAM_BUCKETS.length
        for (let i = 0; i < DEFAULT_HISTOGRAM_BUCKETS.length; i++) {
          if (value <= DEFAULT_HISTOGRAM_BUCKETS[i]) {
            bucketIndex = i
            break
          }
        }
        state.bucketCounts[bucketIndex]++
        state.count++
        state.sum += value
        state.min = Math.min(state.min, value)
        state.max = Math.max(state.max, value)
        const dataPoint = this.#findOrCreateDataPoint(metric, attributes, attrKey, () => ({
          startTimeUnixNano: state.startTime,
          timeUnixNano: timestamp,
          count: 0,
          sum: 0,
          min: Infinity,
          max: -Infinity,
          bucketCounts: new Array(DEFAULT_HISTOGRAM_BUCKETS.length + 1).fill(0),
          explicitBounds: DEFAULT_HISTOGRAM_BUCKETS,
        }))
        dataPoint.count = state.count
        dataPoint.sum = state.sum
        dataPoint.min = state.min
        dataPoint.max = state.max
        dataPoint.bucketCounts = [...state.bucketCounts]
        dataPoint.timeUnixNano = timestamp
      }
    }
    module2.exports = PeriodicMetricReader
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/otlp_transformer.js
var require_otlp_transformer2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/otlp_transformer.js'(exports2, module2) {
    'use strict'
    var OtlpTransformerBase = require_otlp_transformer_base()
    var { getProtobufTypes } = require_protobuf_loader()
    var { METRIC_TYPES, TEMPORALITY } = require_constants4()
    var { protoAggregationTemporality } = getProtobufTypes()
    var AGGREGATION_TEMPORALITY_DELTA = protoAggregationTemporality.values.AGGREGATION_TEMPORALITY_DELTA
    var AGGREGATION_TEMPORALITY_CUMULATIVE = protoAggregationTemporality.values.AGGREGATION_TEMPORALITY_CUMULATIVE
    var OtlpTransformer = class extends OtlpTransformerBase {
      /**
       * Creates a new OtlpTransformer instance.
       *
       * @param {import('@opentelemetry/api').Attributes} resourceAttributes - Resource attributes
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       */
      constructor(resourceAttributes, protocol) {
        super(resourceAttributes, protocol, 'metrics')
      }
      /**
       * Transforms metrics to OTLP format based on the configured protocol.
       * @param {Iterable<AggregatedMetric>} metrics - Iterable of metric data to transform
       * @returns {Buffer} Transformed metrics in the appropriate format
       */
      transformMetrics(metrics) {
        if (this.protocol === 'http/json') {
          return this.#transformToJson(metrics)
        }
        return this.#transformToProtobuf(metrics)
      }
      /**
       * Transforms metrics to protobuf format.
       * @param {Iterable<AggregatedMetric>} metrics - Iterable of metrics to transform
       * @returns {Buffer} Protobuf-encoded metrics
       *
       */
      #transformToProtobuf(metrics) {
        const { protoMetricsService } = getProtobufTypes()
        const metricsData = {
          resourceMetrics: [
            {
              resource: this.transformResource(),
              scopeMetrics: this.#transformScope(metrics),
            },
          ],
        }
        return this.serializeToProtobuf(protoMetricsService, metricsData)
      }
      /**
       * Transforms metrics to JSON format.
       * @param {Array} metrics - Array of metrics to transform
       * @returns {Buffer} JSON-encoded metrics
       *
       */
      #transformToJson(metrics) {
        const metricsData = {
          resourceMetrics: [
            {
              resource: this.transformResource(),
              scopeMetrics: this.#transformScope(metrics, true),
            },
          ],
        }
        return this.serializeToJson(metricsData)
      }
      /**
       * Creates scope metrics grouped by instrumentation scope.
       * @param {Iterable<AggregatedMetric>} metrics - Iterable of metrics to transform
       * @param {boolean} isJson - Whether to format for JSON output
       * @returns {Array<Object>} Array of scope metric objects
       *
       */
      #transformScope(metrics, isJson = false) {
        const groupedMetrics = this.groupByInstrumentationScope(metrics)
        const scopeMetrics = []
        for (const metricsInScope of groupedMetrics.values()) {
          const firstMetric = metricsInScope[0]
          const instrumentationScope = firstMetric.instrumentationScope || {}
          const { name = '', version = '', schemaUrl = '', attributes = {} } = instrumentationScope
          const scope = {
            name,
            version,
            droppedAttributesCount: 0,
          }
          if (attributes) {
            const transformed = isJson ? this.attributesToJson(attributes) : this.transformAttributes(attributes)
            if (transformed.length) {
              scope.attributes = transformed
            }
          }
          scopeMetrics.push({
            scope,
            schemaUrl,
            metrics: metricsInScope.map((metric) => this.#transformMetric(metric, isJson)),
          })
        }
        return scopeMetrics
      }
      /**
       * Transforms a single metric to protobuf or JSON format.
       *
       * @param {AggregatedMetric} metric - The metric to transform
       * @param {boolean} isJson - Whether to output JSON format (vs protobuf)
       * @returns {Object} - The metric transformed to OTLP protobuf or JSON format
       */
      #transformMetric(metric, isJson = false) {
        const result = {
          name: metric.name,
          description: metric.description || '',
          unit: metric.unit || '',
        }
        const isCumulative = metric.temporality === TEMPORALITY.CUMULATIVE
        let temporality
        if (isJson) {
          temporality = isCumulative ? 'AGGREGATION_TEMPORALITY_CUMULATIVE' : 'AGGREGATION_TEMPORALITY_DELTA'
        } else {
          temporality = isCumulative ? AGGREGATION_TEMPORALITY_CUMULATIVE : AGGREGATION_TEMPORALITY_DELTA
        }
        switch (metric.type) {
          case METRIC_TYPES.HISTOGRAM:
            result.histogram = {
              dataPoints: Array.from(metric.dataPointMap.values(), (dp) =>
                this.#transformHistogramDataPoint(dp, isJson)
              ),
              aggregationTemporality: temporality,
            }
            break
          case METRIC_TYPES.COUNTER:
          case METRIC_TYPES.OBSERVABLECOUNTER:
          case METRIC_TYPES.UPDOWNCOUNTER:
          case METRIC_TYPES.OBSERVABLEUPDOWNCOUNTER:
            result.sum = {
              dataPoints: Array.from(metric.dataPointMap.values(), (dp) => this.#transformNumberDataPoint(dp, isJson)),
              aggregationTemporality: temporality,
              isMonotonic: metric.type === METRIC_TYPES.COUNTER || metric.type === METRIC_TYPES.OBSERVABLECOUNTER,
            }
            break
          case METRIC_TYPES.GAUGE:
            result.gauge = {
              dataPoints: Array.from(metric.dataPointMap.values(), (dp) => this.#transformNumberDataPoint(dp, isJson)),
            }
            break
        }
        return result
      }
      /**
       * Transforms a histogram data point.
       *
       * @param {HistogramDataPoint} dp - The histogram data point to transform
       * @param {boolean} isJson - Whether to output JSON format (vs protobuf)
       * @returns {Object} The histogram data point transformed to OTLP protobuf format
       */
      #transformHistogramDataPoint(dp, isJson) {
        const attributes = isJson ? this.attributesToJson(dp.attributes) : this.transformAttributes(dp.attributes)
        const dataPoint = {
          attributes,
          startTimeUnixNano: dp.startTimeUnixNano,
          timeUnixNano: dp.timeUnixNano,
          count: dp.count,
          sum: dp.sum,
          bucketCounts: dp.bucketCounts || [],
          explicitBounds: dp.explicitBounds || [],
          min: dp.min,
          max: dp.max,
        }
        if (isJson) {
          dataPoint.startTimeUnixNano = String(dataPoint.startTimeUnixNano)
          dataPoint.timeUnixNano = String(dataPoint.timeUnixNano)
          dataPoint.count = dataPoint.count || 0
        }
        return dataPoint
      }
      /**
       * Transforms a number data point to protobuf or JSON format.
       *
       * @param {NumberDataPoint} dataPoint - The number data point to transform
       * @param {boolean} isJson - Whether to output JSON format (vs protobuf)
       * @returns {Object} The number data point transformed to OTLP protobuf format
       */
      #transformNumberDataPoint(dataPoint, isJson) {
        const attributes = isJson
          ? this.attributesToJson(dataPoint.attributes)
          : this.transformAttributes(dataPoint.attributes)
        const timeUnixNano = isJson ? String(dataPoint.timeUnixNano) : dataPoint.timeUnixNano
        const result = {
          attributes,
          timeUnixNano,
        }
        if (dataPoint.startTimeUnixNano) {
          result.startTimeUnixNano = isJson ? String(dataPoint.startTimeUnixNano) : dataPoint.startTimeUnixNano
        }
        this.#assignNumberValue(result, dataPoint.value)
        return result
      }
      /**
       * Assigns the appropriate value field (asInt or asDouble) based on the value type.
       *
       * @param {NumberDataPoint} dataPoint - The number data point to assign a value to
       * @param {number} value - The value to assign
       * @returns {void}
       */
      #assignNumberValue(dataPoint, value) {
        if (Number.isInteger(value)) {
          dataPoint.asInt = value
        } else {
          dataPoint.asDouble = value
        }
      }
    }
    module2.exports = OtlpTransformer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/otlp_http_metric_exporter.js
var require_otlp_http_metric_exporter = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/otlp_http_metric_exporter.js'(exports2, module2) {
    'use strict'
    var OtlpHttpExporterBase = require_otlp_http_exporter_base()
    var OtlpTransformer = require_otlp_transformer2()
    var OtlpHttpMetricExporter = class extends OtlpHttpExporterBase {
      /**
       * Creates a new OtlpHttpMetricExporter instance.
       *
       * @param {string} url - OTLP endpoint URL
       * @param {string} headers - Additional HTTP headers as comma-separated key=value string
       * @param {number} timeout - Request timeout in milliseconds
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       * @param {Resource} resource - Resource attributes
       */
      constructor(url, headers, timeout, protocol, resource) {
        super(url, headers, timeout, protocol, '/v1/metrics', 'metrics')
        this.transformer = new OtlpTransformer(resource, protocol)
      }
      /**
       * Exports metrics via OTLP over HTTP.
       *
       * @param {Map<string, AggregatedMetric>} metrics - Map of metric data to export
       *
       * @returns {void}
       */
      export(metrics) {
        if (metrics.size === 0) {
          return
        }
        let dataPointCount = 0
        for (const metric of metrics.values()) {
          if (metric.dataPointMap) {
            dataPointCount += metric.dataPointMap.size
          }
        }
        const additionalTags = [`points:${dataPointCount}`]
        this.recordTelemetry('otel.metrics_export_attempts', 1, additionalTags)
        const payload = this.transformer.transformMetrics(metrics.values())
        this.sendPayload(payload, (result) => {
          if (result.code === 0) {
            this.recordTelemetry('otel.metrics_export_successes', 1, additionalTags)
          }
        })
      }
    }
    module2.exports = OtlpHttpMetricExporter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/index.js
var require_metrics2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/opentelemetry/metrics/index.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var { metrics } = require('@opentelemetry/api')
    var MeterProvider = require_meter_provider()
    var PeriodicMetricReader = require_periodic_metric_reader()
    var OtlpHttpMetricExporter = require_otlp_http_metric_exporter()
    function initializeOpenTelemetryMetrics(config) {
      const resourceAttributes = {
        'service.name': config.service,
        'service.version': config.version,
        'deployment.environment': config.env,
      }
      if (config.tags) {
        const filteredTags = { ...config.tags }
        delete filteredTags.service
        delete filteredTags.version
        delete filteredTags.env
        Object.assign(resourceAttributes, filteredTags)
      }
      if (config.reportHostname) {
        resourceAttributes['host.name'] = os.hostname()
      }
      const exporter = new OtlpHttpMetricExporter(
        config.otelMetricsUrl,
        config.otelMetricsHeaders,
        config.otelMetricsTimeout,
        config.otelMetricsProtocol,
        resourceAttributes
      )
      const reader = new PeriodicMetricReader(
        exporter,
        config.otelMetricsExportInterval,
        config.otelMetricsTemporalityPreference,
        config.otelMaxQueueSize
      )
      const meterProvider = new MeterProvider({ reader })
      metrics.setGlobalMeterProvider(meterProvider)
    }
    module2.exports = {
      MeterProvider,
      initializeOpenTelemetryMetrics,
    }
  },
})

// node_modules/dd-trace/vendor/dist/retry/index.js
var require_retry = __commonJS({
  'node_modules/dd-trace/vendor/dist/retry/index.js'(exports2, module2) {
    ;(() => {
      var t = {
          './retry/index.js': function (t2, e2, r2) {
            t2.exports = r2('./retry/lib/retry.js')
          },
          './retry/lib/retry.js': function (t2, e2, r2) {
            var i = r2('./retry/lib/retry_operation.js')
            ;((e2.operation = function (t3) {
              return new i(e2.timeouts(t3), {
                forever: t3 && (t3.forever || t3.retries === 1 / 0),
                unref: t3 && t3.unref,
                maxRetryTime: t3 && t3.maxRetryTime,
              })
            }),
              (e2.timeouts = function (t3) {
                if (t3 instanceof Array) return [].concat(t3)
                var e3 = { retries: 10, factor: 2, minTimeout: 1e3, maxTimeout: 1 / 0, randomize: false }
                for (var r3 in t3) e3[r3] = t3[r3]
                if (e3.minTimeout > e3.maxTimeout) throw Error('minTimeout is greater than maxTimeout')
                for (var i2 = [], o = 0; o < e3.retries; o++) i2.push(this.createTimeout(o, e3))
                return (
                  t3 && t3.forever && !i2.length && i2.push(this.createTimeout(o, e3)),
                  i2.sort(function (t4, e4) {
                    return t4 - e4
                  }),
                  i2
                )
              }),
              (e2.createTimeout = function (t3, e3) {
                var r3 = Math.round(
                  (e3.randomize ? Math.random() + 1 : 1) * Math.max(e3.minTimeout, 1) * Math.pow(e3.factor, t3)
                )
                return Math.min(r3, e3.maxTimeout)
              }),
              (e2.wrap = function (t3, r3, i2) {
                if ((r3 instanceof Array && ((i2 = r3), (r3 = null)), !i2))
                  for (var o in ((i2 = []), t3)) 'function' == typeof t3[o] && i2.push(o)
                for (var n = 0; n < i2.length; n++) {
                  var s = i2[n],
                    u = t3[s]
                  ;((t3[s] = function (i3) {
                    var o2 = e2.operation(r3),
                      n2 = Array.prototype.slice.call(arguments, 1),
                      s2 = n2.pop()
                    ;(n2.push(function (t4) {
                      o2.retry(t4) || (t4 && (arguments[0] = o2.mainError()), s2.apply(this, arguments))
                    }),
                      o2.attempt(function () {
                        i3.apply(t3, n2)
                      }))
                  }.bind(t3, u)),
                    (t3[s].options = r3))
                }
              }))
          },
          './retry/lib/retry_operation.js': function (t2) {
            function e2(t3, e3) {
              ;('boolean' == typeof e3 && (e3 = { forever: e3 }),
                (this._originalTimeouts = JSON.parse(JSON.stringify(t3))),
                (this._timeouts = t3),
                (this._options = e3 || {}),
                (this._maxRetryTime = (e3 && e3.maxRetryTime) || 1 / 0),
                (this._fn = null),
                (this._errors = []),
                (this._attempts = 1),
                (this._operationTimeout = null),
                (this._operationTimeoutCb = null),
                (this._timeout = null),
                (this._operationStart = null),
                (this._timer = null),
                this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0)))
            }
            ;((t2.exports = e2),
              (e2.prototype.reset = function () {
                ;((this._attempts = 1), (this._timeouts = this._originalTimeouts.slice(0)))
              }),
              (e2.prototype.stop = function () {
                ;(this._timeout && clearTimeout(this._timeout),
                  this._timer && clearTimeout(this._timer),
                  (this._timeouts = []),
                  (this._cachedTimeouts = null))
              }),
              (e2.prototype.retry = function (t3) {
                if ((this._timeout && clearTimeout(this._timeout), !t3)) return false
                var e3 = /* @__PURE__ */ new Date().getTime()
                if (t3 && e3 - this._operationStart >= this._maxRetryTime)
                  return (this._errors.push(t3), this._errors.unshift(Error('RetryOperation timeout occurred')), false)
                this._errors.push(t3)
                var r2 = this._timeouts.shift()
                if (void 0 === r2)
                  if (!this._cachedTimeouts) return false
                  else (this._errors.splice(0, this._errors.length - 1), (r2 = this._cachedTimeouts.slice(-1)))
                var i = this
                return (
                  (this._timer = setTimeout(function () {
                    ;(i._attempts++,
                      i._operationTimeoutCb &&
                        ((i._timeout = setTimeout(function () {
                          i._operationTimeoutCb(i._attempts)
                        }, i._operationTimeout)),
                        i._options.unref && i._timeout.unref()),
                      i._fn(i._attempts))
                  }, r2)),
                  this._options.unref && this._timer.unref(),
                  true
                )
              }),
              (e2.prototype.attempt = function (t3, e3) {
                ;((this._fn = t3),
                  e3 &&
                    (e3.timeout && (this._operationTimeout = e3.timeout), e3.cb && (this._operationTimeoutCb = e3.cb)))
                var r2 = this
                ;(this._operationTimeoutCb &&
                  (this._timeout = setTimeout(function () {
                    r2._operationTimeoutCb()
                  }, r2._operationTimeout)),
                  (this._operationStart = /* @__PURE__ */ new Date().getTime()),
                  this._fn(this._attempts))
              }),
              (e2.prototype.try = function (t3) {
                ;(console.log('Using RetryOperation.try() is deprecated'), this.attempt(t3))
              }),
              (e2.prototype.start = function (t3) {
                ;(console.log('Using RetryOperation.start() is deprecated'), this.attempt(t3))
              }),
              (e2.prototype.start = e2.prototype.try),
              (e2.prototype.errors = function () {
                return this._errors
              }),
              (e2.prototype.attempts = function () {
                return this._attempts
              }),
              (e2.prototype.mainError = function () {
                if (0 === this._errors.length) return null
                for (var t3 = {}, e3 = null, r2 = 0, i = 0; i < this._errors.length; i++) {
                  var o = this._errors[i],
                    n = o.message,
                    s = (t3[n] || 0) + 1
                  ;((t3[n] = s), s >= r2 && ((e3 = o), (r2 = s)))
                }
                return e3
              }))
          },
        },
        e = {},
        r = (function r2(i) {
          var o = e[i]
          if (void 0 !== o) return o.exports
          var n = (e[i] = { exports: {} })
          return (t[i](n, n.exports, r2), n.exports)
        })('./retry/index.js')
      module2.exports = r
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/libuv-size.js
var require_libuv_size = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/libuv-size.js'(exports2, module2) {
    'use strict'
    var { getEnvironmentVariable } = require_config_helper()
    var os = require('node:os')
    function getLibuvThreadPoolSize(envVar) {
      if (envVar === void 0) {
        return
      }
      const s = Number.parseInt(envVar, 10)
      return Number.isNaN(s) ? 0 : s
    }
    var libuvThreadPoolSize = getLibuvThreadPoolSize(getEnvironmentVariable('UV_THREADPOOL_SIZE'))
    function getEffectiveLibuvThreadCount(size) {
      if (size === void 0) {
        return 4
      } else if (size < 0 || size > 1024) {
        return 1024
      } else if (size === 0) {
        return 1
      }
      return size
    }
    var effectiveLibuvThreadCount = getEffectiveLibuvThreadCount(libuvThreadPoolSize)
    function availableParallelism() {
      return typeof os.availableParallelism === 'function' ? os.availableParallelism() : os.cpus().length
    }
    module2.exports = {
      availableParallelism,
      effectiveLibuvThreadCount,
      libuvThreadPoolSize,
      // Only used for testing
      getLibuvThreadPoolSize,
      getEffectiveLibuvThreadCount,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/event_serializer.js
var require_event_serializer = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/event_serializer.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var perf = require('perf_hooks').performance
    var version = require_package().version
    var { availableParallelism, libuvThreadPoolSize } = require_libuv_size()
    var EventSerializer = class {
      constructor({ env, host, service, version: version2, libraryInjected, activation } = {}) {
        this._env = env
        this._host = host
        this._service = service
        this._appVersion = version2
        this._libraryInjected = !!libraryInjected
        this._activation = activation || 'unknown'
      }
      typeToFile(type) {
        return `${type}.pprof`
      }
      getEventJSON({ profiles, infos, start, end, tags = {}, endpointCounts }) {
        return JSON.stringify({
          attachments: Object.keys(profiles).map((t) => this.typeToFile(t)),
          start: start.toISOString(),
          end: end.toISOString(),
          family: 'node',
          version: '4',
          tags_profiler: [
            'language:javascript',
            'runtime:nodejs',
            `runtime_arch:${process.arch}`,
            `runtime_os:${process.platform}`,
            `runtime_version:${process.version}`,
            `process_id:${process.pid}`,
            `profiler_version:${version}`,
            'format:pprof',
            ...Object.entries(tags).map(([key, value]) => `${key}:${value}`),
          ].join(','),
          endpoint_counts: endpointCounts,
          info: {
            application: {
              env: this._env,
              service: this._service,
              start_time: new Date(perf.nodeTiming.nodeStart + perf.timeOrigin).toISOString(),
              version: this._appVersion,
            },
            platform: {
              hostname: this._host,
              kernel_name: os.type(),
              kernel_release: os.release(),
              kernel_version: os.version(),
            },
            profiler: {
              activation: this._activation,
              ssi: {
                mechanism: this._libraryInjected ? 'injected_agent' : 'none',
              },
              version,
              ...infos,
            },
            runtime: {
              available_processors: availableParallelism(),
              // Using `nodejs` for consistency with the existing `runtime` tag.
              // Note that the event `family` property uses `node`, as that's what's
              // proscribed by the Intake API, but that's an internal enum and is
              // not customer visible.
              engine: 'nodejs',
              libuv_threadpool_size: libuvThreadPoolSize,
              // strip off leading 'v'. This makes the format consistent with other
              // runtimes (e.g. Ruby) but not with the existing `runtime_version` tag.
              // We'll keep it like this as we want cross-engine consistency. We
              // also aren't changing the format of the existing tag as we don't want
              // to break it.
              version: process.version.slice(1),
            },
          },
        })
      }
    }
    module2.exports = { EventSerializer }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js
var require_agent2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js'(exports2, module2) {
    'use strict'
    var retry = require_retry()
    var { request: httpRequest } = require('http')
    var { request: httpsRequest } = require('https')
    var { EventSerializer } = require_event_serializer()
    var docker = require_docker()
    var FormData = require_form_data()
    var { storage } = require_datadog_core()
    var version = require_package().version
    var { urlToHttpOptions } = require('url')
    var perf = require('perf_hooks').performance
    var telemetryMetrics = require_metrics()
    var profilersNamespace = telemetryMetrics.manager.namespace('profilers')
    var statusCodeCounters = []
    var requestCounter = profilersNamespace.count('profile_api.requests', [])
    var sizeDistribution = profilersNamespace.distribution('profile_api.bytes', [])
    var durationDistribution = profilersNamespace.distribution('profile_api.ms', [])
    var statusCodeErrorCounter = profilersNamespace.count('profile_api.errors', ['type:status_code'])
    var networkErrorCounter = profilersNamespace.count('profile_api.errors', ['type:network'])
    function countStatusCode(statusCode) {
      let counter = statusCodeCounters[statusCode]
      if (counter === void 0) {
        counter = statusCodeCounters[statusCode] = profilersNamespace.count('profile_api.responses', [
          `status_code:${statusCode}`,
        ])
      }
      counter.inc()
    }
    function sendRequest(options, form, callback) {
      const request = options.protocol === 'https:' ? httpsRequest : httpRequest
      const store = storage('legacy').getStore()
      storage('legacy').enterWith({ noop: true })
      requestCounter.inc()
      const start = perf.now()
      const req = request(options, (res) => {
        durationDistribution.track(perf.now() - start)
        countStatusCode(res.statusCode)
        if (res.statusCode >= 400) {
          statusCodeErrorCounter.inc()
          const error = new Error(`HTTP Error ${res.statusCode}`)
          error.status = res.statusCode
          callback(error)
        } else {
          callback(null, res)
        }
      })
      req.on('error', (err) => {
        networkErrorCounter.inc()
        callback(err)
      })
      if (form) {
        sizeDistribution.track(form.size())
        form.pipe(req)
      }
      storage('legacy').enterWith(store)
    }
    function getBody(stream, callback) {
      const chunks = []
      stream.on('error', (err) => {
        networkErrorCounter.inc()
        callback(err)
      })
      stream.on('data', (chunk) => chunks.push(chunk))
      stream.on('end', () => {
        callback(null, Buffer.concat(chunks))
      })
    }
    function computeRetries(uploadTimeout) {
      let tries = 0
      while (tries < 2 || uploadTimeout > 1e3) {
        tries++
        uploadTimeout /= 2
      }
      return [tries, Math.floor(uploadTimeout)]
    }
    var AgentExporter = class extends EventSerializer {
      constructor(config = {}) {
        super(config)
        const { url, logger, uploadTimeout } = config
        this._url = url
        this._logger = logger
        const [backoffTries, backoffTime] = computeRetries(uploadTimeout)
        this._backoffTime = backoffTime
        this._backoffTries = backoffTries
      }
      export(exportSpec) {
        const { profiles } = exportSpec
        const fields = []
        const event = this.getEventJSON(exportSpec)
        fields.push([
          'event',
          event,
          {
            filename: 'event.json',
            contentType: 'application/json',
          },
        ])
        this._logger.debug(() => {
          return `Building agent export report:
${event}`
        })
        for (const [type, buffer] of Object.entries(profiles)) {
          this._logger.debug(() => {
            const bytes = buffer.toString('hex').match(/../g).join(' ')
            return `Adding ${type} profile to agent export: ` + bytes
          })
          const filename = this.typeToFile(type)
          fields.push([
            filename,
            buffer,
            {
              filename,
              contentType: 'application/octet-stream',
            },
          ])
        }
        return new Promise((resolve, reject) => {
          const operation = retry.operation({
            randomize: true,
            minTimeout: this._backoffTime,
            retries: this._backoffTries,
            unref: true,
          })
          operation.attempt((attempt) => {
            const form = new FormData()
            for (const [key, value, options2] of fields) {
              form.append(key, value, options2)
            }
            const options = {
              method: 'POST',
              path: '/profiling/v1/input',
              headers: {
                'DD-EVP-ORIGIN': 'dd-trace-js',
                'DD-EVP-ORIGIN-VERSION': version,
                ...form.getHeaders(),
              },
              timeout: this._backoffTime * 2 ** attempt,
            }
            docker.inject(options.headers)
            if (this._url.protocol === 'unix:') {
              options.socketPath = this._url.pathname
            } else {
              const httpOptions = urlToHttpOptions(this._url)
              options.protocol = httpOptions.protocol
              options.hostname = httpOptions.hostname
              options.port = httpOptions.port
            }
            this._logger.debug(() => {
              return `Submitting profiler agent report attempt #${attempt} to: ${JSON.stringify(options)}`
            })
            sendRequest(options, form, (err, response) => {
              if (err) {
                const { status } = err
                if ((typeof status !== 'number' || status >= 500 || status === 429) && operation.retry(err)) {
                  this._logger.warn(`Error from the agent: ${err.message}`)
                } else {
                  reject(err)
                }
                return
              }
              getBody(response, (err2, body) => {
                if (err2) {
                  this._logger.warn(`Error reading agent response: ${err2.message}`)
                } else {
                  this._logger.debug(() => {
                    const bytes = (body.toString('hex').match(/../g) || []).join(' ')
                    return `Agent export response: ${bytes}`
                  })
                }
              })
              resolve()
            })
          })
        })
      }
    }
    module2.exports = { AgentExporter, computeRetries }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js
var require_file2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js'(exports2, module2) {
    'use strict'
    var fs = require('fs')
    var { promisify } = require('util')
    var { threadId } = require('worker_threads')
    var writeFile = promisify(fs.writeFile)
    var { EventSerializer } = require_event_serializer()
    var pad = (n) => String(n).padStart(2, '0')
    function formatDateTime(t) {
      return `${t.getUTCFullYear()}${pad(t.getUTCMonth() + 1)}${pad(t.getUTCDate())}T${pad(t.getUTCHours())}${pad(t.getUTCMinutes())}${pad(t.getUTCSeconds())}Z`
    }
    var FileExporter = class extends EventSerializer {
      constructor(config = {}) {
        super(config)
        const { pprofPrefix } = config
        this._pprofPrefix = pprofPrefix || ''
      }
      export(exportSpec) {
        const { profiles, end } = exportSpec
        const types = Object.keys(profiles)
        const dateStr = formatDateTime(end)
        const tasks = types.map((type) => {
          return writeFile(`${this._pprofPrefix}${type}_worker_${threadId}_${dateStr}.pprof`, profiles[type])
        })
        tasks.push(writeFile(`event_worker_${threadId}_${dateStr}.json`, this.getEventJSON(exportSpec)))
        return Promise.all(tasks)
      }
    }
    module2.exports = { FileExporter }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js
var require_console = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js'(exports2, module2) {
    'use strict'
    var mapping = {
      error: 3,
      warn: 4,
      info: 6,
      debug: 7,
    }
    var ConsoleLogger = class {
      constructor(options = {}) {
        this._level = mapping[options.level] || mapping.error
      }
      debug(message) {
        this._log('debug', message)
      }
      info(message) {
        this._log('info', message)
      }
      warn(message) {
        this._log('warn', message)
      }
      error(message) {
        this._log('error', message)
      }
      _log(level, message) {
        if (mapping[level] > this._level) return
        console[level](message)
      }
    }
    module2.exports = { ConsoleLogger }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/shared.js
var require_shared = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/shared.js'(exports2, module2) {
    'use strict'
    var { isMainThread, threadId } = require('worker_threads')
    var END_TIMESTAMP_LABEL = 'end_timestamp_ns'
    var THREAD_NAME_LABEL = 'thread name'
    var OS_THREAD_ID_LABEL = 'os thread id'
    var THREAD_ID_LABEL = 'thread id'
    var SPAN_ID_LABEL = 'span id'
    var LOCAL_ROOT_SPAN_ID_LABEL = 'local root span id'
    var threadNamePrefix = isMainThread ? 'Main' : `Worker #${threadId}`
    var eventLoopThreadName = `${threadNamePrefix} Event Loop`
    function getThreadLabels() {
      const pprof = require('@datadog/pprof')
      const nativeThreadId = pprof.getNativeThreadId()
      return {
        [THREAD_NAME_LABEL]: eventLoopThreadName,
        [THREAD_ID_LABEL]: `${threadId}`,
        [OS_THREAD_ID_LABEL]: `${nativeThreadId}`,
      }
    }
    function cacheThreadLabels() {
      let labels
      return () => {
        if (!labels) {
          labels = getThreadLabels()
        }
        return labels
      }
    }
    function getNonJSThreadsLabels() {
      return { [THREAD_NAME_LABEL]: 'Non-JS threads', [THREAD_ID_LABEL]: 'NA', [OS_THREAD_ID_LABEL]: 'NA' }
    }
    function encodeProfileAsync(profile) {
      return profile.encodeAsync().then(Buffer.from)
    }
    module2.exports = {
      END_TIMESTAMP_LABEL,
      THREAD_NAME_LABEL,
      THREAD_ID_LABEL,
      OS_THREAD_ID_LABEL,
      SPAN_ID_LABEL,
      LOCAL_ROOT_SPAN_ID_LABEL,
      threadNamePrefix,
      eventLoopThreadName,
      getNonJSThreadsLabels,
      getThreadLabels: cacheThreadLabels(),
      encodeProfileAsync,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/webspan-utils.js
var require_webspan_utils = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/webspan-utils.js'(exports2, module2) {
    'use strict'
    var { HTTP_METHOD, HTTP_ROUTE, RESOURCE_NAME, SPAN_TYPE } = require_tags()
    var { WEB } = require_types()
    function isWebServerSpan(tags) {
      return tags[SPAN_TYPE] === WEB
    }
    function endpointNameFromTags(tags) {
      return tags[RESOURCE_NAME] || [tags[HTTP_METHOD], tags[HTTP_ROUTE]].filter(Boolean).join(' ')
    }
    function getStartedSpans(context) {
      return context._trace.started
    }
    module2.exports = {
      isWebServerSpan,
      endpointNameFromTags,
      getStartedSpans,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/wall.js
var require_wall = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/wall.js'(exports2, module2) {
    'use strict'
    var { storage } = require_datadog_core()
    var dc = require_dc_polyfill()
    var runtimeMetrics = require_runtime_metrics2()
    var telemetryMetrics = require_metrics()
    var {
      END_TIMESTAMP_LABEL,
      SPAN_ID_LABEL,
      LOCAL_ROOT_SPAN_ID_LABEL,
      getNonJSThreadsLabels,
      getThreadLabels,
      encodeProfileAsync,
    } = require_shared()
    var TRACE_ENDPOINT_LABEL = 'trace endpoint'
    var { isWebServerSpan, endpointNameFromTags, getStartedSpans } = require_webspan_utils()
    var beforeCh
    var enterCh = dc.channel('dd-trace:storage:enter')
    var spanFinishCh = dc.channel('dd-trace:span:finish')
    var profilerTelemetryMetrics = telemetryMetrics.manager.namespace('profilers')
    var ProfilingContext = /* @__PURE__ */ Symbol('NativeWallProfiler.ProfilingContext')
    var kSampleCount
    function getActiveSpan() {
      const store = storage('legacy').getStore()
      return store && store.span
    }
    function toBigInt(spanId) {
      return spanId !== null && typeof spanId === 'object' ? spanId.toBigInt() : spanId
    }
    function updateContext(context) {
      if (context.spanId !== void 0) {
        context.spanId = toBigInt(context.spanId)
      }
      if (context.rootSpanId !== void 0) {
        context.rootSpanId = toBigInt(context.rootSpanId)
      }
      if (context.webTags !== void 0 && context.endpoint === void 0) {
        context.endpoint = endpointNameFromTags(context.webTags)
      }
    }
    var channelsActivated = false
    function ensureChannelsActivated(asyncContextFrameEnabled) {
      if (channelsActivated) return
      const shimmer = require_datadog_shimmer()
      const asyncHooks = require('async_hooks')
      if (!asyncContextFrameEnabled) {
        const { createHook } = asyncHooks
        beforeCh = dc.channel('dd-trace:storage:before')
        createHook({ before: () => beforeCh.publish() }).enable()
      }
      const { AsyncLocalStorage } = asyncHooks
      let inRun = false
      shimmer.wrap(AsyncLocalStorage.prototype, 'enterWith', function (original) {
        return function (...args) {
          const retVal = original.apply(this, args)
          if (!inRun) enterCh.publish()
          return retVal
        }
      })
      if (!asyncContextFrameEnabled) {
        shimmer.wrap(AsyncLocalStorage.prototype, 'run', function (original) {
          return function (store, callback, ...args) {
            const wrappedCb = shimmer.wrapFunction(
              callback,
              (cb) =>
                function (...args2) {
                  inRun = false
                  enterCh.publish()
                  const retVal2 = cb.apply(this, args2)
                  inRun = true
                  return retVal2
                }
            )
            inRun = true
            const retVal = original.call(this, store, wrappedCb, ...args)
            enterCh.publish()
            inRun = false
            return retVal
          }
        })
      }
      channelsActivated = true
    }
    var NativeWallProfiler = class {
      #asyncContextFrameEnabled = false
      #captureSpanData = false
      #codeHotspotsEnabled = false
      #cpuProfilingEnabled = false
      #endpointCollectionEnabled = false
      #flushIntervalMillis = 0
      #logger
      #mapper
      #pprof
      #samplingIntervalMicros = 0
      #started = false
      #telemetryHeartbeatIntervalMillis = 0
      #timelineEnabled = false
      #v8ProfilerBugWorkaroundEnabled = false
      #withContexts = false
      // Bind these to this so they can be used as callbacks
      #boundEnter = this.#enter.bind(this)
      #boundSpanFinished = this.#spanFinished.bind(this)
      #boundGenerateLabels = this._generateLabels.bind(this)
      get type() {
        return 'wall'
      }
      constructor(options = {}) {
        this.#asyncContextFrameEnabled = !!options.asyncContextFrameEnabled
        this.#codeHotspotsEnabled = !!options.codeHotspotsEnabled
        this.#cpuProfilingEnabled = !!options.cpuProfilingEnabled
        this.#endpointCollectionEnabled = !!options.endpointCollectionEnabled
        this.#flushIntervalMillis = options.flushInterval || 60 * 1e3
        this.#logger = options.logger
        this.#samplingIntervalMicros = (options.samplingInterval || 1e3 / 99) * 1e3
        this.#telemetryHeartbeatIntervalMillis = options.heartbeatInterval || 60 * 1e3
        this.#timelineEnabled = !!options.timelineEnabled
        this.#v8ProfilerBugWorkaroundEnabled = !!options.v8ProfilerBugWorkaroundEnabled
        this.#captureSpanData = this.#codeHotspotsEnabled || this.#endpointCollectionEnabled
        this.#withContexts = this.#captureSpanData || this.#timelineEnabled || this.#cpuProfilingEnabled
      }
      codeHotspotsEnabled() {
        return this.#codeHotspotsEnabled
      }
      endpointCollectionEnabled() {
        return this.#endpointCollectionEnabled
      }
      start({ mapper } = {}) {
        if (this.#started) return
        this.#mapper = mapper
        this.#pprof = require('@datadog/pprof')
        kSampleCount = this.#pprof.time.constants.kSampleCount
        if (!process._startProfilerIdleNotifier) {
          process._startProfilerIdleNotifier = () => {}
        }
        if (!process._stopProfilerIdleNotifier) {
          process._stopProfilerIdleNotifier = () => {}
        }
        this.#pprof.time.start({
          collectCpuTime: this.#cpuProfilingEnabled,
          durationMillis: this.#flushIntervalMillis,
          intervalMicros: this.#samplingIntervalMicros,
          lineNumbers: false,
          sourceMapper: this.#mapper,
          useCPED: this.#asyncContextFrameEnabled,
          withContexts: this.#withContexts,
          workaroundV8Bug: this.#v8ProfilerBugWorkaroundEnabled,
        })
        if (this.#withContexts) {
          if (!this.#asyncContextFrameEnabled) {
            this.#setNewContext()
          }
          if (this.#captureSpanData) {
            this._profilerState = this.#pprof.time.getState()
            this._lastSampleCount = 0
            ensureChannelsActivated(this.#asyncContextFrameEnabled)
            if (this.#asyncContextFrameEnabled) {
              this.#setupTelemetryMetrics()
            } else {
              beforeCh.subscribe(this.#boundEnter)
            }
            enterCh.subscribe(this.#boundEnter)
            spanFinishCh.subscribe(this.#boundSpanFinished)
          }
        }
        this.#started = true
      }
      #setupTelemetryMetrics() {
        const asyncContextsLiveGauge = profilerTelemetryMetrics.gauge('wall.async_contexts_live')
        const asyncContextsUsedGauge = profilerTelemetryMetrics.gauge('wall.async_contexts_used')
        this._contextCountGaugeUpdater = setInterval(() => {
          const { totalAsyncContextCount, usedAsyncContextCount } = this.#pprof.time.getMetrics()
          asyncContextsLiveGauge.mark(totalAsyncContextCount)
          asyncContextsUsedGauge.mark(usedAsyncContextCount)
        }, this.#telemetryHeartbeatIntervalMillis)
        this._contextCountGaugeUpdater.unref()
      }
      #enter() {
        if (!this.#started) return
        const span = getActiveSpan()
        const sampleContext = span ? this.#getProfilingContext(span) : {}
        if (this.#asyncContextFrameEnabled) {
          this.#pprof.time.setContext(sampleContext)
        } else {
          const sampleCount = this._profilerState[kSampleCount]
          if (sampleCount !== this._lastSampleCount) {
            this._lastSampleCount = sampleCount
            const context = this._currentContext.ref
            this.#setNewContext()
            updateContext(context)
          }
          this._currentContext.ref = sampleContext
        }
      }
      #getProfilingContext(span) {
        let profilingContext = span[ProfilingContext]
        if (profilingContext === void 0) {
          const context = span.context()
          const startedSpans = getStartedSpans(context)
          let spanId
          let rootSpanId
          if (this.#codeHotspotsEnabled) {
            spanId = context._spanId
            rootSpanId = startedSpans.length ? startedSpans[0].context()._spanId : context._spanId
          }
          let webTags
          if (this.#endpointCollectionEnabled) {
            const tags = context._tags
            if (isWebServerSpan(tags)) {
              webTags = tags
            } else {
              const parentId = context._parentId
              for (let i = startedSpans.length; --i >= 0; ) {
                const ispan = startedSpans[i]
                if (ispan.context()._spanId === parentId) {
                  webTags = this.#getProfilingContext(ispan).webTags
                  break
                }
              }
            }
          }
          profilingContext = { spanId, rootSpanId, webTags }
          span[ProfilingContext] = profilingContext
        }
        return profilingContext
      }
      #setNewContext() {
        this.#pprof.time.setContext(
          (this._currentContext = {
            ref: {},
          })
        )
      }
      #spanFinished(span) {
        if (span[ProfilingContext] !== void 0) {
          span[ProfilingContext] = void 0
        }
      }
      #reportV8bug(maybeBug) {
        const tag = `v8_profiler_bug_workaround_enabled:${this.#v8ProfilerBugWorkaroundEnabled}`
        const metric = `v8_cpu_profiler${maybeBug ? '_maybe' : ''}_stuck_event_loop`
        this.#logger?.warn(`Wall profiler: ${maybeBug ? 'possible ' : ''}v8 profiler stuck event loop detected.`)
        runtimeMetrics.increment(`runtime.node.profiler.${metric}`, tag, true)
        profilerTelemetryMetrics.count(metric, [tag]).inc()
      }
      #stop(restart) {
        if (!this.#started) return
        if (this.#captureSpanData && !this.#asyncContextFrameEnabled) {
          this.#enter()
          this._lastSampleCount = 0
        }
        const lowCardinalityLabels = Object.keys(getThreadLabels())
        lowCardinalityLabels.push(TRACE_ENDPOINT_LABEL)
        const profile = this.#pprof.time.stop(restart, this.#boundGenerateLabels, lowCardinalityLabels)
        if (restart) {
          const v8BugDetected = this.#pprof.time.v8ProfilerStuckEventLoopDetected()
          if (v8BugDetected !== 0) {
            this.#reportV8bug(v8BugDetected === 1)
          }
        } else {
          clearInterval(this._contextCountGaugeUpdater)
          if (this.#captureSpanData) {
            if (!this.#asyncContextFrameEnabled) {
              beforeCh.unsubscribe(this.#boundEnter)
            }
            enterCh.unsubscribe(this.#boundEnter)
            spanFinishCh.unsubscribe(this.#boundSpanFinished)
            this._profilerState = void 0
          }
          this.#started = false
        }
        return profile
      }
      _generateLabels({ node, context }) {
        if (node.name === this.#pprof.time.constants.NON_JS_THREADS_FUNCTION_NAME) {
          return getNonJSThreadsLabels()
        }
        if (context == null) {
          return getThreadLabels()
        }
        const labels = { ...getThreadLabels() }
        if (this.#timelineEnabled) {
          labels[END_TIMESTAMP_LABEL] = context.timestamp * 1000n
        }
        const asyncId = context.asyncId
        if (asyncId !== void 0 && asyncId !== -1) {
          labels['async id'] = asyncId
        }
        const ref = this.#asyncContextFrameEnabled ? context.context : context.context?.ref
        if (typeof ref !== 'object') {
          return labels
        }
        const { spanId, rootSpanId, webTags, endpoint } = ref
        if (spanId !== void 0) {
          labels[SPAN_ID_LABEL] = toBigInt(spanId)
        }
        if (rootSpanId !== void 0) {
          labels[LOCAL_ROOT_SPAN_ID_LABEL] = toBigInt(rootSpanId)
        }
        if (webTags !== void 0 && Object.keys(webTags).length !== 0) {
          labels[TRACE_ENDPOINT_LABEL] = endpointNameFromTags(webTags)
        } else if (endpoint) {
          labels[TRACE_ENDPOINT_LABEL] = endpoint
        }
        return labels
      }
      profile(restart) {
        return this.#stop(restart)
      }
      getInfo() {
        const { totalAsyncContextCount, usedAsyncContextCount } = this.#pprof.time.getMetrics()
        return {
          totalAsyncContextCount,
          usedAsyncContextCount,
        }
      }
      encode(profile) {
        return encodeProfileAsync(profile)
      }
      stop() {
        this.#stop(false)
      }
      isStarted() {
        return this.#started
      }
    }
    module2.exports = NativeWallProfiler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/constants.js
var require_constants5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/constants.js'(exports2, module2) {
    'use strict'
    var snapshotKinds = Object.freeze({
      PERIODIC: 'periodic',
      ON_SHUTDOWN: 'on_shutdown',
      ON_OUT_OF_MEMORY: 'on_oom',
    })
    var oomExportStrategies = Object.freeze({
      PROCESS: 'process',
      ASYNC_CALLBACK: 'async',
      LOGS: 'logs',
    })
    module2.exports = { snapshotKinds, oomExportStrategies }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/space.js
var require_space = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/space.js'(exports2, module2) {
    'use strict'
    var { oomExportStrategies } = require_constants5()
    var { encodeProfileAsync, getThreadLabels } = require_shared()
    function strategiesToCallbackMode(strategies, callbackMode) {
      return strategies.includes(oomExportStrategies.ASYNC_CALLBACK) ? callbackMode.Async : 0
    }
    var STACK_DEPTH = 64
    var NativeSpaceProfiler = class {
      #mapper
      #oomMonitoring
      #pprof
      #samplingInterval = 512 * 1024
      #started = false
      constructor(options = {}) {
        this.#samplingInterval = options.heapSamplingInterval || 512 * 1024
        this.#oomMonitoring = options.oomMonitoring || {}
      }
      get type() {
        return 'space'
      }
      start({ mapper, nearOOMCallback } = {}) {
        if (this.#started) return
        this.#mapper = mapper
        this.#pprof = require('@datadog/pprof')
        this.#pprof.heap.start(this.#samplingInterval, STACK_DEPTH)
        if (this.#oomMonitoring.enabled) {
          const strategies = this.#oomMonitoring.exportStrategies
          this.#pprof.heap.monitorOutOfMemory(
            this.#oomMonitoring.heapLimitExtensionSize,
            this.#oomMonitoring.maxHeapExtensionCount,
            strategies.includes(oomExportStrategies.LOGS),
            strategies.includes(oomExportStrategies.PROCESS) ? this.#oomMonitoring.exportCommand : [],
            (profile) => nearOOMCallback(this.type, this.#pprof.encodeSync(profile), this.getInfo()),
            strategiesToCallbackMode(strategies, this.#pprof.heap.CallbackMode)
          )
        }
        this.#started = true
      }
      profile(restart) {
        const profile = this.#pprof.heap.profile(void 0, this.#mapper, getThreadLabels)
        if (!restart) {
          this.stop()
        }
        return profile
      }
      getInfo() {
        return {}
      }
      encode(profile) {
        return encodeProfileAsync(profile)
      }
      stop() {
        if (!this.#started) return
        this.#pprof.heap.stop()
        this.#started = false
      }
      isStarted() {
        return this.#started
      }
    }
    module2.exports = NativeSpaceProfiler
  },
})

// node_modules/dd-trace/vendor/dist/pprof-format/index.js
var require_pprof_format = __commonJS({
  'node_modules/dd-trace/vendor/dist/pprof-format/index.js'(exports2, module2) {
    ;(() => {
      'use strict'
      var e,
        t,
        i = {}
      ;((i.d = (e2, t2) => {
        for (var s2 in t2)
          i.o(t2, s2) && !i.o(e2, s2) && Object.defineProperty(e2, s2, { enumerable: true, get: t2[s2] })
      }),
        (i.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2)),
        (i.r = (e2) => {
          ;('undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e2, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(e2, '__esModule', { value: true }))
        }))
      var s = {}
      ;(i.r(s),
        i.d(s, {
          Function: () => A,
          Label: () => L,
          Line: () => U,
          Location: () => V,
          Mapping: () => v,
          Profile: () => P,
          Sample: () => N,
          StringTable: () => I,
          ValueType: () => S,
          emptyTableToken: () => k,
        }))
      var n = function (e2, t2, i2, s2) {
        if ('a' === i2 && !s2) throw TypeError('Private accessor was defined without a getter')
        if ('function' == typeof t2 ? e2 !== t2 || !s2 : !t2.has(e2))
          throw TypeError('Cannot read private member from an object whose class did not declare it')
        return 'm' === i2 ? s2 : 'a' === i2 ? s2.call(e2) : s2 ? s2.value : t2.get(e2)
      }
      let r = 2n ** 32n - 1n,
        a = 4294967296 - 1,
        o = 4294967296 - 1 + 1,
        h = 'undefined' == typeof Buffer ? (e2) => new TextEncoder().encode(e2) : (e2) => Buffer.from(e2, 'utf8')
      function c(e2) {
        if (!e2.length) return 0
        let t2 = 0
        for (; t2 < e2.length && e2[t2++] >= 128; );
        return t2
      }
      function d(e2, t2 = 0) {
        return { value: e2, offset: t2 }
      }
      function u(e2) {
        var t2, i2
        let s2 = e2 < 0
        s2 && (e2 = -e2)
        let n2 = 'bigint' != typeof (t2 = e2) ? (t2 >>> 0) % o : Number(t2 & r),
          h2 = 'bigint' != typeof (i2 = e2) ? (i2 / o) >>> 0 : Number((i2 >> 32n) & r)
        return (s2 && ((h2 = ~h2 >>> 0), (n2 = ~n2 >>> 0), ++n2 > a && ((n2 = 0), ++h2 > a && (h2 = 0))), [h2, n2])
      }
      function l(e2) {
        if (c(e2) > 4) {
          if (!e2.length) return BigInt(0)
          let t3 = BigInt(127 & e2[0]),
            i3 = 0
          for (; e2[i3++] >= 128; ) t3 |= BigInt(127 & e2[i3]) << BigInt(7 * i3)
          return t3
        }
        if (!e2.length) return 0
        let t2 = 127 & e2[0],
          i2 = 0
        for (; e2[i2++] >= 128; ) t2 |= (127 & e2[i2]) << (7 * i2)
        return t2
      }
      function f(e2) {
        let t2 = [],
          i2 = 0
        for (let s2 = 0; s2 < e2.length; s2++) (128 & e2[s2]) == 0 && (t2.push(l(e2.slice(i2, s2 + 1))), (i2 = s2 + 1))
        return t2
      }
      function m(e2, t2) {
        return null == t2 ? [e2] : (t2.push(e2), t2)
      }
      function p(e2) {
        if (0 === e2 || 0n === e2) return 0
        let [t2, i2] = u(e2),
          s2 = ((i2 >>> 28) | (t2 << 4)) >>> 0,
          n2 = t2 >>> 24
        return 0 !== n2
          ? n2 < 128
            ? 9
            : 10
          : 0 !== s2
            ? s2 < 16384
              ? s2 < 128
                ? 5
                : 6
              : s2 < 2097152
                ? 7
                : 8
            : i2 < 16384
              ? i2 < 128
                ? 1
                : 2
              : i2 < 2097152
                ? 3
                : 4
      }
      function g(e2) {
        return void 0 === e2 ? 0 : 'number' == typeof e2 || 'bigint' == typeof e2 ? p(e2) || 1 : e2.length
      }
      function y(e2) {
        let t2 = 0
        for (let i2 of e2) t2 += g(i2)
        return t2
      }
      function T(e2) {
        let t2 = p(e2)
        return t2 ? 1 + t2 : 0
      }
      function b(e2) {
        let t2 = 0
        for (let i2 of e2) t2 += p(i2) || 1
        return t2 ? 1 + p(t2) + t2 : 0
      }
      function w(e2) {
        let t2 = g(e2)
        return t2 ? 1 + p(t2) + t2 : 0
      }
      function B(e2) {
        let t2 = 0
        for (let i2 of e2) t2 += w(i2)
        return t2
      }
      function _(e2, t2, i2) {
        if (0 === i2 || 0n === i2) return ((e2[t2++] = 0), t2)
        let [s2, n2] = u(i2)
        for (; s2; ) ((e2[t2++] = (127 & n2) | 128), (n2 = ((n2 >>> 7) | (s2 << 25)) >>> 0), (s2 >>>= 7))
        for (; n2 > 127; ) ((e2[t2++] = (127 & n2) | 128), (n2 >>>= 7))
        return ((e2[t2++] = n2), t2)
      }
      let k = /* @__PURE__ */ Symbol()
      class I {
        constructor(i2) {
          ;((this.strings = []), e.set(this, []), t.set(this, /* @__PURE__ */ new Map()), i2 !== k && this.dedup(''))
        }
        get encodedLength() {
          let t2 = 0
          for (let i2 of n(this, e, 'f')) t2 += i2.length
          return t2
        }
        _encodeToBuffer(t2, i2) {
          for (let s2 of n(this, e, 'f')) (t2.set(s2, i2), (i2 += s2.length))
          return i2
        }
        encode(e2 = new Uint8Array(this.encodedLength)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static _encodeStringFromUtf8(e2) {
          let t2 = new Uint8Array(1 + e2.length + (p(e2.length) || 1)),
            i2 = 0
          return ((t2[i2++] = 50), (i2 = _(t2, i2, e2.length)), e2.length > 0 && t2.set(e2, i2++), t2)
        }
        static _encodeString(e2) {
          return I._encodeStringFromUtf8(h(e2))
        }
        dedup(i2) {
          if ('number' == typeof i2) return i2
          if (!n(this, t, 'f').has(i2)) {
            let s2 = this.strings.push(i2) - 1
            ;(n(this, t, 'f').set(i2, s2), n(this, e, 'f').push(I._encodeString(i2)))
          }
          return n(this, t, 'f').get(i2)
        }
        _decodeString(i2) {
          let s2 = new TextDecoder().decode(i2)
          ;(n(this, t, 'f').set(s2, this.strings.push(s2) - 1), n(this, e, 'f').push(I._encodeStringFromUtf8(i2)))
        }
      }
      function F(e2, t2) {
        let i2 = {},
          s2 = 0
        for (; s2 < e2.length; ) {
          let n2 = e2[s2] >> 3,
            r2 = 7 & e2[s2]
          s2++
          let { offset: a2, value: o2 } = (function (e3, t3) {
            switch (e3) {
              case 0:
                for (let e4 = 0; e4 < t3.length; e4++) if (!(128 & t3[e4])) return d(t3.slice(0, e4 + 1))
                return d(t3)
              case 2: {
                let e4 = c(t3),
                  i3 = l(t3)
                return d(t3.slice(e4, Number(i3) + e4), e4)
              }
              default:
                throw Error(`Unrecognized value type: ${e3}`)
            }
          })(r2, e2.slice(s2))
          ;((s2 += o2.length + a2), t2(i2, n2, o2))
        }
        return i2
      }
      ;((e = /* @__PURE__ */ new WeakMap()), (t = /* @__PURE__ */ new WeakMap()))
      class S {
        static create(e2) {
          return e2 instanceof S ? e2 : new S(e2)
        }
        constructor(e2) {
          ;((this.type = e2.type || 0), (this.unit = e2.unit || 0))
        }
        get length() {
          return 0 + T(this.type) + T(this.unit)
        }
        _encodeToBuffer(e2, t2 = 0) {
          return (
            this.type && ((e2[t2++] = 8), (t2 = _(e2, t2, this.type))),
            this.unit && ((e2[t2++] = 16), (t2 = _(e2, t2, this.unit))),
            t2
          )
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.type = l(i2)
              break
            case 2:
              e2.unit = l(i2)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      class L {
        static create(e2) {
          return e2 instanceof L ? e2 : new L(e2)
        }
        constructor(e2) {
          ;((this.key = e2.key || 0),
            (this.str = e2.str || 0),
            (this.num = e2.num || 0),
            (this.numUnit = e2.numUnit || 0))
        }
        get length() {
          return 0 + T(this.key) + T(this.str) + T(this.num) + T(this.numUnit)
        }
        _encodeToBuffer(e2, t2 = 0) {
          return (
            this.key && ((e2[t2++] = 8), (t2 = _(e2, t2, this.key))),
            this.str && ((e2[t2++] = 16), (t2 = _(e2, t2, this.str))),
            this.num && ((e2[t2++] = 24), (t2 = _(e2, t2, this.num))),
            this.numUnit && ((e2[t2++] = 32), (t2 = _(e2, t2, this.numUnit))),
            t2
          )
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.key = l(i2)
              break
            case 2:
              e2.str = l(i2)
              break
            case 3:
              e2.num = l(i2)
              break
            case 4:
              e2.numUnit = l(i2)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      class N {
        static create(e2) {
          return e2 instanceof N ? e2 : new N(e2)
        }
        constructor(e2) {
          ;((this.locationId = e2.locationId || []),
            (this.value = e2.value || []),
            (this.label = (e2.label || []).map(L.create)))
        }
        get length() {
          return 0 + b(this.locationId) + b(this.value) + B(this.label)
        }
        _encodeToBuffer(e2, t2 = 0) {
          if (this.locationId.length)
            for (let i2 of ((e2[t2++] = 10), (t2 = _(e2, t2, y(this.locationId))), this.locationId)) t2 = _(e2, t2, i2)
          if (this.value.length)
            for (let i2 of ((e2[t2++] = 18), (t2 = _(e2, t2, y(this.value))), this.value)) t2 = _(e2, t2, i2)
          for (let i2 of this.label) ((e2[t2++] = 26), (t2 = _(e2, t2, i2.length)), (t2 = i2._encodeToBuffer(e2, t2)))
          return t2
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.locationId = f(i2)
              break
            case 2:
              e2.value = f(i2)
              break
            case 3:
              e2.label = m(L.decode(i2), e2.label)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      class v {
        static create(e2) {
          return e2 instanceof v ? e2 : new v(e2)
        }
        constructor(e2) {
          ;((this.id = e2.id || 0),
            (this.memoryStart = e2.memoryStart || 0),
            (this.memoryLimit = e2.memoryLimit || 0),
            (this.fileOffset = e2.fileOffset || 0),
            (this.filename = e2.filename || 0),
            (this.buildId = e2.buildId || 0),
            (this.hasFunctions = !!e2.hasFunctions),
            (this.hasFilenames = !!e2.hasFilenames),
            (this.hasLineNumbers = !!e2.hasLineNumbers),
            (this.hasInlineFrames = !!e2.hasInlineFrames))
        }
        get length() {
          return (
            0 +
            T(this.id) +
            T(this.memoryStart) +
            T(this.memoryLimit) +
            T(this.fileOffset) +
            T(this.filename) +
            T(this.buildId) +
            T(+!!this.hasFunctions) +
            T(+!!this.hasFilenames) +
            T(+!!this.hasLineNumbers) +
            T(+!!this.hasInlineFrames)
          )
        }
        _encodeToBuffer(e2, t2 = 0) {
          return (
            this.id && ((e2[t2++] = 8), (t2 = _(e2, t2, this.id))),
            this.memoryStart && ((e2[t2++] = 16), (t2 = _(e2, t2, this.memoryStart))),
            this.memoryLimit && ((e2[t2++] = 24), (t2 = _(e2, t2, this.memoryLimit))),
            this.fileOffset && ((e2[t2++] = 32), (t2 = _(e2, t2, this.fileOffset))),
            this.filename && ((e2[t2++] = 40), (t2 = _(e2, t2, this.filename))),
            this.buildId && ((e2[t2++] = 48), (t2 = _(e2, t2, this.buildId))),
            this.hasFunctions && ((e2[t2++] = 56), (t2 = _(e2, t2, 1))),
            this.hasFilenames && ((e2[t2++] = 64), (t2 = _(e2, t2, 1))),
            this.hasLineNumbers && ((e2[t2++] = 72), (t2 = _(e2, t2, 1))),
            this.hasInlineFrames && ((e2[t2++] = 80), (t2 = _(e2, t2, 1))),
            t2
          )
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.id = l(i2)
              break
            case 2:
              e2.memoryStart = l(i2)
              break
            case 3:
              e2.memoryLimit = l(i2)
              break
            case 4:
              e2.fileOffset = l(i2)
              break
            case 5:
              e2.filename = l(i2)
              break
            case 6:
              e2.buildId = l(i2)
              break
            case 7:
              e2.hasFunctions = !!l(i2)
              break
            case 8:
              e2.hasFilenames = !!l(i2)
              break
            case 9:
              e2.hasLineNumbers = !!l(i2)
              break
            case 10:
              e2.hasInlineFrames = !!l(i2)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      class U {
        static create(e2) {
          return e2 instanceof U ? e2 : new U(e2)
        }
        constructor(e2) {
          ;((this.functionId = e2.functionId || 0), (this.line = e2.line || 0))
        }
        get length() {
          return 0 + T(this.functionId) + T(this.line)
        }
        _encodeToBuffer(e2, t2 = 0) {
          return (
            this.functionId && ((e2[t2++] = 8), (t2 = _(e2, t2, this.functionId))),
            this.line && ((e2[t2++] = 16), (t2 = _(e2, t2, this.line))),
            t2
          )
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.functionId = l(i2)
              break
            case 2:
              e2.line = l(i2)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      class V {
        static create(e2) {
          return e2 instanceof V ? e2 : new V(e2)
        }
        constructor(e2) {
          ;((this.id = e2.id || 0),
            (this.mappingId = e2.mappingId || 0),
            (this.address = e2.address || 0),
            (this.line = (e2.line || []).map(U.create)),
            (this.isFolded = !!e2.isFolded))
        }
        get length() {
          return 0 + T(this.id) + T(this.mappingId) + T(this.address) + B(this.line) + T(+!!this.isFolded)
        }
        _encodeToBuffer(e2, t2 = 0) {
          for (let i2 of (this.id && ((e2[t2++] = 8), (t2 = _(e2, t2, this.id))),
          this.mappingId && ((e2[t2++] = 16), (t2 = _(e2, t2, this.mappingId))),
          this.address && ((e2[t2++] = 24), (t2 = _(e2, t2, this.address))),
          this.line))
            ((e2[t2++] = 34), (t2 = _(e2, t2, i2.length)), (t2 = i2._encodeToBuffer(e2, t2)))
          return (this.isFolded && ((e2[t2++] = 40), (t2 = _(e2, t2, 1))), t2)
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.id = l(i2)
              break
            case 2:
              e2.mappingId = l(i2)
              break
            case 3:
              e2.address = l(i2)
              break
            case 4:
              e2.line = m(U.decode(i2), e2.line)
              break
            case 5:
              e2.isFolded = !!l(i2)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      class A {
        static create(e2) {
          return e2 instanceof A ? e2 : new A(e2)
        }
        constructor(e2) {
          ;((this.id = e2.id || 0),
            (this.name = e2.name || 0),
            (this.systemName = e2.systemName || 0),
            (this.filename = e2.filename || 0),
            (this.startLine = e2.startLine || 0))
        }
        get length() {
          return 0 + T(this.id) + T(this.name) + T(this.systemName) + T(this.filename) + T(this.startLine)
        }
        _encodeToBuffer(e2, t2 = 0) {
          return (
            this.id && ((e2[t2++] = 8), (t2 = _(e2, t2, this.id))),
            this.name && ((e2[t2++] = 16), (t2 = _(e2, t2, this.name))),
            this.systemName && ((e2[t2++] = 24), (t2 = _(e2, t2, this.systemName))),
            this.filename && ((e2[t2++] = 32), (t2 = _(e2, t2, this.filename))),
            this.startLine && ((e2[t2++] = 40), (t2 = _(e2, t2, this.startLine))),
            t2
          )
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.id = l(i2)
              break
            case 2:
              e2.name = l(i2)
              break
            case 3:
              e2.systemName = l(i2)
              break
            case 4:
              e2.filename = l(i2)
              break
            case 5:
              e2.startLine = l(i2)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      class P {
        constructor(e2 = {}) {
          ;((this.sampleType = (e2.sampleType || []).map(S.create)),
            (this.sample = (e2.sample || []).map(N.create)),
            (this.mapping = (e2.mapping || []).map(v.create)),
            (this.location = (e2.location || []).map(V.create)),
            (this.function = (e2.function || []).map(A.create)),
            (this.stringTable = e2.stringTable || new I()),
            (this.dropFrames = e2.dropFrames || 0),
            (this.keepFrames = e2.keepFrames || 0),
            (this.timeNanos = e2.timeNanos || 0),
            (this.durationNanos = e2.durationNanos || 0),
            (this.periodType = e2.periodType ? S.create(e2.periodType) : void 0),
            (this.period = e2.period || 0),
            (this.comment = e2.comment || []),
            (this.defaultSampleType = e2.defaultSampleType || 0))
        }
        get length() {
          return (
            0 +
            B(this.sampleType) +
            B(this.sample) +
            B(this.mapping) +
            B(this.location) +
            B(this.function) +
            this.stringTable.encodedLength +
            T(this.dropFrames) +
            T(this.keepFrames) +
            T(this.timeNanos) +
            T(this.durationNanos) +
            w(this.periodType) +
            T(this.period) +
            b(this.comment) +
            T(this.defaultSampleType)
          )
        }
        _encodeSampleTypesToBuffer(e2, t2 = 0) {
          for (let i2 of this.sampleType)
            ((e2[t2++] = 10), (t2 = _(e2, t2, i2.length)), (t2 = i2._encodeToBuffer(e2, t2)))
          return t2
        }
        _encodeSamplesToBuffer(e2, t2 = 0) {
          for (let i2 of this.sample) ((e2[t2++] = 18), (t2 = _(e2, t2, i2.length)), (t2 = i2._encodeToBuffer(e2, t2)))
          return t2
        }
        _encodeMappingsToBuffer(e2, t2 = 0) {
          for (let i2 of this.mapping) ((e2[t2++] = 26), (t2 = _(e2, t2, i2.length)), (t2 = i2._encodeToBuffer(e2, t2)))
          return t2
        }
        _encodeLocationsToBuffer(e2, t2 = 0) {
          for (let i2 of this.location)
            ((e2[t2++] = 34), (t2 = _(e2, t2, i2.length)), (t2 = i2._encodeToBuffer(e2, t2)))
          return t2
        }
        _encodeFunctionsToBuffer(e2, t2 = 0) {
          for (let i2 of this.function)
            ((e2[t2++] = 42), (t2 = _(e2, t2, i2.length)), (t2 = i2._encodeToBuffer(e2, t2)))
          return t2
        }
        _encodeBasicValuesToBuffer(e2, t2 = 0) {
          if (
            (this.dropFrames && ((e2[t2++] = 56), (t2 = _(e2, t2, this.dropFrames))),
            this.keepFrames && ((e2[t2++] = 64), (t2 = _(e2, t2, this.keepFrames))),
            this.timeNanos && ((e2[t2++] = 72), (t2 = _(e2, t2, this.timeNanos))),
            this.durationNanos && ((e2[t2++] = 80), (t2 = _(e2, t2, this.durationNanos))),
            void 0 !== this.periodType &&
              ((e2[t2++] = 90),
              (t2 = _(e2, t2, this.periodType.length)),
              (t2 = this.periodType._encodeToBuffer(e2, t2))),
            this.period && ((e2[t2++] = 96), (t2 = _(e2, t2, this.period))),
            this.comment.length)
          )
            for (let i2 of ((e2[t2++] = 106), (t2 = _(e2, t2, y(this.comment))), this.comment)) t2 = _(e2, t2, i2)
          return (this.defaultSampleType && ((e2[t2++] = 112), (t2 = _(e2, t2, this.defaultSampleType))), t2)
        }
        _encodeToBuffer(e2, t2 = 0) {
          return (
            (t2 = this._encodeSampleTypesToBuffer(e2, t2)),
            (t2 = this._encodeSamplesToBuffer(e2, t2)),
            (t2 = this._encodeMappingsToBuffer(e2, t2)),
            (t2 = this._encodeLocationsToBuffer(e2, t2)),
            (t2 = this._encodeFunctionsToBuffer(e2, t2)),
            (t2 = this.stringTable._encodeToBuffer(e2, t2)),
            (t2 = this._encodeBasicValuesToBuffer(e2, t2))
          )
        }
        async _encodeToBufferAsync(e2, t2 = 0) {
          return (
            (t2 = this._encodeSampleTypesToBuffer(e2, t2)),
            await new Promise(setImmediate),
            (t2 = this._encodeSamplesToBuffer(e2, t2)),
            await new Promise(setImmediate),
            (t2 = this._encodeMappingsToBuffer(e2, t2)),
            await new Promise(setImmediate),
            (t2 = this._encodeLocationsToBuffer(e2, t2)),
            await new Promise(setImmediate),
            (t2 = this._encodeFunctionsToBuffer(e2, t2)),
            await new Promise(setImmediate),
            (t2 = this.stringTable._encodeToBuffer(e2, t2)),
            await new Promise(setImmediate),
            (t2 = this._encodeBasicValuesToBuffer(e2, t2))
          )
        }
        encode(e2 = new Uint8Array(this.length)) {
          return (this._encodeToBuffer(e2, 0), e2)
        }
        async encodeAsync(e2 = new Uint8Array(this.length)) {
          return (await this._encodeToBufferAsync(e2, 0), e2)
        }
        static decodeValue(e2, t2, i2) {
          switch (t2) {
            case 1:
              e2.sampleType = m(S.decode(i2), e2.sampleType)
              break
            case 2:
              e2.sample = m(N.decode(i2), e2.sample)
              break
            case 3:
              e2.mapping = m(v.decode(i2), e2.mapping)
              break
            case 4:
              e2.location = m(V.decode(i2), e2.location)
              break
            case 5:
              e2.function = m(A.decode(i2), e2.function)
              break
            case 6:
              ;(void 0 === e2.stringTable && (e2.stringTable = new I(k)), e2.stringTable._decodeString(i2))
              break
            case 7:
              e2.dropFrames = l(i2)
              break
            case 8:
              e2.keepFrames = l(i2)
              break
            case 9:
              e2.timeNanos = l(i2)
              break
            case 10:
              e2.durationNanos = l(i2)
              break
            case 11:
              e2.periodType = S.decode(i2)
              break
            case 12:
              e2.period = l(i2)
              break
            case 13:
              e2.comment = f(i2)
              break
            case 14:
              e2.defaultSampleType = l(i2)
          }
        }
        static decode(e2) {
          return new this(F(e2, this.decodeValue))
        }
      }
      module2.exports = s
    })()
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/poisson.js
var require_poisson = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/poisson.js'(exports2, module2) {
    'use strict'
    var PoissonProcessSamplingFilter = class {
      #currentSamplingInstant = 0
      #nextSamplingInstant
      #samplingInterval
      #resetInterval
      #now
      #lastNow = Number.NEGATIVE_INFINITY
      #samplingInstantCount = 0
      constructor({ samplingInterval, now, resetInterval }) {
        if (samplingInterval <= 0) {
          throw new RangeError(`samplingInterval (${samplingInterval}) must be greater than 0`)
        }
        if (resetInterval < samplingInterval) {
          throw new RangeError(
            `resetInterval (${resetInterval}) must be greater than samplingInterval (${samplingInterval})`
          )
        }
        if (typeof now !== 'function') {
          throw new TypeError('now must be a function')
        }
        this.#samplingInterval = samplingInterval
        this.#resetInterval = resetInterval
        this.#now = now
        this.#nextSamplingInstant = this.#callNow()
        this.#setNextSamplingInstant()
      }
      get currentSamplingInstant() {
        return this.#currentSamplingInstant
      }
      get nextSamplingInstant() {
        return this.#nextSamplingInstant
      }
      get samplingInstantCount() {
        return this.#samplingInstantCount
      }
      #callNow() {
        const nowValue = this.#now()
        if (typeof nowValue !== 'number') {
          throw new TypeError('now() must return a number')
        }
        if (nowValue < this.#lastNow) {
          throw new RangeError('now() must return a value greater than or equal to the last returned value')
        }
        this.#lastNow = nowValue
        return nowValue
      }
      filter(event) {
        const endTime = event.startTime + event.duration
        if (endTime >= this.#nextSamplingInstant) {
          const cappedEndTime = Math.min(endTime, this.#callNow())
          const earliestContinuousPast = cappedEndTime - this.#resetInterval
          if (this.#nextSamplingInstant < earliestContinuousPast) {
            this.#nextSamplingInstant = earliestContinuousPast
          }
          while (cappedEndTime >= this.#nextSamplingInstant) {
            this.#setNextSamplingInstant()
          }
        }
        return event.startTime < this.#currentSamplingInstant
      }
      #setNextSamplingInstant() {
        this.#currentSamplingInstant = this.#nextSamplingInstant
        this.#nextSamplingInstant -= Math.log(1 - Math.random()) * this.#samplingInterval
        this.#samplingInstantCount++
      }
    }
    module2.exports = PoissonProcessSamplingFilter
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/event.js
var require_event = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/event.js'(exports2, module2) {
    'use strict'
    var TracingPlugin = require_tracing()
    var { performance: performance2 } = require('perf_hooks')
    var EventPlugin = class extends TracingPlugin {
      #eventHandler
      #eventFilter
      #dataSymbol
      #entryType
      constructor(eventHandler, eventFilter) {
        super()
        this.#eventHandler = eventHandler
        this.#eventFilter = eventFilter
        this.#entryType = this.constructor.entryType
        this.#dataSymbol = /* @__PURE__ */ Symbol(
          `dd-trace.profiling.event.${this.#entryType}.${this.constructor.operation}`
        )
      }
      start(ctx) {
        ctx[this.#dataSymbol] = performance2.now()
      }
      error(ctx) {
        ctx[this.#dataSymbol] = void 0
      }
      finish(ctx) {
        const startTime = ctx[this.#dataSymbol]
        if (startTime === void 0) {
          return
        }
        ctx[this.#dataSymbol] = void 0
        if (this.ignoreEvent(ctx)) {
          return
        }
        const duration = performance2.now() - startTime
        const event = {
          entryType: this.#entryType,
          startTime,
          duration,
        }
        if (!this.#eventFilter(event)) {
          return
        }
        const context = (ctx.currentStore?.span || this.activeSpan)?.context()
        event._ddSpanId = context?.toBigIntSpanId()
        event._ddRootSpanId = context?._trace.started[0]?.context().toBigIntSpanId() || event._ddSpanId
        this.#eventHandler(this.extendEvent(event, ctx))
      }
      ignoreEvent() {
        return false
      }
    }
    module2.exports = EventPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns.js
var require_dns2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns.js'(exports2, module2) {
    'use strict'
    var EventPlugin = require_event()
    var DNSPlugin = class extends EventPlugin {
      static id = 'dns'
      static entryType = 'dns'
    }
    module2.exports = DNSPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookup.js
var require_dns_lookup = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookup.js'(exports2, module2) {
    'use strict'
    var DNSPlugin = require_dns2()
    var DNSLookupPlugin = class extends DNSPlugin {
      static operation = 'lookup'
      extendEvent(event, startEvent) {
        event.name = 'lookup'
        event.detail = { hostname: startEvent.args[0] }
        return event
      }
    }
    module2.exports = DNSLookupPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookupservice.js
var require_dns_lookupservice = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookupservice.js'(
    exports2,
    module2
  ) {
    'use strict'
    var DNSPlugin = require_dns2()
    var DNSLookupServicePlugin = class extends DNSPlugin {
      static operation = 'lookup_service'
      extendEvent(event, startEvent) {
        event.name = 'lookupService'
        event.detail = { host: startEvent.args[0], port: startEvent.args[1] }
        return event
      }
    }
    module2.exports = DNSLookupServicePlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_resolve.js
var require_dns_resolve = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_resolve.js'(exports2, module2) {
    'use strict'
    var DNSPlugin = require_dns2()
    var queryNames = /* @__PURE__ */ new Map()
    var DNSResolvePlugin = class extends DNSPlugin {
      static operation = 'resolve'
      extendEvent(event, startEvent) {
        const rrtype = startEvent.args[1]
        let name = queryNames.get(rrtype)
        if (!name) {
          name = `query${rrtype}`
          queryNames.set(rrtype, name)
        }
        event.name = name
        event.detail = { host: startEvent.args[0] }
        return event
      }
    }
    module2.exports = DNSResolvePlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_reverse.js
var require_dns_reverse = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/dns_reverse.js'(exports2, module2) {
    'use strict'
    var DNSPlugin = require_dns2()
    var DNSReversePlugin = class extends DNSPlugin {
      static operation = 'reverse'
      extendEvent(event, startEvent) {
        event.name = 'getHostByAddr'
        event.detail = { host: startEvent.args[0] }
        return event
      }
    }
    module2.exports = DNSReversePlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/fs.js
var require_fs2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/fs.js'(exports2, module2) {
    'use strict'
    var EventPlugin = require_event()
    var allowedParams = /* @__PURE__ */ new Set([
      'atime',
      'dest',
      'existingPath',
      'fd',
      'file',
      'flag',
      'gid',
      'len',
      'length',
      'mode',
      'mtime',
      'newPath',
      'offset',
      'oldPath',
      'operation',
      'options',
      'path',
      'position',
      'prefix',
      'src',
      'target',
      'type',
      'uid',
    ])
    var FilesystemPlugin = class extends EventPlugin {
      static id = 'fs'
      static operation = 'operation'
      static entryType = 'fs'
      ignoreEvent(event) {
        return event.operation?.endsWith('Sync')
      }
      extendEvent(event, detail) {
        const d = { ...detail }
        Object.entries(d).forEach(([k, v]) => {
          if (!(allowedParams.has(k) && (typeof v === 'string' || typeof v === 'number'))) {
            delete d[k]
          }
        })
        event.detail = d
        return event
      }
    }
    module2.exports = FilesystemPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/net.js
var require_net2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/event_plugins/net.js'(exports2, module2) {
    'use strict'
    var EventPlugin = require_event()
    var NetPlugin = class extends EventPlugin {
      static id = 'net'
      static operation = 'tcp'
      static entryType = 'net'
      extendEvent(event, { options }) {
        event.name = 'connect'
        event.detail = options
        return event
      }
    }
    module2.exports = NetPlugin
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/events.js
var require_events = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/events.js'(exports2, module2) {
    'use strict'
    var { performance: performance2, constants, PerformanceObserver } = require('perf_hooks')
    var { END_TIMESTAMP_LABEL, SPAN_ID_LABEL, LOCAL_ROOT_SPAN_ID_LABEL, encodeProfileAsync } = require_shared()
    var { Function: Function2, Label, Line, Location, Profile, Sample, StringTable, ValueType } = require_pprof_format()
    var PoissonProcessSamplingFilter = require_poisson()
    var { availableParallelism, effectiveLibuvThreadCount } = require_libuv_size()
    var MS_TO_NS = 1e6
    var POISSON_RESET_FACTOR = 2
    var pprofValueType = 'timeline'
    var pprofValueUnit = 'nanoseconds'
    var dateOffset = BigInt(Math.round(performance2.timeOrigin * MS_TO_NS))
    function labelFromStr(stringTable, key, valStr) {
      return new Label({ key, str: stringTable.dedup(safeToString(valStr)) })
    }
    function safeToString(val) {
      switch (typeof val) {
        case 'string':
          return val
        case 'object':
          return '[object]'
        case 'function':
          return '[function]'
        default:
          return String(val)
      }
    }
    function labelFromStrStr(stringTable, keyStr, valStr) {
      return labelFromStr(stringTable, stringTable.dedup(keyStr), valStr)
    }
    function getMaxSamples(options) {
      const flushInterval = options.flushInterval || 65 * 1e3
      const maxCpuSamples = flushInterval / options.samplingInterval
      const factor = Math.max(1, Math.min(availableParallelism(), effectiveLibuvThreadCount)) + 2
      return Math.min(1e5, Math.floor(maxCpuSamples * factor))
    }
    var GCDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable
        this.reasonLabelKey = stringTable.dedup('gc reason')
        this.kindLabels = []
        this.reasonLabels = []
        this.flagObj = {}
        const kindLabelKey = stringTable.dedup('gc type')
        for (const [key, value] of Object.entries(constants)) {
          if (key.startsWith('NODE_PERFORMANCE_GC_FLAGS_')) {
            this.flagObj[key.slice(26).toLowerCase()] = value
          } else if (key.startsWith('NODE_PERFORMANCE_GC_')) {
            const kind = key.slice(20).toLowerCase()
            this.kindLabels[value] = labelFromStr(stringTable, kindLabelKey, kind)
          }
        }
      }
      decorateSample(sampleInput, item) {
        const { kind, flags } = item.detail
        sampleInput.label.push(this.kindLabels[kind])
        const reasonLabel = this.getReasonLabel(flags)
        if (reasonLabel) {
          sampleInput.label.push(reasonLabel)
        }
      }
      getReasonLabel(flags) {
        if (flags === 0) {
          return null
        }
        let reasonLabel = this.reasonLabels[flags]
        if (!reasonLabel) {
          const reasons = []
          for (const [key, value] of Object.entries(this.flagObj)) {
            if (value & flags) {
              reasons.push(key)
            }
          }
          const reasonStr = reasons.join(',')
          reasonLabel = labelFromStr(this.stringTable, this.reasonLabelKey, reasonStr)
          this.reasonLabels[flags] = reasonLabel
        }
        return reasonLabel
      }
    }
    var DNSDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable
        this.operationNameLabelKey = stringTable.dedup('operation')
        this.hostLabelKey = stringTable.dedup('host')
        this.addressLabelKey = stringTable.dedup('address')
        this.portLabelKey = stringTable.dedup('port')
      }
      decorateSample(sampleInput, item) {
        const labels = sampleInput.label
        const stringTable = this.stringTable
        function addLabel(labelNameKey, labelValue) {
          labels.push(labelFromStr(stringTable, labelNameKey, labelValue))
        }
        const op = item.name
        addLabel(this.operationNameLabelKey, item.name)
        const detail = item.detail
        switch (op) {
          case 'lookup':
            addLabel(this.hostLabelKey, detail.hostname)
            break
          case 'lookupService':
            addLabel(this.addressLabelKey, detail.host)
            labels.push(new Label({ key: this.portLabelKey, num: detail.port }))
            break
          case 'getHostByAddr':
            addLabel(this.addressLabelKey, detail.host)
            break
          default:
            if (op.startsWith('query')) {
              addLabel(this.hostLabelKey, detail.host)
            }
        }
      }
    }
    var NetDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable
        this.operationNameLabelKey = stringTable.dedup('operation')
        this.hostLabelKey = stringTable.dedup('host')
        this.portLabelKey = stringTable.dedup('port')
      }
      decorateSample(sampleInput, item) {
        const labels = sampleInput.label
        const stringTable = this.stringTable
        function addLabel(labelNameKey, labelValue) {
          labels.push(labelFromStr(stringTable, labelNameKey, labelValue))
        }
        const op = item.name
        addLabel(this.operationNameLabelKey, op)
        if (op === 'connect') {
          const detail = item.detail
          addLabel(this.hostLabelKey, detail.host)
          labels.push(new Label({ key: this.portLabelKey, num: detail.port }))
        }
      }
    }
    var FilesystemDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable
      }
      decorateSample(sampleInput, item) {
        const labels = sampleInput.label
        const stringTable = this.stringTable
        Object.entries(item.detail).forEach(([k, v]) => {
          switch (typeof v) {
            case 'string':
              labels.push(labelFromStrStr(stringTable, k, v))
              break
            case 'number':
              labels.push(new Label({ key: stringTable.dedup(k), num: v }))
          }
        })
      }
    }
    var decoratorTypes = {
      fs: FilesystemDecorator,
      dns: DNSDecorator,
      gc: GCDecorator,
      net: NetDecorator,
    }
    var EventSerializer = class {
      #sampleCount = 0
      constructor(maxSamples) {
        this.stringTable = new StringTable()
        this.samples = []
        this.locations = []
        this.functions = []
        this.decorators = {}
        this.maxSamples = maxSamples
        const fn = new Function2({ id: this.functions.length + 1, name: this.stringTable.dedup('') })
        this.functions.push(fn)
        const line = new Line({ functionId: fn.id })
        const location = new Location({ id: this.locations.length + 1, line: [line] })
        this.locations.push(location)
        this.locationId = [location.id]
        this.timestampLabelKey = this.stringTable.dedup(END_TIMESTAMP_LABEL)
        this.spanIdKey = this.stringTable.dedup(SPAN_ID_LABEL)
        this.rootSpanIdKey = this.stringTable.dedup(LOCAL_ROOT_SPAN_ID_LABEL)
      }
      addEvent(item) {
        if (this.samples.length < this.maxSamples) {
          const sample = this.#createSample(item)
          if (sample !== void 0) {
            this.samples.push(sample)
            this.#sampleCount++
          }
        } else {
          this.#sampleCount++
          const replacementIndex = Math.floor(Math.random() * this.#sampleCount)
          if (replacementIndex < this.maxSamples) {
            const sample = this.#createSample(item)
            if (sample === void 0) {
              this.#sampleCount--
            } else {
              this.samples[replacementIndex] = sample
            }
          }
        }
      }
      #createSample(item) {
        const { entryType, startTime, duration, _ddSpanId, _ddRootSpanId } = item
        let decorator = this.decorators[entryType]
        if (!decorator) {
          const DecoratorCtor = decoratorTypes[entryType]
          if (DecoratorCtor) {
            decorator = new DecoratorCtor(this.stringTable)
            decorator.eventTypeLabel = labelFromStrStr(this.stringTable, 'event', entryType)
            this.decorators[entryType] = decorator
          } else {
            return
          }
        }
        const endTime = startTime + duration
        const label = [
          decorator.eventTypeLabel,
          new Label({ key: this.timestampLabelKey, num: dateOffset + BigInt(Math.round(endTime * MS_TO_NS)) }),
        ]
        if (_ddSpanId) {
          label.push(new Label({ key: this.spanIdKey, num: _ddSpanId }))
        }
        if (_ddRootSpanId) {
          label.push(new Label({ key: this.rootSpanIdKey, num: _ddRootSpanId }))
        }
        const sampleInput = {
          value: [Math.round(duration * MS_TO_NS)],
          locationId: this.locationId,
          label,
        }
        decorator.decorateSample(sampleInput, item)
        return new Sample(sampleInput)
      }
      createProfile(startDate, endDate) {
        const timeValueType = new ValueType({
          type: this.stringTable.dedup(pprofValueType),
          unit: this.stringTable.dedup(pprofValueUnit),
        })
        return new Profile({
          sampleType: [timeValueType],
          timeNanos: endDate.getTime() * MS_TO_NS,
          periodType: timeValueType,
          period: 1,
          durationNanos: (endDate.getTime() - startDate.getTime()) * MS_TO_NS,
          sample: this.samples,
          location: this.locations,
          function: this.functions,
          stringTable: this.stringTable,
        })
      }
    }
    function add(items) {
      for (const item of items.getEntries()) {
        this.eventHandler(item)
      }
    }
    var NodeApiEventSource = class {
      constructor(eventHandler, entryTypes) {
        this.eventHandler = eventHandler
        this.observer = void 0
        this.entryTypes = entryTypes || Object.keys(decoratorTypes)
      }
      start() {
        if (this.observer) return
        this.observer = new PerformanceObserver(add.bind(this))
        this.observer.observe({ entryTypes: this.entryTypes })
      }
      stop() {
        if (this.observer) {
          this.observer.disconnect()
          this.observer = void 0
        }
      }
    }
    var DatadogInstrumentationEventSource = class {
      constructor(eventHandler, eventFilter) {
        const plugins = [
          require_dns_lookup(),
          require_dns_lookupservice(),
          require_dns_resolve(),
          require_dns_reverse(),
          require_fs2(),
          require_net2(),
        ]
        this.plugins = plugins.map((Plugin) => {
          return new Plugin(eventHandler, eventFilter)
        })
        this.started = false
      }
      start() {
        if (!this.started) {
          this.plugins.forEach((p) => p.configure({ enabled: true }))
          this.started = true
        }
      }
      stop() {
        if (this.started) {
          this.plugins.forEach((p) => p.configure({ enabled: false }))
          this.started = false
        }
      }
    }
    function createPoissonProcessSamplingFilter(samplingIntervalMillis) {
      const poissonFilter = new PoissonProcessSamplingFilter({
        samplingInterval: samplingIntervalMillis,
        resetInterval: samplingIntervalMillis * POISSON_RESET_FACTOR,
        now: performance2.now.bind(performance2),
      })
      return poissonFilter.filter.bind(poissonFilter)
    }
    var EventsProfiler = class {
      #maxSamples = 0
      #timelineSamplingEnabled = false
      #eventSerializer
      #eventSources
      get type() {
        return 'events'
      }
      constructor(options = {}) {
        this.#maxSamples = getMaxSamples(options)
        this.#timelineSamplingEnabled = !!options.timelineSamplingEnabled
        this.#eventSerializer = new EventSerializer(this.#maxSamples)
        const eventHandler = (event) => this.#eventSerializer.addEvent(event)
        const eventFilter = this.#timelineSamplingEnabled
          ? createPoissonProcessSamplingFilter(options.samplingInterval)
          : () => true
        const filteringEventHandler = (event) => {
          if (eventFilter(event)) {
            eventHandler(event)
          }
        }
        this.#eventSources = options.codeHotspotsEnabled
          ? [
              new DatadogInstrumentationEventSource(eventHandler, eventFilter),
              new NodeApiEventSource(filteringEventHandler, ['gc']),
            ]
          : [new NodeApiEventSource(filteringEventHandler)]
      }
      start() {
        this.#eventSources.forEach((s) => s.start())
      }
      stop() {
        this.#eventSources.forEach((s) => s.stop())
      }
      profile(restart, startDate, endDate) {
        if (!restart) {
          this.stop()
        }
        const thatEventSerializer = this.#eventSerializer
        this.#eventSerializer = new EventSerializer(this.#maxSamples)
        return () => thatEventSerializer.createProfile(startDate, endDate)
      }
      getInfo() {
        return {
          maxSamples: this.#maxSamples,
        }
      }
      encode(profile) {
        return encodeProfileAsync(profile())
      }
    }
    module2.exports = EventsProfiler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js
var require_tagger3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js'(exports2, module2) {
    'use strict'
    var tagger = {
      parse(tags) {
        if (!tags) return {}
        switch (typeof tags) {
          case 'object': {
            if (Array.isArray(tags)) {
              const tagObject = {}
              for (const tag of tags) {
                const colon = tag.indexOf(':')
                if (colon === -1) continue
                const key = tag.slice(0, colon).trim()
                const value = tag.slice(colon + 1).trim()
                if (key.length !== 0 && value.length !== 0) {
                  tagObject[key] = value
                }
              }
              return tagObject
            }
            const tagsArray = []
            for (const [key, value] of Object.entries(tags)) {
              if (value != null) {
                tagsArray.push(`${key}:${value}`)
              }
            }
            return tagger.parse(tagsArray)
          }
          case 'string':
            return tagger.parse(tags.split(','))
          default:
            return {}
        }
      },
    }
    module2.exports = { tagger }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/azure_metadata.js
var require_azure_metadata = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/azure_metadata.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var { getIsAzureFunction } = require_serverless()
    var { getEnvironmentVariable, getEnvironmentVariables } = require_config_helper()
    function extractSubscriptionID(ownerName) {
      if (ownerName !== void 0) {
        const subId = ownerName.split('+')[0].trim()
        if (subId.length > 0) {
          return subId
        }
      }
    }
    function extractResourceGroup(ownerName) {
      return /.+\+(.+)-.+webspace(-Linux)?/.exec(ownerName)?.[1]
    }
    function buildResourceID(subscriptionID, siteName, resourceGroup) {
      if (subscriptionID === void 0 || siteName === void 0 || resourceGroup === void 0) {
        return
      }
      return `/subscriptions/${subscriptionID}/resourcegroups/${resourceGroup}/providers/microsoft.web/sites/${siteName}`.toLowerCase()
    }
    function trimObject(obj) {
      Object.entries(obj)
        .filter(([_, value]) => value === void 0)
        .forEach(([key, _]) => {
          delete obj[key]
        })
      return obj
    }
    function buildMetadata() {
      const {
        COMPUTERNAME,
        DD_AAS_DOTNET_EXTENSION_VERSION,
        FUNCTIONS_EXTENSION_VERSION,
        FUNCTIONS_WORKER_RUNTIME,
        FUNCTIONS_WORKER_RUNTIME_VERSION,
        WEBSITE_INSTANCE_ID,
        WEBSITE_OWNER_NAME,
        WEBSITE_OS,
        WEBSITE_RESOURCE_GROUP,
        WEBSITE_SITE_NAME,
      } = getEnvironmentVariables()
      const subscriptionID = extractSubscriptionID(WEBSITE_OWNER_NAME)
      const siteName = WEBSITE_SITE_NAME
      const [siteKind, siteType] = getIsAzureFunction() ? ['functionapp', 'function'] : ['app', 'app']
      const resourceGroup = WEBSITE_RESOURCE_GROUP ?? extractResourceGroup(WEBSITE_OWNER_NAME)
      return trimObject({
        extensionVersion: DD_AAS_DOTNET_EXTENSION_VERSION,
        functionRuntimeVersion: FUNCTIONS_EXTENSION_VERSION,
        instanceID: WEBSITE_INSTANCE_ID,
        instanceName: COMPUTERNAME,
        operatingSystem: WEBSITE_OS ?? os.platform(),
        resourceGroup,
        resourceID: buildResourceID(subscriptionID, siteName, resourceGroup),
        runtime: FUNCTIONS_WORKER_RUNTIME,
        runtimeVersion: FUNCTIONS_WORKER_RUNTIME_VERSION,
        siteKind,
        siteName,
        siteType,
        subscriptionID,
      })
    }
    function getAzureAppMetadata() {
      if (getEnvironmentVariable('WEBSITE_SITE_NAME') !== void 0) {
        return buildMetadata()
      }
    }
    function getAzureFunctionMetadata() {
      if (getIsAzureFunction()) {
        return buildMetadata()
      }
    }
    function getAzureTagsFromMetadata(metadata) {
      if (metadata === void 0) {
        return {}
      }
      return trimObject({
        'aas.environment.extension_version': metadata.extensionVersion,
        'aas.environment.function_runtime': metadata.functionRuntimeVersion,
        'aas.environment.instance_id': metadata.instanceID,
        'aas.environment.instance_name': metadata.instanceName,
        'aas.environment.os': metadata.operatingSystem,
        'aas.environment.runtime': metadata.runtime,
        'aas.environment.runtime_version': metadata.runtimeVersion,
        'aas.resource.group': metadata.resourceGroup,
        'aas.resource.id': metadata.resourceID,
        'aas.site.kind': metadata.siteKind,
        'aas.site.name': metadata.siteName,
        'aas.site.type': metadata.siteType,
        'aas.subscription.id': metadata.subscriptionID,
      })
    }
    module2.exports = {
      getAzureAppMetadata,
      getAzureFunctionMetadata,
      getAzureTagsFromMetadata,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/config.js
var require_config4 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/config.js'(exports2, module2) {
    'use strict'
    var os = require('os')
    var path = require('path')
    var { URL: URL2, format, pathToFileURL } = require('url')
    var satisfies = require_semifies()
    var { AgentExporter } = require_agent2()
    var { FileExporter } = require_file2()
    var { ConsoleLogger } = require_console()
    var WallProfiler = require_wall()
    var SpaceProfiler = require_space()
    var EventsProfiler = require_events()
    var { oomExportStrategies, snapshotKinds } = require_constants5()
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2()
    var { tagger } = require_tagger3()
    var { isFalse, isTrue } = require_util()
    var { getAzureTagsFromMetadata, getAzureAppMetadata } = require_azure_metadata()
    var { getEnvironmentVariables } = require_config_helper()
    var defaults = require_config_defaults()
    var Config = class {
      constructor(options = {}) {
        const {
          AWS_LAMBDA_FUNCTION_NAME: functionname,
          DD_AGENT_HOST,
          DD_ENV,
          DD_INTERNAL_PROFILING_TIMELINE_SAMPLING_ENABLED,
          // used for testing
          DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED,
          DD_PROFILING_CODEHOTSPOTS_ENABLED,
          DD_PROFILING_CPU_ENABLED,
          DD_PROFILING_DEBUG_SOURCE_MAPS,
          DD_PROFILING_DEBUG_UPLOAD_COMPRESSION,
          DD_PROFILING_ENDPOINT_COLLECTION_ENABLED,
          DD_PROFILING_EXPERIMENTAL_OOM_EXPORT_STRATEGIES,
          DD_PROFILING_EXPERIMENTAL_OOM_HEAP_LIMIT_EXTENSION_SIZE,
          DD_PROFILING_EXPERIMENTAL_OOM_MAX_HEAP_EXTENSION_COUNT,
          DD_PROFILING_EXPERIMENTAL_OOM_MONITORING_ENABLED,
          DD_PROFILING_HEAP_ENABLED,
          DD_PROFILING_HEAP_SAMPLING_INTERVAL,
          DD_PROFILING_PPROF_PREFIX,
          DD_PROFILING_PROFILERS,
          DD_PROFILING_SOURCE_MAP,
          DD_PROFILING_TIMELINE_ENABLED,
          DD_PROFILING_UPLOAD_PERIOD,
          DD_PROFILING_UPLOAD_TIMEOUT,
          DD_PROFILING_V8_PROFILER_BUG_WORKAROUND,
          DD_PROFILING_WALLTIME_ENABLED,
          DD_SERVICE,
          DD_TAGS,
          DD_TRACE_AGENT_PORT,
          DD_TRACE_AGENT_URL,
          DD_VERSION,
          NODE_OPTIONS,
        } = getEnvironmentVariables()
        const env = options.env ?? DD_ENV
        const service = options.service || DD_SERVICE || 'node'
        const host = os.hostname()
        const version = options.version ?? DD_VERSION
        const flushInterval = options.interval ?? (Number(DD_PROFILING_UPLOAD_PERIOD) * 1e3 || 65 * 1e3)
        const uploadTimeout = options.uploadTimeout ?? (Number(DD_PROFILING_UPLOAD_TIMEOUT) || 60 * 1e3)
        const sourceMap = options.sourceMap ?? DD_PROFILING_SOURCE_MAP ?? true
        const pprofPrefix = options.pprofPrefix ?? DD_PROFILING_PPROF_PREFIX ?? ''
        this.service = service
        this.env = env
        this.host = host
        this.functionname = functionname
        this.version = version
        this.tags = Object.assign(
          tagger.parse(DD_TAGS),
          tagger.parse(options.tags),
          tagger.parse({ env, host, service, version, functionname }),
          getAzureTagsFromMetadata(getAzureAppMetadata())
        )
        if (options.repositoryUrl && options.commitSHA) {
          this.tags[GIT_REPOSITORY_URL] = options.repositoryUrl
          this.tags[GIT_COMMIT_SHA] = options.commitSHA
        }
        this.logger = ensureLogger(options.logger)
        const samplingContextsAvailable = process.platform !== 'win32'
        function checkOptionAllowed(option, description, condition) {
          if (option && !condition) {
            throw new Error(`${description} not supported on ${process.platform}.`)
          }
        }
        function checkOptionWithSamplingContextAllowed(option, description) {
          checkOptionAllowed(option, description, samplingContextsAvailable)
        }
        this.flushInterval = flushInterval
        this.uploadTimeout = uploadTimeout
        this.sourceMap = sourceMap
        this.debugSourceMaps = isTrue(options.debugSourceMaps ?? DD_PROFILING_DEBUG_SOURCE_MAPS)
        this.endpointCollectionEnabled = isTrue(
          options.endpointCollection ?? DD_PROFILING_ENDPOINT_COLLECTION_ENABLED ?? samplingContextsAvailable
        )
        checkOptionWithSamplingContextAllowed(this.endpointCollectionEnabled, 'Endpoint collection')
        this.pprofPrefix = pprofPrefix
        this.v8ProfilerBugWorkaroundEnabled = isTrue(
          options.v8ProfilerBugWorkaround ?? DD_PROFILING_V8_PROFILER_BUG_WORKAROUND ?? true
        )
        const hostname = (options.hostname ?? DD_AGENT_HOST) || defaults.hostname
        const port = (options.port ?? DD_TRACE_AGENT_PORT) || defaults.port
        this.url = new URL2(
          options.url ??
            DD_TRACE_AGENT_URL ??
            format({
              protocol: 'http:',
              hostname,
              port,
            })
        )
        this.libraryInjected = options.libraryInjected
        this.activation = options.activation
        this.exporters = ensureExporters(options.exporters || [new AgentExporter(this)], this)
        const oomMonitoringSupported = process.platform !== 'win32'
        const oomMonitoringEnabled = isTrue(
          options.oomMonitoring ?? DD_PROFILING_EXPERIMENTAL_OOM_MONITORING_ENABLED ?? oomMonitoringSupported
        )
        checkOptionAllowed(oomMonitoringEnabled, 'OOM monitoring', oomMonitoringSupported)
        const heapLimitExtensionSize =
          options.oomHeapLimitExtensionSize ?? (Number(DD_PROFILING_EXPERIMENTAL_OOM_HEAP_LIMIT_EXTENSION_SIZE) || 0)
        const maxHeapExtensionCount =
          options.oomMaxHeapExtensionCount ?? (Number(DD_PROFILING_EXPERIMENTAL_OOM_MAX_HEAP_EXTENSION_COUNT) || 0)
        const exportStrategies = oomMonitoringEnabled
          ? ensureOOMExportStrategies(
              options.oomExportStrategies ??
                DD_PROFILING_EXPERIMENTAL_OOM_EXPORT_STRATEGIES ?? [oomExportStrategies.PROCESS],
              this
            )
          : []
        const exportCommand = oomMonitoringEnabled ? buildExportCommand(this) : void 0
        this.oomMonitoring = {
          enabled: oomMonitoringEnabled,
          heapLimitExtensionSize,
          maxHeapExtensionCount,
          exportStrategies,
          exportCommand,
        }
        const profilers =
          options.profilers ||
          getProfilers({
            DD_PROFILING_HEAP_ENABLED,
            DD_PROFILING_WALLTIME_ENABLED,
            DD_PROFILING_PROFILERS,
          })
        this.timelineEnabled = isTrue(
          options.timelineEnabled ?? DD_PROFILING_TIMELINE_ENABLED ?? samplingContextsAvailable
        )
        checkOptionWithSamplingContextAllowed(this.timelineEnabled, 'Timeline view')
        this.timelineSamplingEnabled = isTrue(
          options.timelineSamplingEnabled ?? DD_INTERNAL_PROFILING_TIMELINE_SAMPLING_ENABLED ?? true
        )
        this.codeHotspotsEnabled = isTrue(
          options.codeHotspotsEnabled ?? DD_PROFILING_CODEHOTSPOTS_ENABLED ?? samplingContextsAvailable
        )
        checkOptionWithSamplingContextAllowed(this.codeHotspotsEnabled, 'Code hotspots')
        this.cpuProfilingEnabled = isTrue(
          options.cpuProfilingEnabled ?? DD_PROFILING_CPU_ENABLED ?? samplingContextsAvailable
        )
        checkOptionWithSamplingContextAllowed(this.cpuProfilingEnabled, 'CPU profiling')
        this.samplingInterval = options.samplingInterval || 1e3 / 99
        this.heapSamplingInterval =
          options.heapSamplingInterval ?? (Number(DD_PROFILING_HEAP_SAMPLING_INTERVAL) || 512 * 1024)
        const uploadCompression0 = options.uploadCompression ?? DD_PROFILING_DEBUG_UPLOAD_COMPRESSION ?? 'on'
        let [uploadCompression, level0] = uploadCompression0.split('-')
        if (!['on', 'off', 'gzip', 'zstd'].includes(uploadCompression)) {
          this.logger.warn(`Invalid profile upload compression method "${uploadCompression0}". Will use "on".`)
          uploadCompression = 'on'
        }
        let level = level0 ? Number.parseInt(level0, 10) : void 0
        if (level !== void 0) {
          if (['on', 'off'].includes(uploadCompression)) {
            this.logger.warn(`Compression levels are not supported for "${uploadCompression}".`)
            level = void 0
          } else if (Number.isNaN(level)) {
            this.logger.warn(`Invalid compression level "${level0}". Will use default level.`)
            level = void 0
          } else if (level < 1) {
            this.logger.warn(`Invalid compression level ${level}. Will use 1.`)
            level = 1
          } else {
            const maxLevel = { gzip: 9, zstd: 22 }[uploadCompression]
            if (level > maxLevel) {
              this.logger.warn(`Invalid compression level ${level}. Will use ${maxLevel}.`)
              level = maxLevel
            }
          }
        }
        if (uploadCompression === 'on') {
          uploadCompression = 'gzip'
        }
        this.uploadCompression = { method: uploadCompression, level }
        const that = this
        function turnOffAsyncContextFrame(msg) {
          that.logger.warn(`DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED was set ${msg}, it will have no effect.`)
          that.asyncContextFrameEnabled = false
        }
        const hasExecArg = (arg) => process.execArgv.includes(arg) || String(NODE_OPTIONS).includes(arg)
        this.asyncContextFrameEnabled = isTrue(options.useAsyncContextFrame ?? DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED)
        if (this.asyncContextFrameEnabled) {
          if (satisfies(process.versions.node, '>=24.0.0')) {
            if (hasExecArg('--no-async-context-frame')) {
              turnOffAsyncContextFrame('with --no-async-context-frame')
            }
          } else if (satisfies(process.versions.node, '>=23.0.0')) {
            if (!hasExecArg('--experimental-async-context-frame')) {
              turnOffAsyncContextFrame('without --experimental-async-context-frame')
            }
          } else {
            turnOffAsyncContextFrame('but it requires at least Node.js 23')
          }
        }
        this.heartbeatInterval = options.heartbeatInterval || 60 * 1e3
        this.profilers = ensureProfilers(profilers, this)
      }
      get systemInfoReport() {
        const report = {
          asyncContextFrameEnabled: this.asyncContextFrameEnabled,
          codeHotspotsEnabled: this.codeHotspotsEnabled,
          cpuProfilingEnabled: this.cpuProfilingEnabled,
          debugSourceMaps: this.debugSourceMaps,
          endpointCollectionEnabled: this.endpointCollectionEnabled,
          heapSamplingInterval: this.heapSamplingInterval,
          oomMonitoring: { ...this.oomMonitoring },
          profilerTypes: this.profilers.map((p) => p.type),
          sourceMap: this.sourceMap,
          timelineEnabled: this.timelineEnabled,
          timelineSamplingEnabled: this.timelineSamplingEnabled,
          uploadCompression: { ...this.uploadCompression },
          v8ProfilerBugWorkaroundEnabled: this.v8ProfilerBugWorkaroundEnabled,
        }
        delete report.oomMonitoring.exportCommand
        return report
      }
    }
    module2.exports = { Config }
    function getProfilers({ DD_PROFILING_HEAP_ENABLED, DD_PROFILING_WALLTIME_ENABLED, DD_PROFILING_PROFILERS }) {
      const profilers = new Set((DD_PROFILING_PROFILERS ?? 'space,wall').split(','))
      let spaceExplicitlyEnabled = false
      if (DD_PROFILING_HEAP_ENABLED != null) {
        if (isTrue(DD_PROFILING_HEAP_ENABLED)) {
          if (!profilers.has('space')) {
            profilers.add('space')
            spaceExplicitlyEnabled = true
          }
        } else if (isFalse(DD_PROFILING_HEAP_ENABLED)) {
          profilers.delete('space')
        }
      }
      if (DD_PROFILING_WALLTIME_ENABLED != null) {
        if (isTrue(DD_PROFILING_WALLTIME_ENABLED)) {
          profilers.add('wall')
        } else if (isFalse(DD_PROFILING_WALLTIME_ENABLED)) {
          profilers.delete('wall')
          profilers.delete('cpu')
        }
      }
      const profilersArray = [...profilers]
      if (spaceExplicitlyEnabled) {
        const spaceIdx = profilersArray.indexOf('space')
        if (spaceIdx > 0) {
          profilersArray.splice(spaceIdx, 1)
          profilersArray.unshift('space')
        }
      }
      return profilersArray
    }
    function getExportStrategy(name, options) {
      const strategy = Object.values(oomExportStrategies).find((value) => value === name)
      if (strategy === void 0) {
        options.logger.error(`Unknown oom export strategy "${name}"`)
      }
      return strategy
    }
    function ensureOOMExportStrategies(strategies, options) {
      if (!strategies) {
        return []
      }
      if (typeof strategies === 'string') {
        strategies = strategies.split(',')
      }
      for (let i = 0; i < strategies.length; i++) {
        const strategy = strategies[i]
        if (typeof strategy === 'string') {
          strategies[i] = getExportStrategy(strategy, options)
        }
      }
      return [...new Set(strategies)]
    }
    function getExporter(name, options) {
      switch (name) {
        case 'agent':
          return new AgentExporter(options)
        case 'file':
          return new FileExporter(options)
      }
    }
    function ensureExporters(exporters, options) {
      if (typeof exporters === 'string') {
        exporters = exporters.split(',')
      }
      for (let i = 0; i < exporters.length; i++) {
        const exporter = exporters[i]
        if (typeof exporter === 'string') {
          exporters[i] = getExporter(exporter, options)
        }
      }
      return exporters
    }
    function getProfiler(name, options) {
      switch (name) {
        case 'cpu':
        case 'wall':
          return new WallProfiler(options)
        case 'space':
          return new SpaceProfiler(options)
        default:
          options.logger.error(`Unknown profiler "${name}"`)
      }
    }
    function ensureProfilers(profilers, options) {
      if (typeof profilers === 'string') {
        profilers = profilers.split(',')
      }
      for (let i = 0; i < profilers.length; i++) {
        const profiler = profilers[i]
        if (typeof profiler === 'string') {
          profilers[i] = getProfiler(profiler, options)
        }
      }
      if (options.timelineEnabled && profilers.some((p) => p instanceof WallProfiler)) {
        profilers.push(new EventsProfiler(options))
      }
      return profilers.filter(Boolean)
    }
    function ensureLogger(logger) {
      if (
        typeof logger !== 'object' ||
        typeof logger.debug !== 'function' ||
        typeof logger.info !== 'function' ||
        typeof logger.warn !== 'function' ||
        typeof logger.error !== 'function'
      ) {
        return new ConsoleLogger()
      }
      return logger
    }
    function buildExportCommand(options) {
      const tags = [...Object.entries(options.tags), ['snapshot', snapshotKinds.ON_OUT_OF_MEMORY]]
        .map(([key, value]) => `${key}:${value}`)
        .join(',')
      const urls = []
      for (const exporter of options.exporters) {
        if (exporter instanceof AgentExporter) {
          urls.push(options.url.toString())
        } else if (exporter instanceof FileExporter) {
          urls.push(pathToFileURL(options.pprofPrefix).toString())
        }
      }
      return [process.execPath, path.join(__dirname, 'exporter_cli.js'), urls.join(','), tags, 'space']
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js
var require_profiler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js'(exports2, module2) {
    'use strict'
    var { EventEmitter } = require('events')
    var { Config } = require_config4()
    var { snapshotKinds } = require_constants5()
    var { threadNamePrefix } = require_shared()
    var { isWebServerSpan, endpointNameFromTags, getStartedSpans } = require_webspan_utils()
    var dc = require_dc_polyfill()
    var crashtracker = require_crashtracking()
    var { promisify } = require('util')
    var zlib = require('zlib')
    var profileSubmittedChannel = dc.channel('datadog:profiling:profile-submitted')
    var spanFinishedChannel = dc.channel('dd-trace:span:finish')
    function maybeSourceMap(sourceMap, SourceMapper, debug) {
      if (!sourceMap) return
      return SourceMapper.create([process.cwd()], debug)
    }
    function logError(logger, ...args) {
      if (logger) {
        logger.error(...args)
      }
    }
    function findWebSpan(startedSpans, spanId) {
      for (let i = startedSpans.length; --i >= 0; ) {
        const ispan = startedSpans[i]
        const context = ispan.context()
        if (context._spanId === spanId) {
          if (isWebServerSpan(context._tags)) {
            return true
          }
          spanId = context._parentId
        }
      }
      return false
    }
    function processInfo(infos, info, type) {
      if (Object.keys(info).length > 0) {
        infos[type] = info
      }
    }
    var Profiler = class extends EventEmitter {
      #compressionFn
      #compressionOptions
      #config
      #enabled = false
      #endpointCounts = /* @__PURE__ */ new Map()
      #lastStart
      #logger
      #profileSeq = 0
      #spanFinishListener
      #timer
      constructor() {
        super()
        this._timeoutInterval = void 0
      }
      get flushInterval() {
        return this.#config?.flushInterval
      }
      start(options) {
        return this._start(options).catch((err) => {
          logError(
            options.logger,
            'Error starting profiler. For troubleshooting tips, see <https://dtdg.co/nodejs-profiler-troubleshooting>',
            err
          )
          return false
        })
      }
      get enabled() {
        return this.#enabled
      }
      #logError(err) {
        logError(this.#logger, err)
      }
      async _start(options) {
        if (this.enabled) return true
        const config = (this.#config = new Config(options))
        this.#logger = config.logger
        this.#enabled = true
        this._setInterval()
        let mapper
        try {
          const { setLogger, SourceMapper } = require('@datadog/pprof')
          setLogger(config.logger)
          mapper = await maybeSourceMap(config.sourceMap, SourceMapper, config.debugSourceMaps)
          if (config.sourceMap && config.debugSourceMaps) {
            this.#logger.debug(() => {
              return mapper.infoMap.size === 0
                ? 'Found no source maps'
                : `Found source maps for following files: [${[...mapper.infoMap.keys()].join(', ')}]`
            })
          }
          const clevel = config.uploadCompression.level
          switch (config.uploadCompression.method) {
            case 'gzip':
              this.#compressionFn = promisify(zlib.gzip)
              if (clevel !== void 0) {
                this.#compressionOptions = {
                  level: clevel,
                }
              }
              break
            case 'zstd':
              if (typeof zlib.zstdCompress === 'function') {
                this.#compressionFn = promisify(zlib.zstdCompress)
                if (clevel !== void 0) {
                  this.#compressionOptions = {
                    params: {
                      // eslint-disable-next-line n/no-unsupported-features/node-builtins
                      [zlib.constants.ZSTD_c_compressionLevel]: clevel,
                    },
                  }
                }
              } else {
                const zstdCompress = require('@datadog/libdatadog').load('datadog-js-zstd').zstd_compress
                const level = clevel ?? 0
                this.#compressionFn = (buffer) => Promise.resolve(Buffer.from(zstdCompress(buffer, level)))
              }
              break
          }
        } catch (err) {
          this.#logError(err)
        }
        try {
          const start = /* @__PURE__ */ new Date()
          const nearOOMCallback = this.#nearOOMExport.bind(this)
          for (const profiler of config.profilers) {
            profiler.start({
              mapper,
              nearOOMCallback,
            })
            this.#logger.debug(`Started ${profiler.type} profiler in ${threadNamePrefix} thread`)
          }
          if (config.endpointCollectionEnabled) {
            this.#spanFinishListener = this.#onSpanFinish.bind(this)
            spanFinishedChannel.subscribe(this.#spanFinishListener)
          }
          this._capture(this._timeoutInterval, start)
          return true
        } catch (e) {
          this.#logError(e)
          this.#stop()
          return false
        }
      }
      #nearOOMExport(profileType, encodedProfile, info) {
        const start = this.#lastStart
        const end = /* @__PURE__ */ new Date()
        const infos = this.#createInitialInfos()
        processInfo(infos, info, profileType)
        this.#submit(
          {
            [profileType]: encodedProfile,
          },
          infos,
          start,
          end,
          snapshotKinds.ON_OUT_OF_MEMORY
        )
      }
      _setInterval() {
        this._timeoutInterval = this.#config.flushInterval
      }
      stop() {
        if (!this.enabled) return
        this._collect(snapshotKinds.ON_SHUTDOWN, false)
        this.#stop()
      }
      #stop() {
        if (!this.enabled) return
        this.#enabled = false
        if (this.#spanFinishListener !== void 0) {
          spanFinishedChannel.unsubscribe(this.#spanFinishListener)
          this.#spanFinishListener = void 0
        }
        for (const profiler of this.#config.profilers) {
          profiler.stop()
          this.#logger.debug(`Stopped ${profiler.type} profiler in ${threadNamePrefix} thread`)
        }
        clearTimeout(this.#timer)
        this.#timer = void 0
      }
      _capture(timeout, start) {
        if (!this.enabled) return
        this.#lastStart = start
        if (!this.#timer || timeout !== this._timeoutInterval) {
          this.#timer = setTimeout(() => this._collect(snapshotKinds.PERIODIC), timeout)
          this.#timer.unref()
        } else {
          this.#timer.refresh()
        }
      }
      #onSpanFinish(span) {
        const context = span.context()
        const tags = context._tags
        if (!isWebServerSpan(tags)) return
        const endpointName = endpointNameFromTags(tags)
        if (!endpointName) return
        if (findWebSpan(getStartedSpans(context), context._parentId)) return
        let counter = this.#endpointCounts.get(endpointName)
        if (counter === void 0) {
          counter = { count: 1 }
          this.#endpointCounts.set(endpointName, counter)
        } else {
          counter.count++
        }
      }
      #createInitialInfos() {
        return {
          settings: this.#config.systemInfoReport,
        }
      }
      async _collect(snapshotKind, restart = true) {
        if (!this.enabled) return
        try {
          if (this.#config.profilers.length === 0) {
            throw new Error('No profile types configured.')
          }
          const startDate = this.#lastStart
          const endDate = /* @__PURE__ */ new Date()
          const profiles = []
          crashtracker.withProfilerSerializing(() => {
            for (const profiler of this.#config.profilers) {
              const info = profiler.getInfo()
              const profile = profiler.profile(restart, startDate, endDate)
              if (!restart) {
                this.#logger.debug(`Stopped ${profiler.type} profiler in ${threadNamePrefix} thread`)
              }
              if (!profile) continue
              profiles.push({ profiler, profile, info })
            }
          })
          if (restart) {
            this._capture(this._timeoutInterval, endDate)
          }
          let hasEncoded = false
          const encodedProfiles = {}
          const infos = this.#createInitialInfos()
          await Promise.all(
            profiles.map(async ({ profiler, profile, info }) => {
              try {
                const encoded = await profiler.encode(profile)
                const compressed =
                  encoded instanceof Buffer && this.#compressionFn !== void 0
                    ? await this.#compressionFn(encoded, this.#compressionOptions)
                    : encoded
                encodedProfiles[profiler.type] = compressed
                processInfo(infos, info, profiler.type)
                this.#logger.debug(() => {
                  const profileJson = JSON.stringify(profile, (_, value) => {
                    return typeof value === 'bigint' ? value.toString() : value
                  })
                  return `Collected ${profiler.type} profile: ` + profileJson
                })
                hasEncoded = true
              } catch (err) {
                this.#logError(err)
              }
            })
          )
          if (hasEncoded) {
            await this.#submit(encodedProfiles, infos, startDate, endDate, snapshotKind)
            profileSubmittedChannel.publish()
            this.#logger.debug('Submitted profiles')
          }
        } catch (err) {
          this.#logError(err)
          this.#stop()
        }
      }
      #submit(profiles, infos, start, end, snapshotKind) {
        const { tags } = this.#config
        const endpointCounts = {}
        for (const [endpoint, { count }] of this.#endpointCounts) {
          endpointCounts[endpoint] = count
        }
        this.#endpointCounts.clear()
        tags.snapshot = snapshotKind
        tags.profile_seq = this.#profileSeq++
        const exportSpec = { profiles, infos, start, end, tags, endpointCounts }
        const tasks = this.#config.exporters.map((exporter) =>
          exporter.export(exportSpec).catch((err) => {
            if (this.#logger) {
              this.#logger.warn(err)
            }
          })
        )
        return Promise.all(tasks)
      }
    }
    var ServerlessProfiler = class extends Profiler {
      #profiledIntervals = 0
      #interval = 1
      // seconds
      #flushAfterIntervals
      constructor() {
        super()
        this.#profiledIntervals = 0
        this.#interval = 1
        this.#flushAfterIntervals = void 0
      }
      get profiledIntervals() {
        return this.#profiledIntervals
      }
      _setInterval() {
        this._timeoutInterval = this.#interval * 1e3
        this.#flushAfterIntervals = this.flushInterval / 1e3
      }
      async _collect(snapshotKind, restart = true) {
        if (this.#profiledIntervals >= this.#flushAfterIntervals || !restart) {
          this.#profiledIntervals = 0
          await super._collect(snapshotKind, restart)
        } else {
          this.#profiledIntervals += 1
          this._capture(this._timeoutInterval, /* @__PURE__ */ new Date())
        }
      }
    }
    module2.exports = { Profiler, ServerlessProfiler }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiling/index.js
var require_profiling = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiling/index.js'(exports2, module2) {
    'use strict'
    var { Profiler, ServerlessProfiler } = require_profiler()
    var WallProfiler = require_wall()
    var SpaceProfiler = require_space()
    var { AgentExporter } = require_agent2()
    var { FileExporter } = require_file2()
    var { ConsoleLogger } = require_console()
    var { getEnvironmentVariable } = require_config_helper()
    var profiler = getEnvironmentVariable('AWS_LAMBDA_FUNCTION_NAME') ? new ServerlessProfiler() : new Profiler()
    module2.exports = {
      profiler,
      AgentExporter,
      FileExporter,
      WallProfiler,
      SpaceProfiler,
      ConsoleLogger,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/profiler.js
var require_profiler2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/profiler.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var { profiler } = require_profiling()
    process.once('beforeExit', () => {
      profiler.stop()
    })
    module2.exports = {
      start: (config) => {
        const { service, version, env, url, hostname, port, tags, repositoryUrl, commitSHA, injectionEnabled } = config
        const { enabled, sourceMap, exporters } = config.profiling
        const { heartbeatInterval } = config.telemetry
        const logger = {
          debug: (message) => log.debug(message),
          info: (message) => log.info(message),
          warn: (message) => log.warn(message),
          error: (...args) => log.error(...args),
        }
        const libraryInjected = injectionEnabled.length > 0
        let activation
        if (enabled === 'auto') {
          activation = 'auto'
        } else if (enabled === 'true') {
          activation = 'manual'
        }
        return profiler.start({
          service,
          version,
          env,
          logger,
          sourceMap,
          exporters,
          url,
          hostname,
          port,
          tags,
          repositoryUrl,
          commitSHA,
          libraryInjected,
          activation,
          heartbeatInterval,
        })
      },
      stop: () => {
        profiler.stop()
      },
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/standalone/tracesource.js
var require_tracesource = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/standalone/tracesource.js'(exports2, module2) {
    'use strict'
    var { TRACE_SOURCE_PROPAGATION_KEY } = require_constants2()
    function addTraceSourceTag(tags, product) {
      if (tags && product) {
        const actual = tags[TRACE_SOURCE_PROPAGATION_KEY]
          ? Number.parseInt(String(tags[TRACE_SOURCE_PROPAGATION_KEY]), 16)
          : 0
        tags[TRACE_SOURCE_PROPAGATION_KEY] = ((actual | product.id) >>> 0).toString(16).padStart(2, '0')
      }
      return tags
    }
    function hasTraceSourcePropagationTag(tags) {
      return Object.hasOwn(tags, TRACE_SOURCE_PROPAGATION_KEY)
    }
    module2.exports = {
      addTraceSourceTag,
      hasTraceSourcePropagationTag,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/standalone/tracesource_priority_sampler.js
var require_tracesource_priority_sampler = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/standalone/tracesource_priority_sampler.js'(exports2, module2) {
    'use strict'
    var PrioritySampler = require_priority_sampler()
    var { MANUAL_KEEP } = require_tags()
    var { USER_KEEP, AUTO_KEEP, AUTO_REJECT } = require_priority()
    var { SAMPLING_MECHANISM_DEFAULT } = require_constants2()
    var { addTraceSourceTag, hasTraceSourcePropagationTag } = require_tracesource()
    var { getProductRateLimiter } = require_product()
    var TraceSourcePrioritySampler = class extends PrioritySampler {
      /**
       * @override
       */
      configure(env, sampler, config) {
        this._env = env
        this._limiter = getProductRateLimiter(config)
      }
      /**
       * @override
       * @returns {import('../priority_sampler').SamplingPriority|undefined}
       */
      _getPriorityFromTags(tags, context) {
        if (
          Object.hasOwn(tags, MANUAL_KEEP) &&
          tags[MANUAL_KEEP] !== false &&
          hasTraceSourcePropagationTag(context._trace.tags)
        ) {
          return USER_KEEP
        }
      }
      /**
       * @override
       */
      _getPriorityFromAuto(span) {
        const context = this._getContext(span)
        context._sampling.mechanism = SAMPLING_MECHANISM_DEFAULT
        if (hasTraceSourcePropagationTag(context._trace.tags)) {
          return USER_KEEP
        }
        return this._isSampledByRateLimit(context) ? AUTO_KEEP : AUTO_REJECT
      }
      /**
       * @override
       */
      setPriority(span, samplingPriority, product) {
        super.setPriority(span, samplingPriority, product)
        const context = this._getContext(span)
        addTraceSourceTag(context?._trace?.tags, product)
      }
    }
    module2.exports = TraceSourcePrioritySampler
  },
})

// node_modules/dd-trace/packages/dd-trace/src/standalone/index.js
var require_standalone = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/standalone/index.js'(exports2, module2) {
    'use strict'
    var { channel } = require_dc_polyfill()
    var TraceSourcePrioritySampler = require_tracesource_priority_sampler()
    var { USER_KEEP } = require_priority()
    var TraceState = require_tracestate()
    var { APM_TRACING_ENABLED_KEY } = require_constants2()
    var { hasTraceSourcePropagationTag } = require_tracesource()
    var startCh = channel('dd-trace:span:start')
    var injectCh = channel('dd-trace:span:inject')
    var extractCh = channel('dd-trace:span:extract')
    function configure(config) {
      if (startCh.hasSubscribers) startCh.unsubscribe(onSpanStart)
      if (injectCh.hasSubscribers) injectCh.unsubscribe(onSpanInject)
      if (extractCh.hasSubscribers) extractCh.unsubscribe(onSpanExtract)
      if (config.apmTracingEnabled !== false) return
      startCh.subscribe(onSpanStart)
      injectCh.subscribe(onSpanInject)
      extractCh.subscribe(onSpanExtract)
      return new TraceSourcePrioritySampler(config.env)
    }
    function onSpanStart({ span, fields }) {
      const tags = span.context?.()?._tags
      if (!tags) return
      const { parent } = fields
      if (!parent || parent._isRemote) {
        tags[APM_TRACING_ENABLED_KEY] = 0
      }
    }
    function onSpanInject({ spanContext, carrier }) {
      if (!spanContext?._trace?.tags || !carrier) return
      if (!hasTraceSourcePropagationTag(spanContext._trace.tags)) {
        for (const key in carrier) {
          const lKey = key.toLowerCase()
          if (lKey.startsWith('x-datadog') || lKey.startsWith('x-b3') || lKey === 'traceparent') {
            delete carrier[key]
          } else if (lKey === 'tracestate') {
            const tracestate = TraceState.fromString(carrier[key])
            tracestate.forVendor('dd', (state) => state.clear())
            carrier[key] = tracestate.toString()
          }
        }
      }
    }
    function onSpanExtract({ spanContext = {} }) {
      if (!spanContext._trace?.tags || !spanContext._sampling) return
      if (!hasTraceSourcePropagationTag(spanContext._trace.tags)) {
        spanContext._sampling.priority = void 0
      } else if (spanContext._sampling.priority !== USER_KEEP) {
        spanContext._sampling.priority = USER_KEEP
      }
    }
    module2.exports = {
      configure,
      hasTraceSourcePropagationTag,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/utils.js
var require_utils12 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/utils.js'(exports2, module2) {
    'use strict'
    function getRootSpan(tracer2) {
      let span = tracer2.scope().active()
      if (!span) return
      const context = span.context()
      const started = context._trace.started
      let parentId = context._parentId
      while (parentId) {
        const parent = started.find((s) => s.context()._spanId === parentId)
        const pContext = parent?.context()
        if (!pContext) break
        parentId = pContext._parentId
        if (!pContext._tags?._inferred_span) {
          span = parent
        }
      }
      return span
    }
    module2.exports = {
      getRootSpan,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/set_user.js
var require_set_user = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/set_user.js'(exports2, module2) {
    'use strict'
    var { getRootSpan } = require_utils12()
    var log = require_log2()
    var waf = require_waf2()
    var addresses = require_addresses()
    function setUserTags(user, rootSpan) {
      for (const k of Object.keys(user)) {
        rootSpan.setTag(`usr.${k}`, String(user[k]))
      }
      rootSpan.setTag('_dd.appsec.user.collection_mode', 'sdk')
    }
    function setUser(tracer2, user) {
      if (!user || !user.id) {
        log.warn('[ASM] Invalid user provided to setUser')
        return
      }
      const rootSpan = getRootSpan(tracer2)
      if (!rootSpan) {
        log.warn('[ASM] Root span not available in setUser')
        return
      }
      setUserTags(user, rootSpan)
      const persistent = {
        [addresses.USER_ID]: String(user.id),
      }
      if (user.session_id && typeof user.session_id === 'string') {
        persistent[addresses.USER_SESSION_ID] = user.session_id
      }
      waf.run({ persistent })
    }
    module2.exports = {
      setUserTags,
      setUser,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/track_event.js
var require_track_event = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/track_event.js'(exports2, module2) {
    'use strict'
    var log = require_log2()
    var { getRootSpan } = require_utils12()
    var { setUserTags } = require_set_user()
    var waf = require_waf2()
    var { keepTrace } = require_priority_sampler()
    var addresses = require_addresses()
    var { ASM } = require_product()
    var { incrementSdkEventMetric } = require_telemetry6()
    function trackUserLoginSuccessEvent(tracer2, user, metadata) {
      if (!user || !user.id) {
        log.warn('[ASM] Invalid user provided to trackUserLoginSuccessEvent')
        return
      }
      incrementSdkEventMetric('login_success', 'v1')
      const rootSpan = getRootSpan(tracer2)
      if (!rootSpan) {
        log.warn('[ASM] Root span not available in trackUserLoginSuccessEvent')
        return
      }
      setUserTags(user, rootSpan)
      const login = user.login ?? user.id
      metadata = { 'usr.login': login, ...metadata }
      trackEvent('users.login.success', metadata, 'trackUserLoginSuccessEvent', rootSpan)
      runWaf('users.login.success', { id: user.id, login })
    }
    function trackUserLoginFailureEvent(tracer2, userId, exists, metadata) {
      if (!userId || typeof userId !== 'string') {
        log.warn('[ASM] Invalid userId provided to trackUserLoginFailureEvent')
        return
      }
      const fields = {
        'usr.id': userId,
        'usr.login': userId,
        'usr.exists': exists ? 'true' : 'false',
        ...metadata,
      }
      trackEvent('users.login.failure', fields, 'trackUserLoginFailureEvent', getRootSpan(tracer2))
      runWaf('users.login.failure', { login: userId })
      incrementSdkEventMetric('login_failure', 'v1')
    }
    function trackCustomEvent(tracer2, eventName, metadata) {
      if (!eventName || typeof eventName !== 'string') {
        log.warn('[ASM] Invalid eventName provided to trackCustomEvent')
        return
      }
      trackEvent(eventName, metadata, 'trackCustomEvent', getRootSpan(tracer2))
      incrementSdkEventMetric('custom', 'v1')
      if (eventName === 'users.login.success' || eventName === 'users.login.failure') {
        runWaf(eventName)
      }
    }
    function trackUserLoginSuccessV2(tracer2, login, user, metadata) {
      if (!login || typeof login !== 'string') {
        log.warn('[ASM] Invalid login provided to eventTrackingV2.trackUserLoginSuccess')
        return
      }
      incrementSdkEventMetric('login_success', 'v2')
      const rootSpan = getRootSpan(tracer2)
      if (!rootSpan) {
        log.warn('[ASM] Root span not available in eventTrackingV2.trackUserLoginSuccess')
        return
      }
      const wafData = { login }
      metadata = {
        'usr.login': login,
        ...metadata,
      }
      if (user) {
        if (typeof user !== 'object') {
          user = { id: user }
        }
        if (user.id) {
          wafData.id = user.id
          setUserTags(user, rootSpan)
          metadata.usr = user
        }
      }
      trackEvent('users.login.success', metadata, 'eventTrackingV2.trackUserLoginSuccess', rootSpan)
      runWaf('users.login.success', wafData)
    }
    function trackUserLoginFailureV2(tracer2, login, exists, metadata) {
      if (!login || typeof login !== 'string') {
        log.warn('[ASM] Invalid login provided to eventTrackingV2.trackUserLoginFailure')
        return
      }
      incrementSdkEventMetric('login_failure', 'v2')
      const rootSpan = getRootSpan(tracer2)
      if (!rootSpan) {
        log.warn('[ASM] Root span not available in eventTrackingV2.trackUserLoginFailure')
        return
      }
      const wafData = { login }
      if (exists !== null && typeof exists === 'object' && metadata === void 0) {
        metadata = exists
        exists = false
      }
      metadata = {
        'usr.login': login,
        'usr.exists': exists ? 'true' : 'false',
        ...metadata,
      }
      trackEvent('users.login.failure', metadata, 'eventTrackingV2.trackUserLoginFailure', rootSpan)
      runWaf('users.login.failure', wafData)
    }
    function flattenFields(fields, depth = 0) {
      if (depth > 4) {
        return {
          truncated: true,
        }
      }
      const result = {}
      let truncated = false
      for (const key of Object.keys(fields)) {
        const value = fields[key]
        if (value && typeof value === 'object') {
          const { result: flatValue, truncated: inheritTruncated } = flattenFields(value, depth + 1)
          truncated = truncated || inheritTruncated
          if (flatValue) {
            for (const flatKey of Object.keys(flatValue)) {
              result[`${key}.${flatKey}`] = flatValue[flatKey]
            }
          }
        } else if (value !== void 0) {
          result[key] = value
        }
      }
      return { result, truncated }
    }
    function trackEvent(eventName, fields, sdkMethodName, rootSpan) {
      if (!rootSpan) {
        log.warn('[ASM] Root span not available in %s', sdkMethodName)
        return
      }
      const tags = {
        [`appsec.events.${eventName}.track`]: 'true',
        [`_dd.appsec.events.${eventName}.sdk`]: 'true',
      }
      if (fields) {
        const { result: flatFields, truncated } = flattenFields(fields)
        if (truncated) {
          log.warn('[ASM] Too deep object provided in the SDK method %s, object truncated', sdkMethodName)
        }
        for (const metadataKey of Object.keys(flatFields)) {
          tags[`appsec.events.${eventName}.${metadataKey}`] = String(flatFields[metadataKey])
        }
      }
      rootSpan.addTags(tags)
      keepTrace(rootSpan, ASM)
    }
    function runWaf(eventName, user) {
      const persistent = {
        [`server.business_logic.${eventName}`]: null,
      }
      if (user?.id) {
        persistent[addresses.USER_ID] = String(user.id)
      }
      if (user?.login) {
        persistent[addresses.USER_LOGIN] = String(user.login)
      }
      waf.run({ persistent })
    }
    module2.exports = {
      trackUserLoginSuccessEvent,
      trackUserLoginFailureEvent,
      trackCustomEvent,
      trackUserLoginSuccessV2,
      trackUserLoginFailureV2,
      trackEvent,
      runWaf,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/user_blocking.js
var require_user_blocking = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/user_blocking.js'(exports2, module2) {
    'use strict'
    var { USER_ID } = require_addresses()
    var waf = require_waf2()
    var { getRootSpan } = require_utils12()
    var { block, getBlockingAction } = require_blocking()
    var { storage } = require_datadog_core()
    var { setUserTags } = require_set_user()
    var log = require_log2()
    function isUserBlocked(user) {
      const results = waf.run({ persistent: { [USER_ID]: user.id } })
      return !!getBlockingAction(results?.actions)
    }
    function checkUserAndSetUser(tracer2, user) {
      if (!user || !user.id) {
        log.warn('[ASM] Invalid user provided to isUserBlocked')
        return false
      }
      const rootSpan = getRootSpan(tracer2)
      if (rootSpan) {
        if (!rootSpan.context()._tags['usr.id']) {
          setUserTags(user, rootSpan)
        }
      } else {
        log.warn('[ASM] Root span not available in isUserBlocked')
      }
      return isUserBlocked(user)
    }
    function blockRequest(tracer2, req, res) {
      if (!req || !res) {
        const store = storage('legacy').getStore()
        if (store) {
          req = req || store.req
          res = res || store.res
        }
      }
      if (!req || !res) {
        log.warn('[ASM] Requests or response object not available in blockRequest')
        return false
      }
      const rootSpan = getRootSpan(tracer2)
      if (!rootSpan) {
        log.warn('[ASM] Root span not available in blockRequest')
        return false
      }
      return block(req, res, rootSpan)
    }
    module2.exports = {
      checkUserAndSetUser,
      blockRequest,
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/index.js
var require_sdk = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/index.js'(exports2, module2) {
    'use strict'
    var {
      trackUserLoginSuccessEvent,
      trackUserLoginFailureEvent,
      trackCustomEvent,
      trackUserLoginSuccessV2,
      trackUserLoginFailureV2,
    } = require_track_event()
    var { checkUserAndSetUser, blockRequest } = require_user_blocking()
    var { setTemplates } = require_blocking()
    var { setUser } = require_set_user()
    var EventTrackingV2 = class {
      constructor(tracer2) {
        this._tracer = tracer2
      }
      trackUserLoginSuccess(login, user, metadata) {
        trackUserLoginSuccessV2(this._tracer, login, user, metadata)
      }
      trackUserLoginFailure(login, exists, metadata) {
        trackUserLoginFailureV2(this._tracer, login, exists, metadata)
      }
    }
    var AppsecSdk = class {
      constructor(tracer2, config) {
        this._tracer = tracer2
        if (config) {
          setTemplates(config)
        }
        this.eventTrackingV2 = new EventTrackingV2(tracer2)
      }
      trackUserLoginSuccessEvent(user, metadata) {
        return trackUserLoginSuccessEvent(this._tracer, user, metadata)
      }
      trackUserLoginFailureEvent(userId, exists, metadata) {
        return trackUserLoginFailureEvent(this._tracer, userId, exists, metadata)
      }
      trackCustomEvent(eventName, metadata) {
        return trackCustomEvent(this._tracer, eventName, metadata)
      }
      isUserBlocked(user) {
        return checkUserAndSetUser(this._tracer, user)
      }
      blockRequest(req, res) {
        return blockRequest(this._tracer, req, res)
      }
      setUser(user) {
        return setUser(this._tracer, user)
      }
    }
    module2.exports = AppsecSdk
  },
})

// node_modules/dd-trace/packages/dd-trace/src/llmobs/sdk.js
var require_sdk2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/llmobs/sdk.js'(exports2, module2) {
    'use strict'
    var { SPAN_KIND, OUTPUT_VALUE, INPUT_VALUE } = require_tags3()
    var { getFunctionArguments, validateKind } = require_util8()
    var { isTrue, isError } = require_util()
    var { storage } = require_storage4()
    var Span = require_span2()
    var tracerVersion = require_package().version
    var logger = require_log2()
    var { getEnvironmentVariable } = require_config_helper()
    var telemetry = require_telemetry4()
    var LLMObsTagger = require_tagger2()
    var { channel } = require_dc_polyfill()
    var evalMetricAppendCh = channel('llmobs:eval-metric:append')
    var flushCh = channel('llmobs:writers:flush')
    var registerUserSpanProcessorCh = channel('llmobs:register-processor')
    var NoopLLMObs = require_noop2()
    var LLMObs = class extends NoopLLMObs {
      /**
       * flag representing if a user span processor has been registered
       * @type {boolean}
       */
      #hasUserSpanProcessor = false
      constructor(tracer2, llmobsModule, config) {
        super(tracer2)
        this._config = config
        this._llmobsModule = llmobsModule
        this._tagger = new LLMObsTagger(config)
      }
      get enabled() {
        return this._config.llmobs.enabled
      }
      enable(options = {}) {
        if (this.enabled) {
          logger.debug('LLMObs is already enabled.')
          return
        }
        logger.debug('Enabling LLMObs')
        const { mlApp, agentlessEnabled } = options
        const DD_LLMOBS_ENABLED = getEnvironmentVariable('DD_LLMOBS_ENABLED')
        const llmobsConfig = {
          mlApp,
          agentlessEnabled,
        }
        const enabled = DD_LLMOBS_ENABLED == null || isTrue(DD_LLMOBS_ENABLED)
        if (!enabled) {
          logger.debug('LLMObs.enable() called when DD_LLMOBS_ENABLED is false. No action taken.')
          return
        }
        this._config.llmobs.enabled = true
        this._config.configure({ ...this._config, llmobs: llmobsConfig })
        this._llmobsModule.enable(this._config)
      }
      disable() {
        if (!this.enabled) {
          logger.debug('LLMObs is already disabled.')
          return
        }
        logger.debug('Disabling LLMObs')
        this._config.llmobs.enabled = false
        this._llmobsModule.disable()
      }
      trace(options = {}, fn) {
        if (typeof options === 'function') {
          fn = options
          options = {}
        }
        const kind = validateKind(options.kind)
        telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: false, kind })
        const name = options.name || kind
        if (!name) {
          throw new Error('No span name provided for `trace`.')
        }
        const { spanOptions, ...llmobsOptions } = this._extractOptions(options)
        if (fn.length > 1) {
          return this._tracer.trace(name, spanOptions, (span, cb) =>
            this._activate(span, { kind, ...llmobsOptions }, () => fn(span, cb))
          )
        }
        return this._tracer.trace(name, spanOptions, (span) =>
          this._activate(span, { kind, ...llmobsOptions }, () => fn(span))
        )
      }
      wrap(options = {}, fn) {
        if (typeof options === 'function') {
          fn = options
          options = {}
        }
        const kind = validateKind(options.kind)
        let name = options.name || fn?.name || kind
        if (!name) {
          logger.warn('No span name provided for `wrap`. Defaulting to "unnamed-anonymous-function".')
          name = 'unnamed-anonymous-function'
        }
        const { spanOptions, ...llmobsOptions } = this._extractOptions(options)
        const llmobs = this
        function wrapped() {
          telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: false, kind })
          const span = llmobs._tracer.scope().active()
          const fnArgs = arguments
          const lastArgId = fnArgs.length - 1
          const cb = fnArgs[lastArgId]
          const hasCallback = typeof cb === 'function'
          if (hasCallback) {
            const scopeBoundCb = llmobs._bind(cb)
            fnArgs[lastArgId] = function () {
              const maybeError = arguments[0]
              const maybeResult = arguments[1]
              llmobs._autoAnnotate(
                span,
                kind,
                getFunctionArguments(fn, fnArgs),
                isError(maybeError) || maybeError == null ? maybeResult : maybeError
              )
              return scopeBoundCb.apply(this, arguments)
            }
          }
          try {
            const result = llmobs._activate(span, { kind, ...llmobsOptions }, () => fn.apply(this, fnArgs))
            if (result && typeof result.then === 'function') {
              return result.then(
                (value) => {
                  if (!hasCallback) {
                    llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs), value)
                  }
                  return value
                },
                (err) => {
                  llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs))
                  throw err
                }
              )
            }
            if (!hasCallback) {
              llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs), result)
            }
            return result
          } catch (e) {
            llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs))
            throw e
          }
        }
        return this._tracer.wrap(name, spanOptions, wrapped)
      }
      annotate(span, options, autoinstrumented = false) {
        if (!this.enabled) return
        if (!span) {
          span = this._active()
        }
        if (span && !options && !(span instanceof Span)) {
          options = span
          span = this._active()
        }
        let err = ''
        try {
          if (!span) {
            err = 'invalid_span_no_active_spans'
            throw new Error('No span provided and no active LLMObs-generated span found')
          }
          if (!options) {
            err = 'invalid_options'
            throw new Error('No options provided for annotation.')
          }
          if (!LLMObsTagger.tagMap.has(span)) {
            err = 'invalid_span_type'
            throw new Error('Span must be an LLMObs-generated span')
          }
          if (span._duration !== void 0) {
            err = 'invalid_finished_span'
            throw new Error('Cannot annotate a finished span')
          }
          const spanKind = LLMObsTagger.tagMap.get(span)[SPAN_KIND]
          if (!spanKind) {
            err = 'invalid_no_span_kind'
            throw new Error('LLMObs span must have a span kind specified')
          }
          const { inputData, outputData, metadata, metrics, tags } = options
          if (inputData || outputData) {
            if (spanKind === 'llm') {
              this._tagger.tagLLMIO(span, inputData, outputData)
            } else if (spanKind === 'embedding') {
              this._tagger.tagEmbeddingIO(span, inputData, outputData)
            } else if (spanKind === 'retrieval') {
              this._tagger.tagRetrievalIO(span, inputData, outputData)
            } else {
              this._tagger.tagTextIO(span, inputData, outputData)
            }
          }
          if (metadata) {
            this._tagger.tagMetadata(span, metadata)
          }
          if (metrics) {
            this._tagger.tagMetrics(span, metrics)
          }
          if (tags) {
            this._tagger.tagSpanTags(span, tags)
          }
        } catch (e) {
          if (e.ddErrorTag) {
            err = e.ddErrorTag
          }
          throw e
        } finally {
          if (autoinstrumented === false) {
            telemetry.recordLLMObsAnnotate(span, err)
          }
        }
      }
      exportSpan(span) {
        span = span || this._active()
        let err = ''
        try {
          if (!span) {
            err = 'no_active_span'
            throw new Error('No span provided and no active LLMObs-generated span found')
          }
          if (!(span instanceof Span)) {
            err = 'invalid_span'
            throw new TypeError('Span must be a valid Span object.')
          }
          if (!LLMObsTagger.tagMap.has(span)) {
            err = 'invalid_span'
            throw new Error('Span must be an LLMObs-generated span')
          }
        } catch (e) {
          telemetry.recordExportSpan(span, err)
          throw e
        }
        try {
          return {
            traceId: span.context().toTraceId(true),
            spanId: span.context().toSpanId(),
          }
        } catch {
          err = 'invalid_span'
          logger.warn('Failed to export span. Span must be a valid Span object.')
        } finally {
          telemetry.recordExportSpan(span, err)
        }
      }
      registerProcessor(processor) {
        if (!this.enabled) return
        if (this.#hasUserSpanProcessor) {
          throw new Error(
            '[LLMObs] Only one user span processor can be registered. To register a new processor, deregister the existing processor first using `llmobs.deregisterProcessor()`.'
          )
        }
        this.#hasUserSpanProcessor = true
        registerUserSpanProcessorCh.publish(processor)
      }
      deregisterProcessor() {
        if (!this.enabled) return
        this.#hasUserSpanProcessor = false
        registerUserSpanProcessorCh.publish(null)
      }
      submitEvaluation(llmobsSpanContext, options = {}) {
        if (!this.enabled) return
        let err = ''
        const { traceId, spanId } = llmobsSpanContext
        try {
          if (!traceId || !spanId) {
            err = 'invalid_span'
            throw new Error(
              'spanId and traceId must both be specified for the given evaluation metric to be submitted.'
            )
          }
          const mlApp = options.mlApp || this._config.llmobs.mlApp
          if (!mlApp) {
            err = 'missing_ml_app'
            throw new Error(
              'ML App name is required for sending evaluation metrics. Evaluation metric data will not be sent.'
            )
          }
          const timestampMs = options.timestampMs || Date.now()
          if (typeof timestampMs !== 'number' || timestampMs < 0) {
            err = 'invalid_timestamp'
            throw new Error('timestampMs must be a non-negative integer. Evaluation metric data will not be sent')
          }
          const { label, value, tags } = options
          const metricType = options.metricType?.toLowerCase()
          if (!label) {
            err = 'invalid_metric_label'
            throw new Error('label must be the specified name of the evaluation metric')
          }
          if (!metricType || !['categorical', 'score', 'boolean'].includes(metricType)) {
            err = 'invalid_metric_type'
            throw new Error('metricType must be one of "categorical" or "score"')
          }
          if (metricType === 'categorical' && typeof value !== 'string') {
            err = 'invalid_metric_value'
            throw new Error('value must be a string for a categorical metric.')
          }
          if (metricType === 'score' && typeof value !== 'number') {
            err = 'invalid_metric_value'
            throw new Error('value must be a number for a score metric.')
          }
          if (metricType === 'boolean' && typeof value !== 'boolean') {
            err = 'invalid_metric_value'
            throw new Error('value must be a boolean for a boolean metric')
          }
          const evaluationTags = {
            'ddtrace.version': tracerVersion,
            ml_app: mlApp,
          }
          if (tags) {
            for (const key in tags) {
              const tag = tags[key]
              if (typeof tag === 'string') {
                evaluationTags[key] = tag
              } else if (typeof tag.toString === 'function') {
                evaluationTags[key] = tag.toString()
              } else if (tag == null) {
                evaluationTags[key] = Object.prototype.toString.call(tag)
              } else {
                err = 'invalid_tags'
                throw new Error('Failed to parse tags. Tags for evaluation metrics must be strings')
              }
            }
          }
          const payload = {
            span_id: spanId,
            trace_id: traceId,
            label,
            metric_type: metricType,
            ml_app: mlApp,
            [`${metricType}_value`]: value,
            timestamp_ms: timestampMs,
            tags: Object.entries(evaluationTags).map(([key, value2]) => `${key}:${value2}`),
          }
          evalMetricAppendCh.publish(payload)
        } finally {
          telemetry.recordSubmitEvaluation(options, err)
        }
      }
      annotationContext(options, fn) {
        if (!this.enabled) return fn()
        const currentStore = storage.getStore()
        const store = {
          ...currentStore,
          annotationContext: {
            ...currentStore?.annotationContext,
            ...options,
          },
        }
        return storage.run(store, fn)
      }
      flush() {
        if (!this.enabled) return
        flushCh.publish()
      }
      _autoAnnotate(span, kind, input, output) {
        const annotations = {}
        if (input && !['llm', 'embedding'].includes(kind) && !LLMObsTagger.tagMap.get(span)?.[INPUT_VALUE]) {
          annotations.inputData = input
        }
        if (output && !['llm', 'retrieval'].includes(kind) && !LLMObsTagger.tagMap.get(span)?.[OUTPUT_VALUE]) {
          annotations.outputData = output
        }
        this.annotate(span, annotations, true)
      }
      _active() {
        const store = storage.getStore()
        return store?.span
      }
      _activate(span, options, fn) {
        const parentStore = storage.getStore()
        if (this.enabled) storage.enterWith({ ...parentStore, span })
        if (options) {
          this._tagger.registerLLMObsSpan(span, {
            ...options,
            parent: parentStore?.span,
          })
        }
        try {
          return fn()
        } finally {
          if (this.enabled) storage.enterWith(parentStore)
        }
      }
      // bind function to active LLMObs span
      _bind(fn) {
        if (typeof fn !== 'function') return fn
        const llmobs = this
        const activeSpan = llmobs._active()
        const bound = function () {
          return llmobs._activate(activeSpan, null, () => {
            return fn.apply(this, arguments)
          })
        }
        return bound
      }
      _extractOptions(options) {
        const { modelName, modelProvider, sessionId, mlApp, _decorator, ...spanOptions } = options
        return {
          mlApp,
          modelName,
          modelProvider,
          sessionId,
          _decorator,
          spanOptions,
        }
      }
    }
    module2.exports = LLMObs
  },
})

// node_modules/dd-trace/packages/dd-trace/src/aiguard/client.js
var require_client13 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/aiguard/client.js'(exports2, module2) {
    'use strict'
    async function executeRequest(body, opts) {
      const postData = JSON.stringify(body)
      const headers = {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData),
        ...opts.headers,
      }
      const response = await fetch(opts.url, {
        method: 'POST',
        headers,
        body: postData,
        signal: AbortSignal.timeout(opts.timeout),
      })
      const responseBody = await response.json()
      return {
        status: response.status,
        body: responseBody,
      }
    }
    module2.exports = executeRequest
  },
})

// node_modules/dd-trace/packages/dd-trace/src/aiguard/tags.js
var require_tags5 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/aiguard/tags.js'(exports2, module2) {
    'use strict'
    module2.exports = {
      AI_GUARD_RESOURCE: 'ai_guard',
      AI_GUARD_TARGET_TAG_KEY: 'ai_guard.target',
      AI_GUARD_TOOL_NAME_TAG_KEY: 'ai_guard.tool_name',
      AI_GUARD_ACTION_TAG_KEY: 'ai_guard.action',
      AI_GUARD_REASON_TAG_KEY: 'ai_guard.reason',
      AI_GUARD_BLOCKED_TAG_KEY: 'ai_guard.blocked',
      AI_GUARD_META_STRUCT_KEY: 'ai_guard',
      AI_GUARD_TELEMETRY_REQUESTS: 'ai_guard.requests',
      AI_GUARD_TELEMETRY_TRUNCATED: 'ai_guard.truncated',
    }
  },
})

// node_modules/dd-trace/packages/dd-trace/src/aiguard/sdk.js
var require_sdk3 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/aiguard/sdk.js'(exports2, module2) {
    'use strict'
    var rfdc = require_rfdc()({ proto: false, circles: false })
    var NoopAIGuard = require_noop4()
    var executeRequest = require_client13()
    var {
      AI_GUARD_RESOURCE,
      AI_GUARD_TARGET_TAG_KEY,
      AI_GUARD_REASON_TAG_KEY,
      AI_GUARD_ACTION_TAG_KEY,
      AI_GUARD_BLOCKED_TAG_KEY,
      AI_GUARD_META_STRUCT_KEY,
      AI_GUARD_TOOL_NAME_TAG_KEY,
      AI_GUARD_TELEMETRY_REQUESTS,
      AI_GUARD_TELEMETRY_TRUNCATED,
    } = require_tags5()
    var log = require_log2()
    var telemetryMetrics = require_metrics()
    var tracerVersion = require_package().version
    var appsecMetrics = telemetryMetrics.manager.namespace('appsec')
    var ALLOW = 'ALLOW'
    var AIGuardAbortError = class extends Error {
      constructor(reason, tags) {
        super(reason)
        this.name = 'AIGuardAbortError'
        this.reason = reason
        this.tags = tags
      }
    }
    var AIGuardClientError = class extends Error {
      constructor(message, opts = {}) {
        super(message)
        this.name = 'AIGuardClientError'
        if (opts.errors) {
          this.errors = opts.errors
        }
        if (opts.cause) {
          this.cause = opts.cause
        }
      }
    }
    var AIGuard = class extends NoopAIGuard {
      #initialized
      #tracer
      #headers
      #evaluateUrl
      #timeout
      #maxMessagesLength
      #maxContentSize
      #meta
      constructor(tracer2, config) {
        super()
        if (!config.apiKey || !config.appKey) {
          log.error('AIGuard: missing api and/or app keys, use env DD_API_KEY and DD_APP_KEY')
          this.#initialized = false
          return
        }
        this.#tracer = tracer2
        this.#headers = {
          'DD-API-KEY': config.apiKey,
          'DD-APPLICATION-KEY': config.appKey,
          'DD-AI-GUARD-VERSION': tracerVersion,
          'DD-AI-GUARD-SOURCE': 'SDK',
          'DD-AI-GUARD-LANGUAGE': 'nodejs',
        }
        const endpoint = config.experimental.aiguard.endpoint || `https://app.${config.site}/api/v2/ai-guard`
        this.#evaluateUrl = `${endpoint}/evaluate`
        this.#timeout = config.experimental.aiguard.timeout
        this.#maxMessagesLength = config.experimental.aiguard.maxMessagesLength
        this.#maxContentSize = config.experimental.aiguard.maxContentSize
        this.#meta = { service: config.service, env: config.env }
        this.#initialized = true
      }
      /**
       * Returns a safe copy of the messages to be serialized into the meta struct.
       *
       * - Clones each message so callers cannot mutate the data set in the meta struct.
       * - Truncates the list of messages and `content` fields emitting metrics accordingly.
       */
      #buildMessagesForMetaStruct(messages) {
        const size = Math.min(messages.length, this.#maxMessagesLength)
        if (messages.length > size) {
          appsecMetrics.count(AI_GUARD_TELEMETRY_TRUNCATED, { type: 'messages' }).inc(1)
        }
        const result = []
        let contentTruncated = false
        for (let i = messages.length - size; i < messages.length; i++) {
          const message = rfdc(messages[i])
          if (message.content?.length > this.#maxContentSize) {
            contentTruncated = true
            message.content = message.content.slice(0, this.#maxContentSize)
          }
          result.push(message)
        }
        if (contentTruncated) {
          appsecMetrics.count(AI_GUARD_TELEMETRY_TRUNCATED, { type: 'content' }).inc(1)
        }
        return result
      }
      #isToolCall(message) {
        return message.tool_calls || message.tool_call_id
      }
      #getToolName(message, history) {
        if (message.tool_calls) {
          const names = message.tool_calls.map((tool) => tool.function.name)
          return names.length === 0 ? null : names.join(',')
        }
        const id = message.tool_call_id
        for (let i = history.length - 2; i >= 0; i--) {
          const item = history[i]
          if (item.tool_calls) {
            for (const toolCall of item.tool_calls) {
              if (toolCall.id === id) {
                return toolCall.function.name
              }
            }
          }
        }
        return null
      }
      evaluate(messages, opts) {
        if (!this.#initialized) {
          return super.evaluate(messages, opts)
        }
        const { block = false } = opts ?? {}
        return this.#tracer.trace(AI_GUARD_RESOURCE, {}, async (span) => {
          const last = messages[messages.length - 1]
          const target = this.#isToolCall(last) ? 'tool' : 'prompt'
          span.setTag(AI_GUARD_TARGET_TAG_KEY, target)
          if (target === 'tool') {
            const name = this.#getToolName(last, messages)
            if (name) {
              span.setTag(AI_GUARD_TOOL_NAME_TAG_KEY, name)
            }
          }
          const metaStruct = {
            messages: this.#buildMessagesForMetaStruct(messages),
          }
          span.meta_struct = {
            [AI_GUARD_META_STRUCT_KEY]: metaStruct,
          }
          let response
          try {
            const payload = {
              data: {
                attributes: {
                  messages,
                  meta: this.#meta,
                },
              },
            }
            response = await executeRequest(payload, {
              url: this.#evaluateUrl,
              headers: this.#headers,
              timeout: this.#timeout,
            })
          } catch (e) {
            appsecMetrics.count(AI_GUARD_TELEMETRY_REQUESTS, { error: true }).inc(1)
            throw new AIGuardClientError(`Unexpected error calling AI Guard service: ${e.message}`, { cause: e })
          }
          if (response.status !== 200) {
            appsecMetrics.count(AI_GUARD_TELEMETRY_REQUESTS, { error: true }).inc(1)
            throw new AIGuardClientError(`AI Guard service call failed, status ${response.status}`, {
              errors: response.body?.errors,
            })
          }
          let action, reason, tags, blockingEnabled
          try {
            const attr = response.body.data.attributes
            if (!attr.action) {
              throw new Error('Action missing from response')
            }
            action = attr.action
            reason = attr.reason
            tags = attr.tags
            blockingEnabled = attr.is_blocking_enabled ?? false
          } catch (e) {
            appsecMetrics.count(AI_GUARD_TELEMETRY_REQUESTS, { error: true }).inc(1)
            throw new AIGuardClientError(`AI Guard service returned unexpected response : ${response.body}`, {
              cause: e,
            })
          }
          const shouldBlock = block && blockingEnabled && action !== ALLOW
          appsecMetrics.count(AI_GUARD_TELEMETRY_REQUESTS, { action, error: false, block: shouldBlock }).inc(1)
          span.setTag(AI_GUARD_ACTION_TAG_KEY, action)
          if (reason) {
            span.setTag(AI_GUARD_REASON_TAG_KEY, reason)
          }
          if (tags?.length > 0) {
            metaStruct.attack_categories = tags
          }
          if (shouldBlock) {
            span.setTag(AI_GUARD_BLOCKED_TAG_KEY, 'true')
            throw new AIGuardAbortError(reason, tags)
          }
          return { action, reason, tags }
        })
      }
    }
    module2.exports = AIGuard
  },
})

// node_modules/dd-trace/packages/dd-trace/src/openfeature/flagging_provider.js
var require_flagging_provider = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/openfeature/flagging_provider.js'(exports2, module2) {
    'use strict'
    var { DatadogNodeServerProvider } = require('@datadog/openfeature-node-server')
    var { channel } = require_dc_polyfill()
    var log = require_log2()
    var { EXPOSURE_CHANNEL } = require_constants()
    var FlaggingProvider = class extends DatadogNodeServerProvider {
      /**
       * @param {import('../tracer')} tracer - Datadog tracer instance
       * @param {import('../config')} config - Tracer configuration object
       */
      constructor(tracer2, config) {
        super({
          exposureChannel: channel(EXPOSURE_CHANNEL),
          initializationTimeoutMs: config.experimental.flaggingProvider.initializationTimeoutMs,
        })
        this._tracer = tracer2
        this._config = config
        log.debug(
          this.constructor.name +
            ' created with timeout: ' +
            config.experimental.flaggingProvider.initializationTimeoutMs +
            'ms'
        )
      }
      /**
       * Internal method to update flag configuration from Remote Config.
       * This method is called automatically when Remote Config delivers UFC updates.
       *
       * @internal
       * @param {import('@datadog/openfeature-node-server').UniversalFlagConfigurationV1} ufc
       * - Universal Flag Configuration object
       */
      _setConfiguration(ufc) {
        if (typeof this.setConfiguration === 'function') {
          this.setConfiguration(ufc)
        }
        log.debug(this.constructor.name + ' provider configuration updated')
      }
    }
    module2.exports = FlaggingProvider
  },
})

// node_modules/dd-trace/packages/dd-trace/src/proxy.js
var require_proxy2 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/proxy.js'(exports2, module2) {
    'use strict'
    var NoopProxy = require_proxy()
    var DatadogTracer = require_tracer4()
    var getConfig = require_config2()
    var runtimeMetrics = require_runtime_metrics2()
    var log = require_log2()
    var { setStartupLogPluginManager } = require_startup_log()
    var DynamicInstrumentation = require_debugger()
    var telemetry = require_telemetry3()
    var nomenclature = require_service_naming()
    var PluginManager = require_plugin_manager()
    var NoopDogStatsDClient = require_dogstatsd()
    var { getEnvironmentVariable } = require_config_helper()
    var { setBaggageItem, getBaggageItem, getAllBaggageItems, removeBaggageItem, removeAllBaggageItems } =
      require_baggage()
    var LazyModule = class {
      constructor(provider) {
        this.provider = provider
      }
      enable(...args) {
        this.module = this.provider()
        this.module.enable(...args)
      }
      disable() {
        this.module?.disable()
      }
    }
    function lazyProxy(obj, property, config, getClass, ...args) {
      if (config?._isInServerlessEnvironment?.() === false) {
        defineEagerly(obj, property, getClass, ...args)
      } else {
        defineLazily(obj, property, getClass, ...args)
      }
    }
    function defineEagerly(obj, property, getClass, ...args) {
      const RealClass = getClass()
      obj[property] = new RealClass(...args)
    }
    function defineLazily(obj, property, getClass, ...args) {
      Reflect.defineProperty(obj, property, {
        get() {
          const RealClass = getClass()
          const value = new RealClass(...args)
          Reflect.defineProperty(obj, property, { value, configurable: true, enumerable: true })
          return value
        },
        configurable: true,
        enumerable: true,
      })
    }
    var Tracer = class extends NoopProxy {
      constructor() {
        super()
        this._initialized = false
        this._nomenclature = nomenclature
        this._pluginManager = new PluginManager(this)
        this.dogstatsd = new NoopDogStatsDClient()
        this._tracingInitialized = false
        this._flare = new LazyModule(() => require_flare())
        this.setBaggageItem = setBaggageItem
        this.getBaggageItem = getBaggageItem
        this.getAllBaggageItems = getAllBaggageItems
        this.removeBaggageItem = removeBaggageItem
        this.removeAllBaggageItems = removeAllBaggageItems
        this._modules = {
          appsec: new LazyModule(() => require_appsec()),
          iast: new LazyModule(() => require_iast()),
          llmobs: new LazyModule(() => require_llmobs()),
          rewriter: new LazyModule(() => require_rewriter2()),
          openfeature: new LazyModule(() => require_openfeature()),
        }
      }
      /**
       * @override
       */
      init(options) {
        if (this._initialized) return this
        this._initialized = true
        try {
          const config = getConfig(options)
          if (config.crashtracking.enabled) {
            require_crashtracking().start(config)
          }
          if (config.heapSnapshot.count > 0) {
            require_heap_snapshots().start(config)
          }
          telemetry.start(config, this._pluginManager)
          if (config.dogstatsd) {
            lazyProxy(this, 'dogstatsd', config, () => require_dogstatsd2().CustomMetrics, config)
          }
          if (config.spanLeakDebug > 0) {
            const spanleak = require_spanleak()
            if (config.spanLeakDebug === spanleak.MODES.LOG) {
              spanleak.enableLogging()
            } else if (config.spanLeakDebug === spanleak.MODES.GC_AND_LOG) {
              spanleak.enableGarbageCollection()
            }
            spanleak.startScrubber()
          }
          if (config.remoteConfig.enabled && !config.isCiVisibility) {
            const rc = require_remote_config().enable(config, this._modules.appsec)
            rc.setProductHandler('APM_TRACING', (action, conf) => {
              if (action === 'unapply') {
                config.configure({}, true)
              } else {
                config.configure(conf.lib_config, true)
              }
              this._enableOrDisableTracing(config)
            })
            rc.setProductHandler('AGENT_CONFIG', (action, conf) => {
              if (!conf?.name?.startsWith('flare-log-level.')) return
              if (action === 'unapply') {
                this._flare.disable()
              } else if (conf.config?.log_level) {
                this._flare.enable(config)
                this._flare.module.prepare(conf.config.log_level)
              }
            })
            rc.setProductHandler('AGENT_TASK', (action, conf) => {
              if (action === 'unapply' || !conf) return
              if (conf.task_type !== 'tracer_flare' || !conf.args) return
              this._flare.enable(config)
              this._flare.module.send(conf.args)
            })
            if (config.dynamicInstrumentation.enabled) {
              DynamicInstrumentation.start(config, rc)
            }
            if (config.experimental.flaggingProvider.enabled) {
              rc.setProductHandler('FFE_FLAGS', (action, conf) => {
                if (action === 'apply' || action === 'modify') {
                  this.openfeature._setConfiguration(conf)
                }
              })
            }
          }
          if (config.profiling.enabled === 'true') {
            this._profilerStarted = this._startProfiler(config)
          } else {
            this._profilerStarted = Promise.resolve(false)
            if (config.profiling.enabled === 'auto') {
              const { SSIHeuristics } = require_ssi_heuristics()
              const ssiHeuristics = new SSIHeuristics(config)
              ssiHeuristics.start()
              ssiHeuristics.onTriggered(() => {
                this._startProfiler(config)
                ssiHeuristics.onTriggered()
              })
            }
          }
          if (config.runtimeMetrics.enabled) {
            runtimeMetrics.start(config)
          }
          this._enableOrDisableTracing(config)
          this._modules.rewriter.enable(config)
          if (config.tracing && config.isManualApiEnabled) {
            const TestApiManualPlugin = require_test_api_manual_plugin()
            this._testApiManualPlugin = new TestApiManualPlugin(this)
            this._testApiManualPlugin.configure({ ...config, enabled: true }, false)
          }
          if (config.ciVisAgentlessLogSubmissionEnabled) {
            if (getEnvironmentVariable('DD_API_KEY')) {
              const LogSubmissionPlugin = require_log_submission_plugin()
              const automaticLogPlugin = new LogSubmissionPlugin(this)
              automaticLogPlugin.configure({ ...config, enabled: true })
            } else {
              log.warn(
                // eslint-disable-next-line @stylistic/max-len
                'DD_AGENTLESS_LOG_SUBMISSION_ENABLED is set, but DD_API_KEY is undefined, so no automatic log submission will be performed.'
              )
            }
          }
          if (config.otelLogsEnabled) {
            const { initializeOpenTelemetryLogs } = require_logs2()
            initializeOpenTelemetryLogs(config)
          }
          if (config.otelMetricsEnabled) {
            const { initializeOpenTelemetryMetrics } = require_metrics2()
            initializeOpenTelemetryMetrics(config)
          }
          if (config.isTestDynamicInstrumentationEnabled) {
            const getDynamicInstrumentationClient = require_dynamic_instrumentation()
            getDynamicInstrumentationClient(config)
          }
        } catch (e) {
          log.error('Error initialising tracer', e)
        }
        return this
      }
      _startProfiler(config) {
        try {
          return require_profiler2().start(config)
        } catch (e) {
          log.error(
            'Error starting profiler. For troubleshooting tips, see <https://dtdg.co/nodejs-profiler-troubleshooting>',
            e
          )
        }
      }
      _enableOrDisableTracing(config) {
        if (config.tracing !== false) {
          if (config.appsec.enabled) {
            this._modules.appsec.enable(config)
          }
          if (config.llmobs.enabled) {
            this._modules.llmobs.enable(config)
          }
          if (!this._tracingInitialized) {
            const prioritySampler = config.apmTracingEnabled === false ? require_standalone().configure(config) : void 0
            this._tracer = new DatadogTracer(config, prioritySampler)
            this.dataStreamsCheckpointer = this._tracer.dataStreamsCheckpointer
            lazyProxy(this, 'appsec', config, () => require_sdk(), this._tracer, config)
            lazyProxy(this, 'llmobs', config, () => require_sdk2(), this._tracer, this._modules.llmobs, config)
            if (config.experimental?.aiguard?.enabled) {
              lazyProxy(this, 'aiguard', config, () => require_sdk3(), this._tracer, config)
            }
            this._tracingInitialized = true
          }
          if (config.experimental.flaggingProvider.enabled) {
            this._modules.openfeature.enable(config)
            lazyProxy(this, 'openfeature', config, () => require_flagging_provider(), this._tracer, config)
          }
          if (config.iast.enabled) {
            this._modules.iast.enable(config, this._tracer)
          }
        } else if (this._tracingInitialized) {
          this._modules.appsec.disable()
          this._modules.iast.disable()
          this._modules.llmobs.disable()
          this._modules.openfeature.disable()
        }
        if (this._tracingInitialized) {
          this._tracer.configure(config)
          this._pluginManager.configure(config)
          DynamicInstrumentation.configure(config)
          setStartupLogPluginManager(this._pluginManager)
        }
      }
      /**
       * @override
       */
      profilerStarted() {
        if (!this._profilerStarted) {
          throw new Error('profilerStarted() must be called after init()')
        }
        return this._profilerStarted
      }
      /**
       * @override
       */
      use() {
        this._pluginManager.configurePlugin(...arguments)
        return this
      }
      /**
       * @override
       */
      get TracerProvider() {
        return require_tracer_provider()
      }
    }
    module2.exports = Tracer
  },
})

// node_modules/dd-trace/packages/dd-trace/src/index.js
var require_src75 = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/src/index.js'(exports2, module2) {
    'use strict'
    var { isFalse } = require_util()
    var { getEnvironmentVariable } = require_config_helper()
    var inJestWorker = typeof jest !== 'undefined'
    var ddTraceDisabled = getEnvironmentVariable('DD_TRACE_ENABLED')
      ? isFalse(getEnvironmentVariable('DD_TRACE_ENABLED'))
      : String(getEnvironmentVariable('OTEL_TRACES_EXPORTER')).toLowerCase() === 'none'
    module2.exports = ddTraceDisabled || inJestWorker ? require_proxy() : require_proxy2()
  },
})

// node_modules/dd-trace/packages/dd-trace/index.js
var require_dd_trace = __commonJS({
  'node_modules/dd-trace/packages/dd-trace/index.js'(exports2, module2) {
    'use strict'
    if (!global._ddtrace) {
      const TracerProxy = require_src75()
      Object.defineProperty(global, '_ddtrace', {
        value: new TracerProxy(),
        enumerable: false,
        configurable: true,
        writable: true,
      })
      global._ddtrace.default = global._ddtrace
      global._ddtrace.tracer = global._ddtrace
    }
    module2.exports = global._ddtrace
  },
})

// node_modules/dd-trace/index.js
var require_dd_trace2 = __commonJS({
  'node_modules/dd-trace/index.js'(exports2, module2) {
    'use strict'
    module2.exports = require_dd_trace()
  },
})

// src/index.js
var tracer = require_dd_trace2()
module.exports = tracer
//# sourceMappingURL=dd-trace-bundle.js.map
