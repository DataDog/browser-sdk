/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 * */
/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 * */
/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 * */
/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 * */
/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * * `chunkSize` - size of generated data chunks (16K by default)
 * * `raw` (Boolean) - do raw deflate
 * * `gzip` (Boolean) - create gzip wrapper
 * * `header` (Object) - custom header for gzip
 * ** `text` (Boolean) - true if compressed data believed to be text
 * ** `time` (Number) - modification time, unix timestamp
 * ** `os` (Number) - operation system code
 * ** `extra` (Array) - array of bytes with extra data (max 65536)
 * ** `name` (String) - file name (binary string)
 * ** `comment` (String) - comment (binary string)
 * ** `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 * */
export function Deflate(): void;
export class Deflate {
    options: {
        level: number;
        method: number;
        chunkSize: number;
        windowBits: number;
        memLevel: number;
        strategy: number;
    };
    err: number;
    msg: string;
    ended: boolean;
    chunks: any[];
    strm: ZStream;
    _dict_set: boolean | undefined;
    /**
     * Deflate#push(data[, flush_mode]) -> Boolean
     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
     * converted to utf8 byte sequence.
     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     * See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
     *
     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
     * new compressed chunks. Returns `true` on success. The last data block must
     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
     * buffers and call [[Deflate#onEnd]].
     *
     * On fail call [[Deflate#onEnd]] with error code and return false.
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     * */
    push(data: any, flush_mode: any): boolean;
    /**
     * Deflate#onData(chunk) -> Void
     * - chunk (Uint8Array): output data.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     * */
    onData(chunk: any): void;
    /**
     * Deflate#onEnd(status) -> Void
     * - status (Number): deflate status. 0 (Z_OK) on success,
     * other if not.
     *
     * Called once after you tell deflate that the input stream is
     * complete (Z_FINISH). By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     * */
    onEnd(status: any): void;
    result: Uint8Array<ArrayBuffer> | undefined;
}
export function string2buf(str: any): Uint8Array<ArrayBufferLike>;
export namespace constants {
    let Z_NO_FLUSH: number;
    let Z_PARTIAL_FLUSH: number;
    let Z_SYNC_FLUSH: number;
    let Z_FULL_FLUSH: number;
    let Z_FINISH: number;
    let Z_BLOCK: number;
    let Z_TREES: number;
    let Z_OK: number;
    let Z_STREAM_END: number;
    let Z_NEED_DICT: number;
    let Z_ERRNO: number;
    let Z_STREAM_ERROR: number;
    let Z_DATA_ERROR: number;
    let Z_MEM_ERROR: number;
    let Z_BUF_ERROR: number;
    let Z_NO_COMPRESSION: number;
    let Z_BEST_SPEED: number;
    let Z_BEST_COMPRESSION: number;
    let Z_DEFAULT_COMPRESSION: number;
    let Z_FILTERED: number;
    let Z_HUFFMAN_ONLY: number;
    let Z_RLE: number;
    let Z_FIXED: number;
    let Z_DEFAULT_STRATEGY: number;
    let Z_BINARY: number;
    let Z_TEXT: number;
    let Z_UNKNOWN: number;
    let Z_DEFLATED: number;
}
declare function ZStream(): void;
declare class ZStream {
    input: any;
    next_in: number;
    avail_in: number;
    total_in: number;
    output: any;
    next_out: number;
    avail_out: number;
    total_out: number;
    msg: string;
    state: any;
    data_type: number;
    adler: number;
}
export {};
