import { monitor } from '@datadog/browser-core'
import {
  getSerializedNodeId,
  hasSerializedNode,
  transformAttribute,
  NodeWithSerializedNode,
  nodeIsIgnored,
  serializeNodeWithId,
  IdNodeMap,
  nodeOrAncestorsIsIgnored,
} from '../rrweb-snapshot'
import { nodeOrAncestorsShouldBeHidden } from '../privacy'
import {
  AddedNodeMutation,
  AttributeMutation,
  AttributesMutationRecord,
  CharacterDataMutationRecord,
  ChildListMutationRecord,
  MutationCallBack,
  MutationRecord,
  RemovedNodeMutation,
  TextMutation,
} from './types'
import { forEach } from './utils'
import { MutationController } from './mutation'

type WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }

const enum MutationObserverStatus {
  WaitingForMutation,
  MutationsPending,
  Stopped,
}
type MutationObserverState =
  | {
      status: MutationObserverStatus.WaitingForMutation
    }
  | {
      status: MutationObserverStatus.MutationsPending
      pendingMutations: MutationRecord[]
      cancelScheduledProcess: () => void
    }
  | {
      status: MutationObserverStatus.Stopped
    }

/**
 * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be
 * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the
 * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the
 * browser is busy executing a longer task, mutations will be processed after this task.
 */
const MUTATION_PROCESS_MAX_DELAY = 100

/**
 * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload
 */
export function startMutationObserver(controller: MutationController, mutationCallback: MutationCallBack) {
  let state: MutationObserverState = {
    status: MutationObserverStatus.WaitingForMutation,
  }

  const observer = new MutationObserver(
    monitor((mutations) => {
      switch (state.status) {
        case MutationObserverStatus.WaitingForMutation:
          state = {
            status: MutationObserverStatus.MutationsPending,
            pendingMutations: mutations,
            cancelScheduledProcess: scheduleMutationProcess(processPendingMutations),
          }
          break

        case MutationObserverStatus.MutationsPending:
          state.pendingMutations.push(...mutations)
          break
      }
    })
  )

  observer.observe(document, {
    attributeOldValue: true,
    attributes: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true,
  })
  controller.onFlush(processPendingMutations)

  function processPendingMutations() {
    let pendingMutations: MutationRecord[] = observer.takeRecords()

    if (state.status === MutationObserverStatus.MutationsPending) {
      pendingMutations = state.pendingMutations.concat(pendingMutations)
      state.cancelScheduledProcess()
      state = { status: MutationObserverStatus.WaitingForMutation }
    }

    processMutations(pendingMutations, mutationCallback)
  }

  return {
    stop: () => {
      observer.disconnect()
      if (state.status === MutationObserverStatus.MutationsPending) {
        state.cancelScheduledProcess()
      }
      state = { status: MutationObserverStatus.Stopped }
    },
  }
}

function scheduleMutationProcess(callback: () => void) {
  interface BrowserWindow extends Window {
    requestIdleCallback: (callback: () => void, opts?: { timeout?: number }) => number
    cancelIdleCallback: (handle?: number) => void
  }
  const browserWindow = (window as unknown) as BrowserWindow

  // Use 'requestIdleCallback' when available: it will throttle the mutation processing if the
  // browser is busy rendering frames (ex: when frames are below 60fps). When not available, the
  // fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any
  // browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes
  // efficiently.
  if (browserWindow.requestIdleCallback) {
    const id = browserWindow.requestIdleCallback(callback, { timeout: MUTATION_PROCESS_MAX_DELAY })
    return () => browserWindow.cancelIdleCallback(id)
  }
  const id = browserWindow.requestAnimationFrame(callback)
  return () => browserWindow.cancelAnimationFrame(id)
}

function processMutations(mutations: MutationRecord[], mutationCallback: MutationCallBack) {
  // Discard any mutation with a 'target' node that:
  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely
  // part of a mutation occurring in a parent Node
  // * should be hidden or ignored
  const filteredMutations = mutations.filter(
    (mutation): mutation is WithSerializedTarget<MutationRecord> =>
      document.contains(mutation.target) &&
      hasSerializedNode(mutation.target) &&
      !nodeOrAncestorsIsIgnored(mutation.target) &&
      !nodeOrAncestorsShouldBeHidden(mutation.target)
  )

  const { adds, removes, hasBeenSerialized } = processChildListMutations(
    filteredMutations.filter(
      (mutation): mutation is WithSerializedTarget<ChildListMutationRecord> => mutation.type === 'childList'
    )
  )

  const texts = processCharacterDataMutations(
    filteredMutations.filter(
      (mutation): mutation is WithSerializedTarget<CharacterDataMutationRecord> =>
        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)
    )
  )

  const attributes = processAttributesMutations(
    filteredMutations.filter(
      (mutation): mutation is WithSerializedTarget<AttributesMutationRecord> =>
        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)
    )
  )

  if (!texts.length && !attributes.length && !removes.length && !adds.length) {
    return
  }

  mutationCallback({
    adds,
    removes,
    texts,
    attributes,
  })
}

function processChildListMutations(mutations: Array<WithSerializedTarget<ChildListMutationRecord>>) {
  // First, we iterate over mutations to collect:
  //
  // * nodes that have been added in the document and not removed by a subsequent mutation
  // * nodes that have been removed from the document but were not added in a previous mutation
  //
  // For this second category, we also collect their previous parent (mutation.target) because we'll
  // need it to emit a 'remove' mutation.
  //
  // Those two categories may overlap: if a node moved from a position to another, it is reported as
  // two mutation records, one with a "removedNodes" and the other with "addedNodes". In this case,
  // the node will be in both sets.
  const addedAndMovedNodes = new Set<Node>()
  const removedNodes = new Map<Node, NodeWithSerializedNode>()
  for (const mutation of mutations) {
    forEach(mutation.addedNodes, (node) => {
      addedAndMovedNodes.add(node)
    })
    forEach(mutation.removedNodes, (node) => {
      if (!addedAndMovedNodes.has(node)) {
        removedNodes.set(node, mutation.target)
      }
      addedAndMovedNodes.delete(node)
    })
  }

  // Then, we sort nodes that are still in the document by topological order, for two reasons:
  //
  // * We will serialize each added nodes with their descendants. We don't want to serialize a node
  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in
  // a precedent node.
  //
  // * To emit "add" mutations, we need references to the parent and potential next sibling of each
  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are
  // siblings, we want to iterate from last to first. This will ensure that any "next" node is
  // already serialized and have an id.
  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)
  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)

  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized
  // node ids in a map to be able to skip subsequent related mutations.
  const serializedNodesIdMap: IdNodeMap = {}

  const addedNodeMutations: AddedNodeMutation[] = []
  for (const node of sortedAddedAndMovedNodes) {
    if (hasBeenSerialized(node)) {
      continue
    }

    const serializedNode = serializeNodeWithId(node, { doc: document, map: serializedNodesIdMap, skipChild: false })
    if (!serializedNode) {
      continue
    }

    addedNodeMutations.push({
      nextId: getNextSibling(node),
      parentId: getSerializedNodeId(node.parentNode!)!,
      node: serializedNode,
    })
  }

  // Finally, we emit remove mutations.
  const removedNodeMutations: RemovedNodeMutation[] = []
  removedNodes.forEach((parent, node) => {
    if (hasSerializedNode(node)) {
      removedNodeMutations.push({
        parentId: getSerializedNodeId(parent),
        id: getSerializedNodeId(node),
      })
    }
  })

  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }

  function hasBeenSerialized(node: Node) {
    return hasSerializedNode(node) && serializedNodesIdMap.hasOwnProperty(getSerializedNodeId(node))
  }

  function getNextSibling(node: Node): null | number {
    let nextSibling = node.nextSibling
    while (nextSibling) {
      if (hasSerializedNode(nextSibling) && !nodeIsIgnored(nextSibling)) {
        return getSerializedNodeId(nextSibling)
      }
      nextSibling = nextSibling.nextSibling
    }

    return null
  }
}

function processCharacterDataMutations(mutations: Array<WithSerializedTarget<CharacterDataMutationRecord>>) {
  const textMutations: TextMutation[] = []

  // Deduplicate mutations based on their target node
  const handledNodes = new Set<Node>()
  const filteredMutations = mutations.filter((mutation) => {
    if (handledNodes.has(mutation.target)) {
      return false
    }
    handledNodes.add(mutation.target)
    return true
  })

  // Emit mutations
  for (const mutation of filteredMutations) {
    const value = mutation.target.textContent
    if (value === mutation.oldValue) {
      continue
    }
    textMutations.push({
      id: getSerializedNodeId(mutation.target),
      value,
    })
  }

  return textMutations
}

function processAttributesMutations(mutations: Array<WithSerializedTarget<AttributesMutationRecord>>) {
  const attributeMutations: AttributeMutation[] = []

  // Deduplicate mutations based on their target node and changed attribute
  const handledNodes = new Map<Node, Set<string>>()
  const filteredMutations = mutations.filter((mutation) => {
    const handledAttributes = handledNodes.get(mutation.target)
    if (handledAttributes?.has(mutation.attributeName!)) {
      return false
    }
    if (!handledAttributes) {
      handledNodes.set(mutation.target, new Set([mutation.attributeName!]))
    } else {
      handledAttributes.add(mutation.attributeName!)
    }
    return true
  })

  // Emit mutations
  const emittedMutations = new Map<Node, AttributeMutation>()
  for (const mutation of filteredMutations) {
    const value = ((mutation.target as unknown) as HTMLElement).getAttribute(mutation.attributeName!)
    if (value === mutation.oldValue) {
      continue
    }

    let emittedMutation = emittedMutations.get(mutation.target)
    if (!emittedMutation) {
      emittedMutation = {
        id: getSerializedNodeId(mutation.target),
        attributes: {},
      }
      attributeMutations.push(emittedMutation)
      emittedMutations.set(mutation.target, emittedMutation)
    }

    emittedMutation.attributes[mutation.attributeName!] =
      value && transformAttribute(document, mutation.attributeName!, value)
  }

  return attributeMutations
}

export function sortAddedAndMovedNodes(nodes: Node[]) {
  nodes.sort((a, b) => {
    const position = a.compareDocumentPosition(b)
    /* eslint-disable no-bitwise */
    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1
    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1
    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
      return 1
    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      return -1
    }
    /* eslint-enable no-bitwise */
    return 0
  })
}
